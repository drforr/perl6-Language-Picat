use v6.c;
use Test;
use Language::Picat;

pass "replace me";

my $huge_file = Q:to[_END_];
/* 

  100 doors problem in Picat.

  From Rosetta code:
  http://rosettacode.org/wiki/100_doors
  """

  Leading /* and trailing separated * /
  See also my Picat page: http://www.hakank.org/picat/

*/
/*
  DOS endings here based on constraint programming.
	
  Problem Input implemented as 2D matrix containing local horizontal/
  vertical constraint sums in sub lists

  Model created by Lorenz Schiffmann, lorenz.schiffmann@gmail.com
  [with some small additions by Hakan Kjellerstrand, hakank@gmail.com]

*/

% import util.
% import cp. % With another comment

module matrix_slice.

import bplan.


main => go.
main => time2(go).
main => time(bench).

go => true.
go => euler11.
go => euler19b.
go2 => true.
go => time(euler14).
go => euler22. % , euler22b.
go => time(euler26). % , time(euler26b).
go => datanrev(X), rev(X,Y), writeln(Y).
go => 
  euler96.
go =>
   time2((problem(_), fail)).
go =>
   time2($solveit(6)).
go => true./* foo */
go =>
   _ = findall(_, ($olympic(Vars),$print_olympic(Vars))).
go =>
   write_list(findall([A,B,C], $pythagoras([A,B,C], 100))).



go ?=> 
   initial_state(Init),
   L=new_list(3), % exactly three steps
   time(bplan(Init,L)),
   write(L), nl,
   writeln(len=L.length),
   fail,
   nl.



go => 
   doors(10),
   doors(100),
   doors_opt(100),
   doors_opt2(100),
   nl.

% non-optimized
doors(N) => 
   Doors = new_array(N),
   foreach(I in 1..N) Doors[I] := 0 end,
   foreach(I in 1..N)
     foreach(J in I..I..N)
        Doors[J] := 1^Doors[J]
     end,
     if N <= 10 then
        print_open(Doors)
     end
   end,
   writeln(Doors),
   print_open(Doors),
   nl.

print_open(Doors) => writeln([I : I in 1..Doors.length, Doors[I] == 1]).
  
% optimized version 1
doors_opt(N) =>
  foreach(I in 1..N)
     Root = sqrt(I),
     writeln([I, cond(Root == 1.0*round(Root), open, closed)])
  end,
  nl.

% optimized version 2
doors_opt2(N) => 
  writeln([I**2 : I in 1..N, I**2 <= N]).   

% See http://www.hakank.org/picat/bplan.pi

go =>
   % time(once(bplan(L))),
   time(bplan(L)),
   write(L), nl,
   Len=length(L),
   write(len=Len),nl.

go2 =>
   foreach(Len in 1..15)
      nl,
      write(len=Len), nl,
      L = new_list(Len),
      time(All=findall(L, $plan(L))),
      % writeln(All),
      writeln(all_len=All.length)
   end.

go3 => 
  L = new_list(10),
  All=findall(L,$plan(L)),
  writeln(All),
  writeln(len=All.length),
  nl.

go4 =>
   initial_state(Init),
   time(plan2(Init,L,Cost)),
   write(L), nl,
   writeln(len=L.length),
   writeln(cost=Cost),
   nl.

go5 =>
   initial_state(Init),
   time(plan3(Init,L,Cost,[])),
   write(L), nl,
   writeln(len=L.length),
   writeln(cost=Cost),
   nl.


%
% Length 6 (original problem)
%
% index(-)
% % initial_state([1,3,2,6,5,4]). % Moves: 2,3,2
% % initial_state([5,6,2,1,4,3]). % Moves: 1,3
% % initial_state([6,5,4,1,2,3]). % Moves: 1,2,3
% % initial_state([2,1,5,4,3,6]). % Moves: 1,2,1
% % initial_state([5,1,2,3,4,6]). % Moves: 1,2,1,2
% % initial_state([5,4,3,2,1,6]). % Moves: 1,2,1,2,1
% %% These two takes 11 steps (no problem at all).
% initial_state([6,3,5,2,4,1]).   % GAP: x3*x1*x2*x1*x3*x2*x1*x2*x1*x3*x1
% % initial_state([6,4,2,5,3,1]).   % GAP: x1*x3*x2*x3*x2*x1*x3*x2*x3*x2*x1
% %% initial_state([_,_,_,_,_,_]). % don't work
% % initial_state([6,5,4,3,1,2]). % moves 1,3,2,1,3,1,2,1
% % initial_state([6,3,4,5,2,1]). % 1,3,2,1,3

% goal_state(Goal) => Goal = [1,2,3,4,5,6].

% table
% % legal_move(From, Move, To).
% legal_move([M4,M3,M2,M1,M5,M6],M,To) ?=> M=1, To=[M1,M2,M3,M4,M5,M6]. % move 1
% legal_move([M1,M5,M4,M3,M2,M6],M,To) ?=> M=2, To=[M1,M2,M3,M4,M5,M6]. % move 2
% legal_move([M1,M2,M6,M5,M4,M3],M,To)  => M=3, To=[M1,M2,M3,M4,M5,M6]. % move 3

%
% Length 8
%

index(-)
%% finds all 27 solutions in 0.15s
initial_state([2,4,1,7,5,3,8,6]). % GAP: x2*x3*x2*x4*x3*x5*x4*x1*x2*x1
%% finds all 44 solutions in 0.168s
% initial_state([8,7,6,3,2,5,4,1]).  % x3*x1*x2*x3*x1*x4*x5*x1*x3*x1

table
legal_move([M4,M3,M2,M1,M5,M6,M7,M8],M,To) ?=> M=1,To=[M1,M2,M3,M4,M5,M6,M7,M8]. % move 1
legal_move([M1,M5,M4,M3,M2,M6,M7,M8],M,To) ?=> M=2,To=[M1,M2,M3,M4,M5,M6,M7,M8]. % move 2
legal_move([M1,M2,M6,M5,M4,M3,M7,M8],M,To) ?=> M=3,To=[M1,M2,M3,M4,M5,M6,M7,M8]. % move 3
legal_move([M1,M2,M3,M7,M6,M5,M4,M8],M,To) ?=> M=4,To=[M1,M2,M3,M4,M5,M6,M7,M8]. % move 4
legal_move([M1,M2,M3,M4,M8,M7,M6,M5],M,To)  => M=5,To=[M1,M2,M3,M4,M5,M6,M7,M8]. % move 5

goal_state(Goal) => Goal = [1,2,3,4,5,6,7,8].


%
% for bplan.plan2/3
%
table
legal_move([M4,M3,M2,M1,M5,M6,M7,M8],M,To,Cost) ?=> M=1,To=[M1,M2,M3,M4,M5,M6,M7,M8],Cost=1. % move 1
legal_move([M1,M5,M4,M3,M2,M6,M7,M8],M,To,Cost) ?=> M=2,To=[M1,M2,M3,M4,M5,M6,M7,M8],Cost=1. % move 2
legal_move([M1,M2,M6,M5,M4,M3,M7,M8],M,To,Cost) ?=> M=3,To=[M1,M2,M3,M4,M5,M6,M7,M8],Cost=1. % move 3
legal_move([M1,M2,M3,M7,M6,M5,M4,M8],M,To,Cost) ?=> M=4,To=[M1,M2,M3,M4,M5,M6,M7,M8],Cost=1. % move 4
legal_move([M1,M2,M3,M4,M8,M7,M6,M5],M,To,Cost)  => M=5,To=[M1,M2,M3,M4,M5,M6,M7,M8],Cost=1. % move 5


%
% Length 12
%
%% This takes too long and too much memory...

% table
% legal_move([M4,M3,M2,M1,M5,M6,M7,M8,M9,M10,M11,M12],M,To) ?=> M=1,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12]. % move 1
% legal_move([M1,M5,M4,M3,M2,M6,M7,M8,M9,M10,M11,M12],M,To) ?=> M=2,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12]. % move 2
% legal_move([M1,M2,M6,M5,M4,M3,M7,M8,M9,M10,M11,M12],M,To) ?=> M=3,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12]. % move 3
% legal_move([M1,M2,M3,M7,M6,M5,M4,M8,M9,M10,M11,M12],M,To) ?=> M=4,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12]. % move 4
% legal_move([M1,M2,M3,M4,M8,M7,M6,M5,M9,M10,M11,M12],M,To) ?=> M=5,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12]. % move 5
% legal_move([M1,M2,M3,M4,M5,M9,M8,M7,M6,M10,M11,M12],M,To) ?=> M=6,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12]. % move 6
% legal_move([M1,M2,M3,M4,M5,M6,M10,M9,M8,M7,M11,M12],M,To) ?=> M=7,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12]. % move 7
% legal_move([M1,M2,M3,M4,M5,M6,M7,M11,M10,M9,M8,M12],M,To) ?=> M=8,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12]. % move 8
% legal_move([M1,M2,M3,M4,M5,M6,M7,M8,M12,M11,M10,M9],M,To) ?=> M=9,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12]. % move 9

% %% number of moves: 12
% index(-)
% initial_state([7,5,11,8,9,1,10,3,4,2,6,12]).
% %% number of moves: 12
% % initiial_state([12,2,7,3,4,11,1,10,8,9,6,5]).

% goal_state(Goal) => Goal = [1,2,3,4,5,6,7,8,9,10,11,12].

go =>
   Target = 24,
   Nums = [1+random2() mod 9 : _I in 1..4],
   writeln(nums=Nums),
   All=findall(Expr,catch(solve_num(Nums,Target,Expr),E,ignore(E))),
   foreach(Expr in All) println(Expr.flatten()) end,
   println(len=All.length),
   nl.


go2 =>
  % Different tests from the Rosetta page
  NumsList = [
         [6, 8, 2, 8],
         [4, 2, 8, 1],
         [3, 1, 9, 9],
         [5, 7, 5, 1],
         [5, 8, 4, 1],
         [8, 3, 4, 9],
         [3, 7, 4, 4],
         [5, 6, 4, 1],
         [5, 5, 9, 8]
         ],
  Target=24,
  foreach(Nums in NumsList) 
     writeln(check=Nums),
     All=findall(Expr,catch(solve_num(Nums,Target,Expr),E,ignore(E))),
     foreach(Expr in All) println(Expr.flatten()) end,
     println(len=All.length),
     nl
  end,
  nl.


% What I can see (via some runs of go5/0) the entry with the largest number
% of different solutions is [1,2,3,4].
go3 =>
   Target = 24,
   Nums = [1,2,3,4],
   All=findall(Expr,catch(solve_num(Nums,Target,Expr),E,ignore(E))).remove_dups(),
   foreach(Expr in All) println(Expr.flatten()) end,
   println(len=All.length),
   nl.


% Some of the entries with the largest number of (unique) solutions:
% 326 [1,2,3,4]
% 320 [1,8,1,3]
% 316,[1,7,8,9]
% 238 [4,2,6,2]
% 220 [4,6,8,2]
go4 => 
   MaxLen = 0,
   MaxNums = [],
   Target = 24,
   foreach(_I in 1..100)
      Nums = [1+random2() mod 9 : _K in 1..4],
      % pick just the distinct solutions
      All=findall(Expr,catch(solve_num(Nums,Target,Expr),E,ignore(E))).remove_dups(),
      Len = All.length,
      if Len == MaxLen then
         MaxNums := MaxNums ++ [Nums],
         writeln([MaxNums,len=Len])
      elseif Len > MaxLen then
         MaxLen := Len,
         MaxNums := [Nums],
         writeln([MaxNums,len=Len])
      end
   end,
   writeln([MaxLen,MaxNums]),
   nl.



%
% Testing solve_num2/2
%
go5 =>
   Target = 24,
   Nums = [1,2,3,4],
   writeln(nums=Nums),
   solve_num2(Nums,Target),
   nl.

go6 =>
   Target = 24,
   Nums = [1+random2() mod 9 : _I in 1..4],
   writeln(nums=Nums),
   solve_num2(Nums,Target),
   nl.

go7 =>
  NumsList = [
         [6, 8, 2, 8],
         [4, 2, 8, 1],
         [3, 1, 9, 9],
         [5, 7, 5, 1],
         [5, 8, 4, 1],
         [8, 3, 4, 9],
         [3, 7, 4, 4],
         [5, 6, 4, 1],
         [5, 5, 9, 8]
         ],
  Target=24,
  foreach(Nums in NumsList) 
     writeln(check=Nums),
     solve_num2(Nums,Target),
     nl
  end,
  nl.


go8 =>
  Nums = [2,4,6,8],
  Target = 25,
  _All=findall(_, solve_num2(Nums,Target)),
  % foreach(E in All) println(E.to_string()) end,
  nl.

go9 =>
  Nums = [1,5,6,7],
  Target = 21,
  _All=findall(_, solve_num2(Nums,Target)),
  nl.

go10 =>
  Nums = [1,1,5,8],
  Target = 10,
  _All=findall(_, solve_num2(Nums,Target)),
  nl.


%
% A string based approach
%
solve_num(Nums, Target,Expr) => 
   % The different patterns (inspired by - among others - the Perl6 solution)
   Patterns = ["A X B Y C Z D",
               "(A X B) Y C Z D",
               "(A X B Y C) Z D",
               "((A X B) Y C) Z D",
               "(A X B) Y (C Z D)",
               "A X (B Y C Z D)",
               "A X (B Y (C Z D))"],
   permutation(Nums,[A,B,C,D]),
   Syms = [+,-,*,/],
   member(X ,Syms),
   member(Y ,Syms),
   member(Z ,Syms),
   member(Pattern,Patterns),
   Expr = replace_all(Pattern, 
                      "ABCDXYZ", % ['A','B','C','D','X','Y','Z'],
                      [A,B,C,D,X,Y,Z]),
   % =:= for numerical equality
   catch(Target =:= Expr.eval(),E,ignore(E)).

%
% Replace all occurrences in the lists From -> To 
% in the String (or List) S.
%
replace_all(S,From,To) = Res =>
   R = S,
   foreach({F,T} in zip(From,To))
      R := replace(F,T.to_string(), R)
   end,
   Res = R.

% replace occurrences of Old (a variable or an atomic value) with New
% From http://picat-lang.org/download/exs.pi
replace(Old,New,[H|T]) = [NH|NT] => 
    NH = replace(Old,New,H), 
    NT = replace(Old,New,T).
replace(Old,New,T)=NT,struct(T) => 
    NT = new_struct(T.name,T.length),
    foreach(I in 1 .. T.length) 
        NT[I] = replace(Old,New,T[I]) 
    end.
replace(Old,New,Old) = New.
replace(_Old,_New,T) = T.


% ignore zero_divisor errors
ignore(_E) => fail.

% E=["4","+","3","-","2"].flatten().eval()
% E=["4","-","(","3","-","2",")"].eval()
eval(Expr) = parse_term(Expr.flatten()).apply().



% 
% Alternative approach
% 
solve_num2(Nums, Target) =>
    Syms = [+,-,*,/],
    Perms = permutations([I.to_string() : I in Nums]),
    Seen = new_map(), % weed out duplicates
    foreach(X in Syms,Y in Syms, Z in Syms)
        foreach(P in Perms) 
           [A,B,C,D] = P,
           if catch(check(A,X,B,Y,C,Z,D,Target,Expr),E,ignore(E)), 
              not Seen.has_key(Expr) then
                println(Expr.flatten()=Expr.eval().round()),
                Seen.put(Expr,1)
           end
        end
    end.

to_string2(Expr) = [E.to_string() : E in Expr].flatten().

check(A,X,B,Y,C,Z,D,Target,Expr) ?=> 
   Expr = ["(",A,Y,B,")",X,"(",C,Z,D,")"].to_string2(),
   Target =:= Expr.eval().

check(A,X,B,Y,C,Z,D,Target,Expr) ?=> 
   Expr = [A,X,"(",B,Y,"(",C,Z,D,")",")"].to_string2(),
   Target =:= Expr.eval().

check(A,X,B,Y,C,Z,D,Target,Expr) ?=> 
   Expr = ["(","(",C,Z,D,")",Y,B,")",X,A].to_string2(),
   Target =:= Expr.eval().

check(A,X,B,Y,C,Z,D,Target,Expr) ?=> 
   Expr = ["(",B,Y,"(",C,Z,D,")",")",X,A].to_string2(),
   Target =:= Expr.eval().

check(A,X,B,Y,C,Z,D,Target,Expr) => 
   Expr = [A,X,"(","(",B,Y,C,")", Z,D,")"].to_string2(),
   Target =:= Expr.eval().


go =>
   N = 15,
   Start = 1, % start node
   End = 15,  % end node
   M = 9, % large number
   
   Nodes = [
          "8,0,0", % start
          "5,0,3",
          "5,3,0",
          "2,3,3",
          "2,5,1",
          "7,0,1",
          "7,1,0",
          "4,1,3",
          "3,5,0",
          "3,2,3",
          "6,2,0",
          "6,0,2",
          "1,5,2",
          "1,4,3",
          "4,4,0" % goal
      ],

   % distance matrix (the moves)
   D = [[M, 1, M, M, M, M, M, M, 1, M, M, M, M, M, M],
        [M, M, 1, M, M, M, M, M, M, M, M, M, M, M, M],
        [M, M, M, 1, M, M, M, M, 1, M, M, M, M, M, M],
        [M, M, M, M, 1, M, M, M, M, M, M, M, M, M, M],
        [M, M, M, M, M, 1, M, M, 1, M, M, M, M, M, M],
        [M, M, M, M, M, M, 1, M, M, M, M, M, M, M, M],
        [M, M, M, M, M, M, M, 1, 1, M, M, M, M, M, M],
        [M, M, M, M, M, M, M, M, M, M, M, M, M, M, 1], 
        [M, M, M, M, M, M, M, M, M, 1, M, M, M, M, M],
        [M, 1, M, M, M, M, M, M, M, M, 1, M, M, M, M],
        [M, M, M, M, M, M, M, M, M, M, M, 1, M, M, M],
        [M, 1, M, M, M, M, M, M, M, M, M, M, 1, M, M],
        [M, M, M, M, M, M, M, M, M, M, M, M, M, 1, M],
        [M, 1, M, M, M, M, M, M, M, M, M, M, M, M, 1], 
        [M, M, M, M, M, M, M, M, M, M, M, M, M, M, M]],

   N = D.length,
   
   % decision variables
   Rhs = new_list(N), % requirements (right hand statement)
   Rhs :: -1..1,

   % objective to minimize
   Z :: 0..M,

   % the resulting matrix, 1 if connected, 0 else
   X = new_array(N,N),
   X :: 0..1,

   Z #= sum([D[I,J]*X[I,J] : I in 1..N, J in 1..N, D[I,J] < M]),

   OutFlow = new_list(N),
   OutFlow :: 0..1,

   InFlow = new_list(N),
   InFlow :: 0..1,
   
   foreach(I in 1..N)
       if I == Start then 
         Rhs[I] #= 1
       elseif I == End then 
         Rhs[I] #= -1
       else 
         Rhs[I] #= 0
       end
   end,

   % must be larger than 0
   % foreach(I in 1..N, J in 1..N, D[I,J] < M) X[I,J] #>= 0 end,

   % outflow constraint
   foreach(I in 1..N) OutFlow[I] #= sum([X[I,J] : J in 1..N, D[I,J] < M]) end,
   % inflow constraint
   foreach(J in 1..N) InFlow[J] #= sum([X[I,J] : I in 1..N, D[I,J] < M]) end,
   % inflow = outflow
   foreach(I in 1..N) OutFlow[I]-InFlow[I]#=Rhs[I] end,

   % Z #= 7,

   % solve
   Vars = OutFlow ++ InFlow ++ X.to_list() , % ++ Rhs,

   solve([$min(Z),split], Vars),
   % solve([split], Vars),
   
   writeln(z=Z),
   printf("InFlow = %w\n", InFlow),
   printf("OutFlow= %w\n", OutFlow),
   T = Start,
   while (T != End)
      printf("%s -> ", Nodes[T]),
      Found = 0,
      foreach(J in 1..N,Found==0) 
        if X[T,J] = 1 then
          T := J,
          println(Nodes[T]),
          Found := 1 
        end
      end
   end,
   nl.

go =>

    beer1(99).

go2 => 
   println([beer2(Beer) : Beer in 99..-1..1].join("")).
        

beer1(N) => 
   Beer = N,
   while (Beer > 0)
       printf("%d bottles of beer on the wall,\n", Beer),
       printf("%d bottles of beer.\n", Beer),
       printf("Take one down, pass it around.\n"),
       printf("%d bottles of beer.\n", Beer-1),
       Beer := Beer -1
   end,
   print("0 more bottles of beer on the wall.\n"),
   nl.


beer2(B) = S => 
   BS = B.to_string(),
   BB = " bottle",
   BT = BB,
   if B > 1 then
      BB := BB ++ "s"
   end,
   OB = " of beer",
   NL = "\n",
   BW = OB ++ " on the wall." ++ NL,
   T = "Take one down, pass it around." ++ NL,
   S1 =  BS ++ BT ++ BW ++ BS ++ BT ++ OB ++ T ++
        cond(B > 0, (B-1).to_string() ++ BT ++ BW ++ NL, ""),
   S = S1.

go =>
   L = [1,2,3,4,5,6,2],

   % #1
   my_last(X1,L),
   writeln(my_last=X1),

   % #2
   last_but_one(X2,L),
   writeln(last_but_one=X2),

   % #3
   element_at(X3,L,3),
   writeln(element_at=X3),
   element_at(I3,L,2),
   writeln(element_at=I3),

   % #4
   my_length(L,Len4),
   writeln(my_length=Len4),

   % #5
   my_reverse(L,L5),
   writeln(my_reverse=L5),

   % #6 
   L6 = [a,b,b,a],
   if is_palindrome(L6) then
      writeln([L6,is_palindrome])
   end,
   L6b = [a,b,b,a,s],
   if is_palindrome(L6b) then
      writeln([L6b,is_palindrome])
   else 
      writeln([L6b,is_not_palindrome])
   end,

   % #7
   my_flatten([1,2,[3,4],5,[6,[7,[8,9]]]],L7),
   writeln(my_flatten=L7),

   % #8
   compress([1,1,1,3,2,2,1,4,2,5,5,3,6,5], L8a),
   writeln(compress=L8a),
   compress2([1,1,1,3,2,2,1,4,2,5,5,3,6,5], L8),
   % compress2([], L8),
   % % compress2(L8,[1,2,3]), % don't work (not surprisingly)
   writeln(compress2=L8),

   % #9
   pack([1,1,1,2,1,3,3,3,1,4,4], L9a),
   writeln(pack=L9a),
   pack2([1,1,1,2,1,3,3,3,1,4,4], L9),
   writeln(pack2=L9),

   % #10
   encode([1,1,1,2,1,3,3,3,1,4,4], L10a),
   writeln(encode=L10a),

   encode2([1,1,1,2,1,3,3,3,1,4,4], L10),
   writeln(encode2=L10),

   % #11
   encode_modified([1,1,1,2,1,3,3,3,1,4,4], L11a),
   writeln(encode_modified=L11a),
   encode_modified2([1,1,1,2,1,3,3,3,1,4,4], L11b),
   writeln(encode_modified2=L11b),

   % #12
   decode(L11b, L12a),
   writeln(decode=L12a),
   decode2(L11b, L12b),
   writeln(decode2=L12b),

   % #13
   encode_direct([1,1,1,2,1,3,3,3,1,4,4], L13),
   writeln(encode_direct=L13),

   % #14
   dupli([1,2,3,4,5], L14),
   writeln(dupli=L14),

   dupli2([1,2,3,4,5], L14b),
   writeln(dupli2=L14b),

   % #15
   dupli([1,2,3,4,5], 3, L15),
   writeln(dupliN=L15),

   % it's not reversible
   % dupli(L15b, 3, [1,1,1,2,2,2,3,3,3]),
   % writeln(dupliNRev=L15b),

   % #16
   drop([1,2,3,4,5], 2, L16),
   writeln(drop=L16),

   % #17
   split([1,2,3,4,5,6,7,8], 3, L17a,L17b),
   writeln(split=[L17a,L17b]),

   split(L17c, 3, [1,2,3],[4,5,6,7]),
   writeln(splitrev1=L17c),

   split([1,2,3,4,5,6,7,8], 3, L17d,[4,5,6,7,8]),
   writeln(splitrev2=L17d),

   % #18
   slice([1,2,3,4,5,6,7],2,5,L18),
   writeln(slice=L18),

   % #19
   rotate([a,b,c,d,e,f,g,h],3,L19),
   writeln(rotate=L19),

   rotate([a,b,c,d,e,f,g,h],-2,L19b),
   writeln(rotateb=L19b),

   % #20
   remove_at(X20,[1,2,3,4,5,6,7],3, L20),
   writeln(remove_at=[X20,L20]),

   % #21
   insert_at(3,[1,2,4,5,6,7], 3, L21),
   writeln(insert_at=L21),

   % #22
   range(1,10, L22),
   writeln(range=L22),

   % It's reversible when using CP (#>) so I keep this
   range(N20a,N20b, [1,2,3,4]),
   writeln(rangerev=[N20a,N20b]),

   range(N20c,4, [1,2,3,4]),
   writeln(rangerev=[N20c]),

   % #23
   rnd_select([2,3,5,7,11,13], 6, L23a),
   writeln(rnd_select=L23a),
   rnd_select2([2,3,5,7,11,13], 10, L23b),
   writeln(rnd_select=L23b),

   % #24
   lotto(7,35,L24),
   writeln(lotto=L24),
   writeln(lotto2=lotto2(7,35)),

   % #25
   rnd_permu([1,2,3,4,5],L25),
   writeln(rnd_permu=L25),

   % #26
   L26All = findall(L26, $combination(3,[1,2,3,4,5], L26)),
   writeln(combination=L26All),

   % #27
   group3([1,2,3,4,5,6,7,8,9], L27a,L27b,L27c),
   writeln(group3=[L27a,L27b,L27c]),

   group([1,2,3,4,5,6,7,8,9], [2,3,4],L27d),
   writeln(group2=L27d),

   % #28
   % #29
   % #30

   % #31
   P31 = [P : P in 2..100, is_prime(P)],
   writeln(is_prime=P31),

   % #32
   gcd2(10,70,P32),
   writeln(gcd2=P32),

   % #33
   if coprime(10,11) then println("10 and 11 are coprimes") end,
   if coprime(10,12) then println("10 and 12 are coprimes") end,

   % #34
   totient_phi(20,Phi34),
   writeln(totient_phi=Phi34),

   % #35
   prime_factors(600851475143,P35),
   writeln(prime_factors=P35),

   % #36
   writeln(prime_factors_mult),
   prime_factors_mult(315, P36),
   writeln(prime_factors_mult=P36),

   prime_factors_mult(2305567963945518424753102147331756070, P36b),
   writeln(prime_factors_mult=P36b),

   % #37
   totient_phi_2(36,Phi37),
   writeln(totient_phi_2=Phi37),

   Phi37b= [[N,P] : N in 1..100, totient_phi_2(N,P)],
   write(totient_phi_2=Phi37b),

   % #38
   totient_test(1000002),

   % #39
   prime_list(50,100, P39),
   writeln(prime_list=P39),

   prime_list2(50,100, P39b),
   writeln(prime_list2=P39b),

   println("timing prime_list/2:"),
   time(prime_list(2,1000000, P39c)),
   % writeln(len=P39c.length),
   println("timing prime_list2/2:"),
   time(prime_list2(2,1000000, P39d)),
   % writeln(len=P39d.length),

   % #40
   goldbach(28,P40),
   writeln(goldbach=P40),
   foreach(I in 4..2..20) 
      goldbach2(I,G), 
      writeln([I,G, G.length])
   end,

   % #41
   goldbach_list(4,20),

   % #42
   % #43
   % #44
   % #45

   % #46
   % truth_table(A,B,and(A,or(A,B))),

   p54_test(),

   nl.

% P01 (*): Find the last element of a list
%
% my_last(X,L) :- X is the last element of the list L
%    (element,list) (?,?)
%
% Note: last(?Elem, ?List) is predefined

% Prolog code:
% my_last(X,[X]).
% my_last(X,[_|L]) :- my_last(X,L).

my_last(X,[Y]) => X=Y.
my_last(X,[_|L]) => my_last(X,L).



% P02 (*): Find the last but one element of a list
%
% last_but_one(X,L) :- X is the last but one element of the list L
%    (element,list) (?,?)
%

% Prolog code:
% last_but_one(X,[X,_]).
% last_but_one(X,[_,Y|Ys]) :- last_but_one(X,[Y|Ys]).


last_but_one(X,[Y,_]) => X = Y.
last_but_one(X,[_,Y|Ys]) => last_but_one(X,[Y|Ys]).


% P03 (*): Find the K'th element of a list.
% The first element in the list is number 1.
%
% element_at(X,L,K) :- X is the K'th element of the list L
%    (element,list,integer) (?,?,+)
%
% Note: nth1(?Index, ?List, ?Elem) is predefined
%

% Prolog code
% element_at(X,[X|_],1).
% element_at(X,[_|L],K) :- K > 1, K1 is K - 1, element_at(X,L,K1).

element_at(X,[Y|_],1) => X = Y.
element_at(X,[_|L],K) => K > 1, K1 = K - 1, element_at(X,L,K1).



% P04 (*): Find the number of elements of a list.
%
% my_length(L,N) :- the list L contains N elements
%    (list,integer) (+,?) 
%
% Note: length(?List, ?Int) is predefined
%

% Prolog code:
% my_length([],0).
% my_length([_|L],N) :- my_length(L,N1), N is N1 + 1.

my_length([],N) => N = 0.
my_length([_|L],N) => my_length(L,N1), N = N1 + 1.



% P05 (*): Reverse a list.
%
% my_reverse(L1,L2) :- L2 is the list obtained from L1 by reversing 
%    the order of the elements.
%    (list,list) (?,?)
%
% Note: reverse(+List1, -List2) is predefined

% Prolog code:
% my_reverse(L1,L2) :- my_rev(L1,L2,[]).
% my_rev([],L2,L2) :- !.
% my_rev([X|Xs],L2,Acc) :- my_rev(Xs,L2,[X|Acc]).

my_reverse(L1,L2) => my_rev(L1,L2,[]).
my_rev([],L2,L3) => L2 = L3.
my_rev([X|Xs],L2,Acc) => my_rev(Xs,L2,[X|Acc]).



% P06 (*): Find out whether a list is a palindrome
% A palindrome can be read forward or backward; e.g. [x,a,m,a,x]
%
% is_palindrome(L) => L is a palindrome list
%    (list) (?)
%
is_palindrome(L) => my_reverse(L,L).


% P07 (**): Flatten a nested list structure.
%
% my_flatten(L1,L2) :- the list L2 is obtained from the list L1 by
%    flattening; i.e. if an element of L1 is a list then it is replaced
%    by its elements, recursively. 
%    (list,list) (+,?)
%
% Note: flatten(+List1, -List2) is a predefined predicate
my_flatten(X,Y), not list(X) ?=> Y = [X].
my_flatten([],X) => X = [].
my_flatten([X|Xs],Zs) => my_flatten(X,Y), my_flatten(Xs,Ys), append(Y,Ys,Zs).


% P08 (**): Eliminate consecutive duplicates of list elements.
%
% compress(L1,L2) :- the list L2 is obtained from the list L1 by
%    compressing repeated occurrences of elements into a single copy
%    of the element.
%    (list,list) (+,?)
%

% Prolog version:
% compress([],[]).
% compress([X],[X]).
% compress([X,X|Xs],Zs) :- compress([X|Xs],Zs).
% compress([X,Y|Ys],[X|Zs]) :- X \= Y, compress([Y|Ys],Zs).

compress([],Y) => Y=[].
compress([X],Y1) => Y1=[X].
compress([X,X|Xs],Zs) => compress([X|Xs],Zs).
compress([X,Y|Ys],Z1) => Z1=[X|Zs], X != Y, compress([Y|Ys],Zs).

compress2(X,Y) => 
   Y1 = [X[1]],
   foreach(I in 2..X.length, X[I] != X[I-1]) 
      Y1 := Y1 ++ [X[I]] 
   end,
   Y = Y1.


% P09 (**):  Pack consecutive duplicates of list elements into sublists.

% pack(L1,L2) :- the list L2 is obtained from the list L1 by packing
%    repeated occurrences of elements into separate sublists.
%    (list,list) (+,?)

pack([],Y) => Y = [].
pack([X|Xs],[Z|Zs]) => transfer(X,Xs,Ys,Z), pack(Ys,Zs).
pack(X1,Z1) => X1=[X|Xs],Z1=[Z|Zs],transfer(X,Xs,Ys,Z), pack(Ys,Zs).


% transfer(X,Xs,Ys,Z) Ys is the list that remains from the list Xs
%    when all leading copies of X are removed and transfered to Z

transfer(X,Y1,Y2,Y) ?=> Y1=[], Y2=[], Y = [X].
transfer(X,Y1,Y2,Z) ?=> Y1=Y2, Y1 = [Y|_Ys], X != Y, Z = [X].
transfer(X,Y1,Ys,Z1) ?=> Y1=[X|Xs], Z1=[X|Zs], transfer(X,Xs,Ys,Zs).

pack2(X,Y) =>
   Y1 = [],
   Tmp = [X[1]],
   foreach(I in 2..X.length) 
      if X[I] == X[I-1] then 
        Tmp := Tmp ++ [X[I]]
      else
        Y1 := Y1 ++ [Tmp],
        Tmp := [X[I]]
      end
   end,
   if Tmp.length > 0 then
       Y1 := Y1 ++ [Tmp]
   end,
   Y = Y1.


% P10 (*):  Run-length encoding of a list
%
% encode(L1,L2) :- the list L2 is obtained from the list L1 by run-length
%    encoding. Consecutive duplicates of elements are encoded as terms [N,E],
%    where N is the number of duplicates of the element E.
%    (list,list) (+,?)
%
% :- ensure_loaded(p09).

encode(L1,L2) => pack2(L1,L), transform(L,L2).

% Prolog code:
% transform([],[]).
% transform([[X|Xs]|Ys],[[N,X]|Zs]) :- length([X|Xs],N), transform(Ys,Zs).

transform(X,Y) ?=> X = [], Y = [].
transform(X1, Z1) ?=> X1 = [[X|Xs]|Ys],Z1=[[N,X]|Zs], N = length([X|Xs]), transform(Ys,Zs).


encode2(L1,L2) => pack2(L1,L), transform2(L,L2).
transform2(L,L2) =>
    Tmp = [],
    foreach(E in L) 
       Tmp := Tmp ++ [[E.length,E[1]]]
    end,
    L2 = Tmp.


% P11 (*):  Modified run-length encoding

% encode_modified(L1,L2) :- the list L2 is obtained from the list L1 by 
%    run-length encoding. Consecutive duplicates of elements are encoded 
%    as terms [N,E], where N is the number of duplicates of the element E.
%    However, if N equals 1 then the element is simply copied into the 
%    output list.
%    (list,list) (+,?)


encode_modified(L1,L2) => encode(L1,L), strip(L,L2).

strip([],Y) ?=> Y = [].
strip([[1,X]|Ys],Z1) ?=> Z1=[X|Zs], strip(Ys,Zs).
strip([[N,X]|Ys],Z1) ?=> Z1=[[N,X]|Zs], N > 1, strip(Ys,Zs).


encode_modified2(L1,L2) => encode2(L1,L), strip2(L,L2).
strip2([],[]) => true.
strip2(X,Y) =>
   Y1 = [],
   foreach(E in X)
      if E[1] == 1 then
         Y1 := Y1 ++ [E[2]]
      else
         Y1 := Y1 ++ [E]
      end
   end,
   Y = Y1.


% P12 (**): Decode a run-length compressed list.

% decode(L1,L2) :- L2 is the uncompressed version of the run-length
%    encoded list L1.
%    (list,list) (+,?)

% Note this is a decode of encode_modified/2.
decode([],Y) ?=> Y = [].
decode([X|Ys],Z1) ?=> not list(X), Z1=[X|Zs], decode(Ys,Zs).
decode([[1,X]|Ys],Z1) ?=> Z1 = [X|Zs], decode(Ys,Zs).
decode([[N,X]|Ys],Z1) ?=> N > 1, N1 = N - 1, Z1 = [X|Zs], decode([[N1,X]|Ys],Zs).


decode2(X,Y) =>
   Y1 = [],
   foreach(E in X) 
      if list(E) then
        Y1 := Y1 ++ [E[2] : _I in 1..E[1]]
      else
        Y1 := Y1 ++ [E]
      end
   end,
   Y = Y1.


% P13 (**): Run-length encoding of a list (direct solution) 

% encode_direct(L1,L2) :- the list L2 is obtained from the list L1 by 
%    run-length encoding. Consecutive duplicates of elements are encoded 
%    as terms [N,E], where N is the number of duplicates of the element E.
%    However, if N equals 1 then the element is simply copied into the 
%    output list.
%    (list,list) (+,?)

% Prolog code:
% encode_direct([],[]).
% encode_direct([X|Xs],[Z|Zs]) :- count(X,Xs,Ys,1,Z), encode_direct(Ys,Zs).


encode_direct([],Y) ?=> Y = [].
encode_direct([X|Xs],Z1) ?=> Z1=[Z|Zs], count(X,Xs,Ys,1,Z), encode_direct(Ys,Zs).

% count(X,Xs,Ys,K,T) Ys is the list that remains from the list Xs
%    when all leading copies of X are removed. T is the term [N,X],
%    where N is K plus the number of X's that can be removed from Xs.
%    In the case of N=1, T is X, instead of the term [1,X].

% Prolog code
% count(X,[],[],1,X).
% count(X,[],[],N,[N,X]) :- N > 1.
% count(X,[Y|Ys],[Y|Ys],1,X) :- X \= Y.
% count(X,[Y|Ys],[Y|Ys],N,[N,X]) :- N > 1, X \= Y.
% count(X,[X|Xs],Ys,K,T) :- K1 is K + 1, count(X,Xs,Ys,K1,T).


count(X,[],[],1,X1)  => X1=X.
count(X,[],Y2,N,NX)  => Y2=[],NX=[N,X], N > 1.
count(X,Y1,Y2,N,NX) ?=> NX=[N,X], N=1,Y1=[Y|_Ys], Y2 = Y1, X != Y.
count(X,Y1,Y2,N,NX) ?=> Y1=[Y|_Ys], Y2=Y1, NX=[N,X], N > 1, X != Y.
count(X,X1,Ys,K,T)   => X1=[X|Xs], count(X,Xs,Ys,K+1,T).


% P14 (*): Duplicate the elements of a list
%
% dupli(L1,L2) :- L2 is obtained from L1 by duplicating all elements.
%    (list,list) (?,?)
%
dupli(X,Y) ?=> X = [], Y = [].
% dupli([X|Xs],[X,X|Ys]) ?=> writeln(dupli2), dupli(Xs,Ys).
dupli(X1,Y1) ?=> X1 = [X|Xs], Y1 = [X,X|Ys], dupli(Xs,Ys).

dupli2(X,Y) => 
   Y1 = [],
   foreach(E in X)
     Y1 := Y1 ++ [E,E]
   end,
   Y = Y1.


% P15 (**): Duplicate the elements of a list agiven number of times
%
% dupli(L1,N,L2) :- L2 is obtained from L1 by duplicating all elements
%    N times.
%    (list,integer,list) (?,+,?)

dupli(L1,N,L2) ?=> dupli(L1,N,L2,N).

% dupli(L1,N,L2,K) :- L2 is obtained from L1 by duplicating its leading
%    element K times, all other elements N times.
%    (list,integer,list,integer) (?,+,?,+)
%
dupli([],_,Y,_) ?=> Y = [].
dupli(X1,N,Ys,0) ?=> X1=[_|Xs], dupli(Xs,N,Ys,N).
dupli(X1,N,X2,K) ?=> X1 = [X|Xs], X2 = [X|Ys], K > 0, dupli([X|Xs],N,Ys,K-1).


% P16 (**):  Drop every N'th element from a list
%
% drop(L1,N,L2) :- L2 is obtained from L1 by dropping every N'th element.
%    (list,integer,list) (?,+,?)

drop(L1,N,L2) => drop(L1,N,L2,N).

% drop(L1,N,L2,K) :- L2 is obtained from L1 by first copying K-1 elements
%    and then dropping an element and, from then on, dropping every
%    N'th element.
%    (list,integer,list,integer) (?,+,?,+)

drop([],_,Y,_) => Y = [].
drop([_|Xs],N,Ys,1) => drop(Xs,N,Ys,N).
drop([X|Xs],N,Y1,K) => Y1=[X|Ys],K > 1, K1 = K - 1, drop(Xs,N,Ys,K1).


% P17 (*): Split a list into two parts
%
% split(L,N,L1,L2) :- the list L1 contains the first N elements
%    of the list L, the list L2 contains the remaining elements.
%    (list,integer,list,list) (?,+,?,?)

split(L,0,L1,L2) => L1=[], L2 = L.
split(L,N,L1,Zs) => L=[X|Xs], L1=[X|Ys], N > 0, N1 = N - 1, split(Xs,N1,Ys,Zs).



% P18 (**):  Extract a slice from a list
%
% slice(L1,I,K,L2) :- L2 is the list of the elements of L1 between
%    index I and index K (both included).
%    (list,integer,integer,list) (?,+,+,?)

slice(L1,1,1,L2) => L1=[X|_], L2=[X].
slice(L1,1,K,L2) => L1=[X|Xs], L2=[X|Ys], K > 1, K1 = K - 1, slice(Xs,1,K1,Ys).
slice(L1,I,K,Ys) => L1=[_|Xs],I > 1, I1 = I - 1, K1 = K - 1, slice(Xs,I1,K1,Ys).



% P19 (**): Rotate a list N places to the left 

% rotate(L1,N,L2) :- the list L2 is obtained from the list L1 by 
%    rotating the elements of L1 N places to the left.
%    Examples: 
%    rotate([a,b,c,d,e,f,g,h],3,[d,e,f,g,h,a,b,c])
%    rotate([a,b,c,d,e,f,g,h],-2,[g,h,a,b,c,d,e,f])
%    (list,integer,list) (+,+,?)

rotate(L1,N,L2) ?=> N >= 0, 
   my_length(L1,NL1), N1 = N mod NL1, rotate_left(L1,N1,L2).
rotate(L1,N,L2) ?=> N < 0,
   % original Prolog code:
   % length(L1,NL1), N1 is NL1 + (N mod NL1), rotate_left(L1,N1,L2).
   my_length(L1,NL1), N1 = (NL1 + N) mod NL1, rotate_left(L1,N1,L2).

rotate_left(L,0,L1) => L1=L.
rotate_left(L1,N,L2) => N > 0, split(L1,N,S1,S2), append(S2,S1,L2).




% P20 (*): Remove the K'th element from a list.
% The first element in the list is number 1.
%
% remove_at(X,L,K,R) :- X is the K'th element of the list L; R is the
%    list that remains when the K'th element is removed from L.
%    (element,list,integer,list) (?,?,+,?)

remove_at(X,L,1,R) => L=[X|Xs], R=Xs.
remove_at(X,L,K,R) => L=[Y|Xs], R=[Y|Ys], K #> 1, K1 #= K - 1, remove_at(X,Xs,K1,Ys).


% P21 (*): Insert an element at a given position into a list
% The first element in the list is number 1.
%
% insert_at(X,L,K,R) :- X is inserted into the list L such that it
%    occupies position K. The result is the list R.
%    (element,list,integer,list) (?,?,+,?)

insert_at(X,L,K,R) => remove_at(X,R,K,L).


% P22 (*):  Create a list containing all integers within a given range.
%
% range(I,K,L) :- I <= K, and L is the list containing all 
%    consecutive integers from I to K.
%    (integer,integer,list) (+,+,?)

% Prolog code:
% range(I,I,[I]).
% range(I,K,[I|L]) :- I < K, I1 is I + 1, range(I1,K,L).

% Note: Using #< makes it reversible which means that the mode is (?,?,?).

range(I,I2,L) ?=> I=I2, L = [I].
range(I,K,L2) ?=> L2=[I|L], I #< K, I1 = I + 1, range(I1,K,L).



% P23 (**): Extract a given number of randomly selected elements 
%    from a list.

% rnd_select(L,N,R) :- the list R contains N randomly selected 
%    items taken from the list L.
%    (list,integer,list) (+,+,-)

% Note: This is random selection without replacement, which
%       assumes that N must be <= L.length
rnd_select(_,0,R) ?=> R = [].
rnd_select(Xs,N,R) ?=> 
    R = [X|Zs],
    N > 0,
    my_length(Xs,L),
    % I = random(L) + 1, % Picat's random don't work like this
    I = 1+random2() mod L,
    remove_at(X,Xs,I,Ys),
    N1 = N - 1,
    rnd_select(Ys,N1,Zs).

%
% Variant using list compresension: mode (+,+,-)
% Note: We don't assume anything about N and L.length.
%       This is random selection _with_ replacement 
rnd_select2(L,N,R) =>
    R1 = [],
    Len = L.length,
    foreach(_I in 1..N)
       E = L[1+random2() mod Len],
       R1 := R1 ++ [E]
    end,
    R = R1.



% P24 (*): Lotto: Draw N different random numbers from the set 1..M
%
% lotto(N,M,L) :- the list L contains N randomly selected distinct
%    integer numbers from the interval 1..M
%    (integer,integer,number-list) (+,+,-)

% Prolog code:

lotto(N,M,L) => range(1,M,R), rnd_select(R,N,L).

% as a function
lotto2(N,M) = L => range(1,M,R), rnd_select(R,N,L).


% P25 (*):  Generate a random permutation of the elements of a list
%
% rnd_permu(L1,L2) :- the list L2 is a random permutation of the
%    elements of the list L1.
%    (list,list) (+,-)


rnd_permu(L1,L2) => my_length(L1,N), rnd_select(L1,N,L2).


% P26 (**):  Generate the combinations of k distinct objects
%            chosen from the n elements of a list.
%
% combination(K,L,C) :- C is a list of K distinct elements 
%    chosen from the list L

% Prolog code
% combination(0,_,[]).
% combination(K,L,[X|Xs]) :- el(X,L,R),K1 is K-1, combination(K1,R,Xs).

combination(0,_,C) => C = [].
combination(K,L,C) => C=[X|Xs], el(X,L,R), K1 = K-1, combination(K1,R,Xs).

% Find out what the following predicate el/3 exactly does.

el(X,L1,L) ?=> L1=[X|L].
el(X,L1,R) => L1 = [_|L], el(X,L,R).


% P27 (**) Group the elements of a set into disjoint subsets.

% Problem a)

% group3(G,G1,G2,G3) :- distribute the 9 elements of G into G1, G2, and G3,
%    such that G1, G2 and G3 contain 2,3 and 4 elements respectively

group3(G,G1,G2,G3) =>
    selectN(2,G,G1),
    subtract(G,G1,R1),
    selectN(3,R1,G2),
    subtract(R1,G2,R2),
    selectN(4,R2,G3),
    subtract(R2,G3,[]).

% selectN(N,L,S) :- select N elements of the list L and put them in 
%    the set S. Via backtracking return all posssible selections, but
%    avoid permutations; i.e. after generating S = [a,b,c] do not return
%    S = [b,a,c], etc.

selectN(0,_,S) => S = [].
selectN(N,L,S1) => 
   N > 0, 
   S1 = [X|S],
   el(X,L,R), 
   selectN(N-1,R,S).

% el(X,[X|L],L).
% el(X,[_|L],R) :- el(X,L,R).

% subtract/3 is predefined in Prolog, but not in Picat

subtract([], _, L3) ?=> L3 = [].
subtract(L1, B, D) ?=>
    L1 = [A|C],
    membchk(A, B), 
    subtract(C, B, D).
subtract(L1, C, L3) ?=>
    L1= [A|B],
    L3 =[A|D],
    subtract(B, C, D).

% Problem b): Generalization

% group(G,Ns,Gs) :- distribute the elements of G into the groups Gs.
%    The group sizes are given in the list Ns.

group([],Ns,Gs) => Ns = [], Gs = [].
group(G,NN,G2) =>
   NN = [N1|Ns],
   G2 = [G1|Gs],
   selectN(N1,G,G1),
   subtract(G,G1,R),
   group(R,Ns,Gs).


% P28 (**) Sorting a list of lists according to length
%
% a) length sort
%
% lsort(InList,OutList) :- it is supposed that the elements of InList 
% are lists themselves. Then OutList is obtained from InList by sorting 
% its elements according to their length. lsort/2 sorts ascendingly,
% lsort/3 allows for ascending or descending sorts.
% (list_of_lists,list_of_lists), (+,?)

% hakank: I skip this for now...

% P31 (**) Determine whether a given integer number is prime. 

% is_prime(P) :- P is a prime number
%    (integer) (+)

table
is_prime(2) => true.
is_prime(3) => true.
is_prime(P), P > 3, P mod 2 != 0 => not has_factor(P,3).  

% has_factor(N,L) :- N has an odd factor F >= L.
%    (integer, integer) (+,+)

has_factor(N,L), N mod L == 0 => true.
has_factor(N,L) => L * L <= N, L2 = L + 2, has_factor(N,L2).


% P32 (**) Determine the greatest common divisor of two positive integers.

% gcd(X,Y,G) :- G is the greatest common divisor of X and Y
%    (integer, integer, integer) (+,+,?)


gcd2(X,0,X2) => X > 0, X = X2.
gcd2(X,Y,G) => Y > 0, Z = X mod Y, gcd2(Y,Z,G).


% Declare gcd as an arithmetic function; so you can use it
% like this:  ?- G is gcd(36,63).
% :- arithmetic_function(gcd/2).



% P33 (*) Determine whether two positive integer numbers are coprime. 
%     Two numbers are coprime if their greatest common divisor equals 1.

% coprime(X,Y) :- X and Y are coprime.
%    (integer, integer) (+,+)

coprime(X,Y) => gcd2(X,Y,1).



% P34 (**) Calculate Euler's totient function phi(m). 
%    Euler's so-called totient function phi(m) is defined as the number 
%    of positive integers r (1 <= r < m) that are coprime to m. 
%    Example: m = 10: r = 1,3,7,9; thus phi(m) = 4. Note: phi(1) = 1.

% totient_phi(M,Phi) :- Phi is the value of the Euler's totient function
%    phi for the argument M.
%    (integer, integer) (+,-)

totient_phi(1,Phi) => Phi = 1.
totient_phi(M,Phi) => t_phi(M,Phi,1,0).

% t_phi(M,Phi,K,C) => Phi = C + N, where N is the number of integers R
%    such that K <= R < M and R is coprime to M.
%    (integer,integer,integer,integer) (+,-,+,+)

t_phi(M,Phi,M2,Phi2) ?=> M=M2, Phi=Phi2.
t_phi(M,Phi,K,C), K < M, coprime(K,M) => 
   C1 = C + 1, K1 = K + 1,
   t_phi(M,Phi,K1,C1).
t_phi(M,Phi,K,C), K < M => 
   K1 = K + 1,
   t_phi(M,Phi,K1,C).



% P35 (**) Determine the prime factors of a given positive integer. 

% prime_factors(N, L) :- N is the list of prime factors of N.
%    (integer,list) (+,?)

prime_factors(N,L), N > 0 => prime_factors(N,L,2).

% prime_factors(N,L,K) :- L is the list of prime factors of N. It is 
% known that N does not have any prime factors less than K.


prime_factors(1,L,_) => L=[].
prime_factors(N,FL,F) ?=>                          % N is multiple of F
   FL = [F|L],
   R = N // F, N == R * F,  prime_factors(R,L,F).
prime_factors(N,L,F) =>
   next_factor(N,F,NF), prime_factors(N,L,NF).        % N is not multiple of F
   

% next_factor(N,F,NF) :- when calculating the prime factors of N
%    and if F does not divide N then NF is the next larger candidate to
%    be a factor of N.

next_factor(_,2,NF), NF=3 => true.
next_factor(N,F,NF), F * F < N => NF = F + 2.
next_factor(N,_,N2), N=N2 => true.  % F > sqrt(N)


% P36 (**) Determine the prime factors of a given positive integer (2). 
% Construct a list containing the prime factors and their multiplicity.
% Example: 
% ?- prime_factors_mult(315, L).
% L = [[3,2],[5,1],[7,1]]

% prime_factors_mult(N, L) => L is the list of prime factors of N. It is
%    composed of terms [F,M] where F is a prime factor and M its multiplicity.
%    (integer,list) (+,?)

prime_factors_mult(N,L), N > 0 => prime_factors_mult(N,L,2).

% prime_factors_mult(N,L,K) => L is the list of prime factors of N. It is 
% known that N does not have any prime factors less than K.

prime_factors_mult(1,F,_) => F=[].
prime_factors_mult(N,FML,F) ?=> divide(N,F,M,R), % F divides N
   FML = [[F,M]|L],
   next_factor(R,F,NF), prime_factors_mult(R,L,NF).
prime_factors_mult(N,L,F) =>                           % F does not divide N
   next_factor(N,F,NF), prime_factors_mult(N,L,NF).

% divide(N,F,M,R) => N = R * F**M, M >= 1, and F is not a factor of R. 
%    (integer,integer,integer,integer) (+,+,-,-)

divide(N,F,M,R) => divi(N,F,M,R,0), M > 0.

divi(N,F,M,R,K) ?=> 
   S = N // F, N == S * F,          % F divides N
   K1 = K + 1, divi(S,F,M,R,K1).
divi(N,_,M,N2,M2) => N2 = N, M2 = M.



% P37 (**) Calculate Euler's totient function phi(m) (improved). 
% See problem P34 for the definition of Euler's totient function. 
% If the list of the prime factors of a number m is known in the 
% form of problem P36 then the function phi(m) can be efficiently
% calculated as follows: 
%
% Let [[p1,m1],[p2,m2],[p3,m3],...] be the list of prime factors (and their
% multiplicities) of a given number m. Then phi(m) can be calculated 
% with the following formula:
%
% phi(m) = (p1 - 1) * p1 ** (m1 - 1) * (p2 - 1) * p2 ** (m2 - 1) * 
%          (p3 - 1) * p3 ** (m3 - 1) * ...
%
% Note that a ** b stands for the b'th power of a.

% totient_phi_2(N,Phi) :- Phi is the value of Euler's totient function
%    for the argument N.
%    (integer,integer) (+,?)

totient_phi_2(N,Phi) => prime_factors_mult(N,L), to_phi(L,Phi).

to_phi([],Phi) => Phi=1.
to_phi(F1L,Phi) ?=>
   F1L=[[F,1]|L],
   to_phi(L,Phi1), Phi = Phi1 * (F - 1).
to_phi(FML,Phi) =>
   FML=[[F,M]|L],
   M > 1,
   M1 = M - 1, to_phi([[F,M1]|L],Phi1), Phi = Phi1 * F.


% P38 (*) Compare the two methods of calculating Euler's totient function. 
% Use the solutions of problems P34 and P37 to compare the algorithms. 
% Take the number of logical inferences as a measure for efficiency.

totient_test(N) =>
   printf("\n"),
   write('totient_phi (P34):'),
   time(totient_phi(N,Phi1)),
   write('result = '), write(Phi1), nl,
   write('totient_phi_2 (P37):'),
   time(totient_phi_2(N,Phi2)),
   write('result = '), write(Phi2), nl.



% P39 (*) A list of prime numbers. 
% Given a range of integers by its lower and upper limit, construct a 
% list of all prime numbers in that range.

% prime_list(A,B,L) :- L is the list of prime number P with A <= P <= B

prime_list(A,B,L), A =< 2  => p_list(2,B,L).
prime_list(A,B,L), A > 2 => A1 = (A // 2) * 2 + 1, p_list(A1,B,L).

p_list(A,B,L) ?=> A > B, L = []. 
p_list(A,B,AL) ?=> AL=[A|L], is_prime(A), 
   next(A,A1), p_list(A1,B,L). 
p_list(A,B,L) => 
   next(A,A1), p_list(A1,B,L).

next(2,N) => N = 3 .
next(A,A1) => A1 = A + 2.

% Using list comprehension is much easier, and faster
prime_list2(A,B, L) =>
  L = [ I : I in A..B, is_prime(I)].


% P40 (**) Goldbach's conjecture. 
% Goldbach's conjecture says that every positive even number greater 
% than 2 is the sum of two prime numbers. Example: 28 = 5 + 23.

% goldbach(N,L) :- L is the list of the two prime numbers that
%    sum up to the given N (which must be even).
%    (integer,integer) (+,-)

goldbach(N,L), N mod 2 == 1 => L = [].
goldbach(N,L), N < 2 => L = [].
goldbach(4,L) => L = [2,2].
goldbach(N,L) => N mod 2 == 0, N > 4, goldbach(N,L,3).

goldbach(N,PQ,P) ?=> PQ=[P,Q], Q = N - P, is_prime(Q).
goldbach(N,L,P), P < N ?=> next_prime(P,P1), goldbach(N,L,P1).

next_prime(P,P1) ?=> P1 = P + 2, is_prime(P1).
next_prime(P,P1) => P2 = P + 2, next_prime(P2,P1).

% another approach
goldbach2(N,L) =>
   L = [ [P1,P2] : P1 in 1..N//2, P2 in P1..N, prime(P1),prime(P2), P1+P2=N].



% P41 (*) A list of Goldbach compositions. 
% Given a range of integers by its lower and upper limit, 
% print a list of all even numbers and their Goldbach composition.

% goldbach_list(A,B) :- print a list of the Goldbach composition
%    of all even numbers N in the range A <= N <= B
%    (integer,integer) (+,+)

goldbach_list(A,B) => goldbach_list(A,B,2).

% goldbach_list(A,B,L) => perform goldbach_list(A,B), but suppress
% all output when the first prime number is less than the limit L.

goldbach_list(A,B,L) => A =< 4, g_list(4,B,L).
goldbach_list(A,B,L) => A1 = ((A+1) // 2) * 2, g_list(A1,B,L).

g_list(A,B,_) ?=> A > B.
g_list(A,B,L) => 
   goldbach(A,[P,Q]),
   print_goldbach(A,P,Q,L),
   A2 = A + 2,
   g_list(A2,B,L).

print_goldbach(A,P,Q,L) => P >= L,
   printf("%w = %w + %w",A,P,Q), nl.
print_goldbach(_,_,_,_) => true.


% P46 (**) Truth tables for logical expressions.
% Define predicates and/2, or/2, nand/2, nor/2, xor/2, impl/2 
% and equ/2 (for logical equivalence) which succeed or
% fail according to the result of their respective operations; e.g.
% and(A,B) will succeed, if and only if both A and B succeed.
% Note that A and B can be Prolog goals (not only the constants
% true and fail).
% A logical expression in two variables can then be written in 
% prefix notation, as in the following example: and(or(A,B),nand(A,B)).
%
% Now, write a predicate table/3 which prints the truth table of a
% given logical expression in two variables.
%
% Example:
% ?- table(A,B,and(A,or(A,B))).
% true  true  true
% true  fail  true
% fail  true  fail
% fail  fail  fail
    
% and(A,B) :- A, B.

% or(A,_) :- A.
% or(_,B) :- B.

% equ(A,B) :- or(and(A,B), and(not(A),not(B))).

% xor(A,B) :- not(equ(A,B)).

% nor(A,B) :- not(or(A,B)).

% nand(A,B) :- not(and(A,B)).

% impl(A,B) :- or(not(A),B).

% % bind(X) :- instantiate X to be true and false successively

% bind(true).
% bind(fail).

% table(A,B,Expr) :-
% 	bind(A), bind(B),
% 	write('-----------------------------'),nl,
% 	mydo(A,B,Expr), fail.

% mydo(A,B,Expr):-write(A),write(' '),write(B),write(' '),writeValueOf(Expr),nl.

% writeValueOf(Expr):-Expr,write(itsTrue),nl.
% writeValueOf(Expr):-not(Expr),write(itsFalse),nl.

%
% hakank: Skipping some other problems....
%

% P54: Write a predicate istree/1 which succeeds if and only if its argument
%      is a Prolog term representing a binary tree.
%
% istree(T) :- T is a term representing a binary tree (i), (o)

istree(nil) => true.
istree(T) => T = $t(_,L,R), istree(L), istree(R).


% Test cases (can be used for other binary tree problems as well)
p54_test => 
     foreach(I in 1..4) 
        p54_tree(I, Tree),
        if istree(Tree) then
           writeln([Tree, is_a_tree])
        else
           writeln([Tree, not_a_tree])
        end
     end,
     p54_tree(1, Tree),
     writeln(traverse_tree1=traverse_tree1(Tree)),
     writeln(traverse_tree2=traverse_tree2(Tree)),
     writeln(traverse_tree3=traverse_tree3(Tree)),
     nl.

p54_tree(1,T) => T = $t(a,$t(b,$t(d,nil,nil),$t(e,nil,nil)),$t(c,nil,$t(f,$t(g,nil,nil),nil))).
p54_tree(2,T) => T = $t(a,nil,nil).
p54_tree(3,T) => T = nil.
p54_tree(4,T) => T = $t(nil,$t(nil)). % is not a tree

%
% Traversing a $t/3 tree (as a function)
%
traverse_tree1(nil) = [].
traverse_tree1(T) = L => 
    T = $t(Val,Left,Right), 
    L = [Val] ++ traverse_tree1(Left) ++ traverse_tree1(Right).
    
traverse_tree2(nil) = [].
traverse_tree2(T) = L => 
    T = $t(Val,Left,Right), 
    L = traverse_tree2(Left) ++ [Val] ++ traverse_tree2(Right).

traverse_tree3(nil) = [].
traverse_tree3(T) = L => 
    T = $t(Val,Left,Right), 
    L = traverse_tree3(Left) ++ traverse_tree3(Right)++ [Val].
    

go =>
   L = findall(LD, $abbot(LD)),
   writeln(L), nl.

abbot(LD) =>
   LD = [M, W, C],
   LD :: 1..100,
   M + W + C #= 100,

   % Men: 3, Women: 2, Children: 1/2 = 100
   M * 3 + W * 2 + C/2 #= 100,
   M * 5 #= W,    % additional condition added by Dudeney      

   solve([], LD).


go =>
  Row = 8,
  R = 1..Row,
  Col = 8,
  C = 1..Col,

  X = new_array(Row,Col),
  X :: 0..1,

  A = new_array(Row),
  A :: 0..4,
  B = new_array(Col),
  B :: 0..4,
  Row2=Row-2,
  CC = new_list(Row2),
  CC :: 0..4,
  D = new_list(Col-1),
  D :: 0..4,

  E = new_list(Col-1),
  E :: 0..4,
  F = new_list(Row-2),
  F :: 0..4,


  TotalSum #= sum([X[I,J] : I in R, J in C]),

  foreach(I in R)
     sum([X[I,J] : J in C]) #= 2*A[I]
  end,
    
  foreach(J in C)
     sum([X[I,J] : I in R]) #= 2*B[J]
  end,

  foreach(I in 2..Row-1)
     sum([X[K,I-K+1] : K in 1..I])  #= 2*CC[I-1]
  end,

  foreach(J in 1..Col-1)
     sum([X[K,Col-K+J] : K in J..Row])  #= 2*D[J]
  end,

  foreach(J in 1..Col-1)
    sum([X[K,J+K-1] : K in 1..Row-J+1])  #= 2*E[J]
  end,

  foreach(I in 2..Row-1)
     sum([X[K,K-I+1] : K in I..Row])  #= 2*F[I-1]
  end,

  X[1,1] #= 1,
  X[Row,1] #= 1,
  X[1,Col] #= 1,
  X[Row,Col] #= 1,

  solve($[max(TotalSum)], X.to_list() ++ [TotalSum]),
  % solve($[max(TotalSum)]),

  writeln(totalSum=TotalSum),
  foreach(XRow in X) writeln(XRow.to_list()) end,
  
  nl.

go => 
    foreach(P in 1..10) 
       printf("\nProblem %d\n", P),
       run_problem(P,X),
       % println(x=X),
       print_grid(X)
    end,
    nl.

run_problem(P,X) => 
    problem(P,N,MaxLetter,RowUpper,RowLower,ColLeft,ColRight, Diagonal),
    time2(abc_endview(N,MaxLetter,RowUpper,RowLower,ColLeft,ColRight, Diagonal, X)).


abc_endview(N,MaxLetter,RowUpper,RowLower,ColLeft,ColRight, Diagonal, X) =>
   writeln([n=N,maxLetterMaxLetter,diagonal=Diagonal]),
   writeln([rowUpper=RowUpper,rowLower=RowLower]),
   writeln([colLeft=ColLeft,colRight=ColRight]),

   Dist = N-MaxLetter+1, % Number of accepted empty cells before/after


   % For global cardinality
   GCC = [I : I in 0..MaxLetter],
   Counts = [N-MaxLetter] ++ [1 : I in 1..MaxLetter],

   writeln(gcc=GCC),
   writeln(counts=Counts),
   writeln(dist=Dist),

   % decision variables
   X = new_array(N,N),
   X :: 0..MaxLetter,

   % The hints
   foreach(J in 1..N) 
     Tmp = [X[I,J] : I in 1..N],
     start_with(Tmp, RowUpper[J], Dist),
     end_with(Tmp, RowLower[J], Dist)
   end,

   foreach(I in 1..N) 
     Tmp = [X[I,J] : J in 1..N],
     start_with(Tmp, ColLeft[I], Dist),
     end_with(Tmp, ColRight[I], Dist)
   end,


   % Latin square except 0
   %
   % (It's an alldifferent_except_0/1 but we also know how many zeros there 
   %  should be.)
   foreach(I in 1..N)
      global_cardinality([X[I,J] : J in 1..N], GCC, Counts),
      global_cardinality([X[J,I] : J in 1..N], GCC, Counts) 
   end,

   if Diagonal == 1 then 
     global_cardinality([X[I,I] : I in 1..N], GCC, Counts),
     global_cardinality([X[I,N-I+1] : I in 1..N], GCC, Counts) 
   end,

   Vars = X,

   solve([ff,down],Vars).


print_grid(Grid) => 
   Letters = "ABCDEF",
   foreach(Row in Grid) 
      foreach(E in Row.to_list()) 
         if E == 0 then
            printf("_ ")
         else
            printf("%w ", Letters[E])
         end
      end,
      nl
   end,
   nl.



%
% A start with letter C and accept D empty slots.
start_with(A, C, D) =>
   N = length(A),
   if C > 0 then
     I :: 1..D,
     element(I,A,C),
     foreach(J in 1..N) 
       I #> J #=> A[J] #= 0
     end
   end.


%
% A ends with letter C and accept D empty slots
%
end_with(A, C, D) =>
   N = length(A),
   if C > 0 then
     I :: N-D..N,
     element(I,A,C),
     foreach(J in 1..N)
       J #> I #=> A[J] #= 0
     end
   end.


global_cardinality(A,Gcc,Counts) =>
   foreach(I in 1..Gcc.length) count(Gcc[I],A,#=,Counts[I]) end.

%
% Problem instances
%


%
% Problem instance from
% http://www.funwithpuzzles.com/2009/12/abcd-end-view-a1.html
% This is a 4x4 with 1 blank
%
problem(1,N,MaxLetter,
        RowUpper,RowLower,
        ColLeft,ColRight,
        Diagonal) =>
   A=1,B=2,C=3,
   N = 4,
   MaxLetter = C,
   RowUpper = [0,0,A,0],
   RowLower = [0,B,0,0],
   ColLeft  = [0,C,C,0],
   ColRight = [0,0,B,0],
   Diagonal = 0. % Has diaginal constraint?




% From Dan Moore: Brainpower Bible
% (introduction example)
% Note: This is a 5x5 grid with 2 blanks
problem(2,N,MaxLetter,
        RowUpper,RowLower,
        ColLeft,ColRight,
        Diagonal) =>
   A=1,B=2,C=3,
   N = 5,
   MaxLetter = C,
   RowUpper = [C,C,A,C,0],
   RowLower = [B,B,0,A,0],
   ColLeft  = [0,A,0,0,0],
   ColRight = [0,B,A,B,0],
   Diagonal = 0.


% From Dan Moore: Brainpower Bible
% Alfa 1 (5x5)
problem(3,N,MaxLetter,
        RowUpper,RowLower,
        ColLeft,ColRight,
        Diagonal) =>
  A=1,B=2,C=3,
  N = 5,
  MaxLetter = C,
  RowUpper = [0,B,B,C,0],
  RowLower = [B,C,A,A,B],
  ColLeft  = [0,0,B,B,C],
  ColRight = [0,B,0,A,B],
  Diagonal = 0.

% From Dan Moore: Brainpower Bible
% Alfa 2 (5x5)
problem(4,N,MaxLetter,
        RowUpper,RowLower,
        ColLeft,ColRight,
        Diagonal) =>
   A=1,B=2,C=3,
   N = 5,
   MaxLetter = C,
   RowUpper = [B,0,0,C,B],
   RowLower = [0,A,B,A,C],
   ColLeft  = [0,0,0,A,B],
   ColRight = [A,B,0,0,0],
   Diagonal = 0.

% % From Dan Moore: Brainpower Bible
% % Delta 1 (6x6)
problem(5,N,MaxLetter,
        RowUpper,RowLower,
        ColLeft,ColRight,
        Diagonal) =>
   A=1,_B=2,C=3,D=4,
   N = 6,
   MaxLetter = D,
   RowUpper = [D,D,A,0,C,A],
   RowLower = [0,0,0,C,0,0],
   ColLeft  = [D,0,D,0,0,A],
   ColRight = [0,0,A,D,C,C],
   Diagonal = 0.

% From Dan Moore: Brainpower Bible
% Delta 2 (6x6)
problem(6,N,MaxLetter,
        RowUpper,RowLower,
        ColLeft,ColRight,
        Diagonal) =>
   A=1,B=2,C=3,D=4,
   N = 6,
   MaxLetter = D,
   RowUpper = [0,B,D,D,0,C],
   RowLower = [B,0,0,B,C,D],
   ColLeft  = [A,D,C,0,B,D],
   ColRight = [0,0,B,B,0,0],
   Diagonal = 0.


% From http://www.cross-plus-a.com/puzzles.htm#EasyAsABC
% (6x6)
problem(7,N,MaxLetter,
        RowUpper,RowLower,
        ColLeft,ColRight,
        Diagonal) =>
   A=1,B=2,C=3,D=4,E=5,
   N = 6,
   MaxLetter = E,
   RowUpper = [A,0,0,E,0,0],
   RowLower = [0,B,C,0,0,A],
   ColLeft  = [0,0,A,D,0,0],
   ColRight = [E,0,B,E,0,0],
   Diagonal = 0.


% From http://www.janko.at/Raetsel/AbcEndView/209.a.htm
% ABC End View Nr. 209
% (7x7)
% (Difficulty 8, "schwer")
problem(8,N,MaxLetter,
        RowUpper,RowLower,
        ColLeft,ColRight,
        Diagonal) =>
  A=1,B=2,C=3,D=4,E=5,
  N = 7,
  MaxLetter = E,
  RowUpper = [A,0,B,0,0,C,B],
  RowLower = [0,A,0,B,B,D,0],
  ColLeft  = [A,C,A,0,E,0,E],
  ColRight = [0,D,0,C,0,E,0],
  Diagonal = 0.

% From http://www.janko.at/Raetsel/AbcEndView/046.a.htm
% ABC End View Nr. 46
% (7x7)
% (Difficulty 8, "schwer")
problem(9,N,MaxLetter,
        RowUpper,RowLower,
        ColLeft,ColRight,
        Diagonal) =>
   _A=1,B=2,C=3,D=4,E=5,
   N = 7,
   MaxLetter = E,
   RowUpper = [0,0,D,C,0,0,C],
   RowLower = [0,0,E,D,D,C,0],
   ColLeft  = [0,E,C,C,E,B,0],
   ColRight = [0,0,B,0,0,C,0],
   Diagonal = 0.


% http://www.janko.at/Raetsel/AbcEndView/168.a.htm
% ABC End View Nr. 168
% (7x7)
% (Difficulty 8, "schwer")
% NOTE: This has the Diagonal requirement.
%
% A B C E F _ D
% B E F _ D A C
% _ A D F E C B
% C _ E B A D F
% E F _ D C B A
% D C B A _ F E
% F D A C B E _

problem(10,N,MaxLetter,
        RowUpper,RowLower,
        ColLeft,ColRight,
        Diagonal) =>
   A=1,B=2,C=3,D=4,E=5,F=6,
   N = 7,
   MaxLetter = F,
   RowUpper = [A,0,C,E,F,A,0],
   RowLower = [0,D,0,C,0,0,E],
   ColLeft  = [A,0,0,C,E,D,0],
   ColRight = [0,C,B,0,0,E,0],
   Diagonal = 1.

go =>
    Ack = a(3,4),
    writeln(ack=Ack),
    foreach(I in 0..3, J in 0..6) 
        printf("a(%d,%d): %d\n", I,J, a(I,J))
    end,
    foreach(J in 0..1) 
        printf("a(4,%d): %d\n", J, a(4,J))
    end,
    nl.

table
a(M, N) = N+1,              M==0           => true.
a(M, N) = a(M-1,1),         (M > 0,  N==0) => true.
a(M, N) = a(M-1,a(M, N-1)), (M > 0, N > 0) => true.

go =>
        L = findall(X, $added_corner(X)),
        writef("It was %d solutions.\n", length(L)).


added_corner(X) =>
        Digits = 1..8,

        X = [A,B,C,D,E,F,G,H],
        X :: Digits,

        all_different(X),
        B #= A + C,
        D #= A + F,
        E #= C + H,
        G #= F + H,

        solve(X),

        writef("%d %d %d\n", A,B,C),
        writef("%d   %d\n",  D,E),
        writef("%d %d %d\n", F,G,H),
        nl.

        
go => 
   N = 4,

   Cst = [0,1,0,4],
   % Cst = [0,0,0,0], % for plain all_different 
   % Cst = new_list(N),
   % Cst :: 0..2,

   X = new_list(N),
   X :: 1..9,

   % X = [5,1,9,3],
   L = findall([X,Cst], 
      (alldifferent_cst(X, Cst),
       solve(X++Cst))),
   Len = length(L),
   foreach([X2,Cst2] in L) 
      Y = [I+J : {I,J} in zip(X2,Cst2)],
      writeln([x=X2,cst=Cst2,y=Y]) 
   end,
   write(len=Len),
   nl.

   

alldifferent_cst(Xs, Cst) =>
   Res = [$(X + C) :  {X,C} in zip(Xs,Cst)],
   all_different(Res).

%
% Ensure that all values in Xs which are != 0 are different.
%
alldifferent_except_0(Xs) =>
  foreach(I in 2..Xs.length, J in 1..I-1)
    (Xs[I] #!= 0 #/\ Xs[J] #!= 0) #=> (Xs[I] #!= Xs[J])
  end.

go =>
  N = 4,
  X = new_list(N),
  X :: 0..N,
  alldifferent_except_0(X),

  solve(X),

  println(x=X),
  statistics(backtracks, Backtracks),
  printf("backtracks: %d\n", Backtracks).

go2 =>
  N = 4,
  X = new_list(N),
  X :: 0..N,

  alldifferent_except_0(X),
  increasing(X),

  Solutions = solve_all(X),
  println(Solutions),
  println(sols=length(Solutions)).

% From Picat Guide, page 74
my_count(V,L,Rel,N) =>
  sum([V #= E : E in L]) #= Count,
  call(Rel,Count,N).


go3 =>
  N = 6,
  X = new_list(N),
  X :: 0..N,

  alldifferent_except_0(X),
  count(0,X,#=,2),
  % my_count(0,X,#=<,2),

  Solutions = solve_all(X),
  println(Solutions),
  println(sols=length(Solutions)),
  statistics(backtracks, Backtracks),
  printf("backtracks: %d\n", Backtracks).

go =>
   N = 4,
   X = new_list(N),
   X :: 1..25,
   % X = [25,1,14,3],

   % M :: 1..5,
   % indomain(M),
   M = 5,

   % L = findall([X,M], $test(X,M)),
   L = findall([X,M], (alldifferent_modulo(X, M), solve(X++[M]))),
   Len = length(L),

   % this give no solution since the local X and M conflicts with the global versions
   % foreach([X,M] in L) writeln([m=M2,x=X2]) end,

   % this works, though
   foreach([X2,M2] in L) writeln([m=M2,x=X2]) end,
   writeln(len=Len).


test(X,M) =>
   alldifferent_modulo(X,M), 
   solve(X).

alldifferent_modulo(Xs,M) =>
   all_different([T : X in Xs, T #= X mod M]).

go ?=>
   M = 4,
   N = 6,

   X = new_list(M),
   X :: 1..9,

   Y = new_list(N),
   Y :: 1..9,

   % X = [5,9,1,5],
   X = [5,9,_,5],

   Y = [2,1,6,9,6,2], % constraint holds
   % Y = [2,1,6,9,6,1], % constraint do not hold since 
             %  there are two 1's in 1 and one 1 in x

   alldifferent_on_intersection(X,Y),

   Vars = X ++ Y,
   solve(Vars),

   writeln(x=X),
   writeln(y=Y),
   nl,
   fail.

alldifferent_on_intersection(Xs,Ys) =>
   count_A_in_B(Xs,Ys),
   count_A_in_B(Ys,Xs).


count_A_in_B(As,Bs) =>
   foreach(A in As)
      sum([(A #= B) : B in Bs]) #=< 1
   end.

go =>
   Rows = 3,
   Cols = 4,

   X = new_array(Rows,Cols).array_matrix_to_list_matrix(),

   XList = vars(X),
   XList :: 0..6,


   K :: 0..Cols,
   K #= 2,

   % the example above
   % X = [[2,5,2,0],
   %      [3,6,2,1],
   %      [3,6,1,0]],

   X = [[2,5,2,_],
        [3,6,2,1],
        [3,6,1,0]],
   

   % fails
   % X = [[2,5,2,0],
   %     [2,5,2,1],
   %     [3,6,1,0]],

   all_differ_from_at_least_k_pos(K,X),

   Vars = XList ++ [K],
   solve([],Vars),

   write(k=K),nl,
   foreach(Row in X) writeln(Row) end,
   nl.



all_differ_from_at_least_k_pos(K,X) =>
   Len = X.length(),
   foreach(I in 1..Len, J in 1..Len)
      if I != J then
         sum([(R1 #!= R2) : {R1,R2} in zip(X[I],X[J])]) #>= K
      end
   end.


go =>
   N = 4,
   Lower = 0,
   Upper = 6,
   List = findall(X, $all_equal_test(N,Lower, Upper,X)),
   Len = length(List),
   writeln(List),
   writeln(length=Len),
   nl.

all_equal_test(N, Lower, Upper, X) =>
   X = new_list(N),
   X :: Lower..Upper,
   % x = [5,5,5,5],
   all_equal(X),
   solve([],X).


all_equal(X) =>
   foreach(I in 2..X.length) X[I-1] #= X[I] end.

go =>
        N = 12,
        L = findall(X,all_interval(N,X,[])),
        Len = length(L),
        writef("Total: %d\n", Len).

% Just the first solution
go2 =>
        foreach(N in 2..220) 
           writeln(n=N),
           time2($all_interval(N,_X,[ff,split]))
        end,
        nl.

go3 => 
   all_interval(2000,X,[ff,split]),
   writeln(X),
   nl.

all_interval(N,X,Label) =>

        X = new_list(N),
        X :: 1..N,

        N1 = N-1,
        Diffs = new_list(N1),
        Diffs :: 1..N1,

        SumDistinct = ((N+1)*N) // 2,

        all_different(X),
        all_different(Diffs),
        
        foreach(K in 1..N1)
           Diffs[K] #= abs(X[K+1] - X[K])
        end,
        
        % symmetry breaking
        X[1] #< X[N1],
        Diffs[1] #< Diffs[2],

        Vars = X ++ Diffs,

        % symmetry breaking for one solutions
        % increasing(Diffs),

        %
        % This first solution is found very fast using [ff,split],
        % then the Diffs is the sequence 1..N-1.
        % For getting all solution, the default labeling is better.
        %
        % solve([ff,down], Vars),
        % solve([ff,split], Vars),
        solve(Label, Vars),
        % solve(Vars),
        writef("x: %w  diffs: %w  [sum: %d]\n", X, Diffs, SumDistinct).


increasing(List) =>
   foreach(I in 2..List.length) List[I-1] #=< List[I] end.

%
% The first part is simply to get an ordered array where the sum is N.
% This ordering is needed for removing symmetries when all
% 0's is remove in the second part.
% 
allpartitions(N, Xs) =>

        % part I: get all candidates
        X = new_list(N),
        X :: 0..N,
        N #= sum(X),
        increasing(X),
       
        solve([ffc,down], X),

        % part II: now remove all 0's from X
        Xs = delete_all(X, 0).

increasing(List) =>
        Len = length(List),
        foreach(I in 2..Len) 
            List[I-1] #=< List[I] 
         end.


go ?=>
        N :: 2..1034,
        indomain(N),

        L = findall(X, allpartitions(N, X)),
        Len = length(L),

        % for larger N we really don't want to print all partitions
        if N =< 8 then
              writef("\nN: %d\n", N),
              foreach(El in L) 
                  writeln(El) 
              end
        end,
        writef("n:%d len:%d\n", N,Len),
        fail.

go =>
        go1,
        go2,
        go3.

go1 =>
        Base = 10,
        % SEND + MORE = MONEY
        L = [[_S,E,N,_D],[M,O,_R,E],[M,O,N,E,_Y]],
        alphametic(L, Base, Res),
        writeln(Res),
        writeln(L),
        print_res(L).


go2 => 
        Base = 10,
        % DONALD + GERALD = ROBERT
        Problem = [[D,O,_N,A,L,D],[_G,E,R,A,L,D],[R,O,_B,E,R,_T]],
        alphametic(Problem, Base, Res),
        writeln(Res),
        writeln(Problem),
        print_res(Problem).

go3 =>
        Base = 10,
        % SATURN+URANUS+NEPTUNE+PLUTO=PLANETS
        Problem = [[S,A,T,U,R,N], 
                    [U,R,A,N,U,S], 
                    [N,E,P,T,U,N,E],
                    [P,L,U,T,_O],    
                    [P,L,A,N,E,T,S]],
        alphametic(Problem, Base, Res),
        writeln(Res),
        writeln(Problem),
        print_res(Problem).


term_variables(L) = Flatten =>
       Flatten1 = [],
       foreach(LL in L) 
          Flatten1 := Flatten1 ++ LL
       end,
       Flatten2 = remove_dups(Flatten1),
       Flatten = Flatten2.

alphametic(L,Base, Vars) => 
        Rev = reverse(L),
        Rev = [Last|Sums],
        Vars = term_variables(L),
        Vars :: 0..Base-1,

        all_different(Vars),
        Vals #= sum([Val : S in Sums, Val = calc(S,Base)]),
        Vals = calc(Last,Base),
        foreach(S in Sums) S[1] #> 0 end,

        solve([ff,split], Vars).

calc(X,Base) = Y =>
        Len = length(X),
        Y #= sum([X[I]*Base**(Len-I) : I in 1..Len]).

print_res(L) =>
        Rev = reverse(L),
        Rev = [Last|Sums],
        Sums2 = reverse(Sums),
        foreach(S in Sums2) print_single(S) end,
        print_single(Last),
        nl.

print_single(L) =>
        foreach(S in L) writef("%d",S) end,
        writef("\n").

go =>
  amb_example([Word1, Word2, Word3, Word4]),
  println([Word1, Word2, Word3, Word4]).

go2 => 
  amb_example2([Word1, Word2, Word3, Word4]),
  println([Word1, Word2, Word3, Word4].join(" ")).


% a direct approach
go3 =>
  member(Word1, ["the","that","a"]),
  member(Word2, ["frog","elephant","thing"]),
  member(Word3, ["walked","treaded","grows"]),
  member(Word4, ["slowly","quickly"]),
  Words = [Word1,Word2,Word3,Word4],
  foreach(I in 2..Words.length) 
     Words[I-1].last() = Words[I].first()
  end,
  println([Word1,Word2,Word3,Word4]),
  nl.
  

% Prolog-inspired solution,
% from http://rosettacode.org/wiki/Amb#Prolog
amb(E, E2) ?=> E2 = [E|_] .
amb(E, E2) => E2 = [_|ES], amb(E, ES).
 
joins(Left, Right) =>
  append(_, [T], Left),
  append([R], _, Right),
  ( T != R -> amb(_, [])  % (explicitly using amb fail as required)
  ; true ).
 
amb_example([Word1, Word2, Word3, Word4]) =>
  amb(Word1, ["the","that","a"]),
  amb(Word2, ["frog","elephant","thing"]),
  amb(Word3, ["walked","treaded","grows"]),
  amb(Word4, ["slowly","quickly"]),
  joins(Word1, Word2),
  joins(Word2, Word3),
  joins(Word3, Word4).


% Another approach, perhaps not exactly according the task...
amb2([],[]) => true.
amb2(Word,Words) => member(Word,Words).
% joins2(Word1,Word2) => Word1[Word1.length] = Word2[1].
joins2(Word1,Word2) => Word1.last() = Word2.first().

amb_example2([Word1, Word2, Word3, Word4]) =>
  amb2(Word1, ["the","that","a"]),
  amb2(Word2, ["frog","elephant","thing"]),
  amb2(Word3, ["walked","treaded","grows"]),
  amb2(Word4, ["slowly","quickly"]),
  joins2(Word1,Word2),
  joins2(Word2,Word3),  
  joins2(Word3,Word4).

go =>
   Len = 5,
   R = 8,
   X = new_list(Len),
   X :: 1..R,

   %
   % The set {1,5,8}
   % Note that this is a list
   V = [1,5,8],

   % X = [4,5,5,4,1], % the example above

   % N: number of elements in X that is in V
   N :: 1..Len,
   N #= 3,

   among(N, X, V),

   solve(X),
   println(x=X),
   println(n=N),
   nl.


go2 =>

   Len = 5,
   R = 8,
   X = new_list(Len),
   X :: 1..R,

   %
   % The set {1,5,8}
   % Note that this is a list
   V = [1,5,8],

   % X = [4,5,5,4,1], % the example above

   % N: number of elements in X that is in V
   N :: 1..Len,
   N #= 3,

   L = findall([X,N],
         (
             among(N, X, V),
             solve(X)
         )),

   Len2 = length(L),
   foreach([X2,N2] in L)
       writeln([n=N2, x=X2, v=V])
   end,
   nl,
   writeln(len=Len2),
   nl.



among(N,X,V) =>  
   N #= sum([B :  El in X, B #<=> El in V]).

go ?=>

   Len = 7,

   % The set as a list
   V = [0,2,4,6,8],

   % create X
   X = new_list(Len),
   X :: 0..9,

   % X = [9,2,4,5,5,7,2], % the example above

   % some symmetry breaking if we let X free
   all_different(X),
   increasing(X),

   Low = 1,
   High = 2,
   SeqLen = 4,
   among_seq(Low,High,SeqLen,X,V),

   % search
   solve(X),

   writeln([low=Low,high=High,seq_len=SeqLen]),
   writeln(x=X),
   writeln(v=V),
   nl,
   fail.


among_seq(Low,High,SeqLen,X,V) =>
   Len = X.length,
   Size = Len-SeqLen+1,
   foreach(I in 1..Size)
       Seq = [X[J] : J in I..I+SeqLen-1],
       among_range(Low, High, Seq, V)
   end.

among_range(Low, High,X,V) =>
   Sum #= sum([B :  El in X, B #<=> El in V]),
   Sum #>= Low,
   Sum #=< High.


increasing(List) =>
   foreach(I in 2..List.length)  List[I-1] #=< List[I] end.

go =>
   FD = open("unixdict.txt"),
   % FD = open("words_lower.txt"),
   Dict = new_map(),
   while (not at_end_of_stream(FD))
      Line = read_line(FD),
      Sorted = Line.sort(),
      Dict.put(Sorted, cond(Dict.has_key(Sorted), Dict.get(Sorted), "") ++ [Line])
   end,
   close(FD),

   MaxLen = max([Value.length : _Key=Value in Dict]),
   writeln(maxLen=MaxLen),
   foreach(_Key=Value in Dict, Value.length == MaxLen)
      println(Value)
   end,
   nl.

% shorter, and (mis)using [] as a foreach loop.
go2 =>
  M = new_map(),
  _=[_:W in read_file_lines("unixdict.txt"),S=sort(W),M.put(S,M.get(S,"")++[W])],
  MaxLen = max([Value.length : _Key=Value in M]),
  writeln(maxLen=MaxLen),
  _=[Value : _=Value in M, Value.length=MaxLen, println(Value)],
  nl.

% using group/2
go3 =>
  M=[W:W in read_file_lines("unixdict.txt").group(sort)],
  MaxLen = max([Value.length : _Key=Value in M]),
  writeln(maxLen=MaxLen),
  _=[Value : _=Value in M, Value.length=MaxLen, println(Value)],
  nl.


%
% groups the element in List according to the function F
%
group(List, F) = P, list(List) =>
   P = new_map(),
   foreach(E in List) 
      V = apply(F,E),
      P.put(V, P.get(V,[]) ++ [E])
   end.

go ?=>
  test_analogy(Name,X),
  writeln([Name,X]),
  nl, 
  fail.
  
analogy(AB,CX,Answers) =>
    AB = $is_to(A, B),
    CX = $is_to(C,X), 
    match(A,B,Match),
    match(C,X,Match),
    member(X,Answers).

test_analogy(Name,X) =>
    figures(Name,A,B,C),
    answers(Name,Answers),
    analogy($is_to(A, B),$is_to(C, X),Answers).

% The problem:
%   A is to B as C is to ?
figures(Name,A,B,C) => 
   Name = test1,
   A = $inside(square,triangle),
   B = $inside(triangle,square), 
   C = $inside(circle,square).

%
% The three possible answers
% See Figure 14.5, page 271 in "The Art of Prolog"
%
answers(Name,Answers) => 
   Name = test1,
   Answers = [$inside(circle,triangle), % Answer 1
              $inside(square,circle),   % Answer 2
              $inside(triangle,square)  % Answer 3
              ].

match(A,B,Match) ?=> 
   A = $inside(Figure1,Figure2),
   B = $inside(Figure2,Figure1),
   Match = invert.
match(A,B,Match) => 
   A = $above(Figure1,Figure2),
   B = $above(Figure2,Figure1),
   Match = invert.

go =>
  println("Run go2/0 for the interactive version.").

go2 =>
   println("Write two integers (and CR)"),
   println(read_int()+read_int()).

go => 
   L = 1..10,
   % some different approaches
   writeln(L.map(fun)),
   writeln(map(L,fun)),   
   writeln(map(fun,L)),
   writeln([fun(I) : I in L]),
   writeln([apply(fun,I) : I in L]),
   writeln([I*I : I in L]),

   nl.

fun(X) = X*X.

go => 
    println("Matrix based approach:"),
    L1 = findall(X,appointment_scheduling(X)),
    foreach(S1 in L1)
      foreach(R in S1)
        writeln(R)
      end,
      nl
    end,
    println("\nSet based approach:"),
    L2 = findall(X,appointment_scheduling2(X)),
    foreach(S2 in L2)
       writeln(S2)
    end,
    nl.


% Matrix based approach
appointment_scheduling(X) =>
   N = 4,
   % The allowed slots
   M = [[1, 1, 1, 1],
        [0, 1, 1, 0],
        [1, 0, 0, 1],
        [1, 0, 0, 1]],

   % decision variables

   % the assignment of persons to a slot (appointment number 1..N)
   X = new_array(N,N),
   X :: 0..1,

   % constraints
   foreach(I in 1..N) 
      % ensure a free slot
      sum([M[I,J]*X[I,J] : J in 1..N]) #= 1,

      % ensure one assignment per slot
      sum([X[I,J] : J in 1..N]) #= 1,
      sum([X[J,I] : J in 1..N]) #= 1
   end,

   solve(X).
 

%  
% "Set based" approach
%
appointment_scheduling2(X) => 
   N = 4,
   % The allowed splots
   M = [[1, 2, 3, 4],
        [2, 3],
        [1, 4],
        [1, 4]],

   % decision variables

   % the assignment of persons to a slot (appointment number 1..N)
   X = new_list(N),
   X :: 1..N,

   % constraints
   all_different(X),

   foreach(I in 1..N) 
      % ensure a free slot
      member(X[I], M[I])
   end,

   solve(X).

go =>

   % decision variables
   X0 :: 0..9,
   X1 :: 0..9,
   X2 :: 0..9,
   X3 :: 0..9,
   X4 :: 0..9,
   X5 :: 0..9,
   X6 :: 0..9,
   X7 :: 0..9,
   X8 :: 0..9,
   X9 :: 0..9,

   All = [X0,X1,X2,X3,X4,X5,X6,X7,X8,X9],
   X :: 0..9, % the unknown

   % This yields 10 solutions, all with the same values for X
   X8+X8+X0+X9 #= 6,
   X7+X1+X1+X1 #= 0,
   X2+X1+X7+X2 #= 0,
   X6+X6+X6+X6 #= 4,
   X1+X1+X1+X1 #= 0,
   X3+X2+X1+X3 #= 0,
   X7+X6+X6+X2 #= 2,
   X9+X3+X1+X2 #= 1,
   X0+X0+X0+X0 #= 4,
   X2+X2+X2+X2 #= 0,
   X3+X3+X3+X3 #= 0,
   X5+X5+X5+X5 #= 0,
   X8+X1+X9+X3 #= 3,
   X8+X0+X9+X6 #= 5,
   X7+X7+X7+X7 #= 0,
   X9+X9+X9+X9 #= 4,
   X7+X7+X5+X6 #= 1,
   X6+X8+X5+X5 #= 3,
   X9+X8+X8+X1 #= 5,
   X5+X5+X3+X1 #= 0,

   X2+X5+X8+X1 #= X,


   Res = solve_all([X,All]),
   writeln(Res), % all solutions
   Xs = [Z : [Z, _All2] in Res], 
   writeln(x=Xs), % the different values of X
   nl.

%
% This version has fewer hints, but give two different values of X.
% 
go2 =>

   % decision variables
   X0 :: 0..9,
   X1 :: 0..9,
   X2 :: 0..9,
   X3 :: 0..9,
   X4 :: 0..9,
   X5 :: 0..9,
   X6 :: 0..9,
   X7 :: 0..9,
   X8 :: 0..9,
   X9 :: 0..9,

   All = [X0,X1,X2,X3,X4,X5,X6,X7,X8,X9],
   X :: 0..9, % the unknown

   X8+X8+X0+X9 #= 6,
   X7+X6+X6+X2 #= 2,
   X9+X3+X1+X2 #= 1,
   X8+X1+X9+X3 #= 3,
   X8+X0+X9+X6 #= 5,
   X7+X7+X5+X6 #= 1,
   X6+X8+X5+X5 #= 3,
   X9+X8+X8+X1 #= 5,

   X2+X5+X8+X1 #= X,


   Res = solve_all([X,All]),
   writeln(Res), % all solutions
   Xs = [Z : [Z, _All2] in Res], 
   writeln(x=Xs), % the different values of X
   nl.

go =>
    N = 4,
    Shoes = [_EcruEspadrilles, FuchsiaFlats, PurplePumps,
             SuedeSandals],
    Shoes :: 1..N,

    Store = [FootFarm, HeelsInAHandcart, TheShoePalace, Tootsies],
    Store :: 1..N,

    all_different(Shoes),
    all_different(Store),

    % 1. Harriet bought fuchsia flats at Heels in a Handcart.
    FuchsiaFlats #= HeelsInAHandcart,

    % 2. The store she visited just after buying her purple pumps was not
    %    Tootsies.
    PurplePumps + 1 #!= Tootsies,

    % 3. The Foot Farm was Harriet's second stop.
    FootFarm #= 2,

    % 4. Two stops after leaving The Shoe Place, Harriet bought her suede
    % sandals.
    TheShoePalace + 2 #= SuedeSandals,

    Vars = Shoes ++ Store,

    solve(Vars),
    writeln(shoes=Shoes),
    writeln(store=Store),
    nl.

go =>

   N = 4,

   Jack  = 1,
   Bill  = 2,
   Paul  = 3,
   Frank = 4,
   FirstName = [Jack, Bill, Paul, Frank],
   FirstNameS = ["Jack", "Bill", "Paul", "Frank"],

   LastName = [_Green,Clubb,Sands,Carter],
   LastNameS = ["Green","Clubb","Sands","Carter"],
   LastName :: 1..N,

   Job = [_Cook,MaintenanceMan,Clerk,Caddy],
   JobS = ["Cook","Maintenance Man","Clerk","Caddy"],
   Job :: 1..N,

   Score = new_list(N),
   Score :: 70..85,
   Score = [ScoreJack,ScoreBill,ScorePaul,ScoreFrank],

   all_different(LastName),
   all_different(Job),
   all_different(Score),
   
   % 1. Bill, who is not the maintenance man, plays golf often and had 
   %    the lowest score of the foursome.
   Bill #!= MaintenanceMan,

   ScoreBill #< ScoreJack,
   ScoreBill #< ScorePaul,
   ScoreBill #< ScoreFrank,
   
   % 2. Mr. Clubb, who isn"t Paul, hit several balls into the woods and 
   %    scored ten strokes more than the pro-shop clerk.
   Clubb #!= Paul,

   element(Clubb,Score,ScoreClubb),
   element(Clerk,Score,ScoreClerk),
   ScoreClubb #= ScoreClerk + 10,
       
   % 3. In some order, Frank and the caddy scored four and seven more 
   %    strokes than Mr. Sands.
   Frank #!= Caddy,
   Frank #!= Sands,
   Caddy #!= Sands,
   
   element(Sands,Score,ScoreSands),
   element(Caddy,Score,ScoreCaddy),
   element(Carter,Score,ScoreCarter),
   (
       (ScoreFrank #= ScoreSands + 4 #/\
       ScoreCaddy #= ScoreSands + 7)
       #\/
       (ScoreFrank #= ScoreSands + 7 #/\
       ScoreCaddy #= ScoreSands + 4)
   ),

   % 4. Mr. Carter thought his score of 78 was one of his better games, even 
   % though Frank"s score was lower.
   Frank #!= Carter,
   
   % Score[Carter] #= 78,
   ScoreCarter #= 78,
   ScoreFrank #< ScoreCarter,

   % 5. None of the four scored exactly 81 strokes.
   foreach(S in Score) S #!= 81 end,

   Vars = Score ++ LastName ++ Job,

   solve([ff],Vars),
   
   printf("First names: %w\n", FirstName),
   printf("Last names : %w\n", LastName),
   printf("Jobs       : %w\n", Job),
   printf("Score      : %w\n", Score),
   nl,

   % A nicer presentation.
   % Get the inverse of Last name and Jobs to present
   % the names/jobs
   assignment(LastName,LastNameInv),
   assignment(Job,JobInv),
   % There is no zip/4 right now
   % foreach({F,L,J,S} in zip(FirstName,LastNameInv,JobInv,Score))
   foreach(I in 1..N) 
      F = FirstName[I], 
      L = LastNameInv[I],
      J = JobInv[I],
      S = Score[I],
      F2 = FirstNameS[F],
      L2 = LastNameS[L],
      J2 = JobS[J],
      printf("%w\t%w\t%16w %4d\n",F2,L2,J2,S)
   end,
   nl.

go => 
   L1 = [1,2,3,4,5],
   L2 = [6,7,8,9],

   % The tradtional concatenation
   writeln(L1 ++ L2),

   % Using built-in append
   append(L1,L2,L3),
   writeln(L3),

   % User defined append
   append2(L1,L2,L4),
   writeln(L4),

   nl.

append2(Xs,Ys,Zs) ?=> Xs=[], Ys=Zs.
append2(Xs,Ys,Zs) => Xs=[X|XsR], Zs=[X|Zss], append2(XsR,Ys,Zss).

go =>

   %
   % Arrays
   % 
   println("Arrays"),
   Len = 10,
   A = new_array(Len),
   println(A),
   A[1] := 1,
   println(A),
   println(a1=A[1]),
   foreach(I in 1..Len) A[I] := 2 end,
   println(A),
   
   % 2D array
   A2 = new_array(4,4),
   foreach(I in 1..4, J in 1..4) 
     A2[I,J] := (I-1)*4+J
   end,
   foreach(Row in A2) writeln(Row) end,

   println(rows=A2.rows()), % from util.pi
   println(columns=A2.rows()), % from util.pi
   println(diagonal1=A2.diagonal1()), % from util.pi
   println(diagonal2=A2.diagonal2()), % from util.pi

   % arrays don't increment automatically
   % (here we just catch and write the exception: "out_of_bound")
   catch(writeln(A[Len+1]),E, handle_exception(E)),

   nl,
   % 
   % Lists
   % 
   println("Lists"),
   % Define the lists (with unitialized variables)
   L = new_list(Len),
   println(L),
   % Assign the first element to 1
   L[1] := 1,
   println(L),
   % Assign to all elements
   foreach(I in 1..Len) L[I] := I end,
   println(L),
   % Append an element last
   L := L ++ [1],
   println(L),
   L := delete(L,L[1]),
   println(L),
   L := [L[I] : I in 2..L.length], % remove first element
   println(L),
   % insert an element last
   L := insert(L,L.length+1, 99),
   println(L),

   % extract odd elements
   println([E : E in L, E mod 2==1]),


   println([first=L.first(), second=L.second(),last=L.last()]),

   nl.


 handle_exception(E) => writeln(exception=E).

% pretty prints a square matrix
pretty_print(X) =>
   foreach(I in 1..X.length)
      foreach(J in 1..X[1].length)
         writef(" %w ", X[I,J] )
      end, 
      nl
   end,
   nl.


go =>        
    N = 6,
    foreach(I in 1..N) 
       assignment(I)
    end.


%
% assignment(ProblemNumber)
% 
assignment(Problem) =>

    cost(Problem, Mode, Cost),
    writef("\nProblem %d\n", Problem),
    
    % get the dimension of the problem
    Rows = Cost.length,
    Cols = Cost[1].length,

    % decision variables: a 0..1 matrix
    X = new_array(Rows,Cols),
    X :: 0..1,

    % exacly one assignment per row, all rows must be assigned
    foreach(I in 1..Rows) sum([X[I,J] : J in 1..Cols]) #= 1 end,

    % zero or one assignments per column
    foreach(J in 1..Cols) sum([X[I,J] : I in 1..Rows]) #=< 1 end,

    % calculate TotalCost
    TotalCost #= sum([X[I,J]*Cost[I,J] : I in 1..Rows, J in 1..Cols]),
    
    % prepare for maximization (if needed)
    TotalCostNeg #= -TotalCost,
    
    %
    % get the optimization mode
    %
    writeln(Mode), 
    if Mode = minimize then
       OptValue #= TotalCost 
    else 
       OptValue #= TotalCostNeg
    end,

    %
    % search
    % 
    solve([$min(OptValue)], X),

    %
    % get the assignments 
    %
    % note: this should be done _after_ labeling.
    %
    Assignments = [J : I in 1..Rows, J in 1..Cols, X[I,J] == 1],
    pretty_print(X),
    writeln(assignments=Assignments),
    writeln(total_cost=TotalCost).


%
% cost(ProblemNumber, OptimizationMode, CostMatrix). 
%

% Data from 
% Winston "Operations Research", Assignment Problems, page 393f
% added the fifth column
% See http://www.hakank.org/minizinc/assignment.mzn
cost(1, Op, M) => Op = minimize, 
                  M = [[14,  5, 8,  7, 15],
                       [ 2, 12, 6,  5,  3],
                       [ 7,  8, 3,  9,  7],
                       [ 2,  4, 6, 10,  1]].


% 
% Winston "Operations Research", page 398, swimming team example
% (original version]
% See http://www.hakank.org/minizinc/assignment2.mzn 
% 
cost(2, Op, M) => Op = minimize, 
                M = [[54, 54, 51, 53], 
                     [51, 57, 52, 52],
                     [50, 53, 54, 56],
                     [56, 54, 55, 53]].


% 
% Winston "Operations Research", page 398, swimming team example
% See http://www.hakank.org/minizinc/assignment2_2.mzn 
% expanded version
%
cost(3, Op, M) => Op = minimize, 
                M = [[54, 54, 51, 53,   50,60,70,80,90,100], 
                     [51, 57, 52, 52,   40,50,60,70,80, 90],
                     [50, 53, 54, 56,   40,50,60,80,93, 69],
                     [56, 54, 55, 53,   60,80,40,60,50,100]].


%
% Winston "Operations Research", page 399
% 
% """
% Tom Cruise, Freddy Prinze Jr, Harrison Ford, and Matt LeBlanc
% are marooned on a desert island with Jennifer Anniston,
% Courtney Cos, Gwynneth Paltrow, and Julia Roberts.
% The 'compatibility matrix' in Table 52 indicate how much happiness
% each couple would experience if the spend all their time toghether.
% The happiness earned by a couple is proportional to the fraction 
% of time the spend toghether. 
% ...
% The optimal solution requires that that each person send all their
% time with one person of the opposite sex, so this result is often
% referred to as the Marriage Theorem.
% """
%
% See http://www.hakank.org/minizinc/assignment3.mzn

% males:
% 1 "Tom Cruise"
% 2 "Freddie Prinz Jr"
% 3 "Harrison Ford"
% 4 "Mark LeBlanc"
%
% females:
% 1 "Jennifer Anniston"
% 2 "Courtney Cox"
% 3 "Gwynneth Paltrow"
% 4 "Julia Roberts"
cost(4, Op, M) => Op = maximize, M = 
                       [[7, 5, 8, 2],
                        [7, 8, 8, 4],
                        [3, 5, 7, 9],
                        [5, 5, 6, 7]].


% From
%  "SAS OR 9.1 User's Guide Mathematical Programming"
% """
% Consider assigning five programmers to five programming jobs. Each
% programmer prefers specific programming job over others. [...] 
% Suppose you ask each programmer to rank the jobs according to preference
% (using 1 for the most preferred job and 5 for the least preffered job].
% PROC ASSIGN maximizes the total preference of the group by minimizing the
% sum of the preferences. 
% 
%    PROGRAMMER     JOB1 JOB2 JOB3 JOB4 JOB5
%    PROGRAMMER1    4    1    3    5    2
%              2    2    1    3    4    5
%              3    3    2    4    1    5
%              4    2    3    4    5    1
%              5    4    2    3    1    5
% 
% """
% 
% See http://www.hakank.org/minizinc/assignment5.mzn
% 
cost(5, Op, M) => Op = minimize, 
                M = [[4, 1, 3, 5, 2],
                     [2, 1, 3, 4, 5],
                     [3, 2, 4, 1, 5],
                     [2, 3, 4, 5, 1],
                     [4, 2, 3, 1, 5]].



%
% From GLPK:s example assign.mod:
% """
% The assignment problem is one of the fundamental combinatorial
% optimization problems.
%
% In its most general form, the problem is as follows:
%
% There are a number of agents and a number of tasks. Any agent can be
% assigned to perform any task, incurring some cost that may vary
% depending on the agent-task assignment. It is required to perform all
% tasks by assigning exactly one agent to each task in such a way that
% the total cost of the assignment is minimized.
%
% (From Wikipedia, the free encyclopedia.] 
% """
% 
% """
% These data correspond to an example from [Christofides].
% """
%
% See http://www.hakank.org/minizinc/assignment6.mzn
%
cost(6,Op, M) => Op = minimize, 
               M = [[13, 21, 20, 12,  8, 26, 22, 11],
                    [12, 36, 25, 41, 40, 11,  4,  8],
                    [35, 32, 13, 36, 26, 21, 13, 37],
                    [34, 54,  7,  8, 12, 22, 11, 40],
                    [21,  6, 45, 18, 24, 34, 12, 48],
                    [42, 19, 39, 15, 14, 16, 28, 46],
                    [16, 34, 38,  3, 34, 40, 22, 24],
                    [26, 20,  5, 17, 45, 31, 37, 43]].

go =>
    time((assign(Groups,Cost),solve([Cost|Groups]))),
    writeln((Cost,Groups)).

assign(Groups,TotalCost) =>
    data(NGroups,NSlots,Prefs,Capac,Compon),
    % use a variable for each group which takes on a slot
    Groups=new_list(NGroups),

    % The capacity of each slot cannot be exceeded
    foreach(T in 1..NSlots)
       sum([(Groups[G]#=T)*Compon[G] : G in 1..NGroups]) #=< Capac[T]
    end,

    % The same slot is used for each group in the 
    % capacity constraint and the cost function
    Matrix=transpose(Prefs),
    Vs = [I : I in 1..NSlots],
    Costs = [Cost : {Slot,Row} in zip(Groups,Matrix),
            (element(I,Vs,Slot),element(I,Row,Cost))],
    sum(Costs) #= TotalCost.
   			  
data(Groups,Slots,Prefs,Capac,Compon) =>
    Groups = 26,
    Slots = 6,
    Prefs = [
	     [1,2,6,5,6,6,3,4,4,1,2,4,4,3,1,5,1,4,5,6,5,2,5,5,3,2],
	     [2,3,3,2,1,4,4,2,2,6,3,1,5,5,5,6,4,2,6,4,4,5,6,2,2,1],
	     [5,1,1,6,3,5,5,3,6,5,5,3,6,2,4,1,6,3,2,5,1,1,2,6,4,3],
	     [3,6,5,3,5,3,2,1,3,3,4,2,1,1,6,2,3,5,1,3,6,3,4,3,6,5],
	     [4,4,4,4,2,2,1,6,1,4,6,5,2,4,2,3,5,6,4,2,3,6,1,1,1,6],
	     [6,5,2,1,4,1,6,5,5,2,1,6,3,6,3,4,2,1,3,1,2,4,3,4,5,4]
	     ],
    Capac = [18,18,18,18,18,18],
    Compon = [5,4,4,4,3,3,3,3,3,4,4,5,5,2,5,3,4,4,3,3,3,5,2,4,4,5]. 

go => 
   Map = new_map(),
   println(Map),

   % add some data
   Map.put(a,1),
   Map.put("picat",2),
   Map.put("picat",3), % overwrite values
   Map.put([a,list,of,different,"things",[including, lists],3.14159],2),
   println(Map),

   println(a=Map.get(a)),
   println(a=Map.a), % sometimes we don't have to use get/1 explicitly
   println(b=Map.get(b,'default value')), % the second argument to get/2 is the default value

   % create a map from a list of values
   Map2 = new_map([K=V : {K,V} in zip([a,b,c,d,e,f,g,h],1..8)]),
   println(Map2),
   println(h=Map2.h),

   if not Map2.has_key(z) then
     println("don't have key 'z'")
   end,

   println(keys=Map2.keys()),
   println(values=Map2.values()),

   println([K : K=V in Map2, V mod 2=0]), % not sorted

   nl.

go => 
   N = 27,
   M = 5,

   S = new_list(N+2), % index: 0..N+1
   S :: 0..N+1,

   % foreach(I in 0..N)
   %   S[I+1] #= sum([(S[J+1] #= I) : J in 0..N+1])
   % end,
   
   S[N+2] #= M,

   global_cardinality(S,[I : I in 0..N], [S[I+1] : I in 0..N]),


   solve([ff,split],S),
   writeln(s=S),
   % writeln(t=T),
   nl.


global_cardinality(A,Gcc,Counts) =>
   foreach(I in 1..Gcc.length) count(Gcc[I],A,#=,Counts[I]) end.

go => 

   Lists = [
             [1.121,10.3223,3.41,12.1,0.01],
             1..10,
             1..11,
             [3],
             [],
             [4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2],
             [4.1, 7.2, 1.7, 9.3, 4.4, 3.2],
             [5.1, 2.6, 6.2, 8.8, 4.6, 4.1],
             [5.1, 2.6, 8.8, 4.6, 4.1]],

   foreach(Median in [median, median1, median2, median3])
      writeln(Median),
      foreach(List in Lists) 
         writeln([List, apply(Median,List)])
      end,
      nl
   end,

   nl.

%
% The traditional approach
%
median([])  = undef.
median([X]) = X.
median(L)   = Median =>
   Len = L.length,
   H = Len // 2,
   LL = sort(L), 
   Median=cond(Len mod 2 == 1, LL[H+1], avg([LL[H],LL[H+1]])).


% Variant on median/1: Using conditions instead of cond/3.
median1([])  = undef.
median1([X]) = X.
median1(L)   = LL[(L.length//2)+1], L.length mod 2 == 1 =>  LL = sort(L).
median1(L)   = avg([LL[H],LL[H+1]]) => H = L.length // 2, LL = sort(L).



%
% A variant: shave off the endpoints.
%
median2([])    = undef.
median2([X])   = X.
median2([X,Y]) = avg([X,Y]).
median2(L)     = median2_shrink(L.sort()).
% assume a sorted list
median2_shrink(L) = median2([L[I] : I in 2..L.length-1]).


%
% Another version, kind of same approach as median2/1:
% If there are more than 2 elements, remove the min and max values,
% and then recurse. No need to sort but it need to go through the 
% lists (Len - 2)*2 times to find the min and max.
%
median3([])    = undef.
median3([X])   = X.
median3([X,Y]) = avg([X,Y]).
median3(L) = L.delete_min().delete_max().median3().

delete_min(L) = delete(L,min(L)).
delete_max(L) = delete(L,max(L)).

go =>
   Women = [American,_English,French],
   Women :: 1..3,

   Table = [X,Y,_Z],
   Table :: 1..3,

   all_different(Table),
   all_different(Women),

   rightTo(Y, American),
   leftTo(X, French),

   X #= 1, % symmetry breaking

   solve([],Women),

   println("Table"=Table),
   println("Women"=Women),
   Str = ['American', 'English', 'French'],
   Placing = [P : Place in Table, element(Place,Women,WI), nth(WI,Str,P)],
   println("Placing"=Placing),
   nl.



% x is right to y
rightTo(X, Y) =>
    X #= Y + 1 ;
    X #= Y - 2. % around the corner


leftTo(X, Y) =>
    rightTo(Y,X).

go =>

   % the men
   Men = [Alloway,Bennington,Cunningham,Dunstan,Elmsby],
   Men = [1,2,3,4,5],
   % the name of the wifes, and the names of the ponies
   Francine = 1,
   Georgette = 2,
   Helene = 3,
   Inez = 4,
   Jasmine = 5,

   N = 5,
   Wife = new_list(N),
   Wife :: 1..5,
   Pony = new_list(N),
   Pony :: 1..5,
          
   all_different(Wife),
   all_different(Pony),

   % wife and pony don't have the same name
   foreach({W,P} in zip(Wife, Pony)) P #!= W end,

   % Mr Alloway's pony is named Geogette, 
   element(Alloway,Pony,PonyAlloway),
   PonyAlloway #= Georgette,
   element(Alloway,Wife,WifeAlloway),
   WifeAlloway #!= Georgette,

   % Col Cunningham owns Jasmine
   element(Cunningham,Pony,PonyCunningham),
   PonyCunningham #= Jasmine,
   element(Cunningham,Wife,WifeCunningham),
   WifeCunningham #!= Jasmine,
 
   % Mr Elmsby owns Inez
   element(Elmsby,Pony,PonyElmsby),
   PonyElmsby #= Inez,
   element(Elmsby,Wife,WifeElmsby),
   WifeElmsby #!= Inez,

   % Francine, owned by Mr Dunstan is named after Alloways wife
   element(Dunstan,Pony,PonyDunstan),
   PonyDunstan #= Francine,
   WifeAlloway #= Francine,

   % Georgettes husband owns the pony that is named after 
   % Mr Bennington's wife
   % This is translated to:
   % "There is an X such that X is is Georgettes husband and X 
   % owns a pony with the same name as Bennington's wife."
   X :: 1..5,
   element(X,Wife,WifeX),
   element(X,Pony,PonyX),
   element(Bennington,Wife,WifeBennington),
   (WifeX #= Georgette #/\ PonyX #= WifeBennington),

   % Helene Cunningham is the only wife who knows how to ride a horse.
   WifeCunningham = Helene,

   Vars = Wife ++ Pony,
   solve([], Vars),

   writeln(wife=Wife),
   writeln(pony=Pony),
   nl.


go =>
   
   N = 5,

   Keith = 1, 
   Libby = 2, 
   Margo = 3, 
   Nora  = 4, 
   Otto  = 5,
   First = [Keith, Libby, Margo, Nora, Otto],

   Last  = [Fell, _Gant, Hall, Ivey, Jule],
   Last :: 1..N,

   Age = new_list(N),
   Age :: 2..6,

   all_different(Last),
   all_different(Age),

   % 1. One child is named Libby Jule.
   Libby #= Jule,
   % 2. Keith is one year older than the Ivey child, who is one year 
   %    older than Nora.

   % It's a little boring that this don't work:
   %   Age[Keith] #= Age[Ivey] + 1
   element(Ivey, Age, AgeIvey),
   Age[Keith] #= AgeIvey + 1,
   AgeIvey #= Age[Nora] + 1,

   % 3. The Fell child is three years older than Margo.
   element(Fell, Age, AgeFell),
   AgeFell #= Age[Margo] + 3,

   % 4. Otto is twice as many years old as the Hall child.
   element(Hall,Age,AgeHall),
   Age[Otto] #= AgeHall*2,

   % search
   Vars = First ++ Last ++ Age,
   solve(Vars),

   writeln(first=First),
   writeln(last=Last),
   writeln(age=Age),
   nl,
   
   % print solution
   FirstS = ["Keith", "Libby", "Margo", "Nora", "Otto"],
   LastS  = ["Fell", "Gant", "Hall", "Ivey", "Jule"],
   print_all(First,FirstS),
   print_all(Last,LastS),
   foreach(A in Age) writef("%d\t", A) end,
   nl.


print_all(X,S) =>
   Len = length(X),
   foreach(I in 1..Len)
      % element(IX,X,I),
      Ix = find_first_of(X,I),
      % element(IX,S,This),
      This = S[Ix],
      printf("%w\t",This)
   end,
   nl.


go => 
   rosetta_brackets(),
   balanced_brackets.

go1 => 
   rosetta_brackets2().


go2 =>
   Found = "",
   N = 100, % size of string
   C = 0,
   while(Found == "") 
      C := C + 1,
      B = gen_bracket(N),
      % println(B),
      if balanced_brackets(B) then
         Found := B
      end
   end,
   printf("Found in %d steps: %w\n", C, Found),
   nl.

% Using CP to generate a balanced bracket string.
% Unfortunately this is not very interesting since it
% give the first solution which is 
%     "[" x N ++ "]" x N
% (Picat don't have a random heuristics which would be of 
%  some help here.)
go2b => 
   N = 1000,
   gen_cp(N div 2, 1, X),
   S = "[]",
   B = [S[X[I]] : I in 1..N],
   println(B),
   nl.

rosetta_brackets =>
   println("rosetta_brackets:"),
   test_brackets([]),
   test_brackets("[]"),
   test_brackets("[][]"),
   test_brackets("[[][]]"),
   test_brackets("]["),
   test_brackets("][]["),
   test_brackets("[]][[]"),
   test_brackets("[][][][][][][][][][]"),
   test_brackets("[[[[[[[]]]]]]]"),
   test_brackets("[[[[[[[]]]]]]"),
   test_brackets("[][[]][]"),
   test_brackets("[[][]][]"),
   test_brackets("[][][[]][]"),
   nl.

rosetta_brackets2 =>
   println("rosetta_brackets2:"),
   test_brackets2([]),
   test_brackets2("[]"),
   test_brackets2("[][]"),
   test_brackets2("[[][]]"),
   test_brackets2("]["),
   test_brackets2("][]["),
   test_brackets2("[]][[]"),
   test_brackets2("[][][][][][][][][][]"),
   test_brackets2("[[[[[[[]]]]]]]"),
   test_brackets2("[[[[[[[]]]]]]"),
   test_brackets2("[][[]][]"),
   test_brackets2("[[][]][]"),
   test_brackets2("[][][[]][]"),
   nl.

 
balanced_brackets =>
   println("\nbalanced_brackets (random):"),
   foreach(N in 2..2..10)
      test_brackets(gen_bracket(N)),
      test_brackets(gen_bracket(N))
   end,
   nl.
 
test_brackets(Goal) =>
   if Goal == [] then print("(empty)") else print(Goal) end,
   print(" "), 
   if balanced_brackets(Goal) then
       println(succeed)
   else
       println(failed)
   end.


test_brackets2(Goal) =>
   if Goal == [] then print("(empty)") else print(Goal) end,
   print(" "), 
   if balanced_brackets2(Goal) then
       println(succeed)
   else
       println(failed)
   end.


%
% check if a string of [] is balanced
%
balanced_brackets(B) => 
   C = 0,
   foreach(I in 1..B.length, C >= 0)
      C:= C + cond(B[I] = '[', 1, -1)
   end,
   C == 0.

%
% DCG inspired
%
balanced_brackets2(S) => 
   balanced_brackets2_1(S,[]).

balanced_brackets2_1(S1,S2) ?=> 
   S1 = "", S2 = S1.
balanced_brackets2_1(S1,S2) ?=> 
   S1 = "[]", S2 = S1.
balanced_brackets2_1(S1,S2), S1.length > 0 ?=>
   S1.first() = '[',
   S1.last() = ']',
   balanced_brackets2_1([S1[I] : I in 2..S1.length-1], S2).
balanced_brackets2_1(S1,S2) =>
   S1 = ['[',']'|S3],
   balanced_brackets2_1(S3, S2).




% generate a string of random brackets (which may not be balanced)
gen_bracket(N) = Brackets =>
   B = "[]",
   Brackets = "[",
   foreach(_I in 2..N)
      Brackets := Brackets ++ [B[1+random2() mod 2]]
   end.


%
% CP approach
%
% This generates all balanced brackets of size m*2.
%
% The number of generated solutions for m:
%
%  m        #
%  ----------
%   1       1
%   2       2
%   3       5
%   4      14
%   5      42
%   6     132
%   7     429
%   8    1430
%   9    4862
%  10   16796
%  11   58786
%  12  208012
%  13  742900
%
% 
% Which - of course - is the Catalan numbers.
%
% http://oeis.org/search?q=1%2C2%2C5%2C14%2C42%2C132%2C429%2C1430%2C4862%2C16796%2C58786%2C208012&language=english&go=Search
% http://oeis.org/A000108
%
go3 =>

   % Generating all balanced brackets of length M*2
   M = 4,
   N = M*2,
   S = "[]",
   gen_cp(M,0,All),
   writeln(len=All.length),

   if M <= 6 then
      foreach(X2 in All) 
        % println(X2),
        B = [S[X2[I]] : I in 1..N],
        % println(B),
        test_brackets(B)
      end
   end,
   nl.

%
% The number of solutions for M = 1..13
%
go4 =>
  foreach(M in 1..13)
     time2($gen_cp(M, 0, All)),
     writeln([m=M, All.length])
  end,
  nl.



%
% Generate Sols brackets for size M.
%
gen_cp(M, Sols, All) => 

   N = M * 2,
   T = [1,-1], % +1 for "[", -1 for "]"
   
   % decision variables
   X = new_list(N),
   X :: 1..2, % 1="[", 2 = "]"

   C = new_list(N), % the counter (cumulative sum)
   C :: 0..N,

   % leading "["
   X[1] #= 1,
   C[1] #= 1,

   foreach(I in 2..N)
      element(X[I], T, TT),
      C[I] #= C[I-1] + TT
   end,

   % concluding "]"
   X[N] #= 2,  
   C[N] #= 0, 

   % count(1,X,#=,M), % (makes it slower)

   if Sols == 0 then
     All = solve_all(X)
   else 
     solve(X),
     All = X
   end.

go =>
        N = 5,
        Bales = new_list(N),
        Bales :: 0..50,

        Weights = [80, 82, 83, 84, 85, 86, 87, 88, 90, 91],

        BIJ = [],
        foreach(W in 1..10)
            [I,J] :: 1..N,
            I #< J,
            element(I,Bales,BI),
            element(J,Bales,BJ),
            BI + BJ #= Weights[W],
            BIJ := [[BI,BJ]|BIJ]
        end,

        increasing(Bales),

        Vars = Bales ++ BIJ,
        solve([down],Vars),

        writeln(Bales).

        

increasing(List) =>
        foreach(I in 2..List.length) List[I-1] #=< List[I] end.

go =>

   X = [Bananas, Oranges,Mangoes,Apples],
   X :: 1..100,

   TheSum #= Bananas+Apples,

   % Solution suggested by Josef Feit
   % These don't work since /, //, and div all use integer division
   % 3*Bananas//5 + 5*Oranges//7 + 7*Mangoes//9 + 9*Apples//3 #= 100,
   % 3*Bananas/5 + 5*Oranges/7 + 7*Mangoes/9 + 9*Apples/3 #= 100,

   % instead we multiply with 3*5*7*9=945 on both sides to weed out the
   % divisions
   3*Bananas*189 + 5*Oranges*135 + 7*Mangoes*105 + 9*Apples*315 #= 100*945,

   sum(X) #= 100,

   solve($[min(TheSum)], X),

   writeln(theSum=TheSum),
   writeln(x=X),

   nl.

bench => 

   % The times are from
   % http://www.jekejeke.ch/idatab/doclet/prod/en/docs/05_run/15_stdy/06_bench/08_harness/01_common/01_common.p.html
   Programs = [
       ["dummy_bench.pi",3001],
       ["calc_bench.pi",0], % not (yet)
       ["crypt_bench.pi",301],
       ["deriv_bench.pi",30001],
       ["mtak_bench.pi",31],
       ["nrev_bench.pi",6001],
       % ["perfect_bench.pi",16],
       ["perfect_bench_old.pi",16],
       ["poly_bench.pi",0], % not (yet)
       ["qsort_bench.pi",6001],
       ["queens_bench.pi",16],
       ["query_bench.pi",3001],
       % ["tic_tac_bench.pi",11]
       ["tic_tac_bench_old.pi",11]
      ],

   Total = 0,
   foreach([Program, Runs] in Programs)
       statistics(runtime,_),
       bench_program(Program,Runs),
       statistics(runtime,[_,Time]),
       printf("\ntime: %dms\n", Time),
       Total := Total + Time
   end,
   printf("\nTotal: %5.5fs (%dms)\n", Total/1000.0, Total),
   nl.
   

bench_program(Program, Runs) =>
   println([running, Program, runs=Runs]),
   if Runs > 0 then
     cl(Program),
     foreach(_I in 1..Runs)
        % call(go) % with output
        call(go2)
     end
   end.

go =>
        Names = ["Andrew", "Betty", "Cara", "Dave", "Erica", "Frank"],
        L = findall(X, best_host(X)),
        foreach(LL in L)
            println(LL),
            T = [Names[I] : I in LL],
            println(T)
        end,
        printf("").


best_host(X) =>

        N = 6,
        Andrew = 1,
        Betty  = 2,
        Cara   = 3,
        Dave   = 4,
        Erica  = 5,
        Frank  = 6,

        % Preferences
        Prefs = [[Dave, Frank],   % Andrew
                 [Cara, Erica],   % Betty
                 [Betty, Frank],  % Cara
                 [Andrew, Erica], % Dave 
                 [Betty, Dave],   % Erica
                 [Andrew, Cara]], % Frank

        % Prefs = {{Dave, Frank},   % Andrew
        %          {Cara, Erica},   % Betty
        %          {Betty, Frank},  % Cara
        %          {Andrew, Erica}, % Dave 
        %          {Betty, Dave},   % Erica
        %          {Andrew, Cara}}, % Frank

        % decision variables
        X = new_list(N),
        X :: 1..N,

        % constraints
        all_different(X),

        % Ensure that a person X[I] is sitting between 
        % his/her preferred friends, Prefs[X[I]].
        foreach(I in 1..N)
            A = place(I-1,N),
            B = place(I+1,N),
            XI #= X[I],
            % PrefsXI in 1..N,
            nth(XI,Prefs,PrefsXI), % From the B-Prolog model
            % element(XI,Prefs,PrefsXI),
            member(X[A], PrefsXI),
            member(X[B], PrefsXI)
        end,

        % symmetry breaking
        X[1] #= Andrew,

        solve(X).

% The placement on a circular table
place(C,N) = P =>
        CN = C mod N,
        % P = cond(CN == 0, N, CN).
        if CN = 0 then P = N else P = CN end.

% using cp approach
go =>
  Words = ["abracadabra", 
           "seesaw", 
           "elk", 
           "grrrrrr", 
           "up", 
           "a",
           "kjellerstrand",
           "thisis asdasdsasdasdjsasdsaddgasjdgashdgasjdgasd_a_longerstring",
           "assadashjfgljhfgrakjafkljfjlktrwlkjhglkflkjslkflkslkslsgflksfgjfgslkhjsgflkhgfslkhjsgflkhsflkghjsgflhkjsfglkjhslfghjsflghjlskgjhsgfh",
           "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
           ], 
  foreach(Word in Words)
     Best=best_shuffle_cp(Word),
     println([word=Word,best=Best,diff=diff_word(Word, Best)])
  end,

  nl.


go2 =>
  Words = ["abracadabra", "seesaw", "elk", "grrrrrr", "up", "a"], 
  foreach(Word in Words)
     Best=best_shuffle(Word),
     println([word=Best, diff_word(Word, Best)])
  end,
  nl.

go3 =>
   Alpha = "abcdefghijklmnopqrstuvwxyz",
   foreach(Len in 2..50..502)
     rnd_select2(Alpha, Len, Word),
     Best=best_shuffle_cp(Word),
     println([len=Len,word=Word,best=Best,diff=diff_word(Word, Best)])
   end,
   nl.



%
% CP approach. Guarantee the optimal shuffle
% 
best_shuffle_cp(Word) = Best =>
  WordAlpha = Word.map(ord),
  WordAlphaNoDups = WordAlpha.remove_dups(),
  Occurrences = occurrences(WordAlpha),

  % decision variables
  Len = Word.length,
  WordC = new_list(Len),
  WordC :: WordAlphaNoDups,
  
  % constraints 
  foreach(V in WordAlphaNoDups) 
     count(V, WordC,#=, Occurrences.get(V))
  end,
  Z #= sum([WordC[I] #= WordAlpha[I] : I in 1..Len]),

  solve([$min(Z),split], WordC),

  Best = WordC.map(chr).



% This don't guarantee the optimal shuffle
% best_shuffle(Word) = Word => Word.length == 1.
best_shuffle(Word) = BestWord =>
  BestWord1 = "",
  BestDiff = Word.length+1,
  % NoDups = Word.remove_dups(),
  foreach(_I in 1..min(1000,factorial(Word.length)), BestDiff > 0)
     P = rand_perm(Word),
     Diff = diff_word(Word,P),
     % writeln([p=P,diff=Diff]),
     if Diff < BestDiff then
        BestDiff := Diff,
        BestWord1 := P
     end
  end,
  BestWord = BestWord1,
  println(bestWordafter=BestWord).


diff_word(W1,W2) = Diff =>
  Diff = sum([1 : I in 1..W1.length, W1[I]==W2[I]]).

  
rand_perm(Word) = Word, Word.length == 1 => true.
rand_perm(Word) = Perm => rand_perm(Word, Word.length, Perm).

rand_perm(_,0,R) ?=> R = [].
rand_perm(Xs,N,R) ?=> 
    R = [X|Zs],
    N > 0,
    L = length(Xs),
    I = 1+random2() mod L,
    remove_at(X,Xs,I,Ys),
    N1 = N - 1,
    rand_perm(Ys,N1,Zs).

remove_at(X,L,1,R) => L=[X|Xs], R=Xs.
remove_at(X,L,K,R) => L=[Y|Xs], R=[Y|Ys], K #> 1, K1 #= K - 1, remove_at(X,Xs,K1,Ys).

% random selection _with_ replacement
rnd_select2(L,N,R) =>
    R1 = [],
    Len = L.length,
    foreach(_I in 1..N)
       E = L[1+random2() mod Len],
       R1 := R1 ++ [E]
    end,
    R = R1.


occurrences(L) = Occ => 
  Occ = new_map(),
  foreach(E in L)
    Occ.put(E, Occ.get(E,0) + 1)
  end.


my_count(V,L,Rel,N) =>
  println($my_count(V,L,Rel,N)),
  sum([V #= E : E in L]) #= Count,
  call(Rel,Count,N).

go =>
  A = [2, 4, 6, 8, 9],
  println(A),
  % println(binary_search(A, 2)),

  test1(A,2),
  test1(A, 1),
  test1(A, 8),
  test1(A, 10),
  test1(A, 9),
  test1(A, 5),

  test1([1,20,3,4], 5), % not sorted array

  println("recursive:"),
  % println(binary_search2(A, 2)),
  test2(A,2),
  test2(A, 1),
  test2(A, 8),
  test2(A, 10),
  test2(A, 9),
  test2(A, 5),

  test2([1,20,3,4], 5), % not sorted array


  nl.

test1(A, Value) =>
  Ret = binary_search(A,Value),
  printf("A: %w Value:%d Ret: %d: ", A, Value, Ret),
  if Ret == -1 then
    println("The array is not sorted.")
  elseif Ret == 0 then
    printf("The value %d is not in the array.\n", Value)
  else
    printf("The value %d is found at position %d.\n", Value, Ret)
  end.


test2(A, Value) =>
  Ret = binary_search_rec(A,Value),
  printf("A: %w Value:%d Ret: %d: ", A, Value, Ret),
  if Ret == -1 then
    println("The array is not sorted.")
  elseif Ret == 0 then
    printf("The value %d is not in the array.\n", Value)
  else
    printf("The value %d is found at position %d.\n", Value, Ret)
  end.


%
% iterative version
%
binary_search(A, Value) = V =>
  V1 = 0,
  % we want a sorted array
  if not sort(A) == A then
    V1 := -1
  else 
    Low = 1,
    High = A.length,
    Mid = 1,
    Found = 0,
    while (Found == 0, Low <= High) 
       Mid := (Low + High) // 2,
       if A[Mid] > Value then
         High := Mid - 1
       elseif A[Mid] < Value then
         Low := Mid + 1
       else 
         V1 := Mid,
         Found := 1
      end
    end
  end,

  V = V1.



% Recursive version
binary_search_rec(A, Value) = Ret =>
   Ret = binary_search_rec(A,Value, 1, A.length).

binary_search_rec(A, _Value, _Low, _High) = -1, sort(A) != A => true.
binary_search_rec(_A, _Value, Low, High)  =  0, High < Low   => true.
binary_search_rec(A, Value, Low, High)    = Mid => 
   Mid1 = (Low + High) // 2,
   if A[Mid1] > Value then
      Mid1 := binary_search_rec(A, Value, Low, Mid1-1)
   elseif A[Mid1] < Value then
      Mid1 := binary_search_rec(A, Value, Mid1+1, High)
   end,
   Mid = Mid1.
       

go =>
   N = 16,
   K = 14, 
   println([N,K,binomial(N,K)]),

   foreach(K2 in 0..N)
      printf("binomial(%2d,%2d): %d\n", N, K2, binomial(N,K2))
   end,
   nl.

table
binomial(N,K) = Res =>
   R = 1,
   foreach(I in 1..K) 
     R := floor(R * ((N-I+1)/I))
   end,
   Res = R.

go =>
   foreach(Problem in 1..2, Predicate in [bin_packing1, bin_packing2])
      printf("Problem %d using %w\n", Problem,Predicate),
      do_problem(Problem,Predicate)
   end,
   nl.

 
do_problem(Problem, Predicate) =>

   % we let the Capacity be unknown
   problem(Problem,Bins, Weights,_Capacity),
   % N = 3, % if Bins is free we must set the length of it

   N = length(Weights),
   Bins = new_list(N),

   % Bins :: 1..N,

   % Weights :: 1..4,

   % Capacity = 5,
   Capacity :: 1..20,

   % bin_packing3(Bins,Weights,Capacity),
   
   % bin_packing2(Bins,Weights,Capacity),
   call(Predicate,Bins,Weights,Capacity),

   Vars = Weights ++ Bins ++ [Capacity],
   solve([$min(Capacity)],Vars),

   writeln(capacity=Capacity),
   writeln(bins=Bins),
   writeln(weights=Weights),
   nl.
 
  

% The example cited above
problem(1, Bins, Weights, Capacity) =>
   Bins=[3,1,3], Weights=[4,3,1], Capacity=5.
% another example
problem(2, Bins, Weights, Capacity) => 
   Bins=[3,1,3,2,2,1,2,3], Weights=[4,3,1,3,4,3,1,2], Capacity=5.


% version 1, using list comprehension
bin_packing1(Bins, Weights, Capacity) =>
   N = length(Bins),
   N = length(Weights),
   foreach(B in 1..N)
      sum([(Weights[J]*(Bins[J] #= B)) : J in 1..N ]) #=< Capacity
   end.

% version 2, using accumulator Sum
bin_packing2(Bins, Weights, Capacity) =>
   N = length(Bins),
   N = length(Weights),

   foreach(B in 1..N)
      Sum = 0,
      foreach(J in 1..N)
          Sum := $Sum + Weights[J] * (Bins[J] #= B)
      end,
      Sum #=< Capacity
   end.

% sorted Stuff: very slow for problem 9
go =>
   foreach(P in 0..9) time2($bin_packing(P,sorted)) end.


% Unsorted Stuff: very slow for problem 9
go2 =>
   foreach(P in 0..9) time2($bin_packing(P,unsorted)) end.

% In all very slow...
go3 =>
   foreach(P in 0..9) time2($bin_packing2(P)) end.

go4 => 
  time2(bin_packing(9,sorted)),
  nl.

bin_packing(Problem, SortMode) =>

   problem(Problem, StuffUnordered, BinCapacity),

   % sorting (reversed) the stuff may makes it a bit faster
   if  SortMode = sorted then
       Stuff = sort_down(StuffUnordered)
   else
       Stuff = StuffUnordered
   end,

   printf("\nProblem %w\n",Problem),

   % BinCapacity: the (common) capacity for each bin
   write(bin_capacity=BinCapacity),nl,

   % Stuff: values/weight of the things to pack
   NumStuff = length(Stuff), 
   write(stuff=Stuff),nl,
   write(num_stuff=NumStuff),nl,

   % Number of bins cannot exceed num_stuff...
   NumBins #= NumStuff,

   % Sanity clause: 
   %    No thing can be larger than capacity.
   foreach(S in Stuff)
       if S > BinCapacity then
          printf("Stuff %d is larger than BinCapacity %d\n", S, BinCapacity)
       end
   end,
   
   % Bins: where to put a thing.
   Bins = new_array(NumBins,NumStuff),
   BinsList = vars(Bins),
   BinsList :: 0..1,   


   % BinLoads: contains how many things (the summed 
   %      weights of) a bin takes
   BinLoads = new_list(NumBins),
   BinLoads :: 0..BinCapacity,
   foreach({Bin,Load} in zip(Bins.to_list(),BinLoads))
      scalar_product(Stuff,Bin,Load)
   end,

   % a thing is packed exactly once 
   foreach(Column in transpose(Bins).array_matrix_to_list_matrix()) sum(Column) #= 1 end,

   % compare the total loads
   sum(Stuff) #= sum(BinLoads),



   % load the bins in order:
   % first bin must be loaded, and the list must be ordered
   % element(1, BinLoads, BinLoads1),
   % BinLoads1 #> 0,
   BinLoads[1] #> 0,
   % decreasing(BinLoads),

   % symmetry breaking: 
   %    if bin_loads[i+1] is > 0 then bin_loads[i] must be > 0
   % (This seems to be better than using decreasing/1.)
   foreach(B in 1..NumBins-1)
       BinLoads[B+1] #>0 #=> BinLoads[B] #> 0,
       BinLoads[B] #>= BinLoads[B+1]
   end,

   % calculate the number of loaded bins (which we will minimize)
   NumLoadedBins #= sum([(BL #> 0) : BL in BinLoads]),

   %
   % search
   %
   writeln(search),
   % term_variables([BinsList,BinLoads,NumBins,NumLoadedBins],Vars),
   Vars = Bins.to_list() ++ BinLoads,
   % minof(labeling([inout,split],Vars), NumLoadedBins,
   solve($[inout,split,min(NumLoadedBins), report(printf("NumLoadedBIns: %d\n", NumLoadedBins))],Vars),
   % labeling([inout], Vars),

   % output
   writeln('...'),
   writeln(bin_loads=BinLoads),
   writeln(num_loaded_bins=NumLoadedBins),
   writeln(numBins=NumBins),
   % just print smaller problems
   if NumBins =< 40 then
      % pretty_print(Bins) 
      pretty_print2(Bins) 
   else
      printf("Bins are too large to print.\n")
   end,
   nl.


%
% Using cumulative for this problem was suggested by Mats Carlsson
% (and it is very fast in the SICStus prolog version).
%
% However, the implementation has been rewritten trying to keep
% the same approach. However, this is (much) slower than bin_packing/1. 
% The correct MaxStart value is mostly found very fast 
% (including for #9), but it then takes a long time to prove 
% its optimality. I might have missed something here...
%
bin_packing2(Problem) =>

   problem(Problem, StuffUnordered, BinCapacity),

   % Stuff = sort(StuffUnordered),
   Stuff = sort_down(StuffUnordered),
   % Stuff = StuffUnordered,
     
   N = length(Stuff),
   printf("\nProblem %d BinCapacity:%d N:%d\n", Problem,BinCapacity,N),
   writeln(stuff=Stuff),

   Duration = [1 : _I in 1..N],
   Resources = Stuff,
   Limit #= BinCapacity,
   Start = new_list(N),
   Start :: 1..BinCapacity,
   End = new_list(N),
   End :: 1..BinCapacity,

   % to minimize
   MaxStart #= max(Start),
   foreach({S,D,E} in zip(Start,Duration,End)) E #= S+D end, 

   cumulative(Start,Duration,Resources,Limit),

   Vars =  Start,
   solve([$min(MaxStart),forward,split],Vars),

   nl,
   writeln(maxStart=MaxStart),
   writeln(start=Start),
   writeln(duration=Duration),
   writeln(end=End),
   writeln(limit=Limit),
   writeln(stuff=Stuff),
   writeln(binCapacity=BinCapacity),

   foreach({S,E,T} in zip(Start,End,Stuff))
      writeln([bin=S,stuff=T])
   end,
   nl.



%
% pretty prints the Bin matrix.

pretty_print(X) =>
   writeln(pretty_print),
   foreach(Row in X)
      foreach(R in Row) printf("%d ", R) end,
      printf(" = %w\n", sum(Row.to_list()))
   end.

% just print the filled bins
pretty_print2(X) =>
   writeln(pretty_print2),
   foreach(Row in X)
      Sum = sum(Row.to_list()),
      if Sum > 0 then
          foreach(R in Row) printf("%d ", R) end,
          printf(" = %d\n", Sum)
      end
   end.

decreasing(List) =>
   foreach(I in 2..List.length) List[I-1] #>= List[I] end.

increasing(List) =>
   foreach(I in 2..List.length) List[I-1] #=< List[I] end.

%
% Data
%   

% easy problem to test with
problem(0, P, Capacity) =>
   P=[1,2,3,4,5,6,7,8,9,10],
   Capacity=30.


%
% Example from the Alice system
% Copying files to disks
% http://news.mozart-oz.org/alice/manual/cptutorial/node55.html
%
% """
% Suppose, you want to copy a set of files from your hard-disk onto as 
% few as possible diskettes of a given size, e. g. onto common 1.44 MB 
% diskettes. In case your files do not fit on a single diskette, it might 
% become quite tricky to figure out the minimal number of needed diskettes 
% and how to partition the files.
% """
problem(1, P, Capacity) => 
   P=[360, 850, 630, 70, 700, 210], 
   Capacity=1440.


% simple (and probably unrealistic) packing
problem(2, P, Capacity) => 
   P=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],
   Capacity=20.


% simple (and probably even less unrealistic) packing
problem(3, P, Capacity) => 
   P = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25],
   Capacity = 50.


% This problem below is from
% http://www.dcs.gla.ac.uk/~pat/cpM/slides/binPacking.ppt
% 1D Bin Packing (or "CP? Who cares?"), page 3
% and also from
% http://www.dcs.gla.ac.uk/~pat/cpM/JChoco/binPack
%
% num_stuff = 10;
% stuff = [42,63,67,57,93,90,38,36,45,42];
% bin_capacity = 150;
problem(4, P, Capacity) => 
   P= [42,69,67,57,93,90,38,36,45,42], 
   Capacity = 150.


% same source of data, but now there are 22 things
problem(5, P, Capacity) => 
   P=[42,69,67,57,93,90,38,36,45,42,33,79,27,57,44,84,86,92,
    46,38,85,33],
   Capacity = 250.


%
% continuing of the above example.
%
problem(6, P, Capacity) => 
   P = [42,69,67,57,93,90,38,36,45,42,33,79,27,57,44,84,86,92,
    46,38,85,33,82,73,49,70,59,23,57,72,74,69,33,42,28,46,
    30,64,29,74,41,49,55,98,80,32,25,38,82,30], 
   Capacity = 290.


% ibid. 
problem(7, P, Capacity) => 
   P= [42,69,67,57,93,90,38,36,45,42,33,79,27,57,44,84,86,92,46,38,
    85,33,82,73,49,70,59,23,57,72,74,69,33,42,28,46,30,64,29,74,
    41,49,55,98,80,32,25,38,82,30,35,39,57,84,62,50,55,27,30,36,
    20,78,47,26,45,41,58,98,91,96,73,84,37,93,91,43,73,85,81,79,
    71,80,76,83,41,78,70,23,42,87,43,84,60,55,49,78,73,62,36,44,
    94,69,32,96,70,84,58,78,25,80,58,66,83,24,98,60,42,43,43,
    39],
   Capacity = 500.


% From 
% Graham Kendall: Bin Packing made Easier 
% http://research-reflections.blogspot.com/2009/07/bin-packing-made-easier.html
problem(8, P, Capacity) => 
   P = [442,252,127,106,37,10,10,252,252,127,106,37,10,9,
   252,252,127,85,12,10,9,252,127,106,84,12,10,252,
   127,106,46,12,10],
   Capacity = 524.


% Variant: remove 46 from the problem above
problem(9, P, Capacity) => 
   P =  
   [442,252,127,106,37,10,10,252,252,127,106,37,10,9,
   252,252,127,85,12,10,9,252,127,106,84,12,10,252,
   127,106,12,10],
   Capacity = 524.

go =>
  Coin = 3,  
  C = 1..Coin,
  Value = [30,12,6],
  X = new_list(Coin),
  
  foreach(I in C) X[I] #>= 1 end, 
  sum([Value[I]*X[I] : I in C]) #= 306,
  sum(X) #= 15,

  solve(X),

  writeln(X),
  
  nl.

go =>
  M = 2,

  % w = 1 if Peter is Tom's father, 0 otherwise 
  W :: 0..1,

  % number of books (and price) bought by father i
  X = new_list(M), 
  X :: 1..8, 
  % number of books (and price) bought by son j
  Y = new_list(M), 
  Y :: 1..8, 


  Y[2] #= 1,      % Dick buys one book
  X[1] #= Y[1]+1, % Peter buys one more book than Tom

  % each family spends $65
  X[1]*X[1] + W*Y[1]*Y[1] + (1-W)*Y[2]*Y[2] #= 65,
  X[2]*X[2] + (1-W)*Y[1]*Y[1] + W*Y[2]*Y[2] #= 65,

  solve(X ++ Y ++ [W]),

  writeln(w=W),
  printf("%w is Dick's Father\n", cond(W == 1,"Paul","Peter")),
  writeln(x=X),
  writeln(y=Y),
  
  nl.

%
% This is based on the Prolog solution.
%
go =>
   printTable([0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5, 84.37, 84.38, 
               101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75, 185.62, 
               185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0, 
               286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38]).

%
% inspired by the Nim solution
%
go2 =>
  Names = ["North", "North by east", "North-northeast", "Northeast by north",
           "Northeast", "Northeast by east", "East-northeast", "East by north",
           "East", "East by south", "East-southeast", "Southeast by east",
           "Southeast", "Southeast by south","South-southeast", "South by east",
           "South", "South by west", "South-southwest", "Southwest by south",
           "Southwest", "Southwest by west", "West-southwest", "West by south",
           "West", "West by north", "West-northwest", "Northwest by west",
           "Northwest", "Northwest by north", "North-northwest", "North by west", "North"
          ],
  foreach(I in 0..32)
     J = I mod 32,
     D = I * 11.25,
     if I mod 3 == 1 then D := D + 5.62 end,
     if I mod 3 == 2 then D := D - 5.62 end,
     printf("%2d %-20s %6.2f\n", J+1, Names[J+1], D)
  end,
  nl.


index(-,-,-,-)
compassangle(1, "North",n, 0.00).
compassangle(2, "North by east", nbe, 11.25).
compassangle(3, "North-northeast", nne,22.50).
compassangle(4, "Northeast by north", nebn,33.75).
compassangle(5, "Northeast", ne,45.00).
compassangle(6, "Norteast by east", nebe,56.25).
compassangle(7, "East-northeast", ene,67.50).
compassangle(8, "East by North", ebn,78.75).
compassangle(9, "East", e,90.00).
compassangle(10, "East by south", ebs, 101.25).
compassangle(11, "East-southeast", ese,112.50).
compassangle(12, "Southeast by east", sebe, 123.75).
compassangle(13, "Southeast", se, 135.00).
compassangle(14, "Southeast by south", sebs, 146.25).
compassangle(15, "South-southeast",sse, 157.50).
compassangle(16, "South by east", sbe, 168.75).
compassangle(17, "South", s, 180.00).
compassangle(18, "South by west", sbw, 191.25).
compassangle(19, "South-southwest", ssw, 202.50).
compassangle(20, "Southwest by south", swbs, 213.75).
compassangle(21, "Southwest", sw, 225.00).
compassangle(22, "Southwest by west", swbw, 236.25).
compassangle(23, "West-southwest", wsw, 247.50).
compassangle(24, "West by south", wbs, 258.75).
compassangle(25, "West", w, 270.00).
compassangle(26, "West by north", wbn, 281.25).
compassangle(27, "West-northwest", wnw, 292.50).
compassangle(28, "Northwest by west", nwbw, 303.75).
compassangle(29, "Northwest", nw, 315.00).
compassangle(30, "Northwest by north", nwbn, 326.25).
compassangle(31, "North-northwest", nnw, 337.50).
compassangle(32, "North by west", nbw, 348.75).
% compassangle(1, "North", n, 360.00).

compassangle2(Index , Name, Heading, Angle) => 
    nonvar(Angle), resolveindex(Angle, Index), 
    compassangle(Index,Name, Heading, _).
 

resolveindex(Angle, Index) => 
    N = Angle / 11.25 + 0.5, 
    I = floor(N),
    Index = (I mod 32) + 1.

printTableRow(Angle) => 
    compassangle2(Index, Name, _, Angle), 
    printf("%2d  %-20s %6.2f", Index,Name, Angle).
 
printTable([X|Xs]) => printTableRow(X), nl, printTable(Xs).
printTable([]) => true.

module bplan.

% plan(L): L is a list of moves from the initial state to a goal state.
plan(L) => 
    initial_state(I), 
    goal_state(G), 
    reachable(I,L,G).

% reachable(S1,L,S2): S2 is reachable from S1 using moves L.
table
% reachable(S,[],S) => true.
reachable(S,_,S) => true.   
reachable(S1,[M|L],S3) => 
   legal_move(S1,M,S2), 
   reachable(S2,L,S3).

% This looks for plans, short ones first, using the plan predicate.
% bplan(L) holds if L is a plan.
bplan(L) => tryplan([],L). 

% tryplan(X,L): L is a plan and has X as its final elements.
tryplan(X,L) ?=> X=L, plan(L).
tryplan(X,L) => tryplan([_|X],L).


%
% An alternative version where the Init is a parameter
%

% plan(Init,L): L is a list of moves from the initial state to a goal state.
plan(Init, L) => 
    writeln(len=L.length),
    goal_state(G), 
    reachable(Init,L,G).

% This looks for plans, short ones first, using the plan predicate.
% bplan(Init, L) holds if L is a plan.
bplan(Init,L) => tryplan(Init,[],L). 

% tryplan(Init, X,L): L is a plan and has X as its final elements.
tryplan(Init,X,L) ?=> X=L, plan(Init,L).
tryplan(Init,X,L) => initialize_table, tryplan(Init, [_|X],L).


%
% This versions was suggested by Neng-Fa Zhou
% and is sometimes (much) faster than bplan/3
% and sometimes not.
%
table (+,-,min)
plan2(S,Plan,Cost),goal_state(S) => 
  writeln(solution_found),
  Plan=[],Cost=0.
plan2(S,Plan,Cost) =>
  legal_move(S,Action,S1,ActionCost),
  plan2(S1,Plan1,Cost1),
  Plan = [Action|Plan1],
  Cost = Cost1+ActionCost.


table (+,-,min,nt)
plan3(S,Plan,Cost,Down),goal_state(S) => 
  writeln($solution_found(Down)),
  writeln(len1=length(Down)),
  Plan=[],Cost=0.
plan3(S,Plan,Cost,Down) =>
  % writeln(len2=length(Down)),
  legal_move(S,Action,S1,ActionCost),
  plan3(S1,Plan1,Cost1,[Action|Down]),
  Plan = [Action|Plan1],
  Cost = Cost1+ActionCost.

go =>

   N = 4,

   Corey = 1,
   Jimmy = 2,
   Lois  = 3,
   Perry = 4,
   Reporters = [Corey, Jimmy, Lois, Perry],
   ReportersS = ["Corey", "Jimmy", "Lois", "Perry"],

   Locations = [Bayonne, NewHope, PortCharles, SouthAmboy],
   LocationsS = ["Bayonne", "New Hope", "Port Charles", "South Amboy"],
   Locations :: 1..N,
   
   News = [Baby, Blimp, Skyscraper, Whale],
   NewsS = ["Baby", "Blimp", "Skyscraper", "Whale"],
   News :: 1..N,
   
   all_different(Locations),
   all_different(News),

   % use assignment (inverse) for the presentation   
   assignment(Locations, LocationsInv),
   assignment(News, NewsInv),

   % 1. The 30-pound baby wasn"t born in South Amboy or New Hope.
   Baby #!= SouthAmboy,
   Baby #!= NewHope,
   
   % 2. Jimmy didn"t go to Port Charles.
   Jimmy #!= PortCharles,
   
   % 3. The blimp launching and the skyscraper dedication were covered, 
   %    in some order, by Lois and the reporter who was sent to 
   %    Port Charles.
   Lois #!= PortCharles,
   ( 
       (Blimp #= Lois #/\ Skyscraper #= PortCharles)
       #\/
       (Skyscraper #= Lois #/\ Blimp #= PortCharles)
   ),

   % 4. South Amboy was not the site of either the beached whale or the 
   %    skyscraper dedication.
   SouthAmboy #!= Whale,
   SouthAmboy #!= Skyscraper,

   % 5. Bayonne is either the place that Corey went or the place where 
   %    the whale was beached, or both.
   ( 
       Bayonne #= Corey #\/ Bayonne #= Whale
   ),

   Vars = Locations ++ News ++ LocationsInv ++ NewsInv,
   solve(Vars),

   print_all("Reporters",Reporters,ReportersS),
   print_all("Locations",Locations,LocationsS),
   print_all("News     ",News,NewsS),
   nl,
   % using assignment/inverse
   writeln(locationsInv=LocationsInv),
   writeln(newsInv=NewsInv),
   foreach(I in 1..N) 
      printf("%-8s: %-15s %w\n", ReportersS[I],LocationsS[LocationsInv[I]], NewsS[NewsInv[I]])
   end,

   statistics(backtracks,Backtracks),
   writeln(backtracks=Backtracks).
   


print_all(What, X,S) =>
   Len = length(X),
   printf(What),print(": "),
   foreach(I in 1..Len)
      % element(IX,X,I),
      IX = find_first_of(X,I),
      % element(IX,S,This),
      This = S[IX],
      printf("%w ", This)
   end,
   nl.

go =>
   N = 4,
   M = 40,

   broken_weights(N,M,Weights,X),
   writeln(Weights),
   print_matrix(X),
   nl.

%
% Alternative version of the problem:
% what is the minimal number of weights
% for weighting all values of 1..80.
% We don't minimize the last value of the
% weights, so any value is good.
%
go2 =>
   M = 80,
   N :: 1..M,
   indomain(N),
   writeln(n=N),

   broken_weights(N,M,Weights,X,false),
   writeln(Weights),
   print_matrix(X),
   nl.

% what is the minimal number of weights
% for weighting all values of 1..80.
% Also, we minimize the last value of the
% weights.
go3 =>
   N :: 1..40,
   indomain(N),
   writeln(n=N),

   M = 80,

   broken_weights(N,M,Weights,X,true),
   writeln(Weights),
   print_matrix(X).

%
% recursive variant, from http://stackoverflow.com/questions/38468488/how-to-program-this-puzzle-recursively
%
go4 => 
  println([broken_weights_rec(N) : N in 1..40]),
  nl.

   
% default call
broken_weights(N,M, Weights, X) =>
   broken_weights(N,M, Weights, X, true).

% Minimize = true -> minimize the last value of Weights
broken_weights(N,M, Weights, X, Minimize) =>

   Weights = new_list(N),
   Weights :: 1..M,

   X = new_array(M,N),
   X :: -1..1, 

   all_distinct(Weights),

   % symmetry breaking
   increasing(Weights),

   M #= sum(Weights),
   foreach(J in 1..M)
      scalar_product([X[J,I] : I in 1..N],Weights,J)
   end,
   
   % search
   Vars = Weights ++ X,

   if Minimize = true then
      % minimize the last weights
      solve($[min(Weights[N])], Vars)
   else
      solve([],Vars)
   end.


print_matrix(X) =>
   foreach({I,Row} in zip(1..X.length,X.to_list()))
      writef("%2d: ", I),
      foreach(R in Row) writef("%3d", R) end,
      nl
   end.

product_lists(List1, List2, Sum) =>
   Sum #= sum([L1*L2 : {L1,L2} in zip(List1, List2)]).



% From http://stackoverflow.com/questions/38468488/how-to-program-this-puzzle-recursively
% """
% So, the answer is (1,3,9,27) which can be generalized as twice the sum of previous terms + 1.
% """
% Note that this don't solve the minimization problem, just the satisfiability problem.
%
% For N in 1..40:
% [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14348907,43046721,129140163,387420489,1162261467,3486784401,10460353203,31381059609,94143178827,282429536481,847288609443,2541865828329,7625597484987,22876792454961,68630377364883,205891132094649,617673396283947,1853020188851841,5559060566555523,16677181699666569,50031545098999707,150094635296999121,450283905890997363,1350851717672992089,4052555153018976267]
% 
table
broken_weights_rec1(N) = [1,1], N <= 1 => true.
broken_weights_rec1(N) = [NewSum,NewTerm] =>
  [OldSum, _OldTerm] = broken_weights_rec1(N-1),
  NewTerm = 2*OldSum + 1,
  NewSum = OldSum+NewTerm.

broken_weights_rec(N) = broken_weights_rec1(N).second().

go =>
   L = findall(LD, $build(LD)),
   writeln(L),
   writeln(len=L.length).
   


build(LD) =>
   LD = [TS,TA,TB,TC,TD,TE],
   LD :: 0..20,
   TS #>= 0,       % start
   TA #>= TS + 7,  % foundation
   TB #>= TA + 4,  % interior walls
   TC #>= TA + 3,  % exterior walls
   TD #>= TA + 3,  % chimney
   TD #>= TC + 2,  % roof
   % TE is the End task
   TE #>= TB + 2,  % doors
   TE #>= TD + 3,  % tiles
   TE #>= TC + 3,  % windows
   TE #=< 15,     

   % solve([$min(TE)], LD),
   solve(LD),

   writeln([ts=TS,ta=TA,tb=TB,tc=TC,td=TD,te=TE]).

go =>
   % number of time slots
   TimeSlots = 6,
   
   % demand: minimum number of buses at time t
   Demands = [8, 10, 7, 12, 4, 4],      
   MaxNum #= sum(Demands),
   
   % result: how many buses start the schedule at time slot t?
   X = new_list(TimeSlots),
   X :: 0..MaxNum,

   % the objective to minimize: the total number of buses
   NumBuses #= sum(X),

   % meet the demands for this and the next time slot
   foreach(I in 1..TimeSlots-1)
         X[I]+X[I+1] #>= Demands[I]
   end,

   % demand "around the clock"
   X[TimeSlots] + X[1] #= Demands[TimeSlots],

   % search for minimum number of buses satisfying the constraints
   solve([$min(NumBuses)], X),

   writeln([NumBuses, X]).

go =>
        time2(calculs_d_enfer(AA,Amax)),
        writeln(amax=Amax),
        writeln(AA).

go2 =>
        time2(calculs_d_enfer2(AA,Amax)),
        writeln(amax=Amax),
        writeln(AA).


calculs_d_enfer(AA,Amax) =>

        NN = 26,

        AA = [_A,_B,_C,_D,E,F,G,H,I,_J,_K,L,_M,N,O,_P,_Q,R,S,T,U,V,W,X,_Y,Z],
        AA :: -100..100,
        
        % The objective is to minimize the maximum of the absolute 
        % values of [I]
        Aabs = new_list(NN),
        foreach(II in 1..NN) Aabs[II] #= abs(AA[II]) end,

        % we want to minimize the maximum value in AA
        Amax :: 0..NN,
        Amax #= max(Aabs),
        
        all_different(AA),

        Z+E+R+O     #= 0,
        O+N+E       #= 1,
        T+W+O       #= 2,
        T+H+R+E+E   #= 3,
        F+O+U+R     #= 4,
        F+I+V+E     #= 5,
        S+I+X       #= 6,
        S+E+V+E+N   #= 7,
        E+I+G+H+T   #= 8,
        N+I+N+E     #= 9,
        T+E+N       #= 10,
        E+L+E+V+E+N #= 11,
        T+W+E+L+F   #= 12,
        
        % search
        % This gives the same solution as the one above
        % 0.096s and 1675 backtracks
        % solve([$min(Amax),ff], AA), 

        solve([$min(Amax),ff, down], AA).

        % for generating more solutions (there are _many_)
        % Amax #= 16,
        % solve([ff,down],AA).


% Using sum() #= 
calculs_d_enfer2(AA,Amax) =>

        NN = 26,

        AA = [_A,_B,_C,_D,E,F,G,H,I,_J,_K,L,_M,N,O,_P,_Q,R,S,T,U,V,W,X,_Y,Z],
        AA :: -100..100,
        
        % The objective is to minimize the maximum of the absolute 
        % values of [I]
        Aabs = new_list(NN),
        foreach(II in 1..NN) Aabs[II] #= abs(AA[II]) end,

        % we want to minimize the maximum value in AA
        Amax :: 0..NN,
        Amax #= max(Aabs),
        
        all_different(AA),

        sum([Z,E,R,O])     #=  0,
        sum([O,N,E])       #=  1,
        sum([T,W,O])       #=  2,
        sum([T,H,R,E,E])   #=  3,
        sum([F,O,U,R])     #=  4,
        sum([F,I,V,E])     #=  5,
        sum([S,I,X])       #=  6,
        sum([S,E,V,E,N])   #=  7,
        sum([E,I,G,H,T])   #=  8,
        sum([N,I,N,E])     #=  9,
        sum([T,E,N])       #= 10,
        sum([E,L,E,V,E,N]) #= 11,
        sum([T,W,E,L,F])   #= 12,
        
        % solve([$min(Amax),ff], AA), 
        solve([$min(Amax),ff, down], AA).

        % for generating more solutions (there are _many_)
        % Amax #= 16,
        % solve([ff,down],AA).


go =>
  Input = [1,2,2],
  println(input=Input),
  candies(Input,X,Z),
  println(x=X),
  println(z=Z),
  nl.

go2 => 
  N = 1000,
  _ = random2(),
  Input = [1+random() mod ceiling(sqrt(N)) : _ in 1..N],
  println(input=Input),
  candies(Input,X,Z),
  println(x=X),
  println(z=Z),
  nl.

candies(Input, X,Z) =>
   N = Input.length,
   
   X = new_list(N),
   X :: 1..10000,

   Z #= sum(X),

   foreach(I in 2..N) 
     if Input[I-1] > Input[I] then
       X[I-1] #> X[I]
     elseif Input[I-1] < Input[I] then
       X[I-1] #< X[I]
     end
   end,

   solve($[min(Z)], X).

go =>
        
   NbCars = 6,
   Cars = 1..NbCars,
   NbOptions = 5,
   Options = 1..NbOptions,
   NbSlots = 10,
   Slots = 1..NbSlots,
   Demand = [1, 1, 2, 2, 2, 2],
   Option = [[1, 0, 0, 0, 1, 1],
        [0, 0, 1, 1, 0, 1],
        [1, 0, 0, 0, 1, 0],
        [1, 1, 0, 1, 0, 0],
        [0, 0, 1, 0, 0, 0]],
   Capacity = [[1,2],
          [2,3],
          [1,3],
          [2,5],
          [1,5]],

   % OptionDemand = [],
   % foreach(I in Options)
   %    OD #= sum([ Demand[J]*Option[I,J] : J in Cars]),
   %    OptionDemand := OptionDemand ++ [OD]
   % end,

   OptionDemand = [sum([Demand[J]*Option[I,J] : J in Cars]) : I in Options],

   %
   % decision variables
   %
   Slot = new_list(NbSlots),
   Slot :: 1..NbCars,

   Setup = new_array(NbOptions,NbSlots),
   Setup :: 0..1,

   % To minimize
   Z #= sum([S*Slot[S] : S in Cars]),

   %
   % Constraints
   %
   foreach(C in Cars)
      sum([(Slot[S] #= C) : S in Slots]) #= Demand[C]
   end,

   foreach(O in Options, S in 1..(NbSlots - Capacity[O,2] + 1))
      sum([Setup[O,J] : J in S..S + Capacity[O,2]- 1]) #=< Capacity[O,1]
   end,

   %% This don't work
   % foreach(O in Options, S in Slots)
   %    Setup[O,S] #= Option[O,Slot[S]]
   % end,
   %% Instead one has to use a couple of element/3.
   foreach(O in Options, S in Slots)
      % element(S,Slot,SlotS),
      SlotS = Slot[S],
      matrix_element(Option,O,SlotS,SS),
      Setup[O,S] #= SS
   end,

   foreach(O in Options, I in 1..OptionDemand[O])
       sum([Setup[O,S] : S in 1..(NbSlots - I * Capacity[O,2])]) #>=
                       (OptionDemand[O] - I * Capacity[O,1])
   end,


   Vars = Slot ++ Setup,
   solve([$min(Z)], Vars),

   writeln(z=Z),
   printf("slot:\n%w\n", Slot),
   printf("setup:\n"),
   foreach(Row in Setup) writeln(Row.to_list()) end,

   nl.


matrix_element(X, I, J, Val) =>
   % element(I, X, Row),
   Row = X[I],
   element(J, Row, Val).

% matrix_element(X, I, J, Val) =>
%    freeze(I, (element(I, X, Row),freeze(J,element(J,Row,Val)))).

go =>
  foreach(N in 0..30)
     println([N,catalan(N)])
  end,
  nl.

catalan(N) = catalan1(N+1).

table
catalan1(0) = 1.
catalan1(1) = 1.
catalan1(N) = sum([ catalan1(I)*catalan1(N-I) : I in 1..N-1]) => N > 1.

%
% changes is in oere (100 oere is 1 kr)
% 
go =>
   Change = 123,
   L = findall([Change,NumCoins,LD],$changes(Change,LD,NumCoins)),
   writeln(L).

% check changes for some prime numbers
go2 =>
    foreach(Change in [2,3,5,7,11,13,17,23,29,31])
        changes(Change,LL,NumCoins),
        println([change=Change, numcoins=NumCoins,coins=LL])
    end.

go3 =>
    All = [],
    foreach(Change in 1..100)
        changes(Change,LL,NumCoins),
        println([change=Change, numcoins=NumCoins,coins=LL]),
        All := All ++ [NumCoins]
    end,
    writeln(All).


changes(Change,LD,NumCoins) =>
    LD = [OneKr, FiftyOre, TwentyFiveOre,TenOre,FiveOre, OneOre],
    LD :: 0..Change,

    % the value of coins, in oere
    100*OneKr+50*FiftyOre+25*TwentyFiveOre+10*TenOre+5*FiveOre+1*OneOre #= Change,

    % number of coins, the weights which we will minimize
    NumCoins #= sum(LD),

    % solve(LD).
    solve([$min(NumCoins)], LD).

go => 
   chicken(3),
   chicken(4),
   chicken(5).


%% chicken.pl
% sample query ?-chicken(3).

chicken(N) => 
    NR = 5+2*(N-1),
    NC = 7*2*(N-1)+6,
    A = new_array(NR,NC),
    place_u(A,2*(N-1)+1,1,N),
    (N mod 2=:=0->place_c2(A,1,7*(N-1)+1);place_c1(A,1,7*(N-1)+1)),
    place_d(A,3,7*(N-1)+7,N),
    foreach(R in 1..NR) 
        foreach(C in 1..NC)
           E=A[R,C],
           (var(E)->printf(" ");printf("%w",E))
        end,
        nl
    end.

place_u(_A,_R,_C,I) ?=> I=<1.
place_u(A,R,C,I) => 
    place_cb(A,R,C),
    R1 = R-2,
    C1 = C+7,
    I1 = I-1,
    place_u(A,R1,C1,I1).

place_d(_A,_R,_C,I) ?=> I=<1.
place_d(A,R,C,I) => 
    place_bc(A,R,C),
    R1 = R+2,
    C1 = C+7,
    I1 = I-1,
    place_d(A,R1,C1,I1).
    
place_c1(A,R,C) => 
    place_s(A,R,C,  "   \\\\ "),
    place_s(A,R+1,C,"   (o>"),
    place_s(A,R+2,C,"\\\\_//)"),
    place_s(A,R+3,C," \\_/_)"),
    place_s(A,R+4,C,"___|__").

place_c2(A,R,C) => 
    place_s(A,R,C,  "   // "),
    place_s(A,R+1,C,"   <o)"),
    place_s(A,R+2,C,"(\\\\_//"),
    place_s(A,R+3,C,"(_\\_/)"),
    place_s(A,R+4,C,"__|___").

place_cb(A,R,C) => 
    place_s(A,R,C,  "   \\\\  "),
    place_s(A,R+1,C,"   (o> "),
    place_s(A,R+2,C,"\\\\_//) "),
    place_s(A,R+3,C," \\_/_)|"),
    place_s(A,R+4,C,"___|__|").

place_bc(A,R,C) => 
    place_s(A,R,C,  "  //   "),
    place_s(A,R+1,C," <o)  "),
    place_s(A,R+2,C," (\\\\_//"),
    place_s(A,R+3,C,"|(_\\_/ "),
    place_s(A,R+4,C,"|__|___").

place_s(_A,_R,_C,[]) => true.
place_s(A,R,C,[X|Xs]) => 
    A[R,C] = X,
    C1 = C+1,
    place_s(A,R,C1,Xs).
  
go =>
   _ = findall(LD, $circling_squares(LD)).


write_list([A,B,C,D,E,F,G,H,I,K]) =>
   writef("     %d  %d\n", K,A),
   writef("   %d       %d\n", I,B),
   writef(" %d      %d\n", H,C),
   writef("   %d       %d\n", G,D),
   writef("     %d  %d\n", F,E),
   nl,nl.
   


circling_squares(LD) =>
   LD = [A,B,C,D,E,F,G,H,I,K],
   LD :: 1..99,
   all_different(LD),

   A #= 16,
   B #= 2,
   F #= 8,
   G #= 14,

   s(A,B,  F,G),
   s(B,C,  G,H),
   s(C,D,  H,I),
   s(D,E,  I,K),
   s(E,F,  K,A),
   
   solve([ff], LD),
   write_list(LD).


%
% help predicate
%
s(X1,X2, Y1, Y2 ) =>
   X1*X1 + X2*X2  #= Y1*Y1 + Y2*Y2.

go =>   
        % find all circuits of order 5
        N = 5,
        Print = 1,
        test1(N, Print),
        test2(N, Print).


%
% Show all circuits of order 4..11 and compare with
% the built-in circuit/1 which is (unsurprisingly)
% much faster. Intrestingly the backtracks are the same.
% 
% Note: First is the statistics for my B-Prolog model
%       http://www.hakank.org/bprolog/circuit.pl
%    For N=10
%    - circuit_me/1: 3.388 seconds. Backtracks: 362879
%    - circuit/1   : 2.144 seconds. Backtracks: 362879
%    (There are 362880 different solutions of N=10,
%     i.e. one more than the number of backtracks).
%
%    For N=11:
%    - circuit_me/1: 36.062 seconds. Backtracks: 3628799
%    - circuit/1   : 23.374 seconds. Backtracks: 3628799
% 
% Then the statistics for this Picat model
%    N: 10
%    - circuit_me/1: CPU time 3.004 seconds. Backtracks: 362879
%    - circuit/1   : CPU time 1.636 seconds. Backtracks: 362879
% 
%    N: 11
%    - circuit_me/1: CPU time 31.026 seconds. Backtracks: 3628799
%    - circuit/1   : CPU time 19.449000000000002 seconds. Backtracks: 3628799
%
% So it seems that Picat is slightly faster for this problem than B-Prolog.
% (They have exactly the same number of backtracks.)
%
go2 =>
   Print = 0,
   foreach(N in 4..11)
      garbage_collect(100_000_000),
      writef("\nN: %d\n", N),
      time2(test1(N, Print)),
      time2(test2(N, Print))
   end.

go3 => 
   N = 6,
   X = new_list(N),
   X :: 1..N,
   Path = new_list(N),
   Path :: 1..N,
   circuit_path(X,Path),

   Vars = X ++ Path,
   solve(Vars),

   println(x=X),
   println(path=Path),
   nl,
   fail,
   nl.  


go4 =>   
  % find all circuits of order 5
  garbage_collect(200_000_000),
  N = 10,
  Print = 0,
  time(test2(N, Print)),
  time(test3(N, Print)).


% Using my circuit_me/1
test1(N,Print) =>
   X = new_list(N),
   X :: 1..N, 
   L = findall(X, (circuit_me(X),solve([ff],X))),
   if Print == 1 then writeln(L) end,
   writeln(len=L.length).


% Using the built-in circuit/1.
test2(N,Print) =>

   X = new_list(N),
   X :: 1..N, 
   L = findall(X, (circuit(X),solve([ff],X))),
   if Print == 1 then writeln(L) end,
   writeln(len=L.length).

% Using the built-in circuit/1 and count_all
test3(N,Print) =>

   X = new_list(N),
   X :: 1..N, 
   Count = count_all((circuit(X),solve([ff],X))),
   println(len=Count).

   
       
%
% circuit(X) succeeds for the array X if it's a circuit.
%
% This implementation use an extra array (Z) for the orbit of x[1].
%
circuit_me(X) =>
   N = length(X),
   Z = new_list(N),
   Z :: 1..N,

   %
   % The main constraint is that Z[I] must not be 1 
   % until I = N, and for I = N it must be 1.
   %
   all_different(X),
   all_different(Z),
   % all_distinct(X), % slower
   % all_distinct(Z), % slower

   % put the orbit of x[1] in in z[1..n]
   X[1] #= Z[1],
   
   % when I = N it must be 1
   Z[N] #= 1,

   % Redundant constraint. It is covered by the constraints
   % X[N] = 1 and alldifferent.
   % foreach(I in 1..N-1) Z[I] #\= 1 end,

   %
   % Get the orbit for Z.
   %
   foreach(I in 2..N)
     element(Z[I-1],X,Z[I])
   end.



circuit_path(X,Z) =>
   N = length(X),
   Z = new_list(N),
   Z :: 1..N,

   %
   % The main constraint is that Z[I] must not be 1 
   % until I = N, and for I = N it must be 1.
   %
   all_different(X),
   all_different(Z),
   % all_distinct(X), % slower
   % all_distinct(Z), % slower

   % put the orbit of x[1] in in z[1..n]
   X[1] #= Z[1],
   
   % when I = N it must be 1
   Z[N] #= 1,

   % Redundant constraint. It is covered by the constraints
   % X[N] = 1 and alldifferent.
   % foreach(I in 1..N-1) Z[I] #\= 1 end,

   %
   % Get the orbit for Z.
   %
   foreach(I in 2..N)
     element(Z[I-1],X,Z[I])
   end.

%
% Test the problem instances and find all or just the maximum cliques.
% It also generates a random graph.

%
go =>
    println("Find all cliques"),
    time2($find_all_cliques(1)),
    time2($find_all_cliques(2)),
    time2($find_all_cliques(3)),
    time2($find_all_cliques(4)),
    nl,
    print("\nFind all the largest cliques:"),
    time2($find_all_largest_cliques(1)),
    time2($find_all_largest_cliques(2)),
    time2($find_all_largest_cliques(3)),
    time2($find_all_largest_cliques(4)),
    
    % now try a random problem
    N2 = 100,
    printf("\nTry a random problem of size %d",N2),nl,
    generate_problem(N2,G),
    time2($clique(G,Clique,Card,_)),
    writeln(clique=Clique),
    writeln(cardinality=Card),
    nl.

%
% Generate a graph of size N and find all the largest cliques
%
go2 =>
   N = 200,
   % N = random2() mod 300,
   printf("Generate a graph of size %d and find all largest cliques\n", N),
   generate_problem(N,G),
   % pretty_print(G),
   printf("Graph generated.\nFind the maximum cardinality.\n"),
   time2($clique(G, Clique,Card,_)),
   writeln([clique=Clique,card=Card]),

   println("\nFind all cliques of this size"),
   L = findall(Clique2, $clique(G, Clique2,Card,_)),
   Len=length(L),
   writeln(L),
   printf("The graph has %d clique(s) of size %d\n", Len,Card).


%
% This is quite experimental (it don't work in Picat)
% Given a clique, generate a graph with this clique. 
% Note: It just handles one clique at each call to clique/5, but as we
% see below, calling more times with a new clique seems to work.
%
% go3 =>
%    G1 = new_array(4,4), 
%    G1List =  vars(G1),
%    G1List in 0..1, 
%    Clique1 = [1,2,3],
%    clique(G1,Clique1,_,_),
%    solve(G1List),
%    pretty_print(G1),
  
%    % trying to recreate problem 2 with 3 cliques
%    % matrix(G2,[10,10]), 
%    % term_variables(G2,G2List),
%    % G2List in 0..1, 
%    % Clique2 = [6,7,8,9,10],
%    % clique(G2,Clique2,_,_),
%    % Clique2b = [1,2,3],
%    % clique(G2,Clique2b,_,_),
%    % Clique2c = [4,5,6],
%    % clique(G2,Clique2c,_,_),
%    % labeling([], G2),
%    % pretty_print(G2)
%    nl.


go4 =>  
   time2($find_all_cliques(4)).
   % find_all_largest_cliques(4).


go5 =>
   % now try a small random problem
   N2 = 20,
   printf("\nTry a random problem of size %d",N2),nl,
   generate_problem(N2,G),
   clique(G,Clique,Card,_),
   pretty_print(G),
   nl,
   writeln(clique=Clique),
   writeln(cardinality=Card),
   nl.


%
% First get for the cardinality of the largest clique,
% then get all clique of this cardinality.
%
find_all_largest_cliques(Problem) =>
   printf("\nProblem %d\n", Problem),nl,
   problem(Problem, G),
   clique(G, Clique,Card,_),
   writeln(one_large_clique=[Clique,card=Card]),
   L1=findall(Clique2, $clique(G, Clique2,Card,_)),
   writeln(all_cliques=L1),nl.

    
% 
% Find all cliques for a problem
%
find_all_cliques(Problem) =>
   printf("\nProblem %d\n", Problem),
   problem(Problem, G),
   All=findall(Clique, $clique(G,Clique,_Card,all)),
   Len = length(All),
   write(length=Len),nl,
   if Len < 46 then
         writeln(All)
   else
         printf("List of cliques is too large to show...")
   end,
   nl.


% 
% Find one cliques for a problem
%
find_one_clique(Problem) =>
   printf("\nProblem %d\n", Problem),
   problem(Problem, G),
   clique(G,Clique,_Card,all),
   writeln(Clique),
   nl.

%
% convert a list of boolean to a "set"
%
boolean_to_set(List,Clique) =>
   List :: 0..1,
   Clique = [I : {C,I} in zip(List,1..List.length), C==1].
   

%
% generate a random problem of size N.
%
generate_problem(N, Graph) =>
   writeln($generate_problem(N)),

   Graph1 = new_array(N,N),
   Graph1 :: 0..1,
   _ = random2(),
   foreach(I in 1..N, J in 1..N)
       % Graph1[I,J] = random() mod 2
       Graph1[I,J] = random() mod 2
   end,
   Graph = Graph1.to_list().

%
% clique(Graph,Clique,Cardinality,Type)
%
clique(G, Clique, Card, Type) =>
   % G = new_array(NumNodes,NumNodes),
   NumNodes = G.length,

   % The clique found, here represented as a boolean list
   CliqueBool = new_list(NumNodes),
   CliqueBool :: 0..1,
   
   % cardinality of the clique
   Card #= sum(CliqueBool),
   Card #> 0,

   % check the cliques in G
   check_cliques(G,CliqueBool),
   % Either search for all cliques or a clique with 
   % maximum cardinality.
   Vars = CliqueBool ++ Card,
   if Type == all ; ground(Card) then
       solve([constr], Vars)
   else
       solve([constr,$max(Card)],Vars)
   end,
   % for the result as set representation in Clique
   boolean_to_set(CliqueBool,Clique).


%
% This is kind of backward but it is the whole thing:
% If there is a connection between nodes I and J (I \= J) then
% there should be a node from I to J in G.
%
check_cliques(G, CliqueBool) =>
   Len = length(CliqueBool),
   foreach({C1,I} in zip(CliqueBool,1..Len), {C2,J} in zip(CliqueBool,1..Len))
      if I =\= J, matrix_element(G,I,J,0) then
          #~C1 #\/ #~C2
      end
   end.



% This is slower than check_cliques/2
check_cliques2(G, CliqueBool) =>
   Len = length(CliqueBool),
   foreach(I in 1..Len, J in 1..Len)
      if I =\= J then
          matrix_element(G,I,J,GIJ),
         (CliqueBool[I] #= 1 #/\ CliqueBool[J] #= 1) #=> GIJ #> 0
      end
    end.

% This is faster than check_cliques2/2 but slower than check_cliques/2.
check_cliques3(G, CliqueBool) =>
   Len = length(CliqueBool),
   foreach(I in 1..Len, J in 1..Len)
      if I =\= J then
         matrix_element(G,I,J,Z),
         Z #= #=>
             (CI #= CliqueBool[I],
             CJ #= CliqueBool[J],
             #~CI #\/ #~CJ)
      end
   end.




% Pretty print the graph.
pretty_print(X) =>
   foreach(Row in X)
      foreach(R in Row)
          printf("%2d",R)
      end,
       nl
    end.



% matrix_element
matrix_element(X, I, J, Val) =>
  % element(I, X, Row),
  Row = X[I],
  element(J, Row, Val).

% matrix_element(X, I, J, Val) =>
%     freeze(I, (nth(I, X, Row),freeze(J,nth(J,Row,Val)))).

% matrix_element(X, I, J, Val) =>
%     freeze(I, (element(I, X, Row),freeze(J,element(J,Row,Val)))).

%
% Data
%


%
% Two cliques: (1,2,4) and (3, 5)
%
problem(1, M) => 
M = [[1, 1, 0, 1, 0],
       [1, 1, 0, 1, 0],
       [0, 0, 1, 0, 1],
       [1, 1, 0, 1, 0],
       [0, 0, 1, 0, 1]].


%
% A larger graph
% The cliques are 
%   1,2,3
%   4,5,6
%   6,7,8,9,10   
% (and their sub cliques)
%
problem(2, M) => 
  M = [[1, 1, 1, 0, 0, 0, 0, 1, 0, 0],
       [1, 1, 1, 0, 0, 0, 0, 0, 1, 0],
       [1, 1, 1, 0, 0, 0, 0, 0, 0, 1],
       [0, 1, 0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 1, 1, 1, 1],
       [0, 0, 1, 0, 0, 1, 1, 1, 1, 1],
       [1, 0, 0, 0, 0, 1, 1, 1, 1, 1],
       [0, 0, 0, 0, 1, 1, 1, 1, 1, 1],
       [0, 1, 0, 0, 0, 1, 1, 1, 1, 1]].
       

% The graph from the Global Constraint catalogue (the example above)
% 
% 1 -> 2,4
% 2 -> 1,3,5
% 3 -> 2,5
% 4 -> 1,5
% 5 -> 2,3,4
%   
% The found clique (N=3) is {2,3,5}.
%
problem(3,M) =>
  M = [[1,1,0,1,0],
       [1,1,1,0,1],
       [0,1,1,0,1],
       [1,0,0,1,1],
       [0,1,1,1,1]].


%
% A random graph of size 100 (generated by another program).
% There are 3515 clique of size >= 3 (including sub cliques], 
% and four of size 6.
%
problem(4, M) => 
M = 
[[0,0,1,0,1,0,1,0,0,1,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,0,0,1,1,1,0,0,0,1,1,1,1,1],
[1,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,1,0,1],
[1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,0,1,1,0,0,0,1,1],
[0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,1,0,1,0,0,1,1,1,1,1,0,1,1,1,0,0,0,1,1,1,0,1,1,1,0,1,0,1,1],
[1,0,0,0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0],
[1,0,1,1,0,0,1,1,1,1,1,0,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,1,1,0,1,1,0,0,1,1],
[1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,0,0,1,1,0,0],
[1,0,1,0,0,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,1],
[1,0,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1],
[0,1,0,1,0,1,1,1,1,0,0,1,0,1,0,1,1,0,0,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0],
[1,0,0,0,0,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,1,0,1,1,0,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0],
[0,0,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,0],
[1,1,0,0,0,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,1,1,1,0,0,1],
[1,1,1,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,0,0,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,0,0],
[0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0],
[1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0],
[1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,0,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,1,0],
[0,0,1,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0],
[1,1,1,1,0,0,0,1,1,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,0,1,0,1],
[1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,1],
[1,1,0,1,0,0,1,1,1,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1],
[1,1,1,1,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,0,1,0,0],
[1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,1,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1],
[1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,1,0,1,0,1,0,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0],
[1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,0,1,1,1,1,1,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,1,0,1,1],
[0,0,1,1,1,0,1,1,1,0,1,1,0,0,0,1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,1,0],
[1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1],
[1,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1],
[1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,1,1,0,0,0,1,1,1,0,1,1,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0,1,0,1],
[1,0,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1],
[0,0,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,1,0,0],
[0,0,1,1,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,1,0],
[0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1],
[0,1,1,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,1,0,0,1,1,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,1,0,1,1,0,1,1,1,1],
[0,1,0,1,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,1,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,0,1,1,1,0,0,0,0,0],
[1,0,0,0,1,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,0,0],
[0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,0,1,0,0,1,0,1,0,1,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1],
[0,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,1,0,0,0,0,1,1,0,0,1,1,1,0,0,0,0,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,0,1,1,1],
[1,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,0,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,1,0,1],
[0,0,1,0,0,0,1,1,0,1,1,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,0],
[1,0,0,1,0,0,0,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0],
[1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,1,0,1,1],
[0,0,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1],
[1,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,1,0,0,0,1,0,1,1,1,0,0,0,0,1,0,1,1,1,1,0,0,0,1,0,0,0,1],
[0,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0],
[0,0,1,1,0,1,0,1,1,1,0,1,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,1,0,0,0,1,0,1,1,0,0,1,0,0],
[0,1,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0,1,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0],
[1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,0,1,0,1,1,1],
[0,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,0,1,1,1],
[1,0,1,0,0,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,0,0,1,0],
[1,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,0,1,0,0,1,1,0,1,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1],
[1,1,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1],
[1,0,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,1,0],
[1,0,0,1,0,0,1,0,1,1,0,0,0,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,0,0],
[1,0,0,0,1,0,1,1,0,0,1,0,0,1,1,1,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1],
[1,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1],
[1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,1,0,1,1,1,0,1,0],
[1,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,0,1,0,0,1,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,1,0,0,1,1],
[1,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,1,0,0,1,0,0,0],
[1,0,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,0,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0],
[0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,1,0,0,0,0,1,0,1],
[0,1,1,0,0,1,1,1,1,0,0,0,1,1,1,0,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,0,1,0,1,1,0,0,0,1],
[1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,1,1,0,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,1,1,0,1,1,0,0,1,1,1,0],
[1,1,0,1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,1,1,0,1,0,1,1,1,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,0],
[1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,1,0,0,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,0,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,0,0,0,0],
[1,0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,0,0,1,0],
[1,0,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,0],
[0,0,0,0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,1,1,0,1,0,0,1,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,0,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,1,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,1,0,1,1,0,1,1,1,0],
[1,0,1,0,0,1,0,0,0,1,0,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,1,1,1,1,0,0,1,0,1,0,0,1,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,1,0,0,0,1,1,1,1],
[1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,1,0,1,0,0,0,0,1],
[0,1,1,1,0,0,0,1,1,0,1,1,1,1,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,0,1,0,0,0,0,0,1],
[1,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,1,1,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,0,1,0,0,0,1,1,0,1,0],
[0,0,0,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,1,1,0,0,1,0,1,1,1],
[0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0],
[0,0,1,0,1,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1],
[0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,0],
[1,1,1,0,0,0,0,0,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,0,1,0,0,1,1,1,0],
[1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0],
[0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,1,0,0,1,1,1,0,1,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
[0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0],
[0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,0,1,1,0,1,0,0,0,1,1,0,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1],
[0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,1,1,1,0],
[1,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,0,1,0,1,0,1,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0],
[0,1,0,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,1,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,0,1,1,0],
[0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,1,0,1,0],
[1,1,1,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,0,1,0,0,0,1],
[1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,0,1,0,1,0,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,1,1],
[1,1,0,0,0,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,1,1,1,0,0,1,0,1,1,1,1,1,0,1,0,0,0,1,0,0,1,1,0],
[1,0,1,1,1,0,1,0,0,0,0,1,1,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,0,1,0,1,0,0,1,1,1],
[1,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,0,0,1,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,1,0],
[1,0,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0],
[0,1,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1],
[0,1,0,1,0,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,1,1,1,1,0,0,1,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,0,1,0,0,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,0,1,1,1],
[0,0,0,1,0,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,1,0,1,0,0,0,1,0,1,1,1,1,0,1,1,0,0,1,1,0,0,0,1,0,1,0,0,0,1],
[1,0,1,1,0,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,0,1,1,0,1,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,0,0],
[0,0,0,1,0,1,0,1,0,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,1,0,0,1,1,1,1],
[0,0,0,1,0,1,1,0,0,0,1,0,1,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,1,1],
[0,1,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,1,0,0,0,0],
[1,0,0,1,0,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0],
[1,0,1,0,0,0,0,0,1,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0]].




go =>
   N = 12,
   Sum = 21,
   P = 3, % number in each list to sum
   L = findall(Xs,$clock_triplet(N, P, Sum, Xs)),
   foreach(LL in L) writeln(LL) end,
   writef("Sum: %d Number of solutions: %d\n",Sum,L.length).


go2 =>
   N = 12,
   % Sum = 21,
   % checks if 21 really is the smallest number...
   Sum :: 2..30,
   indomain(Sum),

   P = 3, % number in each list to sum
   L = findall(Xs,$clock_triplet(N, P, Sum, Xs)),
   % writeln(L),
   % foreach(LL in L, writeln(LL)),
   writef("Sum: %d Number of solutions: %d\n",Sum,L.length),
   % Test the next number if no solution
   if L.length == 0 then fail end.


%
% This is slighly more general version where
% P is the length of the tuples to sum
% and N is the length of Xs (the numbers in the "clock")
%
clock_triplet(N, P, Sum, Xs) =>

   Xs = new_list(N),
   Xs :: 1..N,

   all_different(Xs),

   % symmetry breaking
   Xs[1] #= 1,
   Xs[2] #> Xs[N],

   foreach(I in 0..N)
      sum([XI1 : K in 0..P-1, I1 = 1+((I+K) mod N), XI1 = Xs[I1]]) #=< Sum
   end,

   solve(Xs).

%
% This is faster with the cp solver ( 0.0006s) compared to the sat solver (about 8s)
%
go =>
       
   % the different coin values
   Variables = [1,2,5,10,25,50],

   N = length(Variables),

   Xs = new_list(N),
   Xs :: 0..99,

   % total number of the coins used
   NumCoins :: 0..99,
   NumCoins #= sum(Xs),
   
   % This is the "main loop":
   % Checks that all changes from 1 to 99 can be made.
   % To be honest I have forgotten exactly how
   % the ECLiPSe solution looked like.
   % Here is one way.
   foreach(J in 1..99)
       Tmp = new_list(N),
       Tmp :: 0..99,
       scalar_product(Variables,Tmp,J),
       % Ensure that we don't use more coins than in X[I]
       foreach(I in 1..N) 
          Tmp[I] #=< Xs[I] 
       end
   end,

   solve($[min(NumCoins)], Xs),

   writeln(num_coins=NumCoins),
   writeln(x=Xs),
   nl.

% scalar_product(A, X, Product) => 
%    Product #= sum([A[I]*X[I] : I in 1..A.length]).

% increasing(List) =>
%    foreach(I in 2..List.length) List[I-1] #=< List[I] end.

do_coins(J,Xs,Variables,N) =>
   Tmp = new_list(N),
   Tmp :: 0..99,
   scalar_product(Variables,Tmp,J),
   foreach(I in 1..N) Tmp[I] #=< Xs[I] end.


%
% A related problem:
%
% Is there a set of coin denominations which make it possible to change 
% into 1..99 with less than 8 coins?
% 
% Answer: Yes, there is. For example the following configuration:
%
% num_coins:7
% variables:[1,2,3,6,12,25,50]
% x:[1,1,1,1,1,1,1]
% 
% Though, it come with a cost of using 7 different coin denominations.
%
% Also, we can see that there is a set with just 5 different 
% denominations for the 8 coin change. However, it requires that 
% more than one coin of some of the denominations
%
% This is done by comment this constraint:
%       NumCoins #=< 8,
%
% Result: 
%   num_coins:8
%   variables:[1,2,4,11,33]
%   x:[1,1,2,2,2]
%
% This problem is faster using the SAT solver (about 13.7s) compared to the cp solver (about 51.3s)
%
go2 =>
    nolog, 
    % Number of coin denominations
    % Note: It increases with each failure to
    %       solve the instance.
    % N :: 1..10,
    % indomain(N),
    member(N, 1..10),
    write(n=N),nl,

    % we assume that there are no coin of a denomination larger than 50.
    Variables = new_list(N),
    Variables :: 1..50,

    all_different(Variables),
    increasing_strict(Variables),

    Xs = new_list(N),
    Xs :: 1..2, % use either 1 or two coins

    % total number of the coins used
    % in the exchange

    % optimize over total number of coins
    NumCoins #= sum(Xs),

    foreach(J in 1..99) do_coins(J,Xs,Variables,N) end,

    % optimize over number of denominations
    % NumCoins #= sum([1 : _ in Xs]),
    
    % can we manage with less than 8 coins?
    NumCoins #< 8,

    % search
    % Vars = Xs ++ Variables,
    Vars = Variables ++ Xs,
    println(vars=Vars),
    solve([$min(NumCoins)],Vars),

    % output
    writeln(num_coins=NumCoins), 
    writeln(variables=Variables),
    writeln(x=Xs), nl, nl.

go =>
   N = 31,
   C = 14,
   time2($coins(N, C)).


pretty_print(X) =>
   foreach(I in 1..X.length)
      foreach(J in 1..X[1].length)
         writef("%d ", X[I,J])
      end,
      nl
   end.

% standard CLP(FD)
coins(N,C) =>
   
   X = new_array(N,N),
   X :: 0..1,

   % quadratic horizontal distance
   Sum #= sum([(X[I,J] * abs(I-J)*abs(I-J)) : I in 1..N, J in 1..N]),
   println(sum=Sum),

   foreach(I in 1..N)
     C #= sum([X[I,J] : J in 1..N]), % rows
     C #= sum([X[J,I] : J in 1..N])  % columns
   end,

   Vars = X.to_list() ++ [Sum],
   solve($[min(Sum),report(printf("Sum: %w\n", Sum)), min, updown],Vars),
   writeln(sum=Sum),
   pretty_print(X).

initial_state(Initial) => Initial = [h,h,t].

goal_state(Goal) ?=> writeln($goal_state1(Goal)), Goal = [h,h,h].
goal_state(Goal) => writeln($goal_state2(Goal)),Goal = [t,t,t].

% The three-coins problem formulated for the general planner.
% The three possible moves. Each changes one of the coins.
legal_move(From, Move, To) ?=> 
    From=[X,Y,Z],Move=flip_left,To=[X1,Y,Z],
    opposite(X,X1).
legal_move(From, Move, To) ?=> 
    From=[X,Y,Z],Move=flip_middle,To=[X,Y1,Z], 
    opposite(Y,Y1).
legal_move(From, Move, To) =>   
    From=[X,Y,Z],Move=flip_right,To=[X,Y,Z1],
    opposite(Z,Z1).

opposite(H,T) ?=> H=h,T=t.                   % Flipping a head gives a tail.
opposite(T,H) => T=t,H=h.                   % Flipping a tail gives a head.


go => 
   L = new_list(50), % we have 50 coins
   L :: [1,5,10,25,50], % acceptable values
   sum(L) #= 100, % sums to a dollar
   increasing(L), % symmetry breaking
   All=solve_all(L),
   foreach(L2 in All) writeln(L2) end,
   nl.


go2 => 
   L = [One,Five,Ten,TwentyFive,Fifty], 
   L :: 0..100, 
   1*One+5*Five+10*Ten+25*TwentyFive+50*Fifty #= 100, % sums to a dollar
   One+Five+Ten+TwentyFive+Fifty #= 50, % fifty coins
   All = solve_all(L),
   foreach(L2 in All) writeln(L2) end,
   nl.


increasing(List) =>
   foreach(I in 2..List.length) List[I-1] #=< List[I] end.

% color/2
go =>
    time2(color_cp(125,5)).

% color_cp/2
go2 =>
    time2(color(125,5)).

% color2/1
go3 =>
    time2(color2(5)).

% random instances
go4 =>
  N = 100,
  Pct = 7,
  Graph = generate(N,Pct),
  println(generated),
  time2(color3(Graph,A)),
  println(A),
  nl.


% CP: using labeling
color_cp(NV,NC) =>
    println((nv=NV,nc=NC)),
    A = new_list(NV),
    A :: 1..NC,
    foreach(I in 1..NV-1, J in I+1..NV)
       if edge(I,J); edge(J,I) then
          A[I] #!= A[J]
       end
    end,

    % symmetry breaking
    % foreach(I in 1..NC) 
    %   A[I] #<= I
    % end, 

    % solve([ffc,split], A), % 0.748s (0 backtracks)
    solve([ffc,updown], A), % 0.17s (29952 backtracks)
    println(A).


% for sat (no labeling)
color(NV,NC) =>
    A = new_list(NV),
    A :: 1..NC,
    foreach(I in 1..NV-1, J in I+1..NV)
       if edge(I,J); edge(J,I) then
          A[I] #!= A[J]
       end
    end,
    solve(A),
    println(A).

%
% This is a slightly different (and easier) problem instance, using
% the neighbour/2 data (110 nodes).
%
% Time: 0.004s/0 backtracks
%
color2(NC) =>
    AllNeighbors = findall([I,N], (neighbors(I,N))),
    A = new_list(AllNeighbors.length),
    A :: 1..NC,
    foreach([I,Neighbors] in AllNeighbors)
       foreach(J in Neighbors)
          A[I] #!= A[J]
       end
    end,
    solve(A),
    println(A).


% for random generated instances (go4/0)
color3(Graph, A) =>
  N = Graph.len,
  MaxDegree = max([len(Neighbours) : [_,Neighbours] in Graph]),

  A = new_list(N),
  A :: 1..MaxDegree+1,

  println(maxDegree=MaxDegree),

  MaxColor #= max(A),

  % symmetry breaking
  % foreach(I in 1..MaxDegree)
  %   A[I] #<= I
  % end,
  % value_precede_chain(1..MaxDegree+1, A),

  % Neqs = [],
  foreach([I,Neighbors] in Graph)
    foreach(J in Neighbors)
      A[I] #!= A[J]
      % , Neqs := Neqs ++ [A[I] #!= A[J]]
    end
  end,
  % value_precede_chain(1..MaxDegree+1, A),
  % neqs(Neqs),
  println(maxColor=MaxColor),

  solve($[constr,ff,split,min(MaxColor),report(printf("MaxColor: %d\n",MaxColor))], A).


%
% generate a list of neighbours
%
generate(NumNodes,Pct) = Graph =>
   Graph1 = new_array(NumNodes),
   foreach(I in 1..NumNodes)
      Neighbours = [],
      foreach(J in 1..NumNodes, I != J)
        Rand = (1+random() mod 100),
        if Rand <= Pct then
           Neighbours := Neighbours ++ [J]
        end
      end,
      if Neighbours == [] then
        Rand = 1 + random() mod NumNodes,
        while (Rand == I) Rand := 1 + random() mod NumNodes end,
        Neighbours := [Rand]
      end,
      Graph1[I] := [I,Neighbours]
   end,
   Graph = Graph1.to_list().


value_precede_chain(C, X) =>
  foreach(I in 2..C.length)
    value_precede(C[I-1], C[I], X)
  end.


% This definition is inspired by 
% MiniZinc definition value_precede_int.mzn
value_precede(S,T,X) =>
   XLen = X.length,
   B = new_list(XLen+1),
   B :: 0..1,
   foreach(I in 1..XLen)
     % Xis :: 0..1,
     Xis #= (X[I] #= S),
     (Xis #=> (B[I+1] #= 1))
     #/\ ((#~ Xis #= 1) #=> (B[I] #= B[I+1]))
     #/\ ((#~ B[I] #= 1) #=> (X[I] #!= T))
   end,
   B[1] #= 0.




%
% Instance from the B-Prolog model
% http://www.probp.com/cp_sat_lp/color.pl
% 125 nodes.
%
index(-,-)	
edge(1,17).
edge(17,1).
edge(1,25).
edge(25,1).
edge(1,27).
edge(27,1).
edge(1,39).
edge(39,1).
edge(1,45).
edge(45,1).
edge(1,62).
edge(62,1).
edge(1,70).
edge(70,1).
edge(1,77).
edge(77,1).
edge(1,93).
edge(93,1).
edge(1,95).
edge(95,1).
edge(1,96).
edge(96,1).
edge(1,103).
edge(103,1).
edge(1,108).
edge(108,1).
edge(1,125).
edge(125,1).
edge(2,6).
edge(6,2).
edge(2,16).
edge(16,2).
edge(2,18).
edge(18,2).
edge(2,30).
edge(30,2).
edge(2,49).
edge(49,2).
edge(2,51).
edge(51,2).
edge(2,52).
edge(52,2).
edge(2,78).
edge(78,2).
edge(2,82).
edge(82,2).
edge(2,109).
edge(109,2).
edge(3,5).
edge(5,3).
edge(3,6).
edge(6,3).
edge(3,15).
edge(15,3).
edge(3,20).
edge(20,3).
edge(3,24).
edge(24,3).
edge(3,28).
edge(28,3).
edge(3,40).
edge(40,3).
edge(3,42).
edge(42,3).
edge(3,71).
edge(71,3).
edge(3,79).
edge(79,3).
edge(3,80).
edge(80,3).
edge(3,86).
edge(86,3).
edge(3,94).
edge(94,3).
edge(3,101).
edge(101,3).
edge(3,102).
edge(102,3).
edge(3,125).
edge(125,3).
edge(4,15).
edge(15,4).
edge(4,37).
edge(37,4).
edge(4,52).
edge(52,4).
edge(4,63).
edge(63,4).
edge(4,66).
edge(66,4).
edge(4,70).
edge(70,4).
edge(4,97).
edge(97,4).
edge(4,112).
edge(112,4).
edge(4,122).
edge(122,4).
edge(5,18).
edge(18,5).
edge(5,20).
edge(20,5).
edge(5,27).
edge(27,5).
edge(5,29).
edge(29,5).
edge(5,37).
edge(37,5).
edge(5,39).
edge(39,5).
edge(5,56).
edge(56,5).
edge(5,73).
edge(73,5).
edge(5,74).
edge(74,5).
edge(5,76).
edge(76,5).
edge(5,87).
edge(87,5).
edge(5,88).
edge(88,5).
edge(5,105).
edge(105,5).
edge(5,115).
edge(115,5).
edge(5,124).
edge(124,5).
edge(6,15).
edge(15,6).
edge(6,35).
edge(35,6).
edge(6,59).
edge(59,6).
edge(6,61).
edge(61,6).
edge(6,68).
edge(68,6).
edge(6,77).
edge(77,6).
edge(6,81).
edge(81,6).
edge(6,99).
edge(99,6).
edge(6,102).
edge(102,6).
edge(6,104).
edge(104,6).
edge(6,113).
edge(113,6).
edge(6,120).
edge(120,6).
edge(7,36).
edge(36,7).
edge(7,58).
edge(58,7).
edge(7,60).
edge(60,7).
edge(7,61).
edge(61,7).
edge(7,66).
edge(66,7).
edge(7,70).
edge(70,7).
edge(7,90).
edge(90,7).
edge(7,95).
edge(95,7).
edge(7,104).
edge(104,7).
edge(7,125).
edge(125,7).
edge(8,23).
edge(23,8).
edge(8,24).
edge(24,8).
edge(8,26).
edge(26,8).
edge(8,65).
edge(65,8).
edge(8,70).
edge(70,8).
edge(8,102).
edge(102,8).
edge(8,103).
edge(103,8).
edge(8,115).
edge(115,8).
edge(8,116).
edge(116,8).
edge(8,117).
edge(117,8).
edge(9,21).
edge(21,9).
edge(9,41).
edge(41,9).
edge(9,43).
edge(43,9).
edge(9,56).
edge(56,9).
edge(9,93).
edge(93,9).
edge(9,113).
edge(113,9).
edge(10,12).
edge(12,10).
edge(10,49).
edge(49,10).
edge(10,55).
edge(55,10).
edge(10,58).
edge(58,10).
edge(10,68).
edge(68,10).
edge(10,72).
edge(72,10).
edge(10,76).
edge(76,10).
edge(10,99).
edge(99,10).
edge(10,111).
edge(111,10).
edge(10,119).
edge(119,10).
edge(11,20).
edge(20,11).
edge(11,27).
edge(27,11).
edge(11,30).
edge(30,11).
edge(11,38).
edge(38,11).
edge(11,57).
edge(57,11).
edge(11,67).
edge(67,11).
edge(11,68).
edge(68,11).
edge(11,71).
edge(71,11).
edge(11,75).
edge(75,11).
edge(11,77).
edge(77,11).
edge(11,86).
edge(86,11).
edge(11,112).
edge(112,11).
edge(11,123).
edge(123,11).
edge(11,124).
edge(124,11).
edge(12,20).
edge(20,12).
edge(12,47).
edge(47,12).
edge(12,55).
edge(55,12).
edge(12,64).
edge(64,12).
edge(12,69).
edge(69,12).
edge(12,70).
edge(70,12).
edge(12,86).
edge(86,12).
edge(12,90).
edge(90,12).
edge(12,101).
edge(101,12).
edge(12,112).
edge(112,12).
edge(13,27).
edge(27,13).
edge(13,28).
edge(28,13).
edge(13,31).
edge(31,13).
edge(13,41).
edge(41,13).
edge(13,44).
edge(44,13).
edge(13,48).
edge(48,13).
edge(13,54).
edge(54,13).
edge(13,62).
edge(62,13).
edge(13,65).
edge(65,13).
edge(13,67).
edge(67,13).
edge(13,70).
edge(70,13).
edge(13,87).
edge(87,13).
edge(13,118).
edge(118,13).
edge(13,122).
edge(122,13).
edge(14,46).
edge(46,14).
edge(14,48).
edge(48,14).
edge(14,54).
edge(54,14).
edge(14,62).
edge(62,14).
edge(14,72).
edge(72,14).
edge(14,75).
edge(75,14).
edge(14,76).
edge(76,14).
edge(14,87).
edge(87,14).
edge(14,89).
edge(89,14).
edge(14,104).
edge(104,14).
edge(14,105).
edge(105,14).
edge(14,114).
edge(114,14).
edge(14,123).
edge(123,14).
edge(15,40).
edge(40,15).
edge(15,53).
edge(53,15).
edge(15,68).
edge(68,15).
edge(15,81).
edge(81,15).
edge(15,83).
edge(83,15).
edge(15,90).
edge(90,15).
edge(15,96).
edge(96,15).
edge(15,99).
edge(99,15).
edge(15,106).
edge(106,15).
edge(15,118).
edge(118,15).
edge(16,31).
edge(31,16).
edge(16,35).
edge(35,16).
edge(16,37).
edge(37,16).
edge(16,49).
edge(49,16).
edge(16,66).
edge(66,16).
edge(16,67).
edge(67,16).
edge(16,71).
edge(71,16).
edge(16,80).
edge(80,16).
edge(16,89).
edge(89,16).
edge(16,102).
edge(102,16).
edge(16,120).
edge(120,16).
edge(17,28).
edge(28,17).
edge(17,29).
edge(29,17).
edge(17,45).
edge(45,17).
edge(17,49).
edge(49,17).
edge(17,81).
edge(81,17).
edge(17,84).
edge(84,17).
edge(17,96).
edge(96,17).
edge(17,98).
edge(98,17).
edge(17,111).
edge(111,17).
edge(17,112).
edge(112,17).
edge(18,34).
edge(34,18).
edge(18,35).
edge(35,18).
edge(18,49).
edge(49,18).
edge(18,71).
edge(71,18).
edge(18,78).
edge(78,18).
edge(18,81).
edge(81,18).
edge(18,86).
edge(86,18).
edge(18,98).
edge(98,18).
edge(18,99).
edge(99,18).
edge(18,119).
edge(119,18).
edge(18,123).
edge(123,18).
edge(19,36).
edge(36,19).
edge(19,46).
edge(46,19).
edge(19,48).
edge(48,19).
edge(19,61).
edge(61,19).
edge(19,64).
edge(64,19).
edge(19,77).
edge(77,19).
edge(19,78).
edge(78,19).
edge(19,97).
edge(97,19).
edge(19,102).
edge(102,19).
edge(19,103).
edge(103,19).
edge(19,107).
edge(107,19).
edge(19,108).
edge(108,19).
edge(19,118).
edge(118,19).
edge(20,60).
edge(60,20).
edge(20,70).
edge(70,20).
edge(20,71).
edge(71,20).
edge(20,74).
edge(74,20).
edge(20,76).
edge(76,20).
edge(20,94).
edge(94,20).
edge(20,114).
edge(114,20).
edge(20,124).
edge(124,20).
edge(21,25).
edge(25,21).
edge(21,26).
edge(26,21).
edge(21,31).
edge(31,21).
edge(21,33).
edge(33,21).
edge(21,34).
edge(34,21).
edge(21,47).
edge(47,21).
edge(21,80).
edge(80,21).
edge(21,90).
edge(90,21).
edge(21,103).
edge(103,21).
edge(21,119).
edge(119,21).
edge(22,33).
edge(33,22).
edge(22,51).
edge(51,22).
edge(22,58).
edge(58,22).
edge(22,60).
edge(60,22).
edge(22,83).
edge(83,22).
edge(22,90).
edge(90,22).
edge(22,99).
edge(99,22).
edge(22,108).
edge(108,22).
edge(22,119).
edge(119,22).
edge(22,121).
edge(121,22).
edge(22,122).
edge(122,22).
edge(23,27).
edge(27,23).
edge(23,34).
edge(34,23).
edge(23,42).
edge(42,23).
edge(23,46).
edge(46,23).
edge(23,50).
edge(50,23).
edge(23,59).
edge(59,23).
edge(23,74).
edge(74,23).
edge(23,90).
edge(90,23).
edge(23,110).
edge(110,23).
edge(23,121).
edge(121,23).
edge(24,28).
edge(28,24).
edge(24,31).
edge(31,24).
edge(24,43).
edge(43,24).
edge(24,44).
edge(44,24).
edge(24,48).
edge(48,24).
edge(24,52).
edge(52,24).
edge(24,55).
edge(55,24).
edge(24,57).
edge(57,24).
edge(24,97).
edge(97,24).
edge(24,99).
edge(99,24).
edge(24,101).
edge(101,24).
edge(24,102).
edge(102,24).
edge(24,109).
edge(109,24).
edge(24,112).
edge(112,24).
edge(24,125).
edge(125,24).
edge(25,36).
edge(36,25).
edge(25,37).
edge(37,25).
edge(25,41).
edge(41,25).
edge(25,52).
edge(52,25).
edge(25,67).
edge(67,25).
edge(25,70).
edge(70,25).
edge(25,77).
edge(77,25).
edge(25,83).
edge(83,25).
edge(25,91).
edge(91,25).
edge(25,92).
edge(92,25).
edge(25,93).
edge(93,25).
edge(25,100).
edge(100,25).
edge(25,114).
edge(114,25).
edge(25,125).
edge(125,25).
edge(26,48).
edge(48,26).
edge(26,51).
edge(51,26).
edge(26,75).
edge(75,26).
edge(26,92).
edge(92,26).
edge(26,95).
edge(95,26).
edge(26,109).
edge(109,26).
edge(26,112).
edge(112,26).
edge(26,113).
edge(113,26).
edge(26,114).
edge(114,26).
edge(27,28).
edge(28,27).
edge(27,30).
edge(30,27).
edge(27,53).
edge(53,27).
edge(27,81).
edge(81,27).
edge(27,82).
edge(82,27).
edge(27,88).
edge(88,27).
edge(27,92).
edge(92,27).
edge(27,103).
edge(103,27).
edge(27,108).
edge(108,27).
edge(27,113).
edge(113,27).
edge(27,123).
edge(123,27).
edge(28,33).
edge(33,28).
edge(28,34).
edge(34,28).
edge(28,52).
edge(52,28).
edge(28,62).
edge(62,28).
edge(28,63).
edge(63,28).
edge(28,74).
edge(74,28).
edge(28,77).
edge(77,28).
edge(28,89).
edge(89,28).
edge(28,93).
edge(93,28).
edge(28,95).
edge(95,28).
edge(29,30).
edge(30,29).
edge(29,39).
edge(39,29).
edge(29,43).
edge(43,29).
edge(29,51).
edge(51,29).
edge(29,92).
edge(92,29).
edge(29,97).
edge(97,29).
edge(29,108).
edge(108,29).
edge(30,36).
edge(36,30).
edge(30,45).
edge(45,30).
edge(30,53).
edge(53,30).
edge(30,54).
edge(54,30).
edge(30,67).
edge(67,30).
edge(30,92).
edge(92,30).
edge(30,105).
edge(105,30).
edge(30,106).
edge(106,30).
edge(30,114).
edge(114,30).
edge(30,118).
edge(118,30).
edge(31,36).
edge(36,31).
edge(31,44).
edge(44,31).
edge(31,51).
edge(51,31).
edge(31,55).
edge(55,31).
edge(31,65).
edge(65,31).
edge(31,69).
edge(69,31).
edge(31,70).
edge(70,31).
edge(31,86).
edge(86,31).
edge(31,87).
edge(87,31).
edge(31,121).
edge(121,31).
edge(32,33).
edge(33,32).
edge(32,84).
edge(84,32).
edge(32,85).
edge(85,32).
edge(32,113).
edge(113,32).
edge(33,35).
edge(35,33).
edge(33,46).
edge(46,33).
edge(33,72).
edge(72,33).
edge(33,82).
edge(82,33).
edge(33,86).
edge(86,33).
edge(33,88).
edge(88,33).
edge(33,91).
edge(91,33).
edge(33,96).
edge(96,33).
edge(33,97).
edge(97,33).
edge(34,40).
edge(40,34).
edge(34,50).
edge(50,34).
edge(34,55).
edge(55,34).
edge(34,57).
edge(57,34).
edge(34,62).
edge(62,34).
edge(34,76).
edge(76,34).
edge(34,91).
edge(91,34).
edge(34,112).
edge(112,34).
edge(35,43).
edge(43,35).
edge(35,71).
edge(71,35).
edge(35,81).
edge(81,35).
edge(35,94).
edge(94,35).
edge(35,95).
edge(95,35).
edge(35,103).
edge(103,35).
edge(35,109).
edge(109,35).
edge(35,120).
edge(120,35).
edge(36,87).
edge(87,36).
edge(36,102).
edge(102,36).
edge(36,118).
edge(118,36).
edge(36,120).
edge(120,36).
edge(36,122).
edge(122,36).
edge(37,44).
edge(44,37).
edge(37,83).
edge(83,37).
edge(37,88).
edge(88,37).
edge(37,90).
edge(90,37).
edge(37,93).
edge(93,37).
edge(37,96).
edge(96,37).
edge(37,111).
edge(111,37).
edge(37,122).
edge(122,37).
edge(37,123).
edge(123,37).
edge(37,125).
edge(125,37).
edge(38,43).
edge(43,38).
edge(38,50).
edge(50,38).
edge(38,52).
edge(52,38).
edge(38,59).
edge(59,38).
edge(38,64).
edge(64,38).
edge(38,87).
edge(87,38).
edge(38,90).
edge(90,38).
edge(38,101).
edge(101,38).
edge(38,113).
edge(113,38).
edge(39,46).
edge(46,39).
edge(39,61).
edge(61,39).
edge(39,64).
edge(64,39).
edge(39,82).
edge(82,39).
edge(39,103).
edge(103,39).
edge(39,113).
edge(113,39).
edge(39,119).
edge(119,39).
edge(40,46).
edge(46,40).
edge(40,49).
edge(49,40).
edge(40,51).
edge(51,40).
edge(40,55).
edge(55,40).
edge(40,109).
edge(109,40).
edge(40,116).
edge(116,40).
edge(41,42).
edge(42,41).
edge(41,61).
edge(61,41).
edge(41,75).
edge(75,41).
edge(41,89).
edge(89,41).
edge(41,105).
edge(105,41).
edge(41,108).
edge(108,41).
edge(41,113).
edge(113,41).
edge(41,115).
edge(115,41).
edge(41,121).
edge(121,41).
edge(42,47).
edge(47,42).
edge(42,76).
edge(76,42).
edge(42,103).
edge(103,42).
edge(42,110).
edge(110,42).
edge(42,113).
edge(113,42).
edge(42,119).
edge(119,42).
edge(42,123).
edge(123,42).
edge(43,49).
edge(49,43).
edge(43,65).
edge(65,43).
edge(43,67).
edge(67,43).
edge(43,68).
edge(68,43).
edge(43,74).
edge(74,43).
edge(43,80).
edge(80,43).
edge(43,112).
edge(112,43).
edge(44,90).
edge(90,44).
edge(44,94).
edge(94,44).
edge(44,106).
edge(106,44).
edge(44,107).
edge(107,44).
edge(44,114).
edge(114,44).
edge(44,117).
edge(117,44).
edge(45,56).
edge(56,45).
edge(45,60).
edge(60,45).
edge(45,71).
edge(71,45).
edge(45,77).
edge(77,45).
edge(45,87).
edge(87,45).
edge(45,101).
edge(101,45).
edge(46,67).
edge(67,46).
edge(46,79).
edge(79,46).
edge(47,57).
edge(57,47).
edge(47,63).
edge(63,47).
edge(47,107).
edge(107,47).
edge(47,111).
edge(111,47).
edge(47,120).
edge(120,47).
edge(48,53).
edge(53,48).
edge(48,61).
edge(61,48).
edge(48,65).
edge(65,48).
edge(48,68).
edge(68,48).
edge(48,80).
edge(80,48).
edge(48,84).
edge(84,48).
edge(48,98).
edge(98,48).
edge(48,99).
edge(99,48).
edge(48,114).
edge(114,48).
edge(49,53).
edge(53,49).
edge(49,94).
edge(94,49).
edge(50,51).
edge(51,50).
edge(50,52).
edge(52,50).
edge(50,58).
edge(58,50).
edge(50,72).
edge(72,50).
edge(50,92).
edge(92,50).
edge(50,95).
edge(95,50).
edge(50,108).
edge(108,50).
edge(50,109).
edge(109,50).
edge(50,113).
edge(113,50).
edge(50,117).
edge(117,50).
edge(50,119).
edge(119,50).
edge(50,123).
edge(123,50).
edge(51,56).
edge(56,51).
edge(51,101).
edge(101,51).
edge(51,105).
edge(105,51).
edge(51,106).
edge(106,51).
edge(51,115).
edge(115,51).
edge(51,116).
edge(116,51).
edge(51,118).
edge(118,51).
edge(52,63).
edge(63,52).
edge(52,91).
edge(91,52).
edge(52,103).
edge(103,52).
edge(52,108).
edge(108,52).
edge(52,111).
edge(111,52).
edge(52,112).
edge(112,52).
edge(53,70).
edge(70,53).
edge(53,80).
edge(80,53).
edge(53,98).
edge(98,53).
edge(53,118).
edge(118,53).
edge(53,120).
edge(120,53).
edge(54,88).
edge(88,54).
edge(54,92).
edge(92,54).
edge(54,104).
edge(104,54).
edge(54,114).
edge(114,54).
edge(54,115).
edge(115,54).
edge(55,75).
edge(75,55).
edge(55,82).
edge(82,55).
edge(55,96).
edge(96,55).
edge(55,99).
edge(99,55).
edge(55,103).
edge(103,55).
edge(55,115).
edge(115,55).
edge(55,125).
edge(125,55).
edge(56,59).
edge(59,56).
edge(56,64).
edge(64,56).
edge(56,66).
edge(66,56).
edge(56,75).
edge(75,56).
edge(56,76).
edge(76,56).
edge(56,77).
edge(77,56).
edge(56,104).
edge(104,56).
edge(56,105).
edge(105,56).
edge(56,106).
edge(106,56).
edge(56,109).
edge(109,56).
edge(56,112).
edge(112,56).
edge(56,119).
edge(119,56).
edge(57,63).
edge(63,57).
edge(57,65).
edge(65,57).
edge(57,66).
edge(66,57).
edge(57,75).
edge(75,57).
edge(57,80).
edge(80,57).
edge(57,87).
edge(87,57).
edge(57,89).
edge(89,57).
edge(57,95).
edge(95,57).
edge(57,100).
edge(100,57).
edge(58,76).
edge(76,58).
edge(58,77).
edge(77,58).
edge(58,79).
edge(79,58).
edge(58,81).
edge(81,58).
edge(58,91).
edge(91,58).
edge(58,94).
edge(94,58).
edge(58,97).
edge(97,58).
edge(58,108).
edge(108,58).
edge(58,113).
edge(113,58).
edge(59,70).
edge(70,59).
edge(59,74).
edge(74,59).
edge(59,95).
edge(95,59).
edge(59,113).
edge(113,59).
edge(59,124).
edge(124,59).
edge(60,64).
edge(64,60).
edge(60,96).
edge(96,60).
edge(60,98).
edge(98,60).
edge(60,115).
edge(115,60).
edge(60,124).
edge(124,60).
edge(61,63).
edge(63,61).
edge(61,71).
edge(71,61).
edge(61,92).
edge(92,61).
edge(61,94).
edge(94,61).
edge(61,100).
edge(100,61).
edge(61,108).
edge(108,61).
edge(61,115).
edge(115,61).
edge(61,124).
edge(124,61).
edge(62,68).
edge(68,62).
edge(62,69).
edge(69,62).
edge(62,93).
edge(93,62).
edge(62,94).
edge(94,62).
edge(62,105).
edge(105,62).
edge(62,110).
edge(110,62).
edge(62,112).
edge(112,62).
edge(62,120).
edge(120,62).
edge(62,124).
edge(124,62).
edge(62,125).
edge(125,62).
edge(63,65).
edge(65,63).
edge(63,68).
edge(68,63).
edge(63,73).
edge(73,63).
edge(63,86).
edge(86,63).
edge(63,89).
edge(89,63).
edge(63,90).
edge(90,63).
edge(63,96).
edge(96,63).
edge(63,105).
edge(105,63).
edge(63,106).
edge(106,63).
edge(63,112).
edge(112,63).
edge(64,68).
edge(68,64).
edge(64,72).
edge(72,64).
edge(64,77).
edge(77,64).
edge(64,85).
edge(85,64).
edge(64,95).
edge(95,64).
edge(64,110).
edge(110,64).
edge(64,113).
edge(113,64).
edge(64,115).
edge(115,64).
edge(64,117).
edge(117,64).
edge(65,78).
edge(78,65).
edge(65,97).
edge(97,65).
edge(65,102).
edge(102,65).
edge(66,68).
edge(68,66).
edge(66,70).
edge(70,66).
edge(66,71).
edge(71,66).
edge(66,76).
edge(76,66).
edge(66,82).
edge(82,66).
edge(66,88).
edge(88,66).
edge(66,91).
edge(91,66).
edge(66,122).
edge(122,66).
edge(67,68).
edge(68,67).
edge(67,69).
edge(69,67).
edge(67,91).
edge(91,67).
edge(67,125).
edge(125,67).
edge(68,71).
edge(71,68).
edge(68,83).
edge(83,68).
edge(68,102).
edge(102,68).
edge(68,104).
edge(104,68).
edge(69,74).
edge(74,69).
edge(69,118).
edge(118,69).
edge(70,81).
edge(81,70).
edge(70,82).
edge(82,70).
edge(70,83).
edge(83,70).
edge(70,96).
edge(96,70).
edge(70,119).
edge(119,70).
edge(71,95).
edge(95,71).
edge(71,101).
edge(101,71).
edge(71,109).
edge(109,71).
edge(71,110).
edge(110,71).
edge(72,76).
edge(76,72).
edge(72,81).
edge(81,72).
edge(72,82).
edge(82,72).
edge(72,84).
edge(84,72).
edge(72,111).
edge(111,72).
edge(72,117).
edge(117,72).
edge(73,92).
edge(92,73).
edge(73,112).
edge(112,73).
edge(74,92).
edge(92,74).
edge(74,97).
edge(97,74).
edge(74,121).
edge(121,74).
edge(74,123).
edge(123,74).
edge(75,78).
edge(78,75).
edge(75,79).
edge(79,75).
edge(75,86).
edge(86,75).
edge(75,103).
edge(103,75).
edge(75,104).
edge(104,75).
edge(75,107).
edge(107,75).
edge(75,110).
edge(110,75).
edge(75,120).
edge(120,75).
edge(76,80).
edge(80,76).
edge(76,93).
edge(93,76).
edge(76,102).
edge(102,76).
edge(76,103).
edge(103,76).
edge(76,109).
edge(109,76).
edge(77,78).
edge(78,77).
edge(77,85).
edge(85,77).
edge(77,88).
edge(88,77).
edge(77,106).
edge(106,77).
edge(77,107).
edge(107,77).
edge(77,116).
edge(116,77).
edge(77,120).
edge(120,77).
edge(78,81).
edge(81,78).
edge(78,101).
edge(101,78).
edge(78,107).
edge(107,78).
edge(79,88).
edge(88,79).
edge(79,99).
edge(99,79).
edge(79,119).
edge(119,79).
edge(80,88).
edge(88,80).
edge(80,93).
edge(93,80).
edge(80,103).
edge(103,80).
edge(80,113).
edge(113,80).
edge(80,124).
edge(124,80).
edge(81,83).
edge(83,81).
edge(81,92).
edge(92,81).
edge(81,101).
edge(101,81).
edge(81,104).
edge(104,81).
edge(81,114).
edge(114,81).
edge(82,97).
edge(97,82).
edge(82,103).
edge(103,82).
edge(82,120).
edge(120,82).
edge(83,96).
edge(96,83).
edge(83,112).
edge(112,83).
edge(83,121).
edge(121,83).
edge(84,108).
edge(108,84).
edge(84,112).
edge(112,84).
edge(85,95).
edge(95,85).
edge(85,109).
edge(109,85).
edge(85,114).
edge(114,85).
edge(85,117).
edge(117,85).
edge(85,118).
edge(118,85).
edge(85,121).
edge(121,85).
edge(86,91).
edge(91,86).
edge(86,106).
edge(106,86).
edge(87,118).
edge(118,87).
edge(88,90).
edge(90,88).
edge(88,92).
edge(92,88).
edge(88,96).
edge(96,88).
edge(88,101).
edge(101,88).
edge(88,103).
edge(103,88).
edge(88,105).
edge(105,88).
edge(88,118).
edge(118,88).
edge(88,122).
edge(122,88).
edge(89,97).
edge(97,89).
edge(89,98).
edge(98,89).
edge(89,99).
edge(99,89).
edge(89,108).
edge(108,89).
edge(90,96).
edge(96,90).
edge(90,98).
edge(98,90).
edge(90,110).
edge(110,90).
edge(90,125).
edge(125,90).
edge(91,95).
edge(95,91).
edge(91,105).
edge(105,91).
edge(91,109).
edge(109,91).
edge(91,116).
edge(116,91).
edge(91,124).
edge(124,91).
edge(92,93).
edge(93,92).
edge(92,98).
edge(98,92).
edge(92,101).
edge(101,92).
edge(92,102).
edge(102,92).
edge(92,107).
edge(107,92).
edge(92,123).
edge(123,92).
edge(93,102).
edge(102,93).
edge(93,115).
edge(115,93).
edge(93,117).
edge(117,93).
edge(93,118).
edge(118,93).
edge(94,95).
edge(95,94).
edge(94,114).
edge(114,94).
edge(94,121).
edge(121,94).
edge(95,102).
edge(102,95).
edge(95,115).
edge(115,95).
edge(95,117).
edge(117,95).
edge(96,97).
edge(97,96).
edge(96,101).
edge(101,96).
edge(96,112).
edge(112,96).
edge(96,115).
edge(115,96).
edge(97,98).
edge(98,97).
edge(97,100).
edge(100,97).
edge(97,102).
edge(102,97).
edge(97,123).
edge(123,97).
edge(98,110).
edge(110,98).
edge(99,101).
edge(101,99).
edge(99,113).
edge(113,99).
edge(99,119).
edge(119,99).
edge(100,112).
edge(112,100).
edge(100,125).
edge(125,100).
edge(101,102).
edge(102,101).
edge(101,123).
edge(123,101).
edge(101,124).
edge(124,101).
edge(102,104).
edge(104,102).
edge(102,107).
edge(107,102).
edge(102,114).
edge(114,102).
edge(102,122).
edge(122,102).
edge(102,123).
edge(123,102).
edge(103,109).
edge(109,103).
edge(103,112).
edge(112,103).
edge(103,125).
edge(125,103).
edge(104,118).
edge(118,104).
edge(104,121).
edge(121,104).
edge(105,109).
edge(109,105).
edge(105,116).
edge(116,105).
edge(105,123).
edge(123,105).
edge(106,107).
edge(107,106).
edge(106,116).
edge(116,106).
edge(107,108).
edge(108,107).
edge(107,120).
edge(120,107).
edge(109,112).
edge(112,109).
edge(109,114).
edge(114,109).
edge(109,123).
edge(123,109).
edge(110,111).
edge(111,110).
edge(110,113).
edge(113,110).
edge(110,121).
edge(121,110).
edge(111,115).
edge(115,111).
edge(111,117).
edge(117,111).
edge(111,124).
edge(124,111).
edge(112,117).
edge(117,112).
edge(113,116).
edge(116,113).
edge(114,124).
edge(124,114).
edge(115,117).
edge(117,115).
edge(115,118).
edge(118,115).
edge(115,120).
edge(120,115).
edge(115,122).
edge(122,115).
edge(115,125).
edge(125,115).
edge(117,122).
edge(122,117).
edge(118,124).
edge(124,118).
edge(119,123).
edge(123,119).
edge(120,122).
edge(122,120).
edge(121,125).
edge(125,121).
edge(122,125).
edge(125,122).

%
% From the B-Prolog program 
% examples/clpfd/color.pi
%
% (It's a slightly smaller instance than the one above: 110 nodes instead of 125 nodes)
%
index(-,-)
neighbors(1,[]).
neighbors(2,[1]).
neighbors(3,[1,2]).
neighbors(4,[1,3]).
neighbors(5,[1,4]).
neighbors(6,[1,5]).
neighbors(7,[1,6]).
neighbors(8,[1,7]).
neighbors(9,[1,8]).
neighbors(10,[1,9]).
neighbors(11,[1,10]).
neighbors(12,[2,3]).
neighbors(13,[3,4,12]).
neighbors(14,[4,5,13]).
neighbors(15,[5,6,14]).
neighbors(16,[6,7,15]).
neighbors(17,[7,8,16]).
neighbors(18,[8,9,17]).
neighbors(19,[9,10,18]).
neighbors(20,[1,10,11,19]).
neighbors(21,[12,13]).
neighbors(22,[13,14,21]).
neighbors(23,[14,15,22]).
neighbors(24,[15,16,23]).
neighbors(25,[16,17,24]).
neighbors(26,[17,18,25]).
neighbors(27,[18,19,26]).
neighbors(28,[19,20,27]).
neighbors(29,[21,22]).
neighbors(30,[22,23,29]).
neighbors(31,[23,24,30]).
neighbors(32,[24,25,31]).
neighbors(33,[25,26,32]).
neighbors(34,[26,27,33]).
neighbors(35,[27,28,34]).
neighbors(36,[29,30]).
neighbors(37,[30,31,36]).
neighbors(38,[31,32,37]).
neighbors(39,[32,33,38]).
neighbors(40,[33,34,39]).
neighbors(41,[34,35,40]).
neighbors(42,[36,37]).
neighbors(43,[37,38,42]).
neighbors(44,[38,39,43]).
neighbors(45,[39,40,44]).
neighbors(46,[40,41,45]).
neighbors(47,[42,43]).
neighbors(48,[43,44,47]).
neighbors(49,[44,45,48]).
neighbors(50,[45,46,49]).
neighbors(51,[47,48]).
neighbors(52,[48,49,51]).
neighbors(53,[49,50,52]).
neighbors(54,[51,52]).
neighbors(55,[52,53,54]).
neighbors(56,[54,55]).
neighbors(57,[2,12]).
neighbors(58,[12,21,57]).
neighbors(59,[21,29,58]).
neighbors(60,[29,36,59]).
neighbors(61,[36,42,60]).
neighbors(62,[42,47,61]).
neighbors(63,[47,51,62]).
neighbors(64,[51,54,63]).
neighbors(65,[54,56,64]).
neighbors(66,[55,56,65]).
neighbors(67,[53,55,66]).
neighbors(68,[50,53,67]).
neighbors(69,[46,50,68]).
neighbors(70,[41,46,69]).
neighbors(71,[35,41,70]).
neighbors(72,[28,35,71]).
neighbors(73,[1,20,28,72]).
neighbors(74,[64,65,66,67]).
neighbors(75,[63,64,74]).
neighbors(76,[67,68,74,75]).
neighbors(77,[62,63,75]).
neighbors(78,[75,76,77]).
neighbors(79,[68,69,76,78]).
neighbors(80,[61,62,77]).
neighbors(81,[77,78,80]).
neighbors(82,[78,79,81]).
neighbors(83,[69,70,79,82]).
neighbors(84,[60,61,80]).
neighbors(85,[80,81,84]).
neighbors(86,[81,82,85]).
neighbors(87,[82,83,86]).
neighbors(88,[70,71,83,87]).
neighbors(89,[59,60,84]).
neighbors(90,[84,85,89]).
neighbors(91,[85,86,90]).
neighbors(92,[86,87,91]).
neighbors(93,[87,88,92]).
neighbors(94,[71,72,88,93]).
neighbors(95,[58,59,89]).
neighbors(96,[89,90,95]).
neighbors(97,[90,91,96]).
neighbors(98,[91,92,97]).
neighbors(99,[92,93,98]).
neighbors(100,[93,94,99]).
neighbors(101,[72,73,94,100]).
neighbors(102,[2,57,58,95]).
neighbors(103,[2,95,96,102]).
neighbors(104,[2,96,97,103]).
neighbors(105,[2,97,98,104]).
neighbors(106,[2,98,99,105]).
neighbors(107,[99,100,106]).
neighbors(108,[100,101,107]).
neighbors(109,[1,73,101,108]).
neighbors(110,[1,2,106,107,108,109]).

go =>
   N = 3,
   K = 5,
   printf("comb1(3,5): %w\n", comb1(N,K)),
   printf("comb2(3,5): %w\n", comb2(N,K)),
   printf("comb3(3,5): %w\n", comb3(N,K)),

   L = [a,b,c,d,e],
   printf("comb4(%d,%w): %w\n",3,L,comb4(3,L)),

   All = allcomb(1..4),
   printf("allcomb(1..4)  : %w\n", All),

   PowerSet = power_set(1..7),
   printf("power_set(1..7): %w\n", PowerSet.sort()),

   nl.


go2 => 
   printf("\nNumber of different combinations in comb([0..15], 15):\n"),
   foreach(K in 0..15) 
     printf("#comb1(%2d,15): %w\n", K, comb1(K,15).length)
   end,
   nl.


% comb1
comb1(K, N) = Comb =>
   Comb = sort([[J : J in I] : I in power_set(1..N), I.length == K]).


% comb2, using conditions in Head
comb2b(M, _X) = [[]], M = 0  => true.
comb2b(_M, X) =   [], X = [] => true.
comb2b(M, X)  = T =>
   X2 = [X[I] : I in 2..X.length],
   T = [ [X[1]] ++ Xs : Xs in comb2b(M-1, X2) ] ++ comb2b(M, X2).

comb2(M,N) = comb2b(M,1..N).


% comb3, more Prolog like
comb3b(0, _X)     = [[]].
comb3b(_M, [])    = [].
comb3b(M, [X|Xs]) = [ [X] ++ Xs2 : Xs2 in comb3b(M-1, Xs) ] ++ comb3b(M, Xs).

comb3(M,N) = comb3b(M, 1..N).


% comb4: combinations from a list
comb4(M, List) = T =>
   T = [ [List[P[I]] : I in 1..P.length] : P in comb1(M,List.length)].

% cf power_set above. The difference is in the ordering of the sets
allcomb(List) = L => 
   L = [],
   foreach(N in 0..List.length)
     L := L ++ comb4(N, List)
   end.


% sublist(S1, S2):
%    succeeds if S2 is a sublist of S
% (nondet.)
sublist(S1,S2) =>
    append(_, S, S1), append(S2, _, S).

go =>
   problem(1,NumItems,NumBids,Packages,Bids),
   % problem(2,NumItems,NumBids,Packages,Bids),

   % decision variables
   X = new_list(NumBids),
   X :: 0..1,

   Total #= sum([X[I]*Bids[I] : I in 1..NumBids]),

   % ensure that each items is selected atmost once
   foreach(J in 1..NumItems)
      sum([X[I] : I in 1..NumBids, member(J, Packages[I])]) #=< 1
   end,

   solve([$max(Total)], X),

   writeln(total=Total),
   writeln(x=X),
   nl.

% The example cited above
problem(1,NumItems,NumBids,Packages,Bids) => 
  NumItems = 7,
  NumBids = 5,
  Packages = 
    [[1,2,3,4],
     [2,3,6],
     [1,4,5],
     [2,7],
     [5,6]],
   Bids = [8,6,5,2,2].


%%
%% From Numberjack Tutorial, page 24 (slide 51/175)
%%
problem(2,NumItems,NumBids,Packages,Bids) => 
  NumItems = 4,
  NumBids = 5,
  Packages = 
      [[1,2],
       [1,3],
       [2,4],
       [2,3,4],
       [1]],
   Bids = [8,6,5,2,2].

go =>
   L = findall([ph=PH, pa=Pa, pl=Pl, el=El, ca=Ca, ma=Ma], 
      $contracting_costs([PH, Pa, Pl, El, Ca, Ma])),
   writeln(L),
   nl.

contracting_costs(LD) =>
   LD = [PH, Pa, Pl, El, Ca, Ma],
   LD :: 1..5300,

   1100 #= PH + Pa,
   1700 #= Pa + Pl,
   1100 #= Pl + El,
   3300 #= El + Ca,
   5300 #= Ca + Ma,
   3200 #= Ma + Pa,

   solve([], LD).

go => 
   Rows = 30,
   Cols = 30,
   Names = [blinker, p4, p5, glider, figure_eight], 
   foreach(Name in Names )
     pattern(Name, Pattern,I,J),
     writeln(Name),     
     life(fill(Rows,Cols,Pattern,I,J)),
     nl
   end,
   nl.

% random
go2 => 
    Rows = 20,
    Cols = 20,
    Grid = new_array(Rows,Cols),
    foreach(I in 1..Rows, J in 1..Cols) Grid[I,J] := random2() mod 2 end, 
    life(Grid),
    nl.

% larger example (to fit a Linux terminal)
go3 => 
    Rows = 52,
    Cols = 115,
    Grid = new_array(Rows,Cols),
    foreach(I in 1..Rows, J in 1..Cols) Grid[I,J] := random2() mod 2 end, 
    life(Grid).


fill(Rows, Cols, Obj) = fill(Rows, Cols, Obj,1,1).
fill(Rows, Cols, Obj,OffsetI,OffsetJ) = Grid =>
   Grid = new_array(Rows,Cols), bind_vars(Grid,0),
   foreach(I in 1..Obj.length, J in 1..Obj[1].length) 
     Grid[I+OffsetI-1,J+OffsetJ-1] := Obj[I,J]
   end.

% Note: we stop whenever a fixpoint/cycle is detected
life(S) => 
    Rows = S.length,
    Cols = S[1].length,
    writeln([rows=Rows, cols=Cols]),
    print_grid(S),
    Seen = new_map(), % detect fixpoint and cycle
    Count = 0,
    while (not Seen.has_key(S))
       Seen.put(S,1),
       T = new_array(Rows,Cols),
       foreach(I in 1..Rows, J in 1..Cols) 
           Sum = sum([S[I+A,J+B] : A in -1..1,B in -1..1, 
                                   I+A > 0, J+B > 0, 
                                   I+A =< Rows, J+B =< Cols]) - S[I,J],
           C = rules(S[I,J], Sum),
           T[I,J] := C
       end,
       print_grid(T),
       S := T,
       Count := Count + 1
    end,
    printf("%d generations\n", Count).


print_grid(G) => 
  foreach(I in 1..G.length) 
     foreach(J in 1..G[1].length) 
        if G[I,J] == 1 then print("#") else print(".") end
     end,
     nl
  end,
  nl.
   
rules(This,Sum) = 1, (This == 1, member(Sum,[2,3]); This == 0, Sum == 3) => true.
rules(_This, _Sum) = 0 => true.

%
% The patterns
%   pattern(Name, Pattern, OffsetI, OffsetJ)
% where Offset* is the recommended offsets in a
% grid.
% 
pattern(blinker, Pattern,I,J) ?=> 
   Pattern = [[0,0,0],
              [1,1,1],
              [0,0,0]],
   I=5,J=5.

pattern(p4, Pattern,I,J) ?=> 
   Pattern = [[0,0,0,0],
              [1,1,1,1],
              [1,1,1,1],
              [0,0,0,0]],
   I=10,J=10.

pattern(p5, Pattern,I,J) ?=> 
   Pattern = [[0,0,0,0,0],
              [1,1,1,1,1],
              [1,1,1,1,1],
              [1,1,1,1,1],
              [0,0,0,0,0]],
   I=10,J=10.


pattern(glider, Pattern,I,J) ?=> 
   Pattern = [[0,0,1],
              [1,0,1],
              [0,1,1]],
   I=5,J=5.

pattern(figure_eight, Pattern,I,J) =>
   Pattern = [[1,1,1,0,0,0],
              [1,1,1,0,0,0],
              [1,1,1,0,0,0],
              [0,0,0,1,1,1],
              [0,0,0,1,1,1],
              [0,0,0,1,1,1]],
   I=10,J=10.

go =>
   N = 8,
   L=findall(Costas,$costas(N,Costas,print)),
   Len=length(L),
   writeln(len=Len),
   nl.
     
go2 =>
   Seq1 = [],
   foreach(N in 2..10)
       writeln(n=N),
       L = findall(Costas,$costas(N,Costas,noprint)),
       Len = length(L),
       writeln(len=Len),
       Seq1 := Seq1 ++ [Len],
       nl
   end,
   Seq = Seq1,
   writeln(sequence=Seq),
   nl.
          


costas(N,Costas,Print) =>
   
   Costas = new_list(N),
   Costas :: 1..N,

   Differences = new_array(N,N),
   DiffVars = vars(Differences),
   DiffVars :: -N+1..N-1,
   
   %
   % hakank: Here are my two changes
   %
   % 1) I skipped this constraint since I want 
   %    to generate all solutions.
   % Costas[1] #< Costas[N],
   
   % 2) Fix the values in the lower triangle in the
   % difference matrix to -n+1. This removes variants 
   % of the difference matrix for the the same Costas array.
   foreach(I in 1..N, J in 1..I) Differences[I,J] #= -N+1 end,

   % hakank: All the following constraints are from 
   % Barry O'Sullivans's original MiniZinc model.
   all_different(Costas),

   % "How do the positions in the Costas array relate 
   %  to the elements of the distance triangle."
   foreach(I in 1..N, J in I+1..N)
      Differences[I,J] #= Costas[J] - Costas[J-I]
   end,

   % "All entries in a particular row of the difference 
   %  triangle must be distint."
   foreach(I in 1..N-1)
      all_different([Differences[I,J] : J in I+1..N])
   end,

   % "All the following are redundant - only here to speed up search."
   
   % "We can never place a 'token' in the same row as any other."
   foreach(I in 1..N, J in I+1..N)  Differences[I,J] #!= 0 end,

   foreach(K in 3..N, L in K+1..N)
      Differences[K-2,L-1] + Differences[K,L] #= 
      Differences[K-1,L-1] + Differences[K-1,L]
   end,
   
   Vars = Costas ++ DiffVars,
   solve(Vars),
   if Print = print then
       writeln(costas=Costas),
       foreach(I in 1..N)
           foreach(J in 1..N)
              D = Differences[I,J],
              if D > -N+1 then 
                 printf("%2d ",D)
              else 
                 printf(" ")
              end
            end,
            nl
        end,
        nl
   end.

go =>
   println(count_substrings("the three truths", "th")), % 3
   println(count_substrings("ababababab", "abab")),     % 2
   println(count_substrings("aaaaaaaaaaa", "aa")),      % 5
   println(count_substrings("aaaaaaaaaaa", "c")),       % 0
   nl.

go2 =>
   println("This is not correct but is included anyway...."),
   println(count_substrings2("the three truths", "th")), % 3
   println(count_substrings2("ababababab", "abab")),     % 2
   println(count_substrings2("aaaaaaaaaaa", "aa")),      % 5
   println(count_substrings2("aaaaaaaaaaa", "c")),       % 0
   nl.

count_substrings(S, SB) = C =>
   C1 = 0,
   I = 1,
   SLen = S.length,
   SBLen = SB.length,
   while (I < SLen, I+SBLen <= SLen)
     SS = [S[J] : J in I..I+SBLen-1],
     if SS == SB then
        C1 := C1 +1,
        I := I + SBLen
     else
        I := I+1
     end
   end,
   C = C1.


% Note: This use the built-in (and non-deterministric) predicate
%       find/4.
%       However, this is not correct - according to the specification of the
%       problem - since it count _all_ occurences, including all overlapping 
%       substrings.
%       It is included just for show.
%
count_substrings2(S, SB) = C => 
    L = findall([From,To], $find(S,SB,From,To)),
    writeln(L),
    C = L.length.

% 
go =>
  Problems = [[1*100, [25,10,5,1]],            % 1 dollar: 0.0s
              [100*100, [100,50,25,10,5,1]],   % 100 dollars: 0.007s
              [1000*100, [100,50,25,10,5,1]],  % 1000 dollars: 0.067s
              [10000*100, [100,50,25,10,5,1]], % 10000 dollars: 0.723s
              [100000*100, [100,50,25,10,5,1]] % 100000 dollars: 5.44s
              ],
  foreach([N,L] in Problems)
     initialize_table, % clear the tabling from previous run
     println([n=N,l=L]),
     time(println(coins(L, N, 1)))
  end.



go2 =>
  time(printf("changes($100,[25,10,5,1]): %w\n", coins_array(1*100,[25,10,5,1]))), % 0.0s
  time(printf("changes($1000,[100,50,25,10,5,1]): %w\n", coins_array(10*100,[100,50,25,10,5,1]))), % 0.017s
  time(printf("changes($10000,[100,50,25,10,5,1]): %w\n",  coins_array(100*100,[100,50,25,10,5,1]))), % 1.495s
  time(printf("changes($100000,[100,50,25,10,5,1]): %w\n", coins_array(1000*100,[1000,50,25,10,5,1]))). % 163.686s


% CP approach
% slower than go/0 and go2/0.
go3 => 
  garbage_collect(300_000_000),
  Problems = [[100, [1,5,10,25]], % 0.0s
              [1000, [1,5,10,25,50,100]]], % 0.96s
  foreach([N,L] in Problems)
     println([n=N,l=L]),
     time(changes_cp(L,N,Len)),
     println(Len),
     nl
  end.


% CP approach: using count_all/1
% Slightly faster than go3/0
go4 => 
  garbage_collect(300_000_000),
  Problems = [[1*100, [1,5,10,25]], % 0.0s
              [1000*100, [1,5,10,25,50,100]]], % 0.854s
  foreach([N,L] in Problems)
     println([n=N,l=L]),
     time(Count = count_all(changes_cp2(L,N))),
     println(Count),
     nl
  end.


% recursive approach using tabling
% (much faster with table)
table
coins(Coins, Money, M) = Sum =>
    Sum1 = 0,
    Len = Coins.length,
    if M == Len then
      Sum1 := 1
    else 
       foreach(I in M..Len)
         if Money - Coins[I] == 0 then
            Sum1 := Sum1 + 1
         end,
         if Money - Coins[I] > 0 then
            Sum1 := Sum1 + coins(Coins, Money-Coins[I], I)
         end
       end
    end,
    Sum = Sum1.

%
% array approach
%
coins_array(Amount, Coins) = Ret =>
  Ways = [0 : _I in 1..Amount+1],
  Ways[1] := 1,
  foreach(Coin in Coins, J in Coin..Amount)
     Ways[J+1] := Ways[J+1] + Ways[1+J-Coin]
  end,
  Ret = Ways[Amount+1].



changes_cp(L,N,NSols) => 
  Len = L.length,
  X = new_list(Len),
  X :: 0..N,
  % sum([L[I]*X[I] : I in 1..Len]) #= N,
  scalar_product(L,X,N),
  NSols=solve_all([degree,min],X).length.

changes_cp2(L,N) => 
  Len = L.length,
  X = new_list(Len),
  X :: 0..N,
  % sum([L[I]*X[I] : I in 1..Len]) #= N,
  scalar_product(L,X,N),
  solve([degree,min],X).

scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).

go =>
        NumWorkers = 32,

        % The workers qualified for the works
        Qualified = 
        [
            [  1,  9, 19, 22, 25, 28, 31 ],
            [  2, 12, 15, 19, 21, 23, 27, 29, 30, 31, 32 ],
            [  3, 10, 19, 24, 26, 30, 32 ],
            [  4, 21, 25, 28, 32 ],
            [  5, 11, 16, 22, 23, 27, 31 ],
            [  6, 20, 24, 26, 30, 32 ],
            [  7, 12, 17, 25, 30, 31 ] ,
            [  8, 17, 20, 22, 23  ],
            [  9, 13, 14, 26, 29, 30, 31 ],
            [ 10, 21, 25, 31, 32 ],
            [ 14, 15, 18, 23, 24, 27, 30, 32 ],
            [ 18, 19, 22, 24, 26, 29, 31 ],
            [ 11, 20, 25, 28, 30, 32 ],
            [ 16, 19, 23, 31 ],
            [  9, 18, 26, 28, 31, 32 ]
        ],
        
        NumTasks = length(Qualified),
        
        % cost per worker
        Cost = [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 
                3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9 ],


        % which workers to hire        
        Hire = new_list(NumWorkers),
        Hire :: 0..1,

        foreach(J in 1..NumTasks)
            QualifiedJ = Qualified[J],
            sum([Hire[W] : W in QualifiedJ ]) #>= 1
        end,

        scalar_product(Cost,Hire,TotalCost),

        % search
        Vars = Hire ++ [TotalCost],

        solve([$min(TotalCost), ff],Vars),

        writeln(total_cost=TotalCost),
        writeln(hire=Hire),
        get_solution(Hire, ToHire),
        writeln(to_hire=ToHire).


get_solution(List, Result) =>
        Result1 = [],
        foreach(I in 1..List.length)
            if List[I] #= 1 then Result1 := Result1 ++ [I] end
        end,
        Result = Result1.

module cp_utils.


% Different implementations of matrix_element(X,I,J,Val)
% to handle
%    Val = X[I,J]
% which is not available when I or J are CP-variables.
% 

matrix_element1(X, I, J, Val) =>
  element(I, X, Row),
  element(J, Row, Val).

matrix_element2(X, I, J, Val) =>
  nth(I, X, Row),
  element(J, Row, Val).

matrix_element3(X, I, J, Val) =>
     freeze(I, (nth(I, X, Row),freeze(J,nth(J,Row,Val)))).

matrix_element4(X, I, J, Val) =>
   freeze(I, (element(I, X, Row),freeze(J,element(J,Row,Val)))).

matrix_element5(X, I, J, Val) =>
  nth(I, X, Row),
  nth(J, Row, Val).

matrix_element6(X, I, J, Val) =>
   freeze(I, (nth(I, X, Row),freeze(J,element(J,Row,Val)))).

matrix_element7(X, I, J, Val) =>
 foreach (Row in 1..len(X), Col in 1..len(X[1]))
    (I #= Row #/\ J #= Col) #=> (Val #= X[Row,Col])
 end.


%
% converts a number Num to/from a list of integer List given a base Base
%
to_num(List, Base, Num) =>
        Len = length(List),
        Num #= sum([List[I]*Base**(Len-I) : I in 1..Len]).

%
% Ensure a Latin square, 
% i.e. all rows and all columns are different
%
latin_square(Board) =>
   foreach(Row in Board) all_different(Row) end,
   foreach(Column in transpose(Board)) all_different(Column) end.

%
% Ensure that List is increasing
%
% increasing(List) =>
%    foreach(I in 2..List.length) List[I-1] #=< List[I] end.

% increasing_strict(List) =>
%    foreach(I in 2..List.length) List[I-1] #< List[I] end.

% 
% Reified version of increasing
%
increasing_reif(L,B) =>
  (B #= 1) #<=> (sum([L[I-1] #> L[I] : I in 2..L.len]) #= 0).


%
% Ensure that values != 0 is increasing
%
increasing_except_0(List) =>
   Len = List.length,
   foreach(I in 1..Len, J in 1..Len, I < J) 
      (List[I] #!= 0 #/\ List[J] #!= 0) #=> List[I] #=< List[J] 
   end.


%
% Ensure that List is decreasing
%
% decreasing(List) =>
%    foreach(I in 2..List.length) List[I-1] #>= List[I] end.

% decreasing_strict(List) =>
%    foreach(I in 2..List.length) List[I-1] #> List[I] end.


%
% Ensure that values != 0 is decreasing
%
decreasing_except_0(List) =>
   Len = List.length,
   foreach(I in 1..Len, J in 1..Len, I < J) 
      (List[I] #!= 0 #/\ List[J] #!= 0) #=> List[I] #>= List[J] 
   end.

% 
% reified version of decreasing
%
decreasing_reif(L,B) =>
  (B #= 1) #<=> (sum([L[I-1] #< L[I] : I in 2..L.len]) #= 0).

% 
% All values in List are equal
%
all_equal(List) =>
  foreach(I in 2..List.len) List[I-1] #= List[I] end.

%
% Scalar product of the list A and X
%
% scalar_product(A, X, Product) => 
%    Product #= sum([A[I]*X[I] : I in 1..A.length]).

%
% scalar product of List A and X, with one of the relations: 
% 
%   #=, #<, #>, #<=, #>=, #!=
%
% scalar_product(A, X, Rel, Product) => 
%    scalar_product(A, X, P),
%    call(Rel,P,Product).


%%
%% Product = prod(List)
%%
%% returns the product of the numbers in List
%%
%% Note: This is now a built-in in Picat.
%
% prod(List, Product) =>
%    Product1 = 1, 
%    foreach(L in List)
%       % We must "taint" the variable to be a CP variable
%       Product1 := $Product1 * L
%    end,
%    Product #= Product1.


%
% Requires that all values in Xs != 0 must be distinct.
%
% Note: This is now a built-in predicate.
%
% alldifferent_except_0(Xs) =>
%   foreach(I in 1..Xs.length, J in 1..I-1)
%     (Xs[I] #!= 0 #/\ Xs[J] #!= 0) #=> (Xs[I] #!= Xs[J])
%    end.

% all_different_except_0(Xs) =>
%   foreach(I in 1..Xs.length, J in 1..I-1)
%      (Xs[I] #!= 0 #/\ Xs[J] #!= 0) #=> (Xs[I] #!= Xs[J])
%    end.

%
% reified version of all_different/1
%
all_different_reif(L,B) =>
  (B #= 1) #<=> (sum([L[I] #= L[J] : I in 2..L.len, J in 1..I-1]) #= 0).


%
% Ensure that the minumum value (> 0) is MinVal.
%
min_except_0(X,MinVal) =>
  Len = X.length,
  between(1,Len,I),
  MinVal #= X[I],
  foreach(J in 1..Len)
     MinVal #=< X[J] #\/ X[J] #= 0
  end,
  MinVal #> 0.


%
% nvalue(?N,?X)
%
% Requires that there are N distinct values in X.
%
% nvalue(N, X) =>
%   Len = length(X),
%   N #= sum([ (sum([ (X[J] #= I) : J in 1..Len]) #> 0) : I in 1..Len]).

nvalue(N, X) =>
   [Min, Max] = fd_min_max_array(X),
   N #= sum([ (sum([ (X[J] #= I) : J in 1..X.length]) #> 0) : I in Min..Max]).

% Get Min and Max for an array/list
fd_min_max_array(X) = [Min,Max] =>
   Max = fd_max(X[1]),
   Min = fd_min(X[1]),
   foreach(Y in X) 
      if fd_min(Y) < Min then Min = fd_min(Y) end,
      if fd_max(Y) > Max then Max = fd_max(Y) end
   end.
   

%
% nvalues(X,Op,N)
%
% Requires that the number of distinct values in the array X is 
%    Op N 
% where
% Op is either one of 
%   #=, #<m, #=<, #>=, #>
% (this is not checked though)    
%
nvalues(X, Op, N) =>
   nvalue(M,X),
   call(Op, M, N).

%
% global_cardinality(A, Gcc)
%
% This version is bidirectional but limited:
%
% Both A and Gcc are (plain) lists.
%  
% The list A can contain only values 1..Max (i.e. the length of Gcc).
% This means that the caller must know the max values of A.
% Or rather: if A contains another values they will not be counted.
% 
global_cardinality2(A, Gcc) =>
   Len = length(A),
   Max = length(Gcc),
   Gcc :: 0..Len,
   foreach(I in 1..Max) count(I,A,#=,Gcc[I]) end.



% Port of MiniZinc's lex2.mzn 
% """
%-----------------------------------------------------------------------------%
% Require adjacent rows and adjacent columns in the array 'x' to be
% lexicographically ordered.  Adjacent rows and adjacent columns may be equal.
%-----------------------------------------------------------------------------%
% """
% Note: This use lex_less/1.
lex2(X) =>
   Len = X[1].length,
   foreach(I in 2..X.length) 
      lex_less([X[I-1,J] : J in 1..Len], [X[I,J] : J in 1..Len])
   end.

% This use lex_lesseq/1
lex2eq(X) =>
   Len = X[1].length,
   foreach(I in 2..X.length) 
      lex_lesseq([X[I-1,J] : J in 1..Len], [X[I,J] : J in 1..Len])
   end.


% Port of MiniZinc's lex_less_int.mzn
% """
%-----------------------------------------------------------------------------%
% Requires that the array 'x' is strictly lexicographically less than array 'y'.
% Compares them from first to last element, regardless of indices
%-----------------------------------------------------------------------------%
% """
lex_less(X,Y) =>
   LX = 1,
   UX = X.length,
   LY = 1,
   UY = Y.length,
   Size = max(UX-LX,UY-LY),
   B = new_list(Size+2), % (Note: The MiniZinc version is 0-based.)
   B :: 0..1,
   B[1] #= 1,
   foreach(I in 1..Size+1) 
      B[I] #= ( X[I] #<= Y[I] #/\ (X[I] #< Y[I] #\/ B[I+1] #= 1) )
   end,
   B[Size + 2] #= (Size - 1 #< Size - 1).


% Port of MiniZinc's lex_lesseq_in.mzn
% """
%-----------------------------------------------------------------------------%
% Requires that the array 'x' is lexicographically less than or equal to
% array 'y'.  Compares them from first to last element, regardless of indices
%-----------------------------------------------------------------------------%
% """
lex_lesseq(X,Y) =>
   LX = 1,
   UX = X.length,
   LY = 1,
   UY = Y.length,
   Size = max(UX-LX,UY-LY),
   B = new_list(Size+2), % (Note: The MiniZinc version is 0-based.)
   B :: 0..1,
   B[1] #= 1,
   foreach(I in 1..Size+1) 
      B[I] #= ( X[I] #<= Y[I] #/\ (
                ((I #= Size) #=> 1)
                #/\ 
                ((I #< Size) #=> X[I] #< Y[I] #\/ B[I+1] #= 1) 
                )
              )
   end.


lex_greater(X,Y) => lex_less(Y,X).
lex_greatereq(X,Y) => lex_lesseq(Y,X).



%
% Alternative approach where we convert to two
% numbers and ensure that the first number is < second number.
%
lex_less2(X,Y,Base) =>
  to_num(X,Base,NumX),
  to_num(Y,Base,NumY),
  NumX #<= NumY.


%
% exactly(?N,?X,?V)
%
% Requires that exactly N variables in X takes the value V.
%
% exactly(N, X, V) =>
%   count(V,X,#=,N).

%
% atmost(?N,?X,?V)
%
% Requires that atmost N variables in X takes the value V.
%
% atmost(N,X,V) => 
%   count(V,X,#=<,N).

%
% atleast(?N,?X,?V)
%
% Requires that atleast N variables in X takes the value V.
%
% atleast(N,X,V) => 
%   count(V,X,#>=,N).


% The permutation from A <-> B using the permutation P
permutation3(A,P,B) =>
   foreach(I in 1..A.length)
       %  B[I] #= A[P[I]]
       PI #= P[I], 
       BI #= B[I], 
       element(PI, A, BI)
   end.


%
% knapsack: 
%  given Weights, Values and decision variable list Take
%  - ensure that the total weights <= WeightMax
%  - calculate the profit (which will be maximized)
%
knapsack(Weights, Values,Take, WeightMax,Profit) =>
   sum([W*T : {W,T} in zip(Weights, Take)]) #=< WeightMax,
   Profit #= sum([V*T : {V,T} in zip(Values,Take)]).


value_precede_chain(C, X) =>
  foreach(I in 2..C.length)
    value_precede(C[I-1], C[I], X)
  end.

% This definition is inspired by 
% MiniZinc definition value_precede_int.mzn
value_precede(S,T,X) =>
   XLen = X.length,
   B = new_list(XLen+1),
   B :: 0..1,
   foreach(I in 1..XLen)
     % Xis :: 0..1,
     Xis #= (X[I] #= S),
     (Xis #=> (B[I+1] #= 1))
     #/\ ((#~ Xis #= 1) #=> (B[I] #= B[I+1]))
     #/\ ((#~ B[I] #= 1) #=> (X[I] #!= T))
   end,
   B[1] #= 0.



%
% M1 x M2 = M3
%
% assume square matrices
%
% (not very efficient...)
%
matrix_multi_cp(M1,M2,M3) => 
   N = M1.length,
   Dim = 1..N,
   foreach(I in Dim, J in Dim)
      Zip = [T : {P,Q} in zip([M1[I,K] : K in Dim],[M2[L,J] : L in Dim]), T #= P*Q],
      M3[I,J] #= sum(Zip)
   end.


% assume square matrix
matrix_power_cp(M,M2) =>
   matrix_multi_cp(M,M,M2).


% chain(+List, +Relation)
% 
% Chain establishes the Relation constraint between each pair of adjacent 
% elements in List.
% 
% Example:
%   
%   L = new_list(3),
%   L :: 1..3,
%   chain(L,#>=),
%   All = solve_all(L).
% 
% ->
%  All = [[1,1,1],[2,1,1],[2,2,1],[2,2,2],[3,1,1],[3,2,1],[3,2,2],[3,3,1],[3,3,2],[3,3,3]]
%%
chain(L,Rel) => 
  foreach(I in 2..L.len)
    call(Rel,L[I-1],L[I])
  end.


%
% The sum of Seq numbers must be between Low and Up.
%
% Note: Seq must be instantiated, but neither Low or Up has
% to be (the result may be weird unless they are, though).
%
sliding_sum(Low, Up, Seq, Variables) =>
   foreach(I in 1..Variables.length-Seq+1)
      Sum #= sum([Variables[J] : J in I..I+Seq-1]),
      Sum #>= Low,
      Sum #=< Up
   end.

%
% The number of X's in a sequence of Seq numbers must be between Low and Up.
% Note: Seq must be instantiated, but neither Low or Up has
% to be (the result may be weird unless they are, though).
%
sliding_count(X,Low, Up, Seq, Variables) =>
   foreach(I in 1..Variables.length-Seq+1)
      Sum #= sum([Variables[J] #= X : J in I..I+Seq-1]),
      Sum #>= Low,
      Sum #=< Up
   end.

go =>
   crew.


scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).

% scalar product with relation
scalar_product(A, X, Rel, Product) => 
   scalar_product(A, X, P),
   call(Rel,P,Product).


crew =>

   attributes(Attributes),
   required(RequiredCrew),
   NumFlights = length(RequiredCrew),

   names(Names),
   NumPersons = length(Names),

   writef("Number of flights: %d Number of persons: %d\n",NumFlights,NumPersons),

   % split this table
   TotalRequired = [],
   Required = [],
   foreach(R in RequiredCrew)
      R = [Tot|Rest],
      TotalRequired := TotalRequired ++ [Tot],
      Required := Required ++ [Rest]
   end,

   % the crew schedule
   Crew = new_array(NumFlights, NumPersons).array_matrix_to_list_matrix(),
   CrewList = flatten(Crew),
   CrewList :: 0..1,

   % objective to (perhaps) minimize:
   % total number of persons working during these flights
   Z :: 0..NumPersons,
   Z #= sum([sum([Crew[F,P] : F in 1..NumFlights])#>0 : P in 1..NumPersons]),

   % calculate the persons for a specific flight
   % that has the proper requirements.
   % Also the number of persons for a flight.
   foreach(F in 1..NumFlights) 
      % size of crew
      sum([Crew[F,I] : I in 1..NumPersons]) #= RequiredCrew[F, 1],
      % attribute and requirements
      foreach(J in 1..5)
        sum([Attributes[I,J]*Crew[F,I] : I in 1..NumPersons]) #>=  RequiredCrew[F,J+1]
      end
   end,

   % after a flight, break for two flights, i.e.
   % for three consecutive flights there can be
   % work for max 1 of these flights.
   foreach(F in 1..NumFlights-2, I in 1..NumPersons)
      Crew[F,I] + Crew[F+1,I] + Crew[F+2,I] #<= 1
   end,

   % extra contraint: all persons (if at all) 
   % must work at least two times
   CrewTransposed = transpose(Crew),
   foreach(C1 in CrewTransposed) sum(C1) #>=2 #\/ sum(C1) #= 0 end,
   

   %
   % search
   % 
   Vars = CrewList ++ [Z],
   solve([], Vars),
   % optimization: This takes long time...
   % solve([$min(Z), ff], Vars),


   % 
   % Presentation of the solution
   %
   writef("Number of persons working (Z): %d\n", Z),
   foreach({Flight,C} in zip(1..NumFlights,Crew))
      printf("Flight %2d: %w (required: %d)\n", Flight, C, RequiredCrew[Flight,1])
   end,

   nl,
   writef("Persons working during the flights:\n"),
   foreach({I,Flight} in zip(1..NumFlights,Crew))
      Assign = [Name : {F,Name} in zip(Flight,Names), F == 1], 
      printf("Flight %2d: %w\n", I,Assign)
   end,
   
   writef("\nPersonell working at flights:\n"),

   foreach({P,Person} in zip(1..NumPersons, CrewTransposed))
      printf("Person %d (%w) Flights: %w\n",P,Names[P],boolean_to_set(Person))
   end,
   nl.
   

boolean_to_set(List) = Set =>
   Set = [I : {I,C} in zip(1..List.length, List), C #= 1].


% Require that all D consecutive numbers sums to =< Sum.
consecutive_sum_to_less_than(X,D,Sum) =>
   foreach(I in 1..X.length-D) sum([X[J] : J in I..I+D-1 ]) #=< Sum end.
   


attributes(A) => 
   % steward, hostess, french, spanish, german
A= [[1,0,0,0,1], % Tom     = 1
    [1,0,0,0,0], % David   = 2
    [1,0,0,0,1], % Jeremy  = 3
    [1,0,0,0,0], % Ron     = 4
    [1,0,0,1,0], % Joe     = 5
    [1,0,1,1,0], % Bill    = 6
    [1,0,0,1,0], % Fred    = 7
    [1,0,0,0,0], % Bob     = 8
    [1,0,0,1,1], % Mario   = 9
    [1,0,0,0,0], % Ed      = 10

    [0,1,0,0,0], % Carol   = 11
    [0,1,0,0,0], % Janet   = 12
    [0,1,0,0,0], % Tracy   = 13
    [0,1,0,1,1], % Marilyn = 14
    [0,1,0,0,0], % Carolyn = 15
    [0,1,0,0,0], % Cathy   = 16
    [0,1,1,1,1], % Inez    = 17
    [0,1,1,0,0], % Jean    = 18
    [0,1,0,1,1], % Heather = 19
    [0,1,1,0,0]  % Juliet  = 20
   ].


names(Names) => 
  Names = [
     'Tom',     % 1
     'David',   % 2
     'Jeremy',  % 3
     'Ron',     % 4
     'Joe',     % 5
     'Bill',    % 6 
     'Fred',    % 7
     'Bob',     % 8
     'Mario',   % 9
     'Ed',      % 10
     
     'Carol',   % 11
     'Janet',   % 12
     'Tracy',   % 13
     'Marilyn', % 14 
     'Carolyn', % 15 
     'Cathy',   % 16
     'Inez',    % 17
     'Jean',    % 18
     'Heather', % 19 
     'Juliet'   % 20
      ].


required(Required) =>  
  Required = 
   [[4, 1,1,1,1,1], % Flight 1
    [5, 1,1,1,1,1], % Flight 2
    [5, 1,1,1,1,1], % Flight 3
    [6, 2,2,1,1,1], % Flight 4
    [7, 3,3,1,1,1], % Flight 5
    [4, 1,1,1,1,1], % Flight 6
    [5, 1,1,1,1,1], % Flight 7
    [6, 1,1,1,1,1], % Flight 8
    [6, 2,2,1,1,1], % Flight 9
    [7, 3,3,1,1,1]  % Flight 10
   ].

go =>

   N = 20,
   List= [V1,V2,V3,V4,V5,V6,V7,V8,V9,V10,
          V11,V12,V13,V14,V15,V16,V17,V18,V19,V20],
   List :: 0..N,

   V1 :: [2,4,6,7,8,9,10,11,16,18,20],
   V2 :: [2,3,4,8,10,12,17,19,20],
   V3 :: [2,3,4,6,8,9,11,17,18],
   V4 :: [1,3,4,5,6,7,9,10,11,13,18],
   V5 :: [1,5,6,10,12,13,14,17,18,19,20],
   V6 :: [1,3,10,12,15,16,19,20],
   V7 :: [5,8,9,10,17],
   V8 :: [1,2,5,6,7,12,14,15,16,17],
   V9 :: [1,2,3,4,5,7,11,12,13,14,16,17,20],
   V10 :: [4,5,8,9,10,11,13,17,18,19,20],
   V11 :: [2,4,6,7,8,10,12,14,17,18,20],
   V12 :: [3,7,8,9,10,13,14,15,18,20],
   V13 :: [2,3,6,7,8,9,11,13,16,20],
   V14 :: [2,3,5,6,8,9,12,13,15,16,17,18],
   V15 :: [2,7,8,10,12,13,14,15,16,17,18,20],
   V16 :: [1,2,6,11,13,16,17,19,20],
   V17 :: [1,3,6,9,13,19],
   V18 :: [1,3,6,7,8,10,13,14,19],
   V19 :: [1,2,3,4,5,6,7,9,11,12,14,16,17,19,20],
   V20 :: [3,5,6,7,8,9,11,12,13,14,16,18,20],

   all_different(List),

   solve(List),

   writeln(List),
   nl.
    
go =>

   N = 9,

   % Domain = 0..9999, % the max length of the numbers in this problem is 4

   % The valid squares (or rather the invalid are marked as "x")
   Valid = 
    [[ _,  _,  _,  _,  x, _, _, _, _],
     [ _,  _,  x,  _,  _, _, x, _, _],
     [ _,  x,  _,  _,  x, _, _, x, _],
     [ _,  _,  _,  _,  x, _, _, _, _],
     [ x,  _,  x,  x,  x, x, x, _, x],
     [ _,  _,  _,  _,  x, _, _, _, _],
     [ _,  x,  -,  _,  x, _, _, x, _],
     [ _,  _,  x,  _,  _, _, x, _, _],
     [ _,  _,  _,  _,  x, _, _, _, _]],


   M = new_array(N,N),
   MVars = array_matrix_to_list(M),
   MVars :: 0..9,

   AList = [A1,A4,A7,A8,A9,A10,A11,A13,A15,A17,A20,A23,A24,A25,A27,A28,A29,A30],
   AList :: 0..9999,
   DList = [D1,D2,D3,D4,D5,D6,D10,D12,D14,D17,D18,D19,D20,D21,D22,D26,D28],
   DList :: 0..9999,

   % Set up the constraints between the matrix elements and the
   % clue numbers.
   across(M, A1, 4, 1, 1), 
   across(M, A4, 4, 1, 6), 
   across(M, A7, 2, 2, 1), 
   across(M, A8, 3, 2, 4), 
   across(M, A9, 2, 2, 8), 
   across(M, A10, 2, 3, 3), 
   across(M, A11, 2, 3, 6), 
   across(M, A13, 4, 4, 1), 
   across(M, A15, 4, 4, 6), 
   across(M, A17, 4, 6, 1), 
   across(M, A20, 4, 6, 6), 
   across(M, A23, 2, 7, 3), 
   across(M, A24, 2, 7, 6), 
   across(M, A25, 2, 8, 1), 
   across(M, A27, 3, 8, 4), 
   across(M, A28, 2, 8, 8), 
   across(M, A29, 4, 9, 1), 
   across(M, A30, 4, 9, 6), 

   down(M, D1, 4, 1, 1), 
   down(M, D2, 2, 1, 2), 
   down(M, D3, 4, 1, 4), 
   down(M, D4, 4, 1, 6), 
   down(M, D5, 2, 1, 8), 
   down(M, D6, 4, 1, 9), 
   down(M, D10, 2, 3, 3), 
   down(M, D12, 2, 3, 7), 
   down(M, D14, 3, 4, 2), 
   down(M, D16, 3, 4, 8), 
   down(M, D17, 4, 6, 1), 
   down(M, D18, 2, 6, 3), 
   down(M, D19, 4, 6, 4), 
   down(M, D20, 4, 6, 6), 
   down(M, D21, 2, 6, 7), 
   down(M, D22, 4, 6, 9), 
   down(M, D26, 2, 8, 2), 
   down(M, D28, 2, 8, 8), 

   
   % Set up the clue constraints.
   %  Across
   %  1 27 across times two
   %  4 4 down plus seventy-one
   %  7 18 down plus four
   %  8 6 down divided by sixteen
   %  9 2 down minus eighteen
   % 10 Dozen in six gross
   % 11 5 down minus seventy
   % 13 26 down times 23 across
   % 15 6 down minus 350
   % 17 25 across times 23 across
   % 20 A square number
   % 23 A prime number
   % 24 A square number
   % 25 20 across divided by seventeen
   % 27 6 down divided by four
   % 28 Four dozen
   % 29 Seven gross
   % 30 22 down plus 450 
   
   A1 #= 2 * A27,
   A4 #= D4 + 71,
   A7 #= D18 + 4,
   A8 #= D6 // 16,
   A9 #= D2 - 18,
   A10 #= 6 * 144 // 12,
   A11 #= D5 - 70,
   A13 #= D26 * A23,
   A15 #= D6 - 350,
   A17 #= A25 * A23,

   square(A20),
   is_prime(A23),
   square(A24),
   A25 #= A20 // 17,
   A27 #= D6 // 4,
   A28 #= 4 * 12,
   A29 #= 7 * 144,
   A30 #= D22 + 450,

   % Down
   %
   %  1 1 across plus twenty-seven
   %  2 Five dozen
   %  3 30 across plus 888
   %  4 Two times 17 across
   %  5 29 across divided by twelve
   %  6 28 across times 23 across
   % 10 10 across plus four
   % 12 Three times 24 across
   % 14 13 across divided by sixteen
   % 16 28 down times fifteen
   % 17 13 across minus 399
   % 18 29 across divided by eighteen
   % 19 22 down minus ninety-four
   % 20 20 across minus nine
   % 21 25 across minus fifty-two
   % 22 20 down times six
   % 26 Five times 24 across
   % 28 21 down plus twenty-seven 

   D1 #= A1 + 27,

   D2 #= 5 * 12,

   D3 #= A30 + 888,
   D4 #= 2 * A17,

   D5 #= A29 // 12,
   D6 #= A28 * A23,
   D10 #= A10 + 4,

   D12 #= A24 * 3,
   D14 #= A13 // 16,
   D16 #= 15 * D28,
   D17 #= A13 - 399,
   D18 #= A29 // 18,
   D19 #= D22 - 94,
   D20 #= A20 - 9,
   D21 #= A25 - 52,
   D22 #= 6 * D20,
   D26 #= 5 * A24,
   D28 #= D21 + 27,

   % Fix the black boxes
   foreach(I  in 1..N)
     foreach(J in 1..N)
        if Valid[I,J] == x then
          M[I,J] #= 0
        end
     end
   end,

   Vars = MVars ++ AList ++ DList,
   solve(Vars),

   foreach(I in 1..N) 
      foreach(J in 1..N) 
        if Valid[I,J] == x then
           printf(" ")
        else
           printf("%d", M[I,J])
        end
      end,
      nl
   end,
   nl.


      


     
across(Matrix, Across, Len, Row, Col) =>
   Tmp = new_list(Len),
   Tmp :: 0..9999,
   to_num(Tmp, Across),
   foreach(I in 0..Len-1)
      Matrix[Row,Col+I] #= Tmp[I+1]
   end.


down(Matrix, Down, Len, Row, Col) =>
   Tmp = new_list(Len),
   Tmp :: 0..9999,
   to_num(Tmp, Down),
   foreach(I in 0..Len-1)
      Matrix[Row+I,Col] #= Tmp[I+1]
   end.


is_prime(X) =>
   Max = fd_max(X),
   foreach(I in 2..Max // 2)
      I #!= X #=> X mod I #> 0
   end.

%
% x is a square
%
square(X) =>
   Max = fd_max(X),
   Tmp :: 0..Max,
   X #= Tmp**2.

to_num(List, Num) => 
  to_num(List, 10, Num).

to_num(List, Base, Num) =>
        Len = length(List),
        Num #= sum([List[I]*Base**(Len-I) : I in 1..Len]).

go =>
   overlapping(Overlappings),
   NumOverlappings = Overlappings.length,
   words(Words),
   NumWords = length(Words),

   ESize = 8,

   % decision variables
   E = new_list(ESize),
   E :: 1..NumWords,

   all_different(E),

   foreach(I in 1..NumOverlappings)
        % the overlappings
        O1 = Overlappings[I,1], % first word
        O2 = Overlappings[I,2], % position in first word
        O3 = Overlappings[I,3], % second word
        O4 = Overlappings[I,4], % position in second word

        % fetch the two E variables to use
        nth(O1,E,E1),
        nth(O3,E,E2), 

        % Get the words
        nth(E1,Words,Word1),
        nth(E2,Words,Word2),

        Word1 != Word2,

        % The same char in the overlapping.
        nth(O2,Word1,C),
        nth(O4,Word2,C)          
       
   end,
   
   solve(E),

   writeln(e=E),
   foreach(I in 1..ESize)
        Word = Words[E[I]],
        printf("%d (%d): ",I,E[I]),
        print_word(Word),
        writef("\n")
   end.




print_word(Word) =>
   foreach(W in Word)
      if ground(W) then
         printf("%w", W)
      end
   end.


%
% Definition of the words. A _ is used to fill the row.
%
words(Words) => 
   Words= [[h, o, s, e, s], %%  HOSES
           [l, a, s, e, r], %%  LASER
           [s, a, i, l, s], %%  SAILS
           [s, h, e, e, t], %%  SHEET
           [s, t, e, e, r], %%  STEER
           [h, e, e, l],    %%  HEEL
           [h, i, k, e],    %%  HIKE
           [k, e, e, l],    %%  KEEL
           [k, n, o, t],    %%  KNOT
           [l, i, n, e],    %%  LINE
           [a, f, t],       %%  AFT
           [a, l, e],       %%  ALE
           [e, e, l],       %%  EEL
           [l, e, e],       %%  LEE
           [t, i, e]].     %%  TIE


%
% Overlappings of the words
% As an array for easy acces 
%
overlapping(Overlapping) => 
    Overlapping =
              [[1, 3, 2, 1], 
               [1, 5, 3, 1], 
             
               [4, 2, 2, 3], 
               [4, 3, 5, 1], 
               [4, 4, 3, 3], 
               
               [7, 1, 2, 4], 
               [7, 2, 5, 2], 
               [7, 3, 3, 4], 
               
               [8, 1, 6, 2], 
               [8, 3, 2, 5], 
               [8, 4, 5, 3], 
               [8, 5, 3, 5]].  

go =>
  Size = 8,
  Piece = 4, % 1 - Queen, 2 - Bishop, 3 - Knight, 4 - Rook
  % S = 1..Size+4,
  P = 1..Piece+4,
  R = 3..Size+2,  % real part of board
  % Note: The Mosel model defines P only for 1..4 but is 1..8 here
  N = [8,14,21,8,0,0,0,0],
  
  % decision variables 
  X = new_array(Size+4,Size+4,Piece+4), 
  X :: 0..1,


   % for the output
   Res = new_array(Size,Size),
   Res :: 0..4,

   Z #= sum([X[I,J,K] : I in R, J in R, K in P]),

   foreach(K in P) 
        sum([X[I,J,K] : I in R, J in R]) #= N[K]
   end,

   foreach(I in R,J in R) 
      sum([X[I,J,K] : K in P]) #<= 1
   end,

   % No queens attack each other
 
   foreach(I in R)
        sum([X[I,J,1] : J in R])  #<= 1
   end,
  
   foreach(J in R)
        sum([X[I,J,1] : I in R])  #<= 1     
   end,

   foreach (I in 2..Size+3)
           sum([X[K,I-K+1,1] : K in 1..I])  #<= 1
   end,

   foreach(J in 1..Size+3)
        sum([X[K,Size+4-K+J,1] : K in J..Size+4])  #<= 1  
   end,

   foreach(J in 1..Size+3)
       sum([X[K,J+K-1,1] : K in 1..Size-J+5])  #<= 1
   end,

   foreach(I in 2..Size+3)
        sum([X[K,K-I+1,1] : K in I..Size+4])  #<= 1
   end,

   % No bishops attack each other
 
   foreach(I in 2..Size+3)
        sum([X[K,I-K+1,2] : K in 1..I])  #<= 1
   end,

   foreach(J in 1..Size+3)
        sum([X[K,Size+4-K+J,2] : K in J..Size+4])  #<= 1
   end, 

   foreach(J in 1..Size+3)
        sum([ X[K,J+K-1,2] : K in 1..Size-J+5]) #<= 1
   end,

   foreach(I in 2..Size+3)
        sum([X[K,K-I+1,2] : K in I..Size+4]) #<= 1
   end,

   % No rooks attack each other
   foreach(I in R)
        sum([X[I,J,4] : J in 3..Size+2]) #<= 1
   end,
   foreach(J in R)
        sum([X[I,J,4] : I in 3..Size+2])  #<= 1
   end,

   %  a(i,j,3] = 0 if square {i,i} attacked by knight 
 
   foreach(I in R,J in R)
        X[I-2,J-1,3] + X[I-1,J-2,3] + X[I+1,J-2,3] + X[I+2,J-1,3] + 
        X[I+2,J+1,3] + X[I+1,J+2,3] + X[I-1,J+2,3] + X[I-2,I+1,3] + 99*X[I,J,3] #<= 99
   end,


   % Dummy squares not occupied 
    sum([X[I,J,K] : I in 1..Size+4,J in 1..Size+4,K in 1..4, 
                      (I < 3; I > Size+2; J < 3; J > Size+2)])  #=  0,

   % calculate res (the output)
   foreach(I in 1..Size, J in 1..Size)
      Res[I,J] #= sum([K*X[I+2,J+2,K] : K in P]) 
   end,

   % Vars = X.to_list() ++ Res.to_list() ++ [Z],  % 63s with sat
   % Vars = Res.to_list() ++ [Z],  % 68s with sat
   % Vars = [Z] ++ Res.to_list(),  % 59.9s with sat
   % Vars = [Z] ++ X.to_list() ++ Res.to_list(),  % 57.8s with sat
   Vars = [Z] ++ Res.to_list(), % 56.2s with sat

   solve($[min(Z), $report(printf("z=%w\n", Z))], Vars),

   % writeln(x=X),
   writeln(z=Z),

   foreach(Row in Res) writeln(Row) end,

   nl.

go =>
        LD = [A,B,C,D,E,F,G,H,I,J],
        LD :: 0..9,
        Sr1 :: 0..1,
        Sr2 :: 0..1,

        B #>= 1,
        D #>= 1,
        G #>= 1,
        
        all_different(LD),           
        
           A+10*E+100*J+1000*B+10000*B+100000*E+1000000*F+
           E+10*J+100*E+1000*F+10000*G+100000*A+1000000*F
        #= F+10*E+100*E+1000*H+10000*I+100000*F+1000000*B+10000000*Sr1,
        
           C+10*F+100*H+1000*A+10000*I+100000*I+1000000*J+
           F+10*I+100*B+1000*D+10000*I+100000*D+1000000*C+Sr1
        #= J+10*F+100*A+1000*F+10000*H+100000*D+1000000*D+10000000*Sr2,
        
           A+10*J+100*J+1000*I+10000*A+100000*B+
           B+10*A+100*G+1000*F+10000*H+100000*D+Sr2
        #= C+10*A+100*G+1000*E+10000*J+100000*G,       
        
        solve(LD),
        
        writeln(LD).


% Prolog code
/**
 * Prolog code for the crypt riddle benchmark.
 *
 * This is problem 223 from:
 * Trigg, W. C. (1985): Mathematical Quickies,
 * Dover Publications, Inc., New York, 1985
 *
 * Copyright 2010, XLOG Technologies GmbH, Switzerland
 * Jekejeke Prolog 0.8.3 (a fast and small prolog interpreter)
 */
/*
sum2(AL, BL, CL) :-
      sum2(AL, BL, 0, CL).

sum2([A | AL], [B | BL], Carry, [C | CL]) :-
      X is (A + B + Carry),
      C is X rem 10,
      NewCarry is X // 10,
      sum2(AL, BL, NewCarry, CL).
sum2([], BL, 0, BL) :- !.
sum2(AL, [], 0, AL) :- !.
sum2([], [B | BL], Carry, [C | CL]) :-
      X is B + Carry,
      NewCarry is X // 10,
      C is X rem 10,
      sum2([], BL, NewCarry, CL).
sum2([A | AL], [], Carry, [C | CL]) :-
      X is A + Carry,
      NewCarry is X // 10,
      C is X rem 10,
      sum2([], AL, NewCarry, CL).
sum2([], [], Carry, [Carry]).

mult(AL, D, BL) :- mult(AL, D, 0, BL).

mult([], _, Carry, [C, Cend]) :-
      C is Carry rem 10,
      Cend is Carry // 10.
mult([A | AL], D, Carry, [B | BL] ) :-
      X is A * D + Carry,
      B is X rem 10,
      NewCarry is X // 10,
      mult(AL, D, NewCarry, BL).

zero([]).
zero([0 | L]) :- zero(L).

odd(1).
odd(3).
odd(5).
odd(7).
odd(9).

even(0).
even(2).
even(4).
even(6).
even(8).

lefteven(2).
lefteven(4).
lefteven(6).
lefteven(8).

crypt :-
      odd(A), even(B), even(C), even(E),
      mult([C, B, A], E, [I, H, G, F | X]),
      lefteven(F), odd(G), even(H), even(I), zero(X), lefteven(D),
      mult([C, B, A], D, [L, K, J | Y]),
      lefteven(J), odd(K), even(L), zero(Y),
      sum2([I, H, G, F], [0, L, K, J], [P, O, N, M | Z]),
      odd(M), odd(N), even(O), even(P), zero(Z).
*/


% Picat version
sum2(AL, BL, CL) =>
      sum2(AL, BL, 0, CL).

sum2([A | AL], BBL, Carry, CCL) =>
      BBL = [B | BL],
      CCL = [C | CL],
      X = (A + B + Carry),
      C = X rem 10,
      NewCarry = X // 10,
      sum2(AL, BL, NewCarry, CL).
sum2([], BL, 0, BL2) => BL2=BL.
sum2(AL, [], 0, AL2) => AL2=AL.
sum2([], BBL, Carry, CCL) =>
      BBL = [B | BL],
      CCL = [C | CL],
      X = B + Carry,
      NewCarry = X // 10,
      C = X rem 10,
      sum2([], BL, NewCarry, CL).
sum2(AAL, [], Carry, CCL) =>
      AAL=[A | AL],
      CCL=[C | CL],
      X = A + Carry,
      NewCarry = X // 10,
      C = X rem 10,
      sum2([], AL, NewCarry, CL).
sum2([], B, Carry, Carry2) => B=[], Carry2 = [Carry].

mult(AL, D, BL) => mult(AL, D, 0, BL).

mult([], _, Carry, CCendl) =>
      CCendl = [C, Cend],
      C = Carry rem 10,
      Cend = Carry // 10.
mult([A | AL], D, Carry, BBL) =>
      BBL = [B | BL],
      X = A * D + Carry,
      B = X rem 10,
      NewCarry = X // 10,
      mult(AL, D, NewCarry, BL).

table
zero([]) => true.
zero([0 | L]) => zero(L).

index(-)
oddx(1).
oddx(3).
oddx(5).
oddx(7).
oddx(9).

index(-)
evenx(0).
evenx(2).
evenx(4).
evenx(6).
evenx(8).

index(-)
leftevenx(2).
leftevenx(4).
leftevenx(6).
leftevenx(8).

crypt =>
      oddx(A), evenx(B), evenx(C), evenx(E),
      mult([C, B, A], E, [I, H, G, F | X]),
      leftevenx(F), oddx(G), evenx(H), evenx(I), zero(X), leftevenx(D),
      mult([C, B, A], D, [L, K, J | Y]),
      leftevenx(J), oddx(K), evenx(L), zero(Y),
      sum2([I, H, G, F], [0, L, K, J], [P, O, N, M | Z]),
      oddx(M), oddx(N), evenx(O), evenx(P), zero(Z),
      writeln([A,B,C,E,F,G,H,I,J,K,L,M,N,O,P]),
      writeln(ok).

crypt2 =>
      oddx(A), evenx(B), evenx(C), evenx(E),
      mult([C, B, A], E, [I, H, G, F | X]),
      leftevenx(F), oddx(G), evenx(H), evenx(I), zero(X), leftevenx(D),
      mult([C, B, A], D, [L, K, J | Y]),
      leftevenx(J), oddx(K), evenx(L), zero(Y),
      sum2([I, H, G, F], [0, L, K, J], [P, O, N, M | Z]),
      oddx(M), oddx(N), evenx(O), evenx(P), zero(Z).

/*

  Crypto problem (alphametic) in Picat.

  This is a standard alphametic problem in mathematical recreations, 
  constraint programming etc.
    
  From GLPK:s model cryto.mod.
 
  """
  This problem comes from the newsgroup rec.puzzle.
  The numbers from 1 to 26 are assigned to the letters of the alphabet.
  The numbers beside each word are the total of the values assigned to
  the letters in the word (e.g. for LYRE: L, Y, R, E might be to equal
  5, 9, 20 and 13, or any other combination that add up to 47).
  Find the value of each letter under the equations:
 
  BALLET  45     GLEE  66     POLKA      59     SONG     61
  CELLO   43     JAZZ  58     QUARTET    50     SOPRANO  82
  CONCERT 74     LYRE  47     SAXOPHONE 134     THEME    72
  FLUTE   30     OBOE  53     SCALE      51     VIOLIN  100
  FUGUE   50     OPERA 65     SOLO       37     WALTZ    34
 
  Solution:
  A, B,C, D, E,F, G, H, I, J, K,L,M, N, O, P,Q, R, S,T,U, V,W, X, Y, Z
  5,13,9,16,20,4,24,21,25,17,23,2,8,12,10,19,7,11,15,3,1,26,6,22,14,18
 
  Reference:
  Koalog Constraint Solver <http://www.koalog.com/php/jcs.php>,
  Simple problems, the crypto-arithmetic puzzle ALPHACIPHER.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   BALLET     =  45,
   CELLO      =  43,
   CONCERT    =  74,
   FLUTE      =  30,
   FUGUE      =  50,
   GLEE       =  66,
   JAZZ       =  58,
   LYRE       =  47,
   OBOE       =  53,
   OPERA      =  65,
   POLKA      =  59,
   QUARTET    =  50,
   SAXOPHONE  = 134,
   SCALE      =  51,
   SOLO       =  37,
   SONG       =  61,
   SOPRANO    =  82,
   THEME      =  72,
   VIOLIN     = 100,
   WALTZ      =  34,

   % note: D is not in any constraint
   LD = [A,B,C,_D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z],
   LD :: 1..26,

   all_different(LD),

            B + A + L + L + E + T #= BALLET,
                C + E + L + L + O #= CELLO,
        C + O + N + C + E + R + T #= CONCERT,
                F + L + U + T + E #= FLUTE,
                F + U + G + U + E #= FUGUE,
                    G + L + E + E #= GLEE,
                    J + A + Z + Z #= JAZZ,
                    L + Y + R + E #= LYRE,
                    O + B + O + E #= OBOE,
                O + P + E + R + A #= OPERA,
                P + O + L + K + A #= POLKA,
        Q + U + A + R + T + E + T #= QUARTET,
S + A + X + O + P + H + O + N + E #= SAXOPHONE,
                S + C + A + L + E #= SCALE,
                    S + O + L + O #= SOLO,
                    S + O + N + G #= SONG,
        S + O + P + R + A + N + O #= SOPRANO,
                T + H + E + M + E #= THEME,
            V + I + O + L + I + N #= VIOLIN,
                W + A + L + T + Z #= WALTZ,


   solve(LD),

   % show the solution
   Alpha = [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z],
   foreach({Char,Val} in zip(Alpha, LD))  writef("%w: %2d\n", Char,Val) end.

/*

  Test of global constraint cumulative in Picat
.
  cumulative/4 is a built-in predicate in Picat.
 
  Example from Global constraints catalogue
   http://www.emn.fr/x-info/sdemasse/gccat/sec4.71.html
  """
  cumulative(TASKS,LIMIT)
 
  Purpose
 
  Cumulative scheduling constraint or scheduling under resource constraints.
  Consider a set T of tasks described by the TASKS collection. The cumulative
  constraint enforces that at each point in time, the cumulated height of
  the set of tasks that overlap that point, does not exceed a given limit.
  It also imposes for each task of T the constraint origin+duration=end.
 
  Example
     (
     <
      origin-1  duration-3  end-4   height-1,
      origin-2  duration-9  end-11  height-2,
      origin-3  duration-10 end-13  height-1,
      origin-6  duration-6  end-12  height-1,
      origin-7  duration-2  end-9   height-3
      >,8
      )
 
  Figure 4.71.1 [see the web page] shows the cumulated profile associated with
  the example. To each task of the cumulative constraint corresponds a set of
  rectangles coloured with the same colour: the sum of the lengths of the
  rectangles corresponds to the duration of the task, while the height of the
  rectangles (i.e., all the rectangles associated with a task have the same
  height) corresponds to the resource consumption of the task. The cumulative
  constraint holds since at each point in time we don't have a cumulated
  resource consumption strictly greater than the upper limit 8 enforced by
  the last argument of the cumulative constraint.
  """
 
  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   Len = 5,
   LS = new_list(Len),
   LD = new_list(Len),
   LR = new_list(Len),
   LE = new_list(Len),

   LS = [1, 2, 3, 6, 7], % start times
   LS :: 1..10,
   LD = [3, 9,10, 6, 2],% duration times
   LR = [1, 2, 1, 1, 3],% resource used by tasks
   % LE = [4,11,13,12, 9],

   Limit :: 1..8, % we can't use more than 8 resources at the
                  % same time. In fact, we only use 7 in this
                 % example 

   % setup a list of end times LE
   foreach({S,D,E} in zip(LS,LD,LE)) E #= S+D end,

   End #= max(LE),% latest end time of all tasks

   cumulative(LS, LD, LR, Limit),

   % note: Limit must also be labeled.
   Vars = LS ++ LE ++ [Limit],

   solve([$min(Limit)], Vars),

   println('Start   '=LS),
   println('Duration'=LD),
   println('Resource'=LR),
   println('End     '=LE),
   println('Limit   '=Limit),
   println('Max End time'=End).



/*

  Curious set of integers in Picat.

  Martin Gardner (February 1967):
  """
  The integers 1,4,9, and 120 form a set with a remarkable property:
  the product of any two integers is one less than a perfect square. 
  Find a fifth number that can be added to the set without destroying 
  this property.
  """

  Solution: The number is 0.
 
  There are however other sets of five numbers with this property.
  Here are the one in the range of 0.10000:

  [0, 1, 3, 8, 120]
  [0, 1, 3, 120, 1680]
  [0, 1, 8, 15, 528]
  [0, 1, 8, 120, 4095]
  [0, 1, 15, 24, 1520]
  [0, 1, 24, 35, 3480]
  [0, 1, 35, 48, 6888]
  [0, 2, 4, 12, 420]
  [0, 2, 12, 24, 2380]
  [0, 2, 24, 40, 7812]
  [0, 3, 5, 16, 1008]
  [0, 3, 8, 21, 2080]
  [0, 3, 16, 33, 6440]
  [0, 4, 6, 20, 1980]
  [0, 4, 12, 30, 5852]
  [0, 5, 7, 24, 3432]
  [0, 6, 8, 28, 5460]
  [0, 7, 9, 32, 8160]


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   % time2(curious(X,constr,split)),
   % time2(curious(X,degree,split)),   
   time2(curious(X,ffc,split)),
   println(X),
   fail,
   nl.


go2 => 
   selection(VariableSelect),
   choice(ValueSelect),
   foreach(VarSel in VariableSelect, ValSel in ValueSelect)
        writeln([VarSel, ValSel]),
        time2(curious(X,VarSel, ValSel)),
        writeln(X),
        nl,nl
   end.


curious(X,VarSel,ValSel) =>

   N = 5, 
   X = new_list(N),
   DomMax = 10000,
   X :: 0..DomMax,

   all_different(X),
   increasing(X, N),

   Ps = [],
   foreach(I in 1..N, J in 1..I-1)
      P :: 0..DomMax,
      Ps := Ps ++ [P],
      P*P-1 #= X[I]*X[J]
   end,

   Vars = X ++ Ps,
   solve([VarSel,ValSel],Vars).


increasing(List, N) =>
  foreach(I in 2..N) List[I-1] #=< List[I] end.



% Variable selection
selection(Variable) => 
  Variable = [backward,constr,degree,ff,ffc,forward,inout,leftmost,max,min].

% Value selection
choice(Value) => 
  Value = [down,updown,split,reverse_split].
/*

  Curious numbers in Picat.

  """
  Curious Numbers from "Amusements in Mathematics, Dudeney", number 114.

  The number 48 has this peculiarity, that if you add 1 to it the result
  is a square number, and if you add 1 to its half, you also get a
  square number. Now, there is no limit to the numbers that have this
  peculiarity, and it is an interesting puzzle to find three more of
  them---the smallest possible numbers. What are they?
  """ 


  The least such numbers are: 
  [
   [48,49,7,24,25,5],
   [1680,1681,41,840,841,29],
   [57120,57121,239,28560,28561,169], 
   [1940448,1940449,1393,970224,970225,985]
  ]


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   Z = findall(X,$curious(X)),
   foreach(Num in Z) writeln(Num) end.


curious(LD) =>
  LD = [X,A,B,C,D,E],
  LD :: 1..2000000,
  X + 1 #= A, % if you add 1 to it 
  A #= B * B, % the result is a square number
  
  X #= 2 * C, % if you to its half
  C + 1 #= D, % add 1 
  D #= E * E, % you also get a square number

  solve([constr,split], LD).

/*

  Day of the week in Picat.

  From
  http://rosettacode.org/wiki/Day_of_the_week
  """
  A company decides that whenever Xmas falls on a Sunday they will give their 
  workers all extra paid holidays so that, together with any public holidays, 
  workers will not have to work the following week (between the 25th of December 
  and the first of January).

  In what years between 2008 and 2121 will the 25th of December be a Sunday?

  Using any standard date handling libraries of your programming language; compare 
  the dates calculated with the output of other languages to discover any anomalies 
  in the handling of dates which may be due to, for example, overflow in types 
  used to represent dates/times similar to y2k type problems. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   L = [Year : Year in 2008..2121, dow(Year, 12, 25) == 0],
   println(L), 
   println(len=L.length),
   nl.



%
% Day of week, Sakamoto's method
% http://en.wikipedia.org/wiki/Weekday_determination#Sakamoto.27s_Method
%
dow(Y, M, D) = R =>
  T = [0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4],
  if M < 3 then
     Y := Y - 1
  end,
  R = (Y + Y // 4 - Y // 100 + Y // 400 + T[M] + D) mod 7.
/* 

  Test of "DCG" in Picat.

  This is some ways of handling grammars in Picat, inspired
  by Prolog's DCG.

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


% From http://en.wikipedia.org/wiki/Definite_clause_grammar
% """
% A basic example of DCGs helps to illustrate what they are and what they look like.
% 
% sentence --> noun_phrase, verb_phrase.
% noun_phrase --> det, noun.
% verb_phrase --> verb, noun_phrase.
% det --> [the].
% det --> [a].
% noun --> [cat].
% noun --> [bat].
% verb --> [eats].
%
% This generates sentences such as "the cat eats the bat", "a bat eats the cat". 
% One can generate all of the valid expressions in the language generated by 
% this grammar at a Prolog interpreter by typing sentence(X,[]). Similarly, 
% one can test whether a sentence is valid in the language by typing something 
% like sentence([the,bat,eats,the,bat],[]).
%
% Translation into definite clauses
% 
% DCG notation is just syntactic sugar for normal definite clauses in Prolog. 
% For example, the previous example could be translated into the following:
% 
% sentence(S1,S3) :- noun_phrase(S1,S2), verb_phrase(S2,S3).
% noun_phrase(S1,S3) :- det(S1,S2), noun(S2,S3).
% verb_phrase(S1,S3) :- verb(S1,S2), noun_phrase(S2,S3).
% det([the|X], X).
% det([a|X], X).
% noun([cat|X], X).
% noun([bat|X], X).
% verb([eats|X], X).
% """

% Check a sentence
go =>
   S1 = [the,cat,eats,the,bat],
   sentence(S1,S3),
   writeln([s1=S1,s3=S3]),
   nl.

% Check a sentence
go2 =>
   S1 = [a,cat,eats,the,cat],
   sentence(S1,S3),
   writeln([s1=S1,s3=S3]),
   nl.

% Note: When using the grammar for generate sentences, one cannot use
%       pattern matching in the head, e.g. 
%       as in det/2, noun/2, and verb/2.
% If we split the parameter in the body, it works, see version 1
%
go3 => 
   All=findall(S1,$sentence1(S1,[])),
   writeln(All),
   writeln(len=All.length),
   nl.

go4 => 
   All=findall(S1,$sentence2(S1,[])),
   writeln(All),
   writeln(len=All.length),
   nl.

go5 => 
   All=findall(S1,$sentence3(S1,[])),
   writeln(All),
   writeln(len=All.length),
   nl.


%
% Note: This works only to check a sentence,
%       not for generate them. See below for variants to
%       do this
%
sentence(S1,S3) => 
  noun_phrase(S1,S2), 
  verb_phrase(S2,S3).

noun_phrase(S1,S3) => 
  det(S1,S2),
  noun(S2,S3).

verb_phrase(S1,S3) => 
  verb(S1,S2), 
  noun_phrase(S2,S3).

% Note: All but the last must be backtrackable (using ?=>)
det([the|X], X2) ?=> X2 = X.
det([a|X], X2)    => X2 = X.

noun([cat|X], X2) ?=> X2 = X.
noun([bat|X], X2)  => X2 = X.

verb([eats|X], X2) => X2=X.


%
% Generate sentences, version 1, "DCG"
%
sentence1(S1,S3) => 
  noun_phrase1(S1,S2), 
  verb_phrase1(S2,S3).

noun_phrase1(S1,S3) => 
  det1(S1,S2),
  noun1(S2,S3).

verb_phrase1(S1,S3) => 
  verb1(S1,S2), 
  noun_phrase1(S2,S3).

% Note: All but the last must be backtrackable (using ?=>)
det1(X1, X2) ?=> X1 = [the|X2].
det1(X1, X2)  => X1 = [a|X2].

noun1(X1, X2) ?=> X1=[cat|X2].
noun1(X1, X2)  => X1=[bat|X2].

verb1(X1, X2) ?=> X1=[eats|X2].


%
% Generate sentences, version 2, using member
%
% Here we use member to generate the different alternatives
% in det2/2, noun2/2, and verb2/2.
sentence2(S1,S3) => 
  noun_phrase2(S1,S2), 
  verb_phrase2(S2,S3).

noun_phrase2(S1,S3) => 
  det2(S1,S2),
  noun2(S2,S3).

verb_phrase2(S1,S3) => 
  verb2(S1,S2), 
  noun_phrase2(S2,S3).

det2(X1, X2) => 
   Dets = [the,a],
   member(Det,Dets),
   X1 = [Det|X2].

noun2(X1, X2) => 
   Nouns = [cat,bat],
   member(Noun, Nouns),
   X1=[Noun|X2].

verb2(X1, X2) => 
   Verbs = [eats,spots],
   member(Verb, Verbs),
   X1=[Verb|X2].


%
% Generate sentences, version 3, using facts.
%
% Using facts, e.g. det3/1, noun3/1, and verb3/1 
% for generating the alternatives
sentence3(S1,S3) => 
  noun_phrase3(S1,S2), 
  verb_phrase3(S2,S3).

noun_phrase3(S1,S3) => 
   det3(S1,S2),
   noun3(S2,S3).

verb_phrase3(S1,S3) => 
   verb3(S1,S2), 
   noun_phrase3(S2,S3).

det3(X1, X2) => 
   det3(Det),
   X1 = [Det|X2].
index(-)
det3(the).
det3(a).

noun3(X1, X2) => 
  noun3(Noun),
  X1=[Noun|X2].

index(-)
noun3(cat).
noun3(bat).
noun3(dog).

verb3(X1, X2) => 
  verb3(Verb),
  X1=[Verb|X2].
index(-)
verb3(eats).
verb3(spots).
/*

  de Bruijn sequence in Picat.

  Implementation of de Bruijn sequences in Comet, both "classical" 
  and "arbitrary". 
 
  Compare with the the web based programs:
    http://www.hakank.org/comb/debruijn.cgi   
    http://www.hakank.org/comb/debruijn_arb.cgi

  For Base = 2, N = 3, M = 8 there are 2 solutions:
    x : [](0, 1, 3, 7, 6, 5, 2, 4)
    bincode : [0, 0, 0, 1, 1, 1, 0, 1]

    x : [](0, 1, 2, 5, 3, 7, 6, 4)
    bincode : [0, 0, 0, 1, 0, 1, 1, 1]

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

%
% converts a number Num to/from a list of integer List given a base Base
%
to_num(List, Base, Num) =>
        Len = length(List),
        Num #= sum([List[I]*Base**(Len-I) : I in 1..Len]).


%
% de Bruijn sequence with 
%   Base: base to use
%   N: length of each element (row)
%   M: length of sequence
%
deBruijn(Base, N, M, X, Binary, BinCode) =>

        %
        % X: list of the integers to use which are converted to
        %    base-ary numbers below
        %
        X = new_list(M),
        X :: 0..(Base**N)-1,

        % all_different(X),
        all_distinct(X),

        %
        % Binary: the matrix of the "fully expanded" integers in X
        %
        Binary = new_array(M, N),
        Binary :: 0..Base-1,
        foreach(I in 1..M)
              % convert the integer to base-ary representation
              to_num([Binary[I,J] : J in 1..N], Base, X[I])
        end,

        %
        % The de Bruijn criterion: Connect one element to the next...
        %
        foreach(I in 2..M, J in 2..N) 
           Binary[I-1, J] #= Binary[I, J-1]
        end,
        
        % ... and around the corner.
        foreach(J in 2..N) 
           Binary[M, J] #= Binary[1, J-1] 
        end,
        
        
        % 
        % BinCode: The de Bruijn sequence, i.e. the first
        %          elements in each row in Binary
        %          Note: this is just a slice.
        BinCode = [Binary[I,1] : I in 1..M],

        % symmetry breaking
        X[1] #= min(X),

        Flattened = X ++ Binary,
        solve([ff,split],Flattened).
        

% wrapper
do_it(Base, N, M, Tmp) =>
        println([base=Base, n=N, m=M, '(Base**N)-1)'=(Tmp)]),
        deBruijn(Base, N, M, X, Binary, BinCode),
        println(x=X),
        % println(binary=Binary),
        foreach(B in Binary) println(B.to_list()) end,
        println(debruijn=[I.to_string() : I in BinCode].join('')),
        printf("\n").

do_it2(Base, N, M, Tmp) =>
        deBruijn(Base, N, M, X, Binary, BinCode),
        println([to_string(B) : B in BinCode].join('')).




% Let's start simple: This has 2 solutions.
go ?=>
        Base = 2,
        N = 3,
        M = Base**N,
        Tmp = Base**N-1,
        do_it2(Base, N, M, Tmp),
        fail.

% This is an "arbitrary" de Bruijn sequence, i.e. the length of
% the sequence is 52, i.e. < Base**N.
% Many solutions.
go2 ?=>
        Base = 13,
        N = 4,
        M = 52,
        Tmp = Base**N-1,
        do_it(Base, N, M, Tmp),
        fail.

go2 => true.

% The "door code" sequence, i.e. all codes of length 4 in for 0..9.
go3 =>
        Base = 10,
        N = 4,
        M = Base**N,
        Tmp = Base**N-1,
        do_it(Base, N, M, Tmp).

go4 ?=>
        Map = get_global_map(),
        Map.put(count,0),
        Base = 2,
        N = 5,
        M = 27,
        Tmp = Base**N-1,
        do_it(Base, N, M, Tmp),
        Map.put(count,Map.get(count)+1),
        fail.

go4 => 
  println(count=get_global_map().get(count))./*

  Deranged anagrams in Picat.

  http://rosettacode.org/wiki/Anagrams/Deranged_anagrams
  """
  Two or more words are said to be anagrams if they have the same characters, 
  but in a different order. By analogy with derangements we define a deranged 
  anagram as two words with the same characters, but in which the same character 
  does not appear in the same position in both words.

  The task is to use the word list at 
  http://www.puzzlers.org/pub/wordlists/unixdict.txt to find and show 
  the longest deranged anagram. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
   FD = open("unixdict.txt"),
   % FD = open("words_lower.txt"),
   Dict = new_map(),
   while (not at_end_of_stream(FD))
      Line = read_line(FD),
      Sorted = Line.sort(),
      Dict.put(Sorted, cond(Dict.has_key(Sorted), Dict.get(Sorted), "") ++ [Line])
   end,
   close(FD),

   Deranged = [Value : _Key=Value in Dict, Value.length > 1, allderanged(Value)],
   MaxLen = max([V[1].length : V in Deranged]),
   println([V : V in Deranged, V[1].length == MaxLen ]),

   nl.

% shorter and faster
go2 =>
  M = new_map(),
  _=[_:W in read_file_lines("unixdict.txt"),S=sort(W),M.put(S,M.get(S,"")++[W])],
  Deranged = [Value : _Key=Value in M, Value.length > 1, allderanged(Value)],
  MaxLen = max([V[1].length : V in Deranged]),
  println([V : V in Deranged, V[1].length==MaxLen]),
  nl.

% using group/2
go3 =>
  M=[W:W in read_file_lines("unixdict.txt")].group(sort),
  Deranged = [Value : _Key=Value in M, Value.length > 1, allderanged(Value)],
  MaxLen = max([V[1].length : V in Deranged]),
  println([V : V in Deranged, V[1].length==MaxLen]),
  nl.


%
% A and B are deranged: i.e. there is no
% position with the same character.
%
deranged(A,B) => 
   foreach(I in 1..A.length)
       A[I] != B[I]
   end.


%
% All words in list Value are deranged anagrams of each other.
%
allderanged(Value) => 
    IsDeranged = 1,
    % foreach(V1 in Value, V2 in Value, compare_terms(V1,V2) < 0, IsDeranged = 1)
    foreach(V1 in Value, V2 in Value, V1 @< V2, IsDeranged = 1)
       if not deranged(V1,V2) then
          IsDeranged := 0
       end
    end,
    IsDeranged == 1.


%
% groups the element in List according to the function F
%
group(List, F) = P, list(List) =>
   P = new_map(),
   foreach(E in List) 
      V = apply(F,E),
      P.put(V, P.get(V,[]) ++ [E])
   end.


/*

  Derangements in Picat.

  From http://rosettacode.org/wiki/Permutations/Derangements
  """
  Permutations/Derangements
  A derangement is a permutation of the order of distinct items in which 
  no item appears in its original place.

  For example, the only two derangements of the three items 
    (0, 1, 2) are (1, 2, 0), and (2, 0, 1).
  
  The number of derangements of n distinct items is known as the subfactorial of n, 
  sometimes written as !n. There are various ways to calculate !n.

  Task

  The task is to:

   - Create a named function/method/subroutine/... to generate derangements of the integers 
     0..n-1, (or 1..n if you prefer).
   - Generate and show all the derangements of 4 integers using the above routine.
   - Create a function that calculates the subfactorial of n, !n.
   - Print and show a table of the counted number of derangements of n vs. the calculated 
     !n for n from 0..9 inclusive. 

  As an optional stretch goal:

    Calculate !20. 
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   foreach(N in 0..9) 
      println([N,num_derangements=num_derangements(N), subfactorial=subfactorial(N), subfactorial2=subfactorial2(N)])
   end,
   println(["!20", subfactorial(20)]),
   println(["!20 approx", subfactorial2(20)]),
   println([subfactorial(N) : N in 0..30 ]),
   println([subfactorial2(N) : N in 0..30 ]),
   println(["!200", subfactorial(200)]),
   nl,
   println("Syntax sugar:"),
   println("'!'(20)"='!'(20)),
   println("20.'!'()"=200.'!'()),
   println("'!!'(20)"='!!'(20)),
   println("'!-!!'(10)"='!-!!'(10)),
   nl.

go2 => 
  garbage_collect(200_000_000),
  foreach(N in 0..5) 
     All=findall(L, (member(L,permutations(1..N)),nofixpoint(L))),
     println(N=All)
  end,
  nl.

num_derangements(N) = derangements(N).length.

derangements(N) = D =>
  D = [P : P in permutations(1..N), nofixpoint(P)].

table
subfactorial(0) = 1.
subfactorial(1) = 0.
subfactorial(N) = (N-1)*(subfactorial(N-1)+subfactorial(N-2)).


% approximate version of subfactorial
subfactorial2(0) = 1.
subfactorial2(N) = floor(1.0*floor(factorial(N)/2.71828 + 1/2.0)).

fact(N) = F =>
   F1 = 1,
   foreach(I in 1..N)
     F1 := F1 * I
   end,
   F = F1.

nofixpoint(L) =>
   foreach(I in 1..L.length)
     L[I] != I
   end.

% Some syntax sugar. Note the function must be an atom.
'!'(N) = fact(N).
'!!'(N) = subfactorial(N).


'!-!!'(N) = fact(N) - subfactorial(N)./* 

  Deriv benchmark in Picat.

  Prolog code from
  http://www.jekejeke.ch/idatab/doclet/prod/en/docs/05_run/15_stdy/06_bench/09_programs/03_deriv/01_deriv.p.html

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


% Prolog code
/**
 * Prolog code for the symbolic derivation benchmark.
 *
 * This is the benchmark of page 222 of:
 * Warren, D.H.D. (1983): Applied Logic  Its Use and
 * Implementation as a Programming Tool,
 * Technical Note 290, SRI International, 1983
 *
 * Copyright 2010, XLOG Technologies GmbH, Switzerland
 * Jekejeke Prolog 0.8.3 (a fast and small prolog interpreter)
 */

/*
d(U + V, X, DU + DV) =>
      d(U, X, DU),
      d(V, X, DV).
d(U - V, X, DU - DV) =>
      d(U, X, DU),
      d(V, X, DV).
d(U * V, X, DU * V + U * DV) =>
      d(U, X, DU),
      d(V, X, DV).
d(U / V, X, (DU * V - U * DV) / ^(V, 2)) =>
      d(U, X, DU),
      d(V, X, DV).
d(^(U, N), X, DU * N * ^(U, N1)) =>
      N1 = N - 1,
      d(U, X, DU).
d(-U, X, -DU) =>
      d(U, X, DU).
d(exp(U), X, exp(U) * DU) =>
      d(U, X, DU).
d(log(U), X, DU / U) =>
      d(U, X, DU).
d(X, X, 1) => true.

d(_, _, Zero) => Zero = 0.

*/

%
% From http://www.picat.org/download/exs.pi
%
% Note: This adds some extra parenthesis compared to the Prolog version, 
%       e.g. x^2 -> (x^2)
%
d(U+V,X,D) => 
    D = $DU+DV,
    d(U,X,DU),
    d(V,X,DV).
d(U-V,X,D) =>
    D = $DU-DV,
    d(U,X,DU),
    d(V,X,DV).
d(U*V,X,D) =>
    D = $DU*V+U*DV,
    d(U,X,DU),
    d(V,X,DV).
d(U/V,X,D) =>
    D = $(DU*V-U*DV)/(^(V,2)),
    d(U,X,DU),
    d(V,X,DV).
d(^(U,N),X,D) =>
    D = $DU*N*(^(U,N1)),
    integer(N),
    N1=N-1,
    d(U,X,DU).
d(-U,X,D) =>
    D = $-DU,
    d(U,X,DU).
d(exp(U),X,D) =>
    D = $exp(U)*DU,
    d(U,X,DU).
d(log(U),X,D) =>
    D = $DU/U,
    d(U,X,DU).
d(X,X,D) => D=1.
d(_,_,D) => D=0.


% Answer should be:
%    (1+0)*((x^2+2)*(x^3+3))+(x+1)*((1*2*x^1+0)*(x^3+3)+(x^2+2)*(1*3*x^2+0))
ops8(E) => 
   Exp = $((x+1) * ((^(x,2)+2)*(^(x,3)+3))),
   d(Exp,x,E).


% Answer should be:
%    (((((((((1*x-x*1)/x^2*x-x/x*1)/x^2*x-x/x/x*1)/x^2*x-x/x/x/x*1)/x^2*x-x/x/x/x/x*1)/x^2*x-x/x/x/x/x/x*1)/x^2*x-x/x/x/x/x/x/x*1)/x^2*x-x/x/x/x/x/x/x/x*1)/x^2*x-x/x/x/x/x/x/x/x/x*1)/x^2
divide10(E) => 
   Exp= $((((((((x/x)/x)/x)/x)/x)/x)/x)/x)/x,
   d(Exp,x,E).


% Answer should be:
%    1/x/log(x)/log(log(x))/log(log(log(x)))/log(log(log(log(x))))/log(log(log(log(log(x)))))/log(log(log(log(log(log(x))))))/log(log(l
log10(E) => 
  Exp = $(log(log(log(log(log(log(log(log(log(log(x))))))))))),
  d(Exp, x, E).

% Answer should be:
%   ((((((((1*x+x*1)*x+x*x*1)*x+x*x*x*1)*x+x*x*x*x*1)*x+x*x*x*x*x*1)*x+x*x*x*x*x*x*1)*x+x*x*x*x*x*x*x*1)*x+x*x*x*x*x*x*x*x*1)*x+x*x*x*x*x*x*x*x*x*1
times10(E) => 
  Exp = $(((((((((x * x) * x) * x) * x) * x) * x) * x) * x) * x),
  d(Exp, x, E).

deriv =>
   ops8(E1), 
   println(ops8=E1),
   divide10(E2),
   println(divide10=E2),
   log10(E3),
   println(log10=E3),
   times10(E4),
   println(time10=E4).
      
deriv2 =>
   ops8(_E1), 
   divide10(_E2),
   log10(_E3),
   times10(_E4).
      


/*

  Devil's word in Picat.

  Translate each character in a word to ASCII value and then try
  to sum its values (either positive or negative) to a total.
  
  E.g. "hakankjellerstrand" and total 666 gives 359 solutions.
  Here is the first:
  +104 +97 +107 +97 +110 +107 +106 -101 +108 +108 -101 +114 +115 +116 -114 -97 -110 -100
 

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   Name = [h,a,k,a,n, k,j,e,l,l,e,r,s,t,r,a,n,d],
   convert_list(Name, Res),
   printf("%s", Name), 
   nl,
   Total #= 666,
   writeln(total=Total),
   devils_word(Res, SignedRes,Total),
   solve([ff],SignedRes),
      
   writeln([Total, SignedRes]),
   nl.


%
% Let's see how many solutions there are.
%
go2 =>

   Name = [h,a,k,a,n, k,j,e,l,l,e,r,s,t,r,a,n,d],
   convert_list(Name, Res),
   printf("%s", Name),
   nl,
   Total #= 666,
   L = findall(SignedRes, $(devils_word(Res, SignedRes,Total),
                           solve([ff],SignedRes))), 
   printf("There are %d solutions.\n", L.length),
   nl.

% Let us go crazy and set Total free as well
go3 =>

   Name = [h,a,k,a,n],
   % Name = [k,j,e,l,l,e,r,s,t,r,a,n,d],
   convert_list(Name, Res),
   printf("%s", Name),
   nl,
   Total :: 1..sum([abs(R) : R in Res]),
   L = findall([Total,SignedRes], $(devils_word(Res, SignedRes,Total),
                           solve([ff],SignedRes))), 
   foreach([Total2,W] in L) writeln([total=Total2,w=W]) end,
   printf("There are %d solutions.\n", L.length),
   nl.


scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).


%
% Signs is the list of [-1,1] for which
%   List[i]*Signs[i] = Total
%
% SignedRes is the resulting list of 
%   SignedRes[i] = List[i]*Signs[i]
%
devils_word(List, SignedRes, Total) =>

   Len = length(List),
   Signs = new_list(Len),
   Signs :: [-1,1],
   scalar_product(List,Signs,Total),
   % create the resulting list of ASCII codes with +/- signs
   SignedRes = [ SR : {S,R} in zip(Signs,List), SR #= S*R].


% 
% convert a list of atoms to ASCII code
%
convert_list(List, Res) =>
   Res = [I : El in List, I = ord(El)].
   
/*

  Diet problem in Picat.

  Standard diet problem.

  Minimize the cost for the products:
   Type of                        Calories   Chocolate    Sugar    Fat
   Food                                      (ounces)     (ounces) (ounces)
   Chocolate Cake (1 slice)       400           3            2      2
   Chocolate ice cream (1 scoop)  200           2            2      4
   Cola (1 bottle)                150           0            4      1
   Pineapple cheesecake (1 piece) 500           0            4      5


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% find all optimal solutions
go =>
  data(Price, Limits, [Calories, Chocolate, Sugar, Fat]),
  diet(Calories,Chocolate,Sugar,Fat,Price,Limits, Xs,XSum),
  writeln([cost=XSum, Xs]),

  % and get all optimal solutions
  % (It's a unique solution.)
  writef("Find all solutions with cost %d:\n", XSum),
  Sols = findall(Xs2,diet(Calories,Chocolate,Sugar,Fat,Price,Limits, Xs2,XSum)),
  writeln(Sols),
  nl.


go2 =>
  data(Price, Limits, [Calories, Chocolate, Sugar, Fat]),       
  diet1(Calories,Chocolate,Sugar,Fat,Price,Limits, Xs,XSum),
  writeln([cost=XSum, Xs]).

go3 =>
  data(Price, Limits, [Calories, Chocolate, Sugar, Fat]),       
  diet2([Calories,Chocolate,Sugar,Fat],Price,Limits, Xs,XSum),
  writeln([cost=XSum, Xs]).


% plain scalar product
scalar_product(A, X, Product) => 
   Product #= sum([A[I]*X[I] : I in 1..A.length]).

% scalar product with relation
scalar_product(A, X, Rel, Product) => 
   scalar_product(A, X, P),
   call(Rel,P,Product).


%
% Simplest version: Hardcoding each constraint and just optimize
%
diet1(Calories,Chocolate,Sugar,Fat,Price,Limits, Xs,XSum) =>

  Len = length(Price),
  Xs = new_list(Len),
  Xs :: 0..10,

  sum([Calories[I]  * X[I] : I in 1..Len]) #>= Limits[1], % 500,
  sum([Chocolate[I] * X[I] : I in 1..Len]) #>= Limits[2], %   6,
  sum([Sugar[I]     * X[I] : I in 1..Len]) #>= Limits[3], %  10,
  sum([Fat[I]       * X[I] : I in 1..Len]) #>= Limits[4], %   8,

  sum([Price[I]*X[I] : I in 1..Len]) #= XSum, % % to minimize

  solve([$min(XSum)], Xs).


% 
% Slightly more general version: use scalar_product instead of sum/1.
%
diet(Calories,Chocolate,Sugar,Fat,Price,Limits, Xs,XSum) =>

  Len = length(Price),
  Xs = new_list(Len),
 	Xs :: 0..10,

  scalar_product(Calories,  Xs, #>=, Limits[1]), % 500,
  scalar_product(Chocolate, Xs, #>=, Limits[2]), %   6,
  scalar_product(Sugar,     Xs, #>=, Limits[3]), %  10,
  scalar_product(Fat,       Xs, #>=, Limits[4]), %   8,

  scalar_product(Price, Xs, #=, XSum), % to minimize

  % optimize or find all (optimal) solutions
  if var(XSum) then
     solve([$min(XSum)], Xs)
  else 
     % here XSum is bound so we just label the vars
     solve(Xs)
  end.



%
% This is a more general solution where all the nutritions 
% are handled in a foreach loop.
%
diet2(Products,Price,Limits, Xs,XSum) =>

  Len = length(Price),
  Xs = new_list(Len),
 	Xs :: 0..10,

  foreach(P in 1..Products.length)
     scalar_product(Products[P], Xs,#>=, Limits[P])
  end,
  scalar_product(Price, Xs, #=, XSum), % to minimize
  if var(XSum) then
     solve([$min(XSum)], Xs)
  else 
     % here XSum is bound so we just label the vars
     solve(Xs)
  end.

%
% data
%
data(Price, Limits, Nutrition) =>
     Price = [ 50, 20, 30, 80], % price in cents for each nutrition
     Limits = [500,  6, 10,  8], % limits, requirements for each nutrition type

     % nutrition for each product
     Nutrition = 
     [[400, 200, 150, 500],  % calories
      [  3,   2,   0,   0],  % chocolate
      [  2,   2,   4,   4],  % sugar
      [  2,   4,   1,   5]]. % fat
/* 

  Digit 8 problem in Picat.

  Standard Prolog Benchmark
  """
  Benchmark (Finite Domain)                                               
                                                                          
  Name           : digit8.pl                                              
  Title          : particular 8 digit number                              
  Original Source: Daniel Diaz - INRIA France                             
  Adapted by     : Daniel Diaz for GNU Prolog                             
  Date           : October 1993                                           
                                                                          
  Find the 8 digit number N such that:                                    
                                                                          
     - N is a square                                                      
     - if we put a 1 in front of the decimal notation of N then it is     
       still a square                                                     
                                                                          
  Solution:                                                               
   [N,X,M,Y]                                                              
   [23765625,4875,123765625,11125]                                        
   [56250000,7500,156250000,12500]                                        
  """ 


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
    statistics(runtime,_),
    (digit8(L), 
     write(L), nl,
     fail
     ;
     print("No more solutions"), nl),
    statistics(runtime,[_,Y]),
    print("time : "), print(Y), nl.

digit8(L) =>
    L=[N,X,M,Y],
    N :: 10000000..99999999,
    X**2 #= N,
    100000000+N #= M,
    Y**2 #= M,
    solve([ff], L).


/*

  Dinesman's multiple-dwelling problem in Picat.

  From
  http://rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem
  """
  The task is to solve Dinesman's multiple dwelling problem but in a way that most 
  naturally follows the problem statement given below. Solutions are allowed (but 
  not required) to parse and interpret the problem text, but should remain flexible 
  and should state what changes to the problem text are allowed. Flexibility and 
  ease of expression are valued.
  
  Examples may be be split into "setup", "problem statement", and "output" sections 
  where the ease and naturalness of stating the problem and getting an answer, 
  as well as the ease and flexibility of modifying the problem are the primary concerns.

  Example output should be shown here, as well as any comments on the examples flexibility.

  The problem
    Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an 
    apartment house that contains only five floors. Baker does not live on the 
    top floor. Cooper does not live on the bottom floor. Fletcher does not live 
    on either the top or the bottom floor. Miller lives on a higher floor than 
    does Cooper. Smith does not live on a floor adjacent to Fletcher's. Fletcher 
    does not live on a floor adjacent to Cooper's. Where does everyone live? 
  """



  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
   dinesman_cp,
   dinesman1,
   dinesman2a,
   dinesman2b,
   nl.


% CP approach
dinesman_cp =>
   println(dinesman_cp),
   N = 5,
   X = [Baker, Cooper, Fletcher, Miller, Smith],
   X :: 1..N,

   all_different(X),

   % Baker does not live on the fifth floor.
   Baker #!= 5,

   % Cooper does not live on the first floor. 
   Cooper #!= 1,

   % Fletcher does not live on either the fifth or the first floor. 
   Fletcher #!= 5,
   Fletcher #!= 1,

   % Miller lives on a higher floor than does Cooper. 
   Miller #> Cooper,

   % Smith does not live on a floor adjacent to Fletcher'. 
   abs(Smith-Fletcher) #> 1,

   % Fletcher does not live on a floor adjacent to Cooper's.
   abs(Fletcher-Cooper) #> 1,

   solve(X),

   println([baker=Baker, cooper=Cooper, fletcher=Fletcher, miller=Miller, smith=Smith]).



%
% The constraints (non CP approach)
%
% floors: 1: bottom .. 5: top floor
%
constraints([B,C,F,M,S]) =>
  B != 5,               % Baker not top floor
  C != 1,               % Cooper not bottom floor  
  F != 1, F != 5,       % Fletcher not botton nor top floor
  M > C,                % Miller higher floor than Cooper
  not adjacent(S, F),   % Smith and Fletcher not adjacent 
  not adjacent(F, C).   % Fletcher and Cooper not adjacent


adjacent(A,B) => abs(A-B) == 1.


% Non-CP approach, using permutations
dinesman1 =>
   println(dinesman1),
   foreach([B,C,F,M,S] in permutations(1..5), constraints([B,C,F,M,S]))
     println([baker=B, cooper=C, fletcher=F, miller=M, smith=S])
   end.


% using my_alldifferent1
dinesman2a =>
  println(dinesman2a),
  T = 1..5,
  foreach(B in T, C in T, F in T, M in T, S in T)
    if my_alldifferent1([B,C,F,M,S]), constraints([B,C,F,M,S]) then 
      println([baker=B, cooper=C, fletcher=F, miller=M, smith=S])
    end
  end.

% using my_alldifferent2
dinesman2b =>
  println(dinesman2b),
  T = 1..5,
  foreach(B in T, C in T, F in T, M in T, S in T)
    if my_alldifferent1([B,C,F,M,S]), constraints([B,C,F,M,S]) then 
      println([baker=B, cooper=C, fletcher=F, miller=M, smith=S])
    end
  end.


% count the number of different values
my_alldifferent1(L) =>
   L.length == L.remove_dups().length.


my_alldifferent2(L) =>
   foreach(I in L, J in L) 
      if I < J  then
         L[I] != L[J]
      end
   end.


/*

  A dinner problem in Picat
.
  http://www.sellsbrothers.com/spout/#The_Logic_of_Logic
  """
  My son came to me the other day and said, "Dad, I need help with a"
  "math problem." The problem went like this:

    * We're going out to dinner taking 1-6 grandparents, 1-10 parents and/or 1-40 children
    * Grandparents cost $3 for dinner, parents $2 and children $0.50
    * There must be 20 total people at dinner and it must cost $20
    * How many grandparents, parents and children are going to dinner?
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   L = findall([grandparents=Grandparents, 
                parents=Parents, 
                children=Children], 
          $dinner([Grandparents,
                  Parents,
                  Children])),
   writeln(L),
   nl.

dinner([Grandparents, Parents, Children]) =>
   Grandparents :: 0..100,
   Parents      :: 0..100,
   Children     :: 0..100,
   Grandparents * 3 + Parents * 2 + Children / 2 #= 20,

   Grandparents + Parents + Children #= 20, % number of people = 20

   % must be some of each
   Grandparents #> 0,
   Parents      #> 0,
   Children     #> 0,
   
   solve([Grandparents, Parents, Children]).
   
/*

  Discrete tomography in Picat.

  Note: The origin of the problem is from ECLiPSe,
  but this model has been transformed in this way
     MiniZinc -> SICStus Prolog -> ECLiPSe -> B-Prolog -> Picat
  Here is my own take at the problem.

  Problem from http://eclipse-clp.org/examples/tomo.ecl.txt
  """
  This is a little "tomography" problem, taken from an old issue
  of Scientific American.
 
  A matrix which contains zeroes and ones gets "x-rayed" vertically and
  horizontally, giving the total number of ones in each row and column.
  The problem is to reconstruct the contents of the matrix from this
  information. Sample run:
 
  ?- go.
     0 0 7 1 6 3 4 5 2 7 0 0
  0                         
  0                         
  8      * * * * * * * *    
  2      *             *    
  6      *   * * * *   *    
  4      *   *     *   *    
  5      *   *   * *   *    
  3      *   *         *    
  7      *   * * * * * *    
  0                         
  0                         
 
 
  Eclipse solution by Joachim Schimpf, IC-Parc
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
    foreach(P in 1..4) 
       _L = findall(_,discrete_tomography(P))
    end.


discrete_tomography(P) =>

    problem(P,RowSums,ColSums),
    writef("\nProblem %d:\n",P),

    Rows = length(RowSums),
    Cols = length(ColSums),

    X = new_array(Rows,Cols),
    X :: 0..1,
    
    % check rows
    foreach(I in 1..Rows)
       RowSums[I] #= sum([X[I,J] : J in 1..Cols])
    end,

    foreach(J in 1..Cols) 
       ColSums[J] #= sum([X[I,J] : I in 1..Rows])
    end,

    solve(X),
    print_square(X).


print_square(Square) =>
    Rows = Square.length,
    Cols = Square[1].length,
    foreach(I in 1..Rows)
       foreach(J in 1..Cols)
          if Square[I,J] == 0 then writef(" ") else writef("X") end
       end,
       writef("\n")
    end,
    writef("\n").

%
% The three first problems are from the ECLiPSe model:
%
% The above stated problem
problem(1, R, S) => 
       R = [0,0,8,2,6,4,5,3,7,0,0], % row sums
       S = [0,0,7,1,6,3,4,5,2,7,0,0]. % column sums


problem(2, R, S) =>
       R = [10,4,8,5,6],
       S = [5,3,4,0,5,0,5,2,2,0,1,5,1].


%
% This give three slightly different solutions.
problem(3, R, S) => 
        R = [11,5,4],
        S = [3,2,3,1,1,1,1,2,3,2,1].


% This is my own problem.
problem(4, R, S) => 
        R = [0,2,2,2,2,2,8,8,4,4,4,4,4,0],
        S = [0,0,0,12,12,2,2,2,2,7,7,0,0,0].
/*

  Global constraint distribute in Picat.

  Decomposition of global constraint distribute.

  From MiniZinc globals.mzn:
  """
  Requires that 'card[i]' is the number of occurences of 'value[i]' in 'base'.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


/*
 Solution:
   card[4,1,1,1]
   value[6,7,8,9]
   base[6,7,6,8,6,9,6]
 
*/

go =>
        
   % This test is from MiniZinc's testcases.
   Len = 4,
   Card = new_list(Len), 
   Card :: 1..10, 
   Value = new_list(Len),
   Value :: 1..10,
   Base = new_list(7),
   Base :: 1..10,

   % test values
   Card  = [4, _, 1, _],
   Value = [_, 7, 8, _],
   Base  = [_, 7, 6, 8, 6, 9, _],

   distribute(Card, Value, Base),

   Vars = Card ++ Value ++ Base,
   solve([ff],Vars),

   writeln(card=Card),
   writeln(value=Value),
   writeln(base=Base),
   nl.

%
% No initial values of Card and Value
%
go2 ?=>
        
   Len = 4,
   Card = new_list(Len), 
   Card :: 1..10, 
   Value = new_list(Len),
   Value :: 1..10,
   Base = new_list(7),
   Base :: 1..10,

   % test values
   % Card  = [4, _, 1, _],
   % Value = [_, 7, 8, _],
   Base  = [_, 7, 6, 8, 6, 9, _],

   distribute(Card, Value, Base),

   Vars = Card ++ Value ++ Base,
   solve([ff],Vars),

   writeln(card=Card),
   writeln(value=Value),
   writeln(base=Base),
   nl, fail.

go2 => true.


%
% (This comment is from the ECLiPSe model):
% hakank: Compared to the Comet model, I require that Value are
% distinct, but not ordered and not the complete range of values
% (these two requirements seems to be common in the implementations of 
% the global cardinality constraint).
%
distribute(Card, Value, Base) =>
   % Card and Value must have the same length
   CardLen = length(Card),
   CardLen = length(Value), 
   BaseLen = length(Base),

   all_different(Value),
   foreach(I in 1..CardLen)
      Sum #= sum([(ValueI #= BaseJ) : J in 1..BaseLen,
           element(I,Value,ValueI),
           element(J,Base,BaseJ)]),
       element(I,Card,Sum)
   end./*

  Divisible by 9 through 1 puzzle in Picat
.
  From http://msdn.microsoft.com/en-us/vcsharp/ee957404.aspx
  " Solving Combinatory Problems with LINQ"
  """
  Find a number consisting of 9 digits in which each of the digits 
  from 1 to 9 appears only once. This number must also satisfy these 
  divisibility requirements:
  
   1. The number should be divisible by 9.
   2. If the rightmost digit is removed, the remaining number should 
      be divisible by 8.
   3. If the rightmost digit of the new number is removed, the remaining 
      number should be divisible by 7.
   4. And so on, until there's only one digit (which will necessarily 
      be divisible by 1).
  """
  
  Also, see
  "Intel Parallel Studio: Great for Serial Code Too (Episode 1)"
  http://software.intel.com/en-us/blogs/2009/12/07/intel-parallel-studio-great-for-serial-code-too-episode-1/


  This model is however generalized to handle any base 
  (for reasonable limits).

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

/* 

  Here are the solutions for the bases (2..14):

   base:2
   x=[1]
   t=[1]

   base=3

   base=4
   x=[1,2,3]
   t=[27,6,1]

   x=[3,2,1]
   t=[57,14,3]


   base=5

   base=6
   x=[1,4,3,2,5]
   t=[2285,380,63,10,1]

   x=[5,4,3,2,1]
   t=[7465,1244,207,34,5]

   base=8
   x=[3,2,5,4,1,6,7]
   t=[874615,109326,13665,1708,213,26,3]

   x=[5,2,3,4,7,6,1]
   t=[1391089,173886,21735,2716,339,42,5]

   x=[5,6,7,4,3,2,1]
   t=[1538257,192282,24035,3004,375,46,5]

   base = 10
   x = [3,8,1,6,5,4,7,2,9]
   t = [381654729,38165472,3816547,381654,38165,3816,381,38,3]

   base = 14
   x = [9,12,3,10,5,4,7,6,11,8,1,2,13]
   t = [559922224824157,39994444630296,2856746045021,204053288930,14575234923,1041088208,74363443,5311674,379405,27100,1935,138,9]




*/

go =>
   foreach(Base in 2..14)
       nl,
       println(base=Base),
       (
       problem(Base, X, T) ->
          println(x=X),
          println(t=T),nl
        ;
          println("No solution"),
          true
       )
   end,
   nl.


% Finds all solutions
go2 =>
   foreach(Base in 2..14)
      nl,
      println(base=Base),
      L = findall([X, T], $problem(Base, X, T)),
      foreach([X2, T2] in L)
         println(x=X2),
         println(t=T2),
         nl
      end
    end.



go(N) ?=>
   problem(N, X, T),
   println(x=X),
   println(t=T),
   fail.

go(_) => true.

problem(Base, X, T) =>

   M = Base**(Base-1)-1, % largest value
   N = Base - 1,   % the digits are in 1..N , 
               % N is also the length of X 
   X = new_list(N),
   X :: 1..N,
   all_different(X),

   T = new_list(N),
   T :: 1..M,

   foreach(I in 1..N)
      Base_I = Base - I,
      XI = [X[J] : J in  1..Base_I],
      to_num(XI, Base, T[I]),
      T[Base_I] mod I #= 0
   end,
   Vars = T,
   solve([ff],Vars).


to_num(List, Base, Num) =>
   Len = length(List),
   Num #= sum([List[I]*Base**(Len-I) : I in 1..Len]).
/* 

  Domino puzzle in Picat.

  Port from the B-Prolog model
  http://www.probp.com/examples/foreach/dominopuzzle.pl
  """  
  Title: Dominoes
  Solved by: Neng-Fa Zhou (Dec. 2009, adapated using foreach and list comprehension)
  Publication: Dell Logic Puzzles
  Issue: Sep. 2001
  Page: 19
  Stars: 3

  The dominoes of an ordinary double-six set have been scrambled and arranged into 
  the pattern shown below. Each number shows the number of pips in that square, from 
  zero to six, but the boundaries between the dominoes have all been removed. Can you 
  deduce where each domino is, and draw in the lines to show how they are arranged? 
  Each domino is used exactly once. 

  There are 28 dominoes: 0-0, 0-1, 0-2, ... 5-5, 5-6, 6-6. 

  Puzzle pattern:

  3 1 2 6 6 1 2 2
  3 4 1 5 3 0 3 6
  5 6 6 1 2 4 5 0
  5 6 4 1 3 3 0 0 
  6 1 0 6 3 2 4 0
  4 1 5 2 4 3 5 5
  4 1 0 2 4 5 2 0 
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go=>
    data(Config),
    Rows = 7,
    Cols = 8,
    A=new_array(Rows,Cols),
    Vars = [A[I,J] : I in 1..Rows, J in 1..Cols],
    D = [X : I in 0..6, J in I..6, X = I*10+J],  % D=[0,1,6,11,..,16,...,55,56,66]
    Vars :: D,
    println(d=D),

    % All possible combinations
    Table = [{E,Rem} : E in D, Rem = E mod 10] ++ [{E,Div} : E in D, Div = E // 10],
    println(table=Table),

    foreach(I in 1..Rows, J in 1..Cols)
      table_in({A[I,J],Config[I,J]}, Table),
      form_domino(A,I,J)
    end,

    Values = [$X-2 : X in D],
    global_cardinality(Vars,Values),

    solve([ff],Vars),

    foreach(I in 1..7)
      foreach(J in 1..8)
        printf("%2d ",A[I,J])
      end,
      nl
    end,

    nl.
    

% Exactly one of A[I,J]'s neighbors is the same as A[I,J]
form_domino(A,I,J)=>
  sum([(A[I1,J1]#=A[I,J]) : 
      I1 in I-1..I+1, J1 in J-1..J+1, 
      I1>0,I1=<7,J1>0,J1=<8,
      (I1=I;J1=J),(I,J)!=(I1,J1)]) #= 1.

data(Board)=>
    Board = [[3,1,2,6,6,1,2,2],
	     [3,4,1,5,3,0,3,6],
	     [5,6,6,1,2,4,5,0],
	     [5,6,4,1,3,3,0,0],
	     [6,1,0,6,3,2,4,0],
	     [4,1,5,2,4,3,5,5],
	     [4,1,0,2,4,5,2,0]].
/*

  DONALD + GERALD = ROBERT problem in Picat.

  Classic alphametic problem.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   X = [D,O,N,A,L,G,E,R,B,T],
   X :: 0..9,

   all_different(X),

      100000*D + 10000*O + 1000*N + 100*A + 10*L + D 
    + 100000*G + 10000*E + 1000*R + 100*A + 10*L + D
   #= 100000*R + 10000*O + 1000*B + 100*E + 10*R + T,

   D #> 0,
   G #> 0,
   R #> 0,

   solve([],X),

   writeln(X),
   nl.



/* 

  Dudeney's queen placement problem in Picat.

  From Martin Chlond Integer Programming Puzzles:
  http://www.chlond.demon.co.uk/puzzles/puzzles2.html, puzzle nr. 11
  Description  : Dudeney's queen placement problem
  Source       : Dudeney, H.E., (1917), Amusements in Mathematics, Thomas Nelson and Sons.
  """
  11. The Amazons.
  Remove three of the queens to other squares so that there shall be eleven squares on the board that are not
  attacked. The removal of the three queens need not be by "queen moves". You may take them up and place them
  anywhere. There is only one solution. 

  (Dudeney)
  """
 
  This model was inspired by the XPress Mosel model created by Martin Chlond.
  http://www.chlond.demon.co.uk/puzzles/sol2s11.html


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
   Size = 8,
   X = new_array(Size,Size), % 1 if square {I,J} occupied, 0 otherwise
   X :: 0..1,
   A = new_array(Size,Size), % 1 if square {I,J} attacked, 0 otherwise
   A :: 0..1,

   SumA :: 0..100,
   SumA #= sum([A[I,J] : I in 1..Size, J in 1..Size]),

   % all eight queens used
   sum([X[I,J] : I in 1..Size, J in 1..Size]) #= 8,

   % five of original queens untouched
   sum([(X[8,J] + X[7,Size] + X[6,Size]) : J in 3..Size]) #= 5,

   % a(i,j) = 1 if square (i,j) attacked
   % (Yes, it's an IP approach.)
   foreach(I in 1..Size, J in 1..Size)
     (
        sum([X[M,M-I+J] : M in 1..Size, M != I, M-I+J >= 1, M-I+J <= Size])  +
        sum([X[M,I+J-M] : M in 1..Size, M != I, I+J-M >= 1, I+J-M <= Size]) +
        sum([X[M,J] : M in 1..Size, M != I])  + 
        sum([X[I,N] : N in 1..Size, N != J]) 
      )  #<= 99*A[I,J]
   end,

   Vars = A.to_list() ++ X.to_list(),
   solve($[min(SumA),ff],Vars),
   
   println(sumA=SumA),
   println('X'),
   foreach(Row in X) println(Row.to_list()) end,
   println('A'),
   foreach(Row in A) println(Row.to_list()) end,
   nl./* 

  Drive Ya Nuts puzzle in Picat.

  From http://www.samstoybox.com/toys/DriveYaNuts.html
  """
  The Drive Ya Nuts puzzle by Milton Bradley was cool and quite difficult. The object of 
  the puzzle is to place all seven nuts such that the numbers on all sides of each 
  nut match the numbers on the adjoining nut. There is but one way to solve the puzzle. 
  Here are two versions of puzzle. Note that the second one is still factory sealed and 
  shows the solution. So you think it sounds easy? 
  """

  Some other links: 
  - http://www.jaapsch.net/puzzles/circus.htm

  Representation:

  A side of a nut is numbered as following
  
             1

        6        2
    
        5        3

             4


  and the 7 nuts are numbered as follows:

             1 

         6       2
             7
         5        3
  
             4
  
  i.e. nut 7 is the master (center) nut.


  Note: There are 6 solutions, depending on how we orient
        the center nut (7). This is handled by symmetry breaking below.

  Here is one solution (which has the center nut start with 1):
  
     2 3 5 1 4 6    Nut 1 (in the representation above)
     3 2 4 1 6 5    Nut 2
     1 4 3 6 5 2    Nut 3
     4 5 6 1 2 3    Nut 4
     2 5 3 1 6 4    Nut 5
     5 4 3 2 1 6    Nut 6
     1 6 2 4 5 3    Nut 7 (center nut)

  E.g. the first nut is the nut 1,4,6,2,3,5 rotated like this, i.e.
  with 2 at 12 o'clock and then clock wise: 2,3,5,1,4, and 6:
     
             2

        6        3
    
        4        5

             1

  And so on with the other nuts.
  

  [Comment from the MiniZinc model
   http://www.hakank.org/minizinc/drive_ya_nuts.mzn:
  Note: I started with this MiniZinc model after reading the Frink 
  implementation by Alan Eliasen 
      http://futureboy.us/fsp/colorize.fsp?f=DriveYaNuts.frink
  which had the link cited above. The Frink program use a different 
  approach, though.
  ]

  [Personal comment: 
   This is the same puzzle as the infamous AWA-Patent problem 
  from a long long time ago, though I didn't then know what 
  it was called.
  Yes, I did solve it manually without any computational help.]


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
   foreach(P in 1..3) 
      problem(P, Nuts),
      nuts(Nuts),
      nl
   end,
   nl.


nuts(Nuts) => 

    M = 7,
    N = 6,

    connections(Connections),
    NumConnections = Connections.length,


    % decision variables
    X = new_array(M,N),  % the final solution
    X :: 1..N,
    
    Pos = new_list(M), % which nut is this? (in the nuts matrix)
    Pos :: 1..M,
    PosInv = new_list(M), % Permutation array of pos.
    PosInv :: 1..M,
    % indices to start the nut (in the nuts m x n*2 matrix)
    StartIx = new_list(M),
    StartIx :: 0..N-1,

    Ks = [],
    Ps = [],
    foreach(I in 1..M) 
      all_different([X[I,J] : J in 1..N]),

      % for some "rotation" of each nut...
      K :: 0..N-1, % the "rotation" (i.e. shift in the n*2 array)
      P :: 1..M,   % which nut is at position pos[i] 
      StartIx[I] #= K,
      Pos[I] #= P,
      % foreach(J in 1..N) X[I,J] #= Nuts[P,JK] end % offset by k
      foreach(J in 1..N) 
          JK #= J+K,          
          matrix_element(Nuts,P,JK,X[I,J])
      end,
      Ks := [K|Ks],
      Ps := [P|Ps]
   end,

   all_different(Pos),
   % all_different(PosInv),

   % for display (and pondering)
   assignment(Pos, PosInv), % inverse

   % symmetry breaking: 
   % We pick the solution where the center nut (nut 7) start with 1.
   StartIx[7] #= 0,


   % check the connections
   foreach(C in 1..NumConnections)
      CC = [Connections[C,J] : J in 1..4],
      X[CC[1], CC[3]] #= X[CC[2], CC[4]]
   end,
   

   Vars = Ps ++ Ks, 
   % solve($[split], Vars),
   solve(Vars),

   println("X:"),
   foreach(Row in X) println(Row.to_list()) end,
   println("Nuts:"),
   foreach(Row in Nuts) println([Row[I] : I in 1..Row.length div 2]) end,

   println(pos=Pos),
   println(posInv=PosInv),
   println(startIx=StartIx),

   nl.


% Special version when X is an (ground) integer matrix
% (suggested by Neng-Fa). Not used since the built-in matrix_element/4 
% works and is faster.
matrix_element_nfz(X, I, J, Val) =>
  foreach(R in 1..X.length, C in 1..X[1].length)
      (I #= R #/\ J #= C) #=> Val#=X[R,C]
  end.

%
% The connection points between the nuts, i.e. where the values
% must be the same.
% (Not surprisingly there are some permutations involved.)
%
connections(Connections) => 
   Connections = 
   [
     % nuts    sides to be equal
     [1,2,       3,6],
     [2,3,       4,1],
     [3,4,       5,2],
     [4,5,       6,3],
     [5,6,       1,4],
     [6,1,       2,5],

     [7,1,       1,4],
     [7,2,       2,5],
     [7,3,       3,6],
     [7,4,       4,1],
     [7,5,       5,2],
     [7,6,       6,3]
    ].



% "arbitrary" order (sorted)
% Note that pos_inv for the shown solution is the permutation 
% [4,3,1,7,5,2,6]
problem(1, Nuts) => 
  Nuts =  
   [
     [1,2,3,4,5,6, 1,2,3,4,5,6], % 4 (row 4 in the solution order shown above)
     [1,4,3,6,5,2, 1,4,3,6,5,2], % 3
     [1,4,6,2,3,5, 1,4,6,2,3,5], % 1 
     [1,6,2,4,5,3, 1,6,2,4,5,3], % 7 [center nut]
     [1,6,4,2,5,3, 1,6,4,2,5,3], % 5
     [1,6,5,3,2,4, 1,6,5,3,2,4], % 2 
     [1,6,5,4,3,2, 1,6,5,4,3,2]  % 6 
    ].

%
% This is the nuts in the solution order.
%
problem(2, Nuts) =>
  Nuts = 
   [
     [1,4,6,2,3,5, 1,4,6,2,3,5], % 1 
     [1,6,5,3,2,4, 1,6,5,3,2,4], % 2 
     [1,4,3,6,5,2, 1,4,3,6,5,2], % 3
     [1,2,3,4,5,6, 1,2,3,4,5,6], % 4
     [1,6,4,2,5,3, 1,6,4,2,5,3], % 5
     [1,6,5,4,3,2, 1,6,5,4,3,2], % 6 
     [1,6,2,4,5,3, 1,6,2,4,5,3]  % 7 % center nut
   ].

% Another order
% nuts = array2d(1..m], 1..n*2,
problem(3, Nuts) =>
  Nuts = 
   [
     [1,6,5,3,2,4, 1,6,5,3,2,4], % 2 
     [1,2,3,4,5,6, 1,2,3,4,5,6], % 4 (row 4 in the solution order shown above)
     [1,6,2,4,5,3, 1,6,2,4,5,3], % 7 [center nut]
     [1,6,4,2,5,3, 1,6,4,2,5,3], % 5
     [1,6,5,4,3,2, 1,6,5,4,3,2], % 6 
     [1,4,6,2,3,5, 1,4,6,2,3,5], % 1 
     [1,4,3,6,5,2, 1,4,3,6,5,2]  % 3
   ].
/* 

  Dudeney's Bishop Placement problem 1 in Picat.

  From Martin Chlond Integer Programming Puzzles:

  http://www.chlond.demon.co.uk/puzzles/puzzles1.htm2, puzzle nr. 7
  Description  : Dudeney's bishop placement problem I
  Source       : Dudeney, H.E., (1917), Amusements in Mathematics, Thomas Nelson and Sons.
  """
  7. Place as few bishops as possible on an ordinary chessboard so that every 
  square of the board shall be either occupied or attacked. (Dudeney)
  """

  This model was inspired by the XPress Mosel model created by Martin Chlond.
  http://www.chlond.demon.co.uk/puzzles/sol2s7.html


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 

   Size = 8,
 
   X = new_array(Size,Size), % x(i,j) = 1 if square (I,J) occupied, 0 otherwise
   X :: 0..1, 
   A = new_array(Size,Size), % a(i,j) = 1 if square (I,J) attacked, 0 otherwise
   A :: 0..1,

   SumX #= sum([X[I,J] : I in 1..Size, J in 1..Size]),

   % a(i,j) = 0 if square (i,j) not attacked
   foreach(I in 1..Size, J in 1..Size)
     (
      sum([X[M,M-I+J] : M in 1..Size, M != I, M-I+J >= 1, M-I+J <= Size])  +
      sum([X[M,I+J-M] : M in 1..Size, M != I, I+J-M >= 1, I+J-M <= Size])  
      ) #>= A[I,J] 
   end,

  % each square is either attacked or occupied
  foreach(I in 1..Size, J in 1..Size) 
     A[I,J]+X[I,J] #= 1
  end,

  Vars = X.to_list() ++ [SumX] ++ A.to_list(),
  % minimize number of bishops
  solve($[min(SumX),report(print_sol(X,A,SumX)),ffc,split],Vars),


  print_sol(X,A,SumX),

  nl.


print_sol(X,A,SumX) => 
  println(sumX=SumX),
  println("X:"),
  foreach(Row in X) println(Row.to_list()) end,
  println("A:"),
  foreach(Row in A) println(Row.to_list()) end,
  nl.
/* 

  Dudeney's Bishop Placement problem 2 in Picat.

  From Martin Chlond Integer Programming Puzzles:

  http://www.chlond.demon.co.uk/puzzles/puzzles2.html, puzzle nr. 8 
  Description  : Dudeney's bishop placement problem II
  Source       : Dudeney, H.E., (1917), Amusements in Mathematics, Thomas Nelson and Sons.
  """
  8. What is the greatest number of bishops that can be placed on the chessboard 
  without any bishop attacking another? (Dudeney)
  """

  This model was inspired by the XPress Mosel model created by Martin Chlond.
  http://www.chlond.demon.co.uk/puzzles/sol2s8.html

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 

   Size = 8,
 
   X = new_array(Size,Size), % x(i,j) = 1 if square (I,J) occupied, 0 otherwise
   X :: 0..1, 
   A = new_array(Size,Size), % a(i,j) = 1 if square (I,J) attacked, 0 otherwise
   A :: 0..1,

   SumX #= sum([X[I,J] : I in 1..Size, J in 1..Size]),

   % a(i,j) = 1 if square (i,j) is attacked
   foreach(I in 1..Size, J in 1..Size)
     (
      sum([X[M,M-I+J] : M in 1..Size, M != I, M-I+J >= 1, M-I+J <= Size])  +
      sum([X[M,I+J-M] : M in 1..Size, M != I, I+J-M >= 1, I+J-M <= Size])  
      ) #=< 99*A[I,J] 
   end,

  % each square is either attacked or occupied
  foreach(I in 1..Size, J in 1..Size) 
     A[I,J]+X[I,J] #= 1
  end,

  Vars = X.to_list() ++ [SumX] ++ A.to_list(),
  % maximise number of bishops
  solve($[max(SumX),report(print_sol(X,A,SumX)),ffc,split],Vars),


  print_sol(X,A,SumX),

  nl.


print_sol(X,A,SumX) => 
  println(sumX=SumX),
  println("X:"),
  foreach(Row in X) println(Row.to_list()) end,
  println("A:"),
  foreach(Row in A) println(Row.to_list()) end,
  nl.
/*

  Dudeney numbers in Picat.

  From Pierre Schaus blog post
  Dudeney number
   http://cp-is-fun.blogspot.com/2010/09/test-python.html
  """
  I discovered yesterday Dudeney Numbers
  A Dudeney Numbers is a positive integer that is a perfect cube such that the sum 
  of its decimal digits is equal to the cube root of the number. There are only six 
  Dudeney Numbers and those are very easy to find with CP.
  I made my first experience with google cp solver so find these numbers (model below) 
  and must say that I found it very convenient to build CP models in python!
  When you take a close look at the line: 
      solver.Add(sum([10**(n-i-1)*x[i] for i in range(n)]) == nb)
  It is difficult to argue that it is very far from dedicated 
  optimization languages!
  """
  
  Also see: http://en.wikipedia.org/wiki/Dudeney_number


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   N = 6,

   L = findall([X,NB,S], $dudeney(N,X,NB,S)),
   foreach([X2,NB2,S2] in L)
      writeln(x=X2),
      writeln(nb=NB2),
      writeln(s=S2),
       nl
   end,
   writeln(len=L.length),
   nl.


dudeney(N, X, NB, S) =>

   X = new_list(N),
   X :: 0..9,

   NB :: 1..10**N,
   S :: 1..9*N+1,

   NB #= S*S*S,
   NB #= sum([X[I]*10**(N-I) : I in 1..N]),
   S #= sum(X),

   solve(X)./* 

  Dummy bench in Picat.


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


dummy => true.

/* 

  Egg basket puzzle in Picat.

  From Martin Chlond Integer Programming Puzzles:
  http://www.chlond.demon.co.uk/puzzles/puzzles1.html, puzzle nr. 3
  Description  : Egg basket puzzle
  Source       : Boris Kordemsky - The Moscow Puzzles (P136)
  """
  3. A woman was carrying a basket of eggs to market when a passer-by bumped her. 
  She dropped the basket and all the eggs broke. The passer-by, wishing to pay 
  for her loss, asked, 'How many eggs were in your basket?'

  'I don't remember exactly,' the woman replied, 'but I do recall that whether 
  I divided the eggs by 2,3,4,5 or 6 there was always one egg left over. When 
  I took the eggs out in groups of seven, I emptied the basket.'

  What is the least number of eggs that broke? (Kordemsky)
  """

  This model was inspired by the XPress Mosel model created by Martin Chlond.
  http://www.chlond.demon.co.uk/puzzles/sol1s3.html


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
   MaxN = 6,
   X = new_list(MaxN),
   X :: 1..10000,
   N :: 1..10000,

   foreach(I in 1..MaxN) X[I] #> 0 end,
   N #> 1,

   % N = 2*X[1]+1,
   % N = 3*X[2]+1,
   % N = 4*X[3]+1,
   % N = 5*X[4]+1,
   % N = 6*X[5]+1,
   % N = 7*X[6]

   % generalized solution
   foreach(I in 1..MaxN) 
     if I < MaxN then
       N #= (I+1)*X[I]+1 
     else 
       N #= (I+1)*X[I] 
     end
   end,

   % to see the infered domains
   % writeln(x_before=X),
   % writeln(n_before=N),
   solve($[min(N)], X),

   writeln(n=N),
   writeln(x=X),
   nl.
/*

  A programming puzzle from Einav in Picat.

  From 
  "A programming puzzle from Einav"
  http://gcanyon.wordpress.com/2009/10/28/a-programming-puzzle-from-einav/
  """
  My friend Einav gave me this programming puzzle to work on. Given this array of positive and negative numbers:
  33   30  -10 -6  18   7  -11 -23   6
  ...
  -25   4  16  30  33 -23  -4   4 -23
 
  You can flip the sign of entire rows and columns, as many of them
  as you like. The goal is to make all the rows and columns sum to positive
  numbers (or zero), and then to find the solution (there are more than one)
  that has the smallest overall sum. So for example, for this array:
  33  30 -10
  -16  19   9
  -17 -12 -14
  You could flip the sign for the bottom row to get this array:
  33  30 -10
  -16  19   9
  17  12  14
  Now all the rows and columns have positive sums, and the overall total is 
  108.
  But you could instead flip the second and third columns, and the second 
  row, to get this array:
  33  -30  10
  16   19    9
  -17   12   14
  All the rows and columns still total positive, and the overall sum is just 
  66. So this solution is better (I don't know if it's the best)
  A pure brute force solution would have to try over 30 billion solutions. 
  I wrote code to solve this in J. I'll post that separately.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   problem(Data),
   Rows = Data.length,
   Cols = Data[1].length,
   
   X = new_array(Rows,Cols),
   XList = vars(X),
   XList :: -100..100,
   
   % row/column sums
   RowSums = new_list(Rows),
   ColSums = new_list(Cols),
   RowSums :: 0..300,
   ColSums :: 0..300,

   % the signs of rows and column
   RowSigns = new_list(Rows),
   RowSigns :: [-1,1],
   ColSigns = new_list(Rows),
   ColSigns :: [-1,1],

   % Assign X[I,J]
   foreach(I in 1..Rows,J in 1..Cols)
       T #= Data[I,J]*RowSigns[I]*ColSigns[J],
       matrix_element(X,I,J,T)
   end,

   % total sum (to minimize)
   TotalSum #= sum([T : I in 1..Rows,J in 1..Cols, matrix_element(X,I,J,T)]),
   TotalSum :: 0..1000,

   % row sums
   foreach(I in 1..Rows)
      /*
      T #= sum([TT : J in 1..Cols, 
            element(I,RowSigns,RS),
            element(J,ColSigns,CS),
            TT #= RS*CS*Data[I,J]
           ]),
      */
      T #= sum([TT : J in 1..Cols, 
          TT #= RowSigns[I]*ColSigns[J]*Data[I,J]
          ]),

      % slower
      % T #= sum([RowSigns[I]*ColSigns[J]*Data[I,J] : J in 1..Cols]),

      element(I,RowSums,T)
   end,

   % column sums
   foreach(J in 1..Cols)
      /*
      T #= sum([TT : I in 1..Rows, 
            element(I,RowSigns,RS),
            element(J,ColSigns,CS),
            TT #= RS*CS*Data[I,J]
           ]),
       */
       T #= sum([TT : I in 1..Rows, 
            TT #= RowSigns[I]*ColSigns[J]*Data[I,J]
           ]),
       element(J,ColSums,T)
   end,

   Vars = RowSums ++ ColSums ++ RowSigns ++ ColSigns ++ XList,
   solve($[min(TotalSum), report(printf("Found %d\n", TotalSum)), ffd],Vars),

   foreach(Row in X) 
      foreach(V in Row) printf("%3d ", V) end, 
      nl
   end,
   nl,
   writeln(total_sums=TotalSum),
   writeln(row_sums=RowSums),
   writeln(col_sums=ColSums),
   writeln(row_signs=RowSigns),
   writeln(col_signs=ColSigns),
   nl.

matrix_element(X, I, J, Val) =>
   % element(I, X, Row),
   Row = X[I],
   element(J, Row, Val).

% matrix_element(X, I, J, Val) =>
%    freeze(I, (element(I, X, Row),freeze(J,element(J,Row,Val)))).


problem(Problem) => 
Problem = 
[[33,30,10,-6,18,-7,-11,23,-6],
 [16,-19,9,-26,-8,-19,-8,-21,-14],
 [17,12,-14,31,-30,13,-13,19,16],
 [-6,-11,1,17,-12,-4,-7,14,-21],
 [18,-31,34,-22,17,-19,20,24,6],
 [33,-18,17,-15,31,-5,3,27,-3],
 [-18,-20,-18,31,6,4,-2,-12,24],
 [27,14,4,-29,-3,5,-29,8,-12],
 [-15,-7,-23,23,-9,-8,6,8,-12],
 [33,-23,-19,-4,-8,-7,11,-12,31],
 [-20,19,-15,-30,11,32,7,14,-5],
 [-23,18,-32,-2,-31,-7,8,24,16],
 [32,-4,-10,-14,-6,-1,0,23,23],
 [25,0,-23,22,12,28,-27,15,4],
 [-30,-13,-16,-3,-3,-32,-3,27,-31],
 [22,1,26,4,-2,-13,26,17,14],
 [-9,-18,3,-20,-27,-32,-11,27,13],
 [-17,33,-7,19,-32,13,-31,-2,-24],
 [-31,27,-31,-29,15,2,29,-15,33],
 [-18,-23,15,28,0,30,-4,12,-32],
 [-3,34,27,-25,-18,26,1,34,26],
 [-21,-31,-10,-13,-30,-17,-12,-26,31],
 [23,-31,-19,21,-17,-10,2,-23,23],
 [-3,6,0,-3,-32,0,-10,-25,14],
 [-19,9,14,-27,20,15,-5,-27,18],
 [11,-6,24,7,-17,26,20,-31,-25],
 [-25,4,-16,30,33,23,-4,-4,23]].
/* 

  "Einstein puzzle" in Picat.

  Translated from the LPL model in
  Tony Hurlimann "Mathematical Modelling of Puzzles and Games", page 181

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 

   N = 5,
   A = new_list(N), % Nationalities: Norwegian, Dane, Briton, Swede, German
   A :: 1..N,
   B = new_list(N), % Colors: yellow blue red green white
   B :: 1..N,
   C = new_list(N), % Pets: cat bird dog horse fish
   C :: 1..N,
   D = new_list(N), % Drinks: coffee tea milk juice water
   D :: 1..N,
   E = new_list(N), % Smokes: Dunhill Marlboro Pall-Mall Bluemaster Prince
   E :: 1..N,

   Nationalities = ["Norwegian", "Dane", "Briton", "Swede", "German"],


   all_different(A),
   all_different(B),
   all_different(C),
   all_different(D),
   all_different(E),

   A[3] #= B[3], 
   A[4] #= C[3], 
   A[2] #= D[2], 
   B[4] + 1 #= B[5], 
   B[4] #= D[1], 
   E[3] #= C[2], 
   D[3] #= 3, 
   B[1] #= E[1], 
   A[1] #= 1, 
   (E[2] #= C[1]+1 #\/ E[2] #= C[1]-1), 
   (C[4] #= E[1]+1 #\/ C[4] #= E[1]-1), 
   E[4] #= D[4], 
   B[2] #= 2, 
   A[5] #= E[5], 
   (E[2] #= D[5] + 1 #\/ E[2] #= D[5] - 1),

   solve(A ++ B ++ C ++D ++ E),

   writeln(a=A),
   writeln(b=B),
   writeln(c=C),
   writeln(d=D),
   writeln(e=E),


   printf("The %w owns the fish.\n", Nationalities[A[C[5]]]),
   nl.
/*

  Einstein puzzle in Picat.

  This is a Picat version of the OPL code presented in 
  Daniel Selman's "Einstein's Puzzle - Or, 'The Right Tool for the Job'"
  http://blogs.ilog.com/brms/2009/02/16/einsteins-puzzle/
  """
  * Norwegian cats water Dunhill yellow
  * Dane horses tea Blends blue
  * Brit birds milk Pall Mall red
  * German fish coffee Prince green
  * Sweed dogs beer Blue Master white
  """
  
  Note: I let the "Sweed" stand, it should - of course - be "Swede".

  See also:
  http://www.stanford.edu/~laurik/fsmbook/examples/Einstein%27sPuzzle.html


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   N = 5,

   % nationalities
   Brit = 1,Sweed = 2,Dane = 3,Norwegian = 4,German = 5,
   NationalitiesS = ["Brit","Sweed","Dane","Norwegian","German"],

   % animals
   Dogs = 1,Fish = 2,Birds = 3,Cats = 4,Horses = 5,
   AnimalsS = ["Dogs","Fish","Birds","Cats","Horses"],

   % drinks
   Tea = 1,Coffee = 2,Milk = 3,Beer = 4,Water = 5,
   DrinksS = ["Tea","Coffee","Milk","Beer","Water"],

   % smokes
   PallMall = 1,Dunhill = 2,Blends = 3,BlueMaster = 4,Prince = 5,
   SmokesS = ["Pall Mall","Dunhill","Blends","Blue Master","Prince"],

   % color
   Red = 1,Green = 2,White = 3,Yellow = 4,Blue = 5,
   ColorsS = ["Red","Green","White","Yellow","Blue"],
   

   % decision variables
   S = new_list(N), S :: 1..N,
   A = new_list(N), A :: 1..N,
   D = new_list(N), D :: 1..N,
   K = new_list(N), K :: 1..N,
   C = new_list(N), C :: 1..N,

   % constraints
   all_different(S),
   all_different(A),
   all_different(D),
   all_different(K),
   all_different(C),
   
   % 1. The Brit lives in a red house.
   S[Brit] #= C[Red],

   % 2. The Swede keeps dogs as pets.
   S[Sweed] #= A[Dogs],

   % 3. The Dane drinks tea.
   S[Dane] #= D[Tea],

   % 5. The owner of the Green house drinks coffee.
   C[Green] #= D[Coffee],

   % 6. The person who smokes Pall Mall rears birds.
   K[PallMall] #= A[Birds],

   % 7. The owner of the Yellow house smokes Dunhill.
   C[Yellow] #= K[Dunhill],

   % 8. The man living in the centre house drinks milk.
   D[Milk] #= 3,

   % 9. The Norwegian lives in the first house.
   S[Norwegian] #= 1,

   % 12. The man who smokes Blue Master drinks beer.
   K[BlueMaster] #= D[Beer],

   % 13. The German smokes Prince.
   S[German] #= K[Prince],

   % 4. The Green house is on the left of the White house.
   C[Green] #= C[White]-1,

   % 10. The man who smokes Blends lives next to the one who keeps cats.
   abs(K[Blends] - A[Cats]) #= 1,

   % 11. The man who keeps horses lives next to the man who smokes Dunhill.
   abs(A[Horses] - K[Dunhill]) #= 1,

   % 14. The Norwegian lives next to the blue house.
   abs(S[Norwegian] - C[Blue]) #= 1,

   % 15. The man who smokes Blends has a neighbour who drinks water.
   abs(K[Blends] - D[Water]) #= 1,

   
   Vars = S++A++D++K++C,
   solve(Vars),

   writeln(states=S),
   writeln(animals=A),
   writeln(drink=D),
   writeln(smoke=K),
   writeln(color=C),
   nl,

   foreach(I in 1..N)
      p(I,S,NationalitiesS,Nationality),
      p(I,A,AnimalsS,Animal),
      p(I,D,DrinksS,Drink),
      p(I,K,SmokesS,Smoke),
      p(I,C,ColorsS,Color),
      printf("In the %w house the %w drinks %w, smokes %w, and keeps %w.\n", 
                                         Color,Nationality,Drink,Smoke,Animal)
   end,

   % And who keep the fish?
   nth(FishId,A,Fish),
   nth(FishId,NationalitiesS,WhoFish),
   printf("It's the %w who keep the fish.\n",WhoFish),

   nl.


p(I,X,Strings,Y) =>
   nth(T,X,I),
   nth(T,Strings,Y).
/* 

  Eliza in Picat.

  ' Analogy program.

  This Picat version is based on the Prolog code from
  Leon S. Sterling: "The Art of Prolog", 2nd edition,
  page 273ff

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


/*
  Here is a sample dialog,
  from The Art of Prolog, figure 14.6, page 273.
  (Don't forget the trailing ".")

  
   Picat> cl(eliza), eliza
   [i, am, unhappy].
   How long have you been unhappy ?
   [six, months, can, you, help, me].
   What makes you think I help you ?
   [you, make, me, think, of, my, father, and, my, brother].
   Please you tell me more about father
   [I, like, teasing, father].
   Does anyone else in your family like teasing father ?
   [no, only, me].
   Please go on .
   [bye].
   [Goodbye. I hope I have helped you]


*/

go => 
  eliza,
  nl.


go2 => 
  eliza([i, am, unhappy]),
  nl.


eliza ?=> 
   Input = read_term(), eliza(Input).
eliza([bye]) ?=>
   println(['Goodbye. I hope I have helped you']).

eliza(Input) =>
   pattern(Stimulus,Response),
   match(Stimulus,Table,Input),
   match(Response,Table,Output),
   reply(Output),
   Input1 = read_term(),
   eliza(Input1).

reply(HT) ?=> 
   HT=[Head|Tail],
   print(Head), print(' '), 
   reply(Tail).
reply([]) => nl.

pattern(Stimulus,Response) ?=> 
    Stimulus = [i,am,1],
    Response = ['How',long,have,you,been,1,?].
pattern(Stimulus, Response) ?=> 
    Stimulus = [1,you,2,me],
    Response = ['What',makes,you,think,'I',2,you,?].
pattern(Stimulus, Response) ?=> 
    Stimulus = [i,like,1],
    Response = ['Does',anyone,else,in,your,family,like,1,?].
pattern(Stimulus, Response) ?=> 
    Stimulus = [i,feel,1],
    Response = ['Do',you,often,feel,that,way,?].
pattern(Stimulus, Response) ?=> 
    Stimulus = [1,X,2],
    Response = ['Please',you,tell,me,more,about,X],
    important(X).
pattern(Stimulus, Response) => 
    Stimulus = [1],
    Response = ['Please',go,on,'.'].

index(-)
important(father).
important(mother).
important(sister).
important(brother).
important(son).
important(daughter).

match(NPattern,Table,Target) ?=>
   NPattern = [N|Pattern],
   integer(N),
   lookup1(N,Table,LeftTarget),
   append(LeftTarget,RightTarget,Target),
   match(Pattern,Table,RightTarget).
match(WordPattern,Table,WordTarget) ?=>
   WordPattern = [Word|Pattern],
   WordTarget = [Word|Target],
   atom(Word),
   match(Pattern,Table,Target).
match([],_Table,Target) => Target = [].


lookup1(X,XV,V) ?=>
   XV = [(X,V)|_XVs].
lookup1(X,XV,V) => 
   XV = [(X1,_V1)|XVs],
   X != X1, 
   lookup1(X,XVs,V).


/*

  Eq10 problem in Picat.

  Standard benchmark problem.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   LD = [X1,X2,X3,X4,X5,X6,X7],
   LD :: 0..10,

      0+98527*X1+34588*X2+5872*X3+59422*X5+65159*X7 
   #= 1547604+30704*X4+29649*X6,

      0+98957*X2+83634*X3+69966*X4+62038*X5+37164*X6+85413*X7 
   #= 1823553+93989*X1,

      900032+10949*X1+77761*X2+67052*X5 
   #= 0+80197*X3+61944*X4+92964*X6+44550*X7,

      0+73947*X1+84391*X3+81310*X5 
   #= 1164380+96253*X2+44247*X4+70582*X6+33054*X7,

      0+13057*X3+42253*X4+77527*X5+96552*X7 
   #= 1185471+60152*X1+21103*X2+97932*X6,

      1394152+66920*X1+55679*X4 
   #= 0+64234*X2+65337*X3+45581*X5+67707*X6+98038*X7,

      0+68550*X1+27886*X2+31716*X3+73597*X4+38835*X7 
   #= 279091+88963*X5+76391*X6,

      0+76132*X2+71860*X3+22770*X4+68211*X5+78587*X6 
   #= 480923+48224*X1+82817*X7,

      519878+94198*X2+87234*X3+37498*X4 
   #= 0+71583*X1+25728*X5+25495*X6+70023*X7,

      361921+78693*X1+38592*X5+38478*X6 
   #= 0+94129*X2+43188*X3+82528*X4+69025*X7,

   solve(LD),
   writeln(LD).
/*

  Eq20 problem in Picat.

  Standard benchmark problem.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
        
   X = [X0,X1,X2,X3,X4,X5,X6],
   X :: 0..10,

   -76706*X0 + 98205*X1 + 23445*X2 + 67921*X3 + 24111*X4 + 
   -48614*X5 + -41906*X6
   #= 821228,
   87059*X0 + -29101*X1 + -5513*X2 + -21219*X3 + 22128*X4 +
   7276*X5 + 57308*X6
   #= 22167,
   -60113*X0 + 29475*X1 + 34421*X2 + -76870*X3 + 62646*X4 + 
   29278*X5 + -15212*X6
   #= 251591,
   49149*X0 + 52871*X1 + -7132*X2 + 56728*X3 + -33576*X4 + 
   -49530*X5 + -62089*X6
   #= 146074,
   -10343*X0 + 87758*X1 + -11782*X2 + 19346*X3 + 70072*X4 + 
   -36991*X5 + 44529*X6
   #= 740061,
   85176*X0 + -95332*X1 + -1268*X2 + 57898*X3 + 15883*X4 +
   50547*X5 + 83287*X6
   #= 373854,
   -85698*X0 + 29958*X1 + 57308*X2 + 48789*X3 + -78219*X4 +
   4657*X5 + 34539*X6
   #= 249912,
   -67456*X0 + 84750*X1 + -51553*X2 + 21239*X3 + 81675*X4 + 
   -99395*X5 + -4254*X6
   #= 277271,
   94016*X0 + -82071*X1 + 35961*X2 + 66597*X3 + -30705*X4 + 
   -44404*X5 + -38304*X6
   #= 25334,
   -60301*X0 + 31227*X1 + 93951*X2 + 73889*X3 + 81526*X4 + 
   -72702*X5 + 68026*X6
   #= 1410723,
   -16835*X0 + 47385*X1 + 97715*X2 + -12640*X3 + 69028*X4 + 
   76212*X5 + -81102*X6
   #= 1244857,
   -43277*X0 + 43525*X1 + 92298*X2 + 58630*X3 + 92590*X4 +
   -9372*X5 + -60227*X6
   #= 1503588,
   -64919*X0 + 80460*X1 + 90840*X2 + -59624*X3 + -75542*X4 + 
   25145*X5 + -47935*X6
   #= 18465,
   -45086*X0 + 51830*X1 + -4578*X2 + 96120*X3 + 21231*X4 +
   97919*X5 + 65651*X6
   #= 1198280,
   85268*X0 + 54180*X1 + -18810*X2 + -48219*X3 + 6013*X4 +
   78169*X5 + -79785*X6
   #= 90614,
   8874*X0 + -58412*X1 + 73947*X2 + 17147*X3 + 62335*X4 +
   16005*X5 + 8632*X6
   #= 752447,
   71202*X0 + -11119*X1 + 73017*X2 + -38875*X3 + -14413*X4 + 
   -29234*X5 + 72370*X6
   #= 129768,
   1671*X0 + -34121*X1 + 10763*X2 + 80609*X3 + 42532*X4 +
   93520*X5 + -33488*X6
   #= 915683,
   51637*X0 + 67761*X1 + 95951*X2 + 3834*X3 + -96722*X4 +
   59190*X5 + 15280*X6
   #= 533909,
   -16105*X0 + 62397*X1 + -6704*X2 + 43340*X3 + 95100*X4 + 
   -68610*X5 + 58301*X6
   #= 876370,
   
   solve(X),
   writeln(X).
/*

  Solve the equation in Picat.

 11x11=4 
  22x22=16 
  33x33=?
  
  This model solves the problem with four interpretations.
  
  (2013-03-11: I've seen this problem in my web server log the 
               last days. Don't know the origin.)


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   interpretation1(X1),
   writeln(x1=X1),
   interpretation2(X2),
   writeln(x2=X2),
   interpretation3(X3),
   writeln(x3=X3),
   interpretation4(X4),
   writeln(x4=X4),
   nl.

interpretation1(X) =>
   X :: 0..10000,
   (1+1) * (1+1) #= 4,
   (2+2) * (2+2) #= 16,
   (3+3) * (3+3) #= X,
   solve(X).

scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).
   
calc(X,Y,Z) =>
   Len = length(X),
   Xs = [(10**I) : I in 0..Len-1],
   scalar_product(X,Xs,Y),
   sum(X) #= Z.

interpretation2(X) =>
   X :: 0..10000,
   N = 6,
   A = new_list(N), A :: 0..9,
   B = new_list(N), B :: 0..9,
   C = new_list(N), C :: 0..9,
   calc(A, 11*11, 4),
   calc(B, 22*22, 16),
   calc(C, 33*33, X),
   solve(X).


s3(I, X) =>
   X #= 4**I.

interpretation3(X) =>
   X :: 0..10000,
   s3(1, 4),
   s3(2, 16),
   s3(3, X),
   solve(X).


s4(I, X) =>
   X #= 4*(I**I).

interpretation4(X) =>
   X :: 0..10000,
   s4(1, 4),
   s4(2, 16),
   s4(3, X),
   solve(X).

/* 

  Euler #10 in Picat.

  Problem 10
  """ 
  The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
  
  Find the sum of all the primes below two million.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% using the built-in primes/1
% 0.58s
euler10 => 
  println(sum(primes(2000000))).

% 0.82s
euler10a => 
   writeln(sum(sieve(2000000))).

sieve(N) = Res => 
   Sieve = new_array(N),
   foreach(I in 2..round(sqrt(N)), J in I*I..I..N)
      Sieve[J] := 1
   end,
   Res := [I : I in 2..N, var(Sieve[I])].


% 7.53s
% slower
euler10b =>
  Sum = 2,
  foreach(I in 3..2..2000000)
       if prime(I) then
      Sum := Sum + I
       end
  end,
  writeln(Sum).


% using list comprehension instead
% 7.44s (7.54s)
euler10c =>
  % writeln(sum([I : I in 1..2000000, prime(I)])). % 7.54s
  writeln(2+sum([I : I in 3..2..2000000, prime(I)])). % 7.46s


% 7.78s
euler10d =>
  Sum = 2, % for 2
  I = 3,
  while(I <= 2000000)
     if prime(I) then
    Sum := Sum + I
     end,
     I := I + 2
   end,
   writeln(Sum).

%
% recursion approach. 
% It seems to be slightly faster than any other of the loop/list comprehension
% approaches.
%
% 7.43s
euler10e =>
  e10e(Sum),
  println(Sum).

e10e(Sum) =>
  e10e(3,2,Sum).

e10e(N,S0,S) ?=>
  N > 2000000,
  S = S0.

e10e(N,S0,S) =>
  N <= 2000000,
  (prime(N) ->
     S1 = S0+N
    ;
     S1 = S0
  ),
  e10e(N+2,S1,S).

/* 

  Euler #11 in Picat.

  Problem 11
  """
  In the 2020 grid below, four numbers along a diagonal line have 
  been marked in red.

  ...

  The product of these numbers is 26 x 63 x 78 x 14 = 1788696.

  What is the greatest product of four adjacent numbers in any direction 
  (up, down, left, right, or diagonally) in the 20 x 20 grid?
  """


*/

% This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
% See also my Picat page: http://www.hakank.org/picat/
%

% Euler 11

p11(Mat) => Mat = 
     [[08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08],
      [49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,04,56,62,00],
      [81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,03,49,13,36,65],
      [52,70,95,23,04,60,11,42,69,24,68,56,01,32,56,71,37,02,36,91],
      [22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80],
      [24,47,32,60,99,03,45,02,44,75,33,53,78,36,84,20,35,17,12,50],
      [32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70],
      [67,26,20,68,02,62,12,20,95,63,94,39,63,08,40,91,66,49,94,21],
      [24,55,58,05,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72],
      [21,36,23,09,75,00,76,44,20,45,35,14,00,61,33,97,34,31,33,95],
      [78,17,53,28,22,75,31,67,15,94,03,80,04,62,16,14,09,53,56,92],
      [16,39,05,42,96,35,31,47,55,58,88,24,00,17,54,24,36,29,85,57],
      [86,56,00,48,35,71,89,07,05,44,44,37,44,60,21,58,51,54,17,58],
      [19,80,81,68,05,94,47,69,28,73,92,13,86,52,17,77,04,89,55,40],
      [04,52,08,83,97,35,99,16,07,97,57,32,16,26,26,79,33,27,98,66],
      [88,36,68,87,57,62,20,72,03,46,33,67,46,55,12,32,63,93,53,69],
      [04,42,16,73,38,25,39,11,24,94,72,18,08,46,29,32,40,62,76,36],
      [20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,04,36,16],
      [20,73,35,29,78,31,90,01,74,31,49,71,48,86,81,16,23,57,05,54],
      [01,70,54,71,83,51,54,69,16,92,33,48,61,43,52,01,89,19,67,48]].


euler11 => 
  p11(M),

  % rows
  Max1 = max([max(running_prod(Row, 4)) : Row in M]),
  % columns
  Max2 = max([max(running_prod(Column, 4)) : Column in M.transpose()]),   
  % diag down
  Max3 = max([max([prod([M[A+I,A+J] : A in 0..3]) : I in 1..17]) : J in 1..17]),
  % diag up
  Max4 = max([max([prod([M[I-A,J+A] : A in 0..3]) : I in 4..20]) : J in 1..17]),
  % writeln([Max1,Max2,Max3,Max4]),
  writeln(max([Max1,Max2,Max3,Max4])).

%
% Using rows() and columns() from the utils module,
% and skips all the intermediate max'es.
%
euler11b => 
  p11(M),
  writeln(max(([running_prod(Row, 4) : Row in M.rows()] ++
               [running_prod(Column, 4) : Column in M.columns()] ++
               [[prod([M[A+I,A+J] : A in 0..3]) : I in 1..17] : J in 1..17] ++
               [[prod([M[I-A,J+A] : A in 0..3]) : I in 4..20] : J in 1..17]
              ).flatten())).


%
% slices an array A [...] into slices of length SliceLen
% and returns a list List
%
array_slice(A, SliceLen) = List =>
  List = [A2 : I in 1..A.length-SliceLen,
               A2 = [ A[J] : J in I..I+SliceLen-1] ].

% running prod of a list L1 with slice length RLen -> L2
running_prod(L1, RLen) = L2 =>
  Slices = array_slice(L1, RLen),
  L2 =  [Prod : LL in Slices, Prod = prod(LL)].
/* 

  Euler #12 in Picat.

  Problem 12
  """
  The sequence of triangle numbers is generated by adding the natural numbers. 
  So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
  The first ten terms would be:

  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

  Let us list the factors of the first seven triangle numbers:

       1: 1
       3: 1,3
       6: 1,2,3,6
      10: 1,2,5,10
      15: 1,3,5,15
      21: 1,3,7,21
      28: 1,2,4,7,14,28

  We can see that the 7th triangle number, 28, is the first triangle number 
  to have over five divisors.

  Which is the first triangle number to have over five-hundred divisors?")
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% Using a map: 0.26s
euler12 => 
  garbage_collect(300_000_000),
  println("Problem 12: "),
  Len = 0,
  I = 0,
  TNum = 0,
  while (Len <= 500)
     I := I + 1,
     TNum := TNum + I,
     Map = new_map(),
     factorsMap(TNum,Map),
     Len := prod([V+1 : _=V in Map])
  end,
  println([i=I, tnum=TNum, len=Len]),
  nl.


% 0.313s
euler12a => 
  println("Problem 12: "),
  Len = 0,
  I = 0,
  TNum = 0,
  while (Len <= 500)
     I := I + 1,
     TNum := TNum + I,
     Len := prod([E+1 : E in collect4(factors(TNum))])
  end,
  
  println([i=I, tnum=TNum, len=Len]),
  nl.



% recursive version, slightly slower: 0.318s
euler12b => 
  e12b(Num,Len),
  println([num=Num,len=Len]).

e12b(Num,Len) =>
  e12b(0,0,Num,0,Len).

e12b(N,Num0,Num,Len0,Len) ?=>
  Len0 < 500,
  Num1 = Num0+N+1,
  Len1 = prod([E+1 : E in collect4(factors(Num1))]),
  e12b(N+1,Num1,Num,Len1,Len).

e12b(N,Num0,Num,Len0,Len) =>
   N > 500,
   Num=Num0,
   Len=Len0.

% table
collect2(A) = C => 
  C = [],
  foreach(I in A.remove_dups()) 
    % C := C ++ [[I, [J: J in A, J == I].length]  ]
    C := C ++ [[J: J in A, J == I].length]
  end.

% Variant (slightly slower)
collect3(A) = C => 
  M = new_map(),
  foreach(I in A) 
    M.put(I, M.get(I,0)+1)
  end,
  C = [[K,V] : K=V in M].

% a variant of collect2/1
% using sum/1 is slightly faster than using length/1
% Also, skipping the first variable in the result list.
% collect4(A) = [[I,[J: J in A, J == I].length] : I in A.remove_dups() ].
% collect4(A) = [[I,length([1: J in A, J == I])] : I in A.remove_dups() ].
collect4(A) = [sum([1: J in A, J == I]) : I in A.remove_dups() ].
% collect4(A) = [[1: J in A, J == I].len : I in A.remove_dups() ].

collect5(A) = [ [1 : V in A, V=UU ].len : UU in A.remove_dups()].



alldivisorsM(N,Div) = [Divisors,NewN] =>
   M = N,
   Divisors1 = [],
   while (M mod Div == 0) 
      Divisors1 := [Div|Divisors1],
      M := M div Div
   end,
   NewN = M,
   Divisors = Divisors1.

% table
factors(N) = Factors =>
     M = N,
     Factors1 = [],
     while (M mod 2 == 0) 
         Factors1 := Factors1 ++ [2],  
         M := M div 2 
     end,
     T = 3,
     while (M > 1, T < ceiling(sqrt(M)))
        if M mod T == 0 then
           [Divisors, NewM] = alldivisorsM(M, T),
           Factors1 := Factors1 ++ Divisors,
           M := NewM
        end,
        T := T + 2 
     end,
     if M > 1 then Factors1 := [M|Factors1] end,
     Factors = Factors1.


% factors as a map
factorsMap(N,Map) =>
     % Map = new_map(),
     M = N,
     while (M mod 2 == 0) 
         Map.put(2,Map.get(2,0)+1),
         M := M div 2 
     end,
     T = 3,
     while (M > 1, T < ceiling(sqrt(M)))
        while (M mod T == 0) 
          Map.put(T,Map.get(T,0)+1),
          M := M div T
        end,
        T := T + 2 
     end,
     if M > 1 then 
        Map.put(M,Map.get(M,0)+1) 
     end.



next_prime(N) = P =>
  M = N+2,
  while(not prime_cached(M))
    M := M+2
  end,
  P = M.

table
prime_cached(N) => prime(N).
37107287533902102798797998220837590246510135740250
46376937677490009712648124896970078050417018260538
74324986199524741059474233309513058123726617309629
91942213363574161572522430563301811072406154908250
23067588207539346171171980310421047513778063246676
89261670696623633820136378418383684178734361726757
28112879812849979408065481931592621691275889832738
44274228917432520321923589422876796487670272189318
47451445736001306439091167216856844588711603153276
70386486105843025439939619828917593665686757934951
62176457141856560629502157223196586755079324193331
64906352462741904929101432445813822663347944758178
92575867718337217661963751590579239728245598838407
58203565325359399008402633568948830189458628227828
80181199384826282014278194139940567587151170094390
35398664372827112653829987240784473053190104293586
86515506006295864861532075273371959191420517255829
71693888707715466499115593487603532921714970056938
54370070576826684624621495650076471787294438377604
53282654108756828443191190634694037855217779295145
36123272525000296071075082563815656710885258350721
45876576172410976447339110607218265236877223636045
17423706905851860660448207621209813287860733969412
81142660418086830619328460811191061556940512689692
51934325451728388641918047049293215058642563049483
62467221648435076201727918039944693004732956340691
15732444386908125794514089057706229429197107928209
55037687525678773091862540744969844508330393682126
18336384825330154686196124348767681297534375946515
80386287592878490201521685554828717201219257766954
78182833757993103614740356856449095527097864797581
16726320100436897842553539920931837441497806860984
48403098129077791799088218795327364475675590848030
87086987551392711854517078544161852424320693150332
59959406895756536782107074926966537676326235447210
69793950679652694742597709739166693763042633987085
41052684708299085211399427365734116182760315001271
65378607361501080857009149939512557028198746004375
35829035317434717326932123578154982629742552737307
94953759765105305946966067683156574377167401875275
88902802571733229619176668713819931811048770190271
25267680276078003013678680992525463401061632866526
36270218540497705585629946580636237993140746255962
24074486908231174977792365466257246923322810917141
91430288197103288597806669760892938638285025333403
34413065578016127815921815005561868836468420090470
23053081172816430487623791969842487255036638784583
11487696932154902810424020138335124462181441773470
63783299490636259666498587618221225225512486764533
67720186971698544312419572409913959008952310058822
95548255300263520781532296796249481641953868218774
76085327132285723110424803456124867697064507995236
37774242535411291684276865538926205024910326572967
23701913275725675285653248258265463092207058596522
29798860272258331913126375147341994889534765745501
18495701454879288984856827726077713721403798879715
38298203783031473527721580348144513491373226651381
34829543829199918180278916522431027392251122869539
40957953066405232632538044100059654939159879593635
29746152185502371307642255121183693803580388584903
41698116222072977186158236678424689157993532961922
62467957194401269043877107275048102390895523597457
23189706772547915061505504953922979530901129967519
86188088225875314529584099251203829009407770775672
11306739708304724483816533873502340845647058077308
82959174767140363198008187129011875491310547126581
97623331044818386269515456334926366572897563400500
42846280183517070527831839425882145521227251250327
55121603546981200581762165212827652751691296897789
32238195734329339946437501907836945765883352399886
75506164965184775180738168837861091527357929701337
62177842752192623401942399639168044983993173312731
32924185707147349566916674687634660915035914677504
99518671430235219628894890102423325116913619626622
73267460800591547471830798392868535206946944540724
76841822524674417161514036427982273348055556214818
97142617910342598647204516893989422179826088076852
87783646182799346313767754307809363333018982642090
10848802521674670883215120185883543223812876952786
71329612474782464538636993009049310363619763878039
62184073572399794223406235393808339651327408011116
66627891981488087797941876876144230030984490851411
60661826293682836764744779239180335110989069790714
85786944089552990653640447425576083659976645795096
66024396409905389607120198219976047599490197230297
64913982680032973156037120041377903785566085089252
16730939319872750275468906903707539413042652315011
94809377245048795150954100921645863754710598436791
78639167021187492431995700641917969777599028300699
15368713711936614952811305876380278410754449733078
40789923115535562561142322423255033685442488917353
44889911501440648020369068063960672322193204149535
41503128880339536053299340368006977710650566631954
81234880673210146739058568557934581403627822703280
82616570773948327592232845941706525094512325230608
22918802058777319719839450180888072429661980811197
77158542502016545090413245809786882778948721859617
72107838435069186155435662884062257473692284509516
20849603980134001723930671666823555245252804609722
53503534226472524250874054075591789781264330331690
/* 

  Euler #13 in Picat.

  Problem 13
  """ 
  Work out the first ten digits of the sum of the following 
  one-hundred 50-digit numbers.
    37107287533902102798797998220837590246510135740250
    ....
    20849603980134001723930671666823555245252804609722
    53503534226472524250874054075591789781264330331690")
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.000s
euler13 =>
   X = sum([I:I in nums()]).to_string(),
   println([X[I] : I in 1..10]).

% 0.004s
euler13b =>
   X = sum([Line.to_integer() : Line in read_file_lines("euler13_data.txt")]).to_string(),
   println([X[I] : I in 1..10]).


% From http://picat-lang.org/euler/p13.pi
% 0.000s
euler13c => 
   Sum = sum(nums()),
   Pre = new_list(10),
   append(Pre,_,Sum.to_string()),
   println(Pre).

nums() =
[37107287533902102798797998220837590246510135740250,
46376937677490009712648124896970078050417018260538,
74324986199524741059474233309513058123726617309629,
91942213363574161572522430563301811072406154908250,
23067588207539346171171980310421047513778063246676,
89261670696623633820136378418383684178734361726757,
28112879812849979408065481931592621691275889832738,
44274228917432520321923589422876796487670272189318,
47451445736001306439091167216856844588711603153276,
70386486105843025439939619828917593665686757934951,
62176457141856560629502157223196586755079324193331,
64906352462741904929101432445813822663347944758178,
92575867718337217661963751590579239728245598838407,
58203565325359399008402633568948830189458628227828,
80181199384826282014278194139940567587151170094390,
35398664372827112653829987240784473053190104293586,
86515506006295864861532075273371959191420517255829,
71693888707715466499115593487603532921714970056938,
54370070576826684624621495650076471787294438377604,
53282654108756828443191190634694037855217779295145,
36123272525000296071075082563815656710885258350721,
45876576172410976447339110607218265236877223636045,
17423706905851860660448207621209813287860733969412,
81142660418086830619328460811191061556940512689692,
51934325451728388641918047049293215058642563049483,
62467221648435076201727918039944693004732956340691,
15732444386908125794514089057706229429197107928209,
55037687525678773091862540744969844508330393682126,
18336384825330154686196124348767681297534375946515,
80386287592878490201521685554828717201219257766954,
78182833757993103614740356856449095527097864797581,
16726320100436897842553539920931837441497806860984,
48403098129077791799088218795327364475675590848030,
87086987551392711854517078544161852424320693150332,
59959406895756536782107074926966537676326235447210,
69793950679652694742597709739166693763042633987085,
41052684708299085211399427365734116182760315001271,
65378607361501080857009149939512557028198746004375,
35829035317434717326932123578154982629742552737307,
94953759765105305946966067683156574377167401875275,
88902802571733229619176668713819931811048770190271,
25267680276078003013678680992525463401061632866526,
36270218540497705585629946580636237993140746255962,
24074486908231174977792365466257246923322810917141,
91430288197103288597806669760892938638285025333403,
34413065578016127815921815005561868836468420090470,
23053081172816430487623791969842487255036638784583,
11487696932154902810424020138335124462181441773470,
63783299490636259666498587618221225225512486764533,
67720186971698544312419572409913959008952310058822,
95548255300263520781532296796249481641953868218774,
76085327132285723110424803456124867697064507995236,
37774242535411291684276865538926205024910326572967,
23701913275725675285653248258265463092207058596522,
29798860272258331913126375147341994889534765745501,
18495701454879288984856827726077713721403798879715,
38298203783031473527721580348144513491373226651381,
34829543829199918180278916522431027392251122869539,
40957953066405232632538044100059654939159879593635,
29746152185502371307642255121183693803580388584903,
41698116222072977186158236678424689157993532961922,
62467957194401269043877107275048102390895523597457,
23189706772547915061505504953922979530901129967519,
86188088225875314529584099251203829009407770775672,
11306739708304724483816533873502340845647058077308,
82959174767140363198008187129011875491310547126581,
97623331044818386269515456334926366572897563400500,
42846280183517070527831839425882145521227251250327,
55121603546981200581762165212827652751691296897789,
32238195734329339946437501907836945765883352399886,
75506164965184775180738168837861091527357929701337,
62177842752192623401942399639168044983993173312731,
32924185707147349566916674687634660915035914677504,
99518671430235219628894890102423325116913619626622,
73267460800591547471830798392868535206946944540724,
76841822524674417161514036427982273348055556214818,
97142617910342598647204516893989422179826088076852,
87783646182799346313767754307809363333018982642090,
10848802521674670883215120185883543223812876952786,
71329612474782464538636993009049310363619763878039,
62184073572399794223406235393808339651327408011116,
66627891981488087797941876876144230030984490851411,
60661826293682836764744779239180335110989069790714,
85786944089552990653640447425576083659976645795096,
66024396409905389607120198219976047599490197230297,
64913982680032973156037120041377903785566085089252,
16730939319872750275468906903707539413042652315011,
94809377245048795150954100921645863754710598436791,
78639167021187492431995700641917969777599028300699,
15368713711936614952811305876380278410754449733078,
40789923115535562561142322423255033685442488917353,
44889911501440648020369068063960672322193204149535,
41503128880339536053299340368006977710650566631954,
81234880673210146739058568557934581403627822703280,
82616570773948327592232845941706525094512325230608,
22918802058777319719839450180888072429661980811197,
77158542502016545090413245809786882778948721859617,
72107838435069186155435662884062257473692284509516,
20849603980134001723930671666823555245252804609722,
53503534226472524250874054075591789781264330331690].
/* 

  Euler #14 in Picat.

  Problem 14
  """
  The following iterative sequence is defined for the set of positive integers:

  n n/2 (n is even)
  n 3n + 1 (n is odd)

  Using the rule above and starting with 13, we generate the following 
  sequence:
  13 40 20 10 5 16 8 4 2 1

  It can be seen that this sequence (starting at 13 and finishing at 1) 
  contains 
  10 terms. Although it has not been proved yet (Collatz Problem), it is 
  thought that all starting numbers finish at 1.

  Which starting number, under one million, produces the longest chain?

  NOTE: Once the chain starts the terms are allowed to go above one million.)
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


% This is from
% http://picat-lang.org/euler/p14.pi
% (slightly adjusted)
% testing all numbers: 1.7s
% only the odd numbers: 1.5s
euler14 =>
    garbage_collect(300_000_000),
    max_chain(N,_Chain,Len),
    printf("N=%w,Len=%w%n",N,Len).

table (-,-,max)
max_chain(N,Chain,Len) =>
    % between(2,999999,N), % Original
    between(3,2,999999,N), % just checking the odd numbers
    % member(N,3..2..999999), % slightly slower
    gen(N,Chain,Len).

table (+,-,-)
gen(1,Chain,Len) => Chain=[1], Len=1.
gen(N,Chain,Len), N mod 2 ==0 => 
    gen(N div 2,Chain1,Len1),
    Chain=[N|Chain1],
    Len=Len1+1.
gen(N,Chain,Len) =>
    gen(3*N+1,Chain1,Len1),
    Chain=[N|Chain1],
    Len=Len1+1.
    
between(From,Step,To,N) =>
  between(From,To div Step,Tmp),
  N = (Tmp-From)*Step+From.



% This is 2.6s (1.96 with only odd numbers
euler14a => 
   [MaxLen, MaxN] = longest_seq(999999),
   writeln([maxLen=MaxLen, maxN=MaxN]),
   nl.

% 8.9s
euler14b => 
   [MaxLen, MaxN] = longest_seq2(999999),
   writeln([maxLen=MaxLen, maxN=MaxN]),
   nl.

% 2.78s
euler14c =>
   L=[collLength(N)=N : N in 1..10**6],
   Max=max(L),
   writeln(max=Max),
   nl.
   



% We just care about the lengths so 
% map will do fine.
% Testing all numbers 2..Limit: 2.5s
% Testing just the odd numbers: 1.96s
longest_seq(Limit) = [MaxLen, MaxN] =>

   Lens = new_map(),
   MaxLen = 0,
   MaxN = 1,
   foreach(N in 3..2..Limit) 
      M = N,
      CLen = 1,
      while (M > 1) 
        (
         Lens.has_key(M) -> 
            CLen := CLen + Lens.get(M) - 1,
            M := 1
         ; 
            M := hailstone1(M), % 2.5s
            % M := hailstone2(M),  % 3.1s
            % Without the call to hailstone1/1: 2.7s
            % (
            %    M mod 2 == 0 ->
            %    % M /\ 1 == 0 ->
            %       M := M // 2
            %       % M := M >> 1
            %    ;
            %       M := 3*M+1
            % ),
            CLen := CLen + 1
         )
      end,
      Lens.put(N, CLen),
      (
      CLen > MaxLen ->
         MaxLen := CLen,
         MaxN := N
        ;
          true
      )
   end.
   


% Without caching the lengths
longest_seq2(Limit) = [MaxLen, MaxN] =>
   MaxLen = 0,
   MaxN = 1,
   N = 1,
   while( N < Limit) 
      M = N,
      CLen = 1,
      while (M > 1) 
         M := hailstone1(M),
         CLen := CLen + 1
      end,
      if CLen > MaxLen then
         MaxLen := CLen,
         MaxN := N
      end,
      N := N + 1 
   end.


% With table: 6.2s
% Without table: 2.5s
% table
hailstone1(N) = N//2, N mod 2 == 0 => true.
hailstone1(N) = 3*N+1 => true.


% Alternative, a bit slower
% table
hailstone2(N) = H => 
   (N mod 2 == 0 ->
      H = N // 2
   ;
      H := 3*N+1
   ).

table
hailstoneseq1(N) = Seq =>
   Seq := [N],
   while (N > 1)
      N := hailstone1(N),
      Seq := Seq ++ [N]
   end.

table
hailstoneseq2(N) = Seq =>
   Seq := [N],
   while (N > 1)
      N := hailstone2(N),
      Seq := Seq ++ [N]
   end.


table
collLength(1) = 1.
collLength(2) = 2.
collLength(N) = 1+ cond(N mod 2 == 0,
                        collLength(N div 2),
                        collLength(3*N +1))./* 

  Euler #15 in Picat.

  Problem 15
  """
  Starting in the top left corner of a 22 grid, there are 6 routes 
  (without backtracking) to the bottom right corner.
  
  How many routes are there through a 2020 grid?
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


%
% The times for these versions are barely discernible, all are 
% between 0.000s and 0.004s.
%
euler15 => 
   println(prodlist2(21..40) // prodlist2(2..20)).

euler15b =>
   println(prod(21..40) / prod(2..20)).

euler15c =>
   println(prodlist(21..40) // prodlist(2..20)).


prodlist(List) = Res =>
    Res1 = 1,
    foreach(I in List) 
        Res1 := Res1 * I
    end,
    Res = Res1.

%
% recursive version
prodlist2(List) = Prod =>
  prodlist2_aux(List,1,Prod).

prodlist2_aux([], Prod0,Prod) =>
  Prod = Prod0.

prodlist2_aux([H|T], Prod0,Prod) =>
   Prod1 = H*Prod0,
   prodlist2_aux(T,Prod1,Prod)./* 

  Euler #16 in Picat.

  Problem 16
  """
  2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
  
  What is the sum of the digits of the number 2^1000?
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


% both these version are between 0s and 0.004s.

euler16 => 
  println(sum([I.to_integer() : I in (2**1000).to_string()])).

euler16b =>
  sum2((2**1000).to_string(), 0, Sum),
  println(Sum).

% recursive version
sum2([],Sum0,Sum) =>
  Sum = Sum0.

sum2([H|T],Sum0,Sum) => 
  Sum1 = H.to_integer()+Sum0,
  sum2(T,Sum1,Sum)./* 

  Euler #17 in Picat.

  """
  If the numbers 1 to 5 are written out in words: one, two, three, four, five, 
  then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
  
  If all the numbers from 1 to 1000 (one thousand) inclusive were written out in 
  words, how many letters would be used?
  
  NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) 
  contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of 
  "and" when writing out numbers is in compliance with British usage.
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

english(N) = English =>
    Divs      =  [1000000000, 1000000,  1000,       100],
    Divnames  =  ["billion", "million", "thousand", "hundred"],
    Prefixes  =  ["0", "twen", "thir", "for", "fif", "six", "seven", "eigh", "nine"],
    _Ordinals  = ["first", "second", "third", "fourth", "fifth", "sixth", "seventh",
                  "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", 
                  "fourteenth","fifteenth", "sixteenth", "seventeenth", 
                  "eighteenth", "nineteenth"],
    Cardinals =  ["one", "two", "three", "four", "five", "six", "seven",
                  "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen",
                  "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"],

    Sstr = "",
    Printed = 0,
    if N < 0 then
        Sstr := "minus" ++ Sstr,
        N := -N
    end,
    foreach(I in 1..Divs.length) 
        D = N div Divs[I],
        N := N mod Divs[I],
        if D != 0 then
	    Sstr := Sstr ++ english(D) ++ Divnames[I],
	    Printed := 1
        end
    end,
    if N > 0, Printed = 1 then
        Sstr := Sstr ++ "and"
    end,
    if N == 0 then      
        1 == 1 % dummy
    elseif N > 19 then
        D = N div 10,
        N := N mod 10,
        Sstr := Sstr ++ Prefixes[D] ++ "ty" ++ english(N)
    else 
        Sstr := Sstr ++ Cardinals[N]
    end,
    English = Sstr.



euler17 =>
    Total = 0,
    foreach(I in 1..1000) 
        Sstr = english(I),
        Total := Total + Sstr.length
    end,
    println(Total).

% recursive version
euler17b =>
  e17b(1000,0,Total),
  println(Total).

e17b(0,Total0,Total) =>
  Total = Total0.

e17b(N,Total0,Total) =>
  Total1 = Total0 + length(english(N)),
  e17b(N-1,Total1,Total)./* 

  Euler #18 in Picat.

  """
  By starting at the top of the triangle below and moving to adjacent 
  numbers on the row below, the maximum total from top to bottom is 23.

  3
  7 4
  2 4 6
  8 5 9 3

  That is, 3 + 7 + 4 + 9 = 23.

  Find the maximum total from top to bottom of the triangle below:

   75
   95 64
   17 47 82
   18 35 87 10
   20 04 82 47 65
   19 01 23 75 03 34
   88 02 77 73 07 63 67
   99 65 04 28 06 16 70 92
   41 41 26 56 83 40 80 70 33
   41 48 72 33 47 32 37 16 94 29
   53 71 44 65 25 43 91 52 97 51 14
   70 11 33 28 77 73 17 78 39 68 17 57
   91 71 52 38 17 14 91 43 58 50 27 29 48
   63 66 04 68 89 53 67 30 73 16 69 87 40 31
   04 62 98 27 23 09 70 98 73 93 38 53 60 04 23

  NOTE: As there are only 16384 routes, it is possible to solve this problem 
  by trying every route. However, Problem 67, is the same challenge with a 
  triangle containing one-hundred rows; it cannot be solved by brute force, 
  and requires a clever method! ;o)
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


euler18 =>
  euler18c.

p18(Triangle) => 
Triangle  = 
[[75],
 [95,64],
 [17,47,82],
 [18,35,87,10],
 [20, 4,82,47,65],
 [19, 1,23,75, 3,34],
 [88, 2,77,73, 7,63,67],
 [99,65, 4,28, 6,16,70,92],
 [41,41,26,56,83,40,80,70,33],
 [41,48,72,33,47,32,37,16,94,29],
 [53,71,44,65,25,43,91,52,97,51,14],
 [70,11,33,28,77,73,17,78,39,68,17,57],
 [91,71,52,38,17,14,91,43,58,50,27,29,48],
 [63,66, 4,68,89,53,67,30,73,16,69,87,40,31],
 [ 4,62,98,27,23, 9,70,98,73,93,38,53,60, 4,23]].


euler18a => 
  p18(Tri),
  M = new_map(),
  M.put(max_val,0),
  pp(1,1, Tri[1,1], Tri, M),
  writeln(max_val=M.max_val).

pp(Row, Column, Sum, Tri, M) =>
  if Sum > M.max_val then
     M.put(max_val,Sum)
  end,
  Row := Row + 1,
  if Row <= Tri.length then
    foreach(I in 0..1) 
       pp(Row,Column+I, Sum+Tri[Row,Column+I], Tri, M)
     end
  end.


euler18b => 
  p18(Tri),
  get_global_map().put(max_val,0),
  pp2(1,1, Tri[1,1], Tri),
  writeln(max_val=get_global_map().max_val).



pp2(Row, Column, Sum, Tri) =>
  G = get_global_map(),
  if Sum > G.get(max_val) then
     G.put(max_val,Sum)
  end,
  Row := Row + 1,
  if Row <= Tri.length then
    foreach(I in 0..1) 
      pp2(Row,Column+I, Sum+Tri[Row,Column+I], Tri)
    end
  end.



% Neng-Fa's approach:
% This is slightly faster than euler18a and euler18b
p18c(Triangle) => 
Triangle  = 
{{75},
{95,64},
{17,47,82},
{18,35,87,10},
{20,4,82,47,65},
{19,1,23,75,3,34},
{88,2,77,73,7,63,67},
{99,65,4,28,6,16,70,92},
{41,41,26,56,83,40,80,70,33},
{41,48,72,33,47,32,37,16,94,29},
{53,71,44,65,25,43,91,52,97,51,14},
{70,11,33,28,77,73,17,78,39,68,17,57},
{91,71,52,38,17,14,91,43,58,50,27,29,48},
{63,66,4,68,89,53,67,30,73,16,69,87,40,31},
{ 4,62,98,27,23,9,70,98,73,93,38,53,60,4,23}}.

euler18c =>
  p18c(Tri),
  pp(1,1,Tri,Sum),
  writeln(max_val=Sum).

table (+,+,+,max)  
pp(Row,_Column,Tri,Sum),Row>Tri.length => Sum=0.
pp(Row,Column,Tri,Sum) ?=> 
  pp(Row+1,Column,Tri,Sum1),
  Sum = Sum1+Tri[Row,Column].
pp(Row,Column,Tri,Sum) => 
  pp(Row+1,Column+1,Tri,Sum1),
  Sum = Sum1+Tri[Row,Column].    
/* 

  Euler #19 in Picat.

  """
  You are given the following information, but you may prefer 
  to do some research for yourself.

  * 1 Jan 1900 was a Monday.
  * Thirty days has September,
    April, June and November.
    All the rest have thirty-one,
    Saving February alone,
    Which has twenty-eight, rain or shine.
    And on leap years, twenty-nine.
  * A leap year occurs on any year evenly divisible by 4, but not 
    on a century unless it is divisible by 400.
  
  How many Sundays fell on the first of the month during the 
  twentieth century (1 Jan 1901 to 31 Dec 2000)?
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


euler19 =>
  euler19b.

euler19a => 
   Sum = 0,
   foreach(D in date2julian(1901,1,1)..date2julian(2000,12,31))
      DD = julian2date(D),
      if DD[3] == 1, dow(DD[1],DD[2],DD[3]) == 0 then
          Sum := Sum+1
      end
   end,
   println(Sum).

% Just one list comprehension.
euler19b => 
   Sum = [1 : D in date2julian(1901,1,1)..date2julian(2000,12,31), 
                  DD = julian2date(D), 
                  DD[3] == 1,
                  dow(DD[1],DD[2],DD[3]) == 0].sum(),
   println(Sum).

% recursive version
euler19c =>
  L = date2julian(1901,1,1)..date2julian(2000,12,31),
  e19c(L,0,Sum),
  println(Sum).

e19c([],Sum0,Sum) =>
  Sum = Sum0.

e19c([D|T],Sum0,Sum) =>
  DD = julian2date(D),
  (  
    DD[3] == 1,
    dow(DD[1],DD[2],DD[3]) == 0 ->
     Sum1 = Sum0 + 1
   ;
     Sum1 = Sum0
  ),
  e19c(T,Sum1,Sum).


%
% Day of week, Sakamoto's method
% http:%en.wikipedia.org/wiki/Weekday_determination#Sakamoto.27s_Method
%
dow(Y, M, D) = Dow =>
   T = [0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4],
   YY = Y,
   if M < 3 then
      YY := YY - 1
   end,
   Dow := (YY + YY div 4 - YY div 100 + YY div 400 + T[M] + D) mod 7.


%
% http://en.wikipedia.org/wiki/Julian_day
% gregorian date -> julian day
date2julian(Year,Month,Day) = JD =>
  A = floor((14-Month) / 12), % 1 for Jan or Feb, 0 for other months
  Y = Year + 4800 - A,
  M = Month + 12*A - 3, % 0 for Mars, 11 for Feb
  JD = Day + floor( (153*M + 2) / 5) + 365*Y + floor(Y/4) -
       floor(Y / 100) + floor(Y / 400) - 32045.


% julian day -> gregorian date
julian2date(JD) = Date =>
  Y=4716,
  V=3,
  J=1401,
  U=5,
  M=2,
  S=153,
  N=12,
  W=2,
  R=4,
  B=274277,
  P=1461,
  C= -38,
  F = JD + J + (((4 * JD + B) div 146097) * 3) div 4 + C,
  E = R * F + V,
  G = mod(E, P) div R,
  H = U * G + W,
  Day = (mod(H, S)) div U + 1,
  Month = mod(H div S + M, N) + 1,
  Year = (E div P) - Y + (N + M - Month) div N,
  Date = [Year,Month,Day].
/* 

  Euler #1 in Picat.

  Problem 1
  """
  If we list all the natural numbers below 10 that are multiples of 3 or 5, 
  we get 3, 5, 6 and 9. The sum of these multiples is 23.
  Find the sum of all the multiples of 3 or 5 below 1000.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go2 => 
   euler1,
   euler1b,
   euler1c,
   euler1d,
   euler1e,
   euler1f,
   euler1g,
   euler1h,
   euler1i,
   euler1j,
   euler1k,
   euler1l,
   euler1m,
   euler1n,
   euler1o,
   euler1p,
   euler1q,
   euler1r,
   euler1s,
   euler1t,
   nl.

%
% some larger limits, using the euler1t solution
%
go3 => 
  M = 100,
  foreach(I in 0..M)
    N = 10**I-1,
    println(I=e1t(3,N) + e1t(5,N) - e1t(15,N))
  end,
  nl.
  


euler1 => 
   writeln(sum([I: I in 1..999, (I mod 3== 0; I mod 5==0)])).

%
% Some alternative approaches
%
euler1b =>
   Sum = 0,
   foreach(I in 1..999)
      if I mod 3 == 0; I mod 5 == 0 then
        Sum := Sum + I
      end
   end,
   writeln(Sum).


pred1c(N) = cond((N mod 3 == 0; N mod 5 == 0), 1, 0).
euler1c => 
   writeln(sum([I*pred1c(I): I in 1..999])).

euler1d => 
   writeln(sum([cond((I mod 3 == 0; I mod 5 == 0), 1, 0)*I: I in 1..999])).

pred1e(N) => N mod 3 == 0; N mod 5 == 0.
euler1e => 
   writeln(sum([I: I in 1..999, pred1e(I)])).


pred1f(N), N mod 3 == 0 => true.
pred1f(N), N mod 5 == 0 => true.
euler1f => 
   writeln(sum([I: I in 1..999, pred1f(I)])).
   

euler1g => 
   L = findall(N, (member(N, 1..999), pred1f(N))),
   writeln(sum(L)).

% using CP and reification (this is a little contrieved)
euler1h =>  
   Len = 999,
   X = new_list(Len),
   X :: 0..1, 
   foreach(I in 1..Len) 
      I mod 3 #= 0 #\/ I mod 5 #= 0 #<=> X[I] #= 1
   end,

   Sum #= sum([I*X[I] : I in 1..Len]),
   solve(X),
   writeln(Sum).

% another CP approach
euler1i =>  
   X #= [I*(I mod 3 #= 0 #\/ I mod 5 #= 0) : I in 1..999],
   Sum #= sum(X),
   solve(X),
   writeln(Sum).

euler1j => 
   % writeln(union2(3..3..999, 5..5..999).sum()).
   writeln(remove_dups(3..3..999++5..5..999).sum()).

union2(A,B) = C =>
    bp.sort(A++B,C).

% using \/ (or) on 0/1 lists
euler1k => 
   N = 999,
   L3 = [cond(I mod 3==0,1,0) : I in 1..N],
   L5 = [cond(I mod 5==0,1,0) : I in 1..N],
   println(sum([I : {I,V} in zip(1..N, map(\/,L3,L5)), V=1])).

euler1l => 
   writeln(sum([I*cond((I mod 3== 0; I mod 5==0),1,0) : I in 1..999])).


% Using an acumulator 
p1m(N,Limit,S) => p1m(N,Limit,0,S).
p1m(N,Limit,S1,S2) ?=> 
  N > Limit, S1=S2.
p1m(N,Limit,S1,S2) ?=> 
  (N mod 3 = 0; N mod 5 = 0),
  p1m(N+1,Limit,S1+N,S2).
p1m(N,Limit,S1,S2)  => 
  p1m(N+1,Limit,S1,S2).

euler1m =>
  p1m(1,999,S),
  println(S).


euler1n => 
  ([I:I in 3..3..999 ]++[I:I in 5..5..999]).remove_dups().sum().println().

sum_mult(Limit,Mults) = sum([sum_mult1(Limit,Mult) : Mult in Mults]) - sum_mult1(Limit,prod(Mults)).
sum_mult1(Limit,Mult) = 
   Mult*((Limit div Mult)*(Limit div Mult+1) div 2). % shorter variant

euler1o => 
  println(sum_mult(999,[3,5])).


euler1p =>
  println(sum([I: I in 1..999,member(M,[3,5]), I mod M == 0])).


% analytic version
e1q(A,B) = floor((A / 2)*(1 + floor((B-A) / A))*(2 + floor((B-A) / A))).
euler1q =>
  N = 999,
  println(e1q(3,N) + e1q(5,N) - e1q(15,N)).


% another analytic version
e1r(A,B) = Ret => 
  N1=B//A,
  N2=N1+1,
  Ret=floor(A*N1*N2 / 2).

euler1r =>
  N = 999,
  println(e1r(3,N) + e1r(5,N) - e1r(15,N)).


% using triangular numbers
tri(N) = N*(1+N) // 2.
e1s(A,B) = tri(B//A)*A.
euler1s =>
  N = 999,
  println(e1s(3,N) + e1s(5,N) - e1s(15,N)).

%
% Note: This also handles the much 
% larger limit of 10**20 -> 2333333333333333333316666666666666666668
%
e1t(A,B) = X => 
  N1 = B//A, 
  X = A*N1*(N1+1) // 2.
euler1t =>
  N = 999,
  println(e1t(3,N) + e1t(5,N) - e1t(15,N)).

/* 

  Euler #20 in Picat.

  Problem 20
  """
  n! means n (n 1) ... 3 2 1

  Find the sum of the digits in the number 100!")
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler20 =>
  euler20f.

euler20a => 
  println(sum([I.to_integer() : I in 100.factorial().to_string()])).

% using fold directly
euler20b => 
  println(sum([I.to_integer() : I in fold(*,1,2..100).to_string()])).

euler20c => 
  println(map(to_integer, fold(*,1,2..100).number_chars()).sum()).

% using map2/2 for nicer chaining
euler20d => 
  println(fold(*,1,2..100).to_string().map(to_integer).sum()).

% using reduce
euler20e => 
  println(reduce(*,2..100).to_string().map(to_integer).sum()).

% using recursion
euler20f =>
  e20f(100.factorial().to_string(), 0, Sum),
  println(Sum).

e20f([],Sum0,Sum) =>
  Sum = Sum0.
e20f([H|T],Sum0,Sum) =>
  Sum1 = Sum0+H.to_integer(),
  e20f(T,Sum1,Sum)./* 

  Euler #21 in Picat.

  Problem 21
  """
  Let d(n) be defined as the sum of proper divisors of n (numbers less 
  than n which divide evenly into n).
  If d(a) = b and d(b) = a, where a /= b, then a and b are an amicable 
  pair and each of a and b are called amicable numbers.
  
  For example, the proper divisors of 220 are 
  1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. 
  The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.
  
  Evaluate the sum of all the amicable numbers under 10000.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler21 => 
  S = new_map(),
  foreach(A in 1..9999) 
     B = sum_divisors3(A),
     C = sum_divisors3(B),
     if A != B, A == C then
        S.put(A, 1),
        S.put(B, 1)
     end
  end,
  println(sum(S.keys())).

% list comprehension
euler21b => 
  Sum = [A : A in 1..9999, 
       B = sum_divisors3(A), 
       C = sum_divisors3(B),
       A != B, A == C].remove_dups().sum(),
  println(Sum).


table
sum_divisors2(N) = Sum =>
    D = floor(sqrt(N)),
    Sum1 = 1,
    foreach(I in 2..D, N mod I == 0) 
        Sum1 := Sum1+I,
        if I != N div I then
            Sum1 := Sum1 + N div I
        end
    end,
    Sum = Sum1.

% This recursive version is slightly faster than sum_divisors2/1.
table
sum_divisors3(N) = Sum =>
  sum_divisors3(2,N,1,Sum).

sum_divisors3(I,N,Sum0,Sum), I > floor(sqrt(N)) =>
  Sum = Sum0.

% I is a divisor of N
sum_divisors3(I,N,Sum0,Sum), N mod I == 0 =>
  Sum1 = Sum0 + I,
  (I != N div I -> 
    Sum2 = Sum1 + N div I 
    ; 
    Sum2 = Sum1
  ),
  sum_divisors3(I+1,N,Sum2,Sum).

% I is no divisor of N.
sum_divisors3(I,N,Sum0,Sum) =>
  sum_divisors3(I+1,N,Sum0,Sum).
/* 

  Euler #22 in Picat.

  """
  Using names.txt (right click and 'Save Link/Target As...'), a 46K 
  text file containing over five-thousand first names, begin by sorting 
  it into alphabetical order. Then working out the alphabetical value 
  for each name, multiply this value by its alphabetical position in the 
  list to obtain a name score.

  For example, when the list is sorted into alphabetical order, COLIN, 
  which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in 
  the list. So, COLIN would obtain a score of 938 53 = 49714.

  What is the total of all the name scores in the file?")
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler22 => 
   Names = split(read_file_chars("names.txt"),","),
   A = 1,
   Sum = 0,
   foreach(Name in Names.sort())
      CodeSum = sum(to_code([C : C in Name, C != '"'])), % "
      Sum := Sum + A*CodeSum,
      A := A + 1
   end,
   writeln(Sum).

% tighter
euler22b => 
   Names = split(read_file_chars("euler22_names.txt"),",").sort(),
   sum([A*sum(to_code([C:C in Name,C!='"'])):{Name,A}in zip(Names,1..Names.length)]).writeln().

% using recursive sum4/1
euler22c =>
   Names = split(read_file_chars("euler22_names.txt"),",").sort(),
   Sum = sum2(Names),
   println(Sum).

% convert a string to position code
% A=1, B=2, etc
to_code(S) = [C.ord()-64 : C in S].


sum2(Names) = Sum =>
  sum2(Names,1,1,Sum).

sum2([], _A, Sum0, Sum) =>
 Sum = Sum0.

sum2([Name|Names], A, Sum0, Sum) =>
  Sum1 = Sum0 + A*sum(to_code([C : C in Name, C != '"'])), % "
  sum2(Names,A+1,Sum1,Sum).
/* 

  Euler #23 in Picat.

  """
  A perfect number is a number for which the sum of its proper divisors 
  is exactly equal to the number. For example, the sum of the proper divisors 
  of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.

  A number n is called deficient if the sum of its proper divisors is less than 
  n and it is called abundant if this sum exceeds n.

  As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number 
  that can be written as the sum of two abundant numbers is 24. By mathematical 
  analysis, it can be shown that all integers greater than 28123 can be written 
  as the sum of two abundant numbers. However, this upper limit cannot be reduced 
  any further by analysis even though it is known that the greatest number that 
  cannot be expressed as the sum of two abundant numbers is less than this limit.

  Find the sum of all the positive integers which cannot be written as the sum of 
  two abundant numbers.
  """ 

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% inspired by a C++ solution
% 1.29s
euler23 =>
    Limit = 20161,
    Arr = new_array(Limit), bind_vars(Arr,1), 
    foreach(I in 2..Limit,J in I*2..I..Limit)
       Arr[J] := Arr[J] + I 
    end,

    Abundant = [I: I in 12..Limit, Arr[I] > I],

    /*
    foreach(A in Abundant, B in Abundant,A <= B, A+B < Limit)
       Arr[A + B] := 0
    end,
    */

    % Faster
    foreach(A in Abundant)
       Found = 0,
       foreach(B in Abundant, A <= B, Found == 0)
         if A+B < Limit then
            Arr[A + B] := 0
         else 
            Found := 1
         end
       end
    end,

    println(sum([I : I in 1..Limit, Arr[I] != 0])).


% 1.374s
euler23a1 =>
  % N = 28123, 
  % From http://mathworld.wolfram.com/AbundantNumber.html: 
  %  "Every number greater than 20161 can be expressed as a sum of two abundant numbers."
  N = 20161, 
  Abundant = [A : A in 1.. N, sum_divisors5(A) > A],
  % Vec = [0 : _I in 1..N].to_array(),
  Vec = new_array(N), bind_vars(Vec,0),
  foreach(A in Abundant, B in Abundant, A >= B, A+B <= N) 
    Vec[A+B] := 1
  end,
  println(sum([A : A in 1..N, Vec[A] == 0])).


% 1.38s
euler23a =>
  N = 20161, 
  Abundant = [A : A in 1.. N, sum_divisors2(A) > A],
  Vec = new_array(N), bind_vars(Vec,0),
  % foreach(I in 1..N) Vec[I] := 0 end,
  foreach(A in Abundant, B in Abundant) 
    if A >= B, A+B <= N then
      Vec[A+B] := 1
    end
  end,
  println(sum([A : A in 1..N, Vec[A] == 0])).


% 1.38s
euler23b =>
  N = 20161, 
  Abundant = [A : A in 1.. N, sum_divisors4(A) > A],
  Vec = new_array(N), bind_vars(Vec,0),
  % foreach(I in 1..N) Vec[I] := 0 end,
  foreach(A in Abundant, B in Abundant, A >= B, A+B <= N) 
    Vec[A+B] := 1
  end,
  println(sum([A : A in 1..N, Vec[A] == 0])).


% using map: 2.3s
euler23c =>
  N = 20161, 
  Abundant = [A : A in 1.. N, sum_divisors5(A) > A],
  Vec = new_map(),
  foreach(A in Abundant, B in Abundant, A >= B, A+B <= N) 
    Vec.put(A+B,1)
  end,
  println(sum([A : A in 1..N, not Vec.has_key(A)])).

% testing Vec var() instead: 1.396s
euler23d =>
  N = 20161, 
  Abundant = [A : A in 1.. N, sum_divisors2(A) > A],
  Vec = new_array(N), % we don't initialize this with 0
  foreach(A in Abundant, B in Abundant) 
    if A >= B, A+B <= N then
      Vec[A+B] := 1
    end
  end,
  println(sum([A : A in 1..N, var(Vec[A])])).


% 1.44s, slightly different approach (a litle slower)
euler23e =>
  N = 20161, 
  Abundant = [A : A in 1.. N, sum_divisors5(A) > A],
  Vec = (1..N).to_array(),
  foreach(A in Abundant, B in Abundant, A+B <= N, A >= B) 
    Vec[A+B] := 0
  end,
  println(sum([Vec[I] : I in 1..N])).

% using only list is very slow
euler23f =>
  N = 20161, 
  Abundant = [A : A in 1.. N, sum_divisors5(A) > A],
  Vec = (1..N),
  foreach(A in Abundant, B in Abundant, A+B <= N, A >= B) 
    Vec[A+B] := 0
  end,
  println(sum(Vec)).

% out of memory
euler23g =>
  N = 20161,
  Abundant = [A : A in 1.. N, sum_divisors5(A) > A],
  Vec = (1..N),
  foreach(A in Abundant, B in Abundant, A+B <= N, A >= B) 
    Vec := delete(Vec,A+B)
  end,
  println(sum(Vec)).



sum_divisors2(N) = Sum =>
  D = floor(sqrt(N)),
  Sum = 1,
  foreach(I in 2..D) 
     if N mod I == 0 then
       Sum := Sum+I,
       if I != N div I then
         Sum := Sum + N div I
       end
     end
  end.


sum_divisors3(N) = Sum =>
  Sum = 1,
  foreach(I in 2..floor(sqrt(N)), N mod I == 0) 
     Sum := Sum + I + cond(I != N div I,N div I, 0)
  end.

% as a sum
sum_divisors4(N) = 1+sum([I + cond(I != N div I,N div I, 0) 
                          : I in 2..floor(sqrt(N)), N mod I == 0]). 


%
% This recursive version is slightly faster than sum_divisors2/1.
%
sum_divisors5(N) = Sum =>
  sum_divisors5(2,N,1,Sum).

% Part 0: base case
sum_divisors5(I,N,Sum0,Sum), I > floor(sqrt(N)) =>
  Sum = Sum0.

% Part 1: I is a divisor of N
sum_divisors5(I,N,Sum0,Sum), N mod I == 0 =>
  Sum1 = Sum0 + I,
  (I != N div I -> 
    Sum2 = Sum1 + N div I 
    ; 
    Sum2 = Sum1
  ),
  sum_divisors5(I+1,N,Sum2,Sum).

% Part 2: I is no divisor of N.
sum_divisors5(I,N,Sum0,Sum) =>
  sum_divisors5(I+1,N,Sum0,Sum).


% very slow
is_abundant(J) =>
  Divisors = 0,
  Loop = 1,
  foreach(N in 2..J, N*N <= J, Loop == 1)
    if J mod N == 0 then
       Divisors := Divisors + N,
       if N < J div N then
          Divisors := Divisors + J div N
       end,
       if J <= Divisors then
         Loop := 0
       end
    end
  end,
  J <= Divisors.

/* 

  Euler #24 in Picat.

  """
  A permutation is an ordered arrangement of objects. For example, 3124 is one 
  possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are 
  listed numerically or alphabetically, we call it lexicographic order. The 
  lexicographic permutations of 0, 1 and 2 are:
   
      012   021   102   120   201   210
  
  What is the millionth lexicographic permutation of the digits 
  0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?
  """ 


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.0s
% inspired by a solution on the 'net
euler24 =>
   N = 999999,
   P = 10,
   Eli = [I mod 10 : I in 1..P],
   Answer = [],
   foreach(I in 1..P-1) 
      F = factorial(P-I),
      D = N // F,
      N := N mod F,
      Answer := Answer ++ [Eli[D]],
      Eli := Eli.delete(Eli[D])
   end,
   println([E.to_string(): E in Answer ++ Eli].flatten()),
   nl.

% about 1.09s
euler24a =>
  L = 0..9,
  C = 1,
  while (C < 1000000) 
    L := next_permutation(L),
    C := C + 1
  end,
  println([I.to_string() : I in L].flatten()).

% Using CP: 2.05s
euler24b => 
  % garbage_collect(70_000_000), % stack overflow
  % garbage_collect(80_000_000), % 5.1s
  garbage_collect(90_000_000), % 2.05s
  % garbage_collect(100_000_000), % 2.06s
  P = alldiff(10),
  writeln(P[1000000]).


% Using permutations/1: 8.88s
euler24c =>
   P = permutations(0..9).sort(),
   println(P[1000000]),
   nl.


% 1.101s
euler24d =>
  nth_solution($permutation(0..9,L), 1000000),
  println([I.to_string() : I in L]).


% 5.22s
euler24e =>
  L = 0..9,
  C = 1,
  while (C < 1000000) 
    next_higher_permutation(L,L2),
    L := L2,
    C := C + 1
  end,
  println([I.to_string() : I in L].flatten()).


nth_solution(Goal, N) =>
  get_global_map().put(solcount,1), 
  call(Goal),
  C = get_global_map().get(solcount),
  if C < N then get_global_map().put(solcount,C+1), fail end.


next_permutation(P) = Perm =>
   Perm1 = P,
   N = Perm1.length,
   K = N - 1,
   while (Perm1[K] > Perm1[K+1], K >= 0) 
      K := K - 1
   end,
   if K > 0 then
      J = N,
      while (Perm1[K] > Perm1[J])  J := J - 1 end,      
      % [Perm1[K],Perm1[J]] = [Perm1[J], Perm1[K]], % don't work
      Tmp := Perm1[K],
      Perm1[K] := Perm1[J],
      Perm1[J] := Tmp,
      R = N, 
      S = K + 1,
      while (R > S) 
         % [Perm1[R],Perm1[S]] = [Perm1[S],Perm1[R]], % don't work
         Tmp := Perm1[R],
         Perm1[R] := Perm1[S],
         Perm1[S] := Tmp,
         R := R - 1, 
         S := S + 1
      end
   end,
   Perm = Perm1.

% CP version.
% solve_all/1 happens to yield all 
% permutations in correct order.
alldiff(N) = Perms =>
  P = new_list(N),
  P :: 0..N-1,
  all_different(P),
  Perms = solve_all(P).

%
% next_higher_permutation/2
%
% From T. Van Le, "Techniques of Prolog Programming", page 100f
% 
next_higher_permutation(L,L1) => 
   reverse3(L,[],L2),
   append(A,[X,Y|B],L2), X > Y,
   append(A,[X],C),
   append(A1,[U|B1],C), U > Y,
   append(A1,[Y|B1], B2),
   reverse3([U|B], B2,L1).

%
% reverse3/3
%
% From T. Van Le, "Techniques of Prolog Programming", page 99
reverse3([],R1,R2) => R1=R2.
reverse3([H|T],R,L1) => reverse3(T,[H|R],L1).

random_perm(L,N) = Perm => 
  Perm = L,
  Len = L.length,
  foreach(_I in 1..N) 
     R1 = 1+(random2() mod Len),
     R2 = 1+(random2() mod Len),
     T = Perm[R1],
     Perm[R1] := Perm[R2],
     Perm[R2] := T
  end.
/* 

  Euler #25 in Picat.

  """
  The Fibonacci sequence is defined by the recurrence relation:

     Fn = Fn1 + Fn2, where F1 = 1 and F2 = 1.
  
  Hence the first 12 terms will be:

     F1 = 1
     F2 = 1
     F3 = 2
     F4 = 3
     F5 = 5
     F6 = 8
     F7 = 13
     F8 = 21
     F9 = 34
     F10 = 55
     F11 = 89
     F12 = 144

  The 12th term, F12, is the first term to contain three digits.

  What is the first term in the Fibonacci sequence to contain 1000 digits?")
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.4s
euler25 => 
    Target = 1000,
    FoundUpper = 0,
    I = 1,
    FibLen = 0,
    Step = 43,
    % Get the upper limit
    while(FibLen < Target, FoundUpper == 0)
       FibLen := fib_len(Step*I),
       if  FibLen > Target then
         FoundUpper := I
       end,
       I := I + 1 % jump to the next step
    end,
    % Now check all numbers from Step*(FoundUpper-1) .. Step*FoundUpper
    % The target must be in that interval.
    Fib = Step*(FoundUpper-1),
    FibLen := fib_len(Fib),
    while(FibLen < Target, Fib <= Step*FoundUpper) 
       FibLen := fib_len(Fib),
       Fib := Fib + 1
    end,
    writeln([fib=Fib,fibLen=FibLen]),
    nl.
    

% 11.7s
% (to_string() is not very fast in Picat)
euler25b =>
    F1 = 1,
    F2 = 1,
    Len = 1,
    Ix = 2,
    while (Len < 1000) 
       Tmp = F1,
       F1 := F2,
       F2 := Tmp + F1,
       Len := F2.to_string().length,
       Ix := Ix + 1
    end,
    writeln([Ix,Len]),
    nl.


% 11.9s
euler25c => 
    I = 1,
    Len = 0,
    while (Len < 1000) 
       Fib := fib(I),
       Len := Fib.to_string().length,
       % Len := nlen(Fib),
       I := I + 1
    end,
    writeln([I,Len]).

%% using int_len: 1min 47s
% using int_len2/2 is much faster: 0.72s
euler25d =>
    F1 = 1,
    F2 = 1,
    Len = 1,
    Ix = 2,
    while (Len < 1000) 
       Tmp = F1,
       F1 := F2,
       F2 := Tmp + F1,
       % Len := int_len(F2),
       Len := int_len2(F2,Len),
       Ix := Ix + 1
    end,
    writeln([ix=Ix,len=Len]),
    nl.

%
% a little bit slower than euler25d: 0.76s
%
euler25e =>
    Len = 1,
    N = 2,
    while (Len < 1000) 
       Len := int_len2(fib(N),Len),
       N := N+1
    end,
    writeln([n=N,len=Len]),
    nl.



table
fib_len(I) = fib(I).to_string().length.
% fib_len(I) = fib(I).number_chars().length.

% From 
% http://www.had2know.com/academics/number-digits-length-fibonacci-number.html
% 
% Nope: It's not that exact, it differ by 1 sometimes:
%   Picat> L=[ fib_len(I)-fib_len2(I) : I in 1..1000].sum()
%  L = 209
%   Picat> L=[ I : I in 1..100, fib_len(I)-fib_len2(I) != 0]         
%  L = [1,6,11,16,20,25,30,35,39,44,49,54,59,63,68,73,78,83,87,92,97]
fib_len2(N) = floor(N*log10((1+sqrt(5))/2) - log10(5)/2 + 1).


table
fib(0)=1.
fib(1)=1.
fib(N)=F,N>1 => F=fib(N-1)+fib(N-2).


% float overflow after I=1475 (length 309)
nlen(N) = floor(log10(N))+1.

% using this it takes 1min47s.
int_len(V) = Len =>
  Len1=1,
  while (V > 9)
     Len1 := Len1 + 1,
     V := V div 10
  end,
  Len = Len1.

%
% This is much faster than int_len/1 (1.47s)
%
% For this application we know that Len must be
% greater or equal that the last length (OldLen).
%
int_len2(V,OldLen) = Len =>
  I = OldLen,
  while(V > 10**I)
    I := I+1
  end,
  Len := I.
/* 

  Euler #26 in Picat.

  """
  A unit fraction contains 1 in the numerator. The decimal representation of the 
  unit fractions with denominators 2 to 10 are given:

      1/2	= 	0.5
      1/3	= 	0.(3)
      1/4	= 	0.25
      1/5	= 	0.2
      1/6	= 	0.1(6)
      1/7	= 	0.(142857)
      1/8	= 	0.125
      1/9	= 	0.(1)
      1/10	= 	0.1

  Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be 
  seen that 1/7 has a 6-digit recurring cycle.

  Find the value of d < 1000 for which 1/d contains the longest recurring cycle in 
  its decimal fraction part.
  """ 


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.024s
euler26 =>
    MaxLen = 0,
    MaxD = 0,
    foreach (D in 2..999) 
      if prime(D) then
        Len = get_rep_len(D),
        if Len > MaxLen then
          MaxLen := Len,
          MaxD := D
        end
      end
    end,
    println([maxD=MaxD,maxLen=MaxLen]).

% 0.028s
euler26b =>
   M = [[get_rep_len(D),D]: D in 2..999, prime(D)].sort_down().first(),
   writeln(M).

% slighly slower than euler26/0: 0.025s
euler26c =>
  e26c(2,999,MaxD,MaxLen),
  println([d=MaxD,len=MaxLen]).

e26c(From,To,MaxD,MaxLen) =>
  e26c(From,To,0,MaxD,0,MaxLen).

e26c(From,To,MaxD0, MaxD,MaxLen0,MaxLen), From = To =>
  MaxLen = MaxLen0,
  MaxD = MaxD0.

e26c(From,To,MaxD0,MaxD,MaxLen0,MaxLen), prime(From) =>
  Len = get_rep_len(From),
  ( Len > MaxLen0 ->
      MaxLen1 = Len,
      MaxD1 = From
   ;
      MaxLen1 = MaxLen0,
      MaxD1 = MaxD0
  ),
  e26c(From+1,To,MaxD1,MaxD,MaxLen1,MaxLen).

e26c(From,To,MaxD0,MaxD,MaxLen0,MaxLen) =>
  e26c(From+1,To,MaxD0,MaxD,MaxLen0,MaxLen).



%
% Get the length of the repeating cycle for 1/n
%
get_rep_len(I) = Len => 
    FoundRemainders = [0 : _K in 1..I+1].to_array(),
    Value = 1,
    Position = 1,
    while (FoundRemainders[Value+1] == 0, Value != 0) 
        FoundRemainders[Value+1] := Position,
        Value := (Value*10) mod I,
        Position := Position+1
    end,
    Len = Position-FoundRemainders[Value+1].


/* 

  Euler #27 in Picat.

  """
  Euler published the remarkable quadratic formula:

  n^2 + n + 41

  It turns out that the formula will produce 40 primes for the consecutive values 
  n = 0 to 39. However, when n = 40, 402 + 40 + 41 = 40(40 + 1) + 41 is divisible by 
  41, and certainly when n = 41, 41^2 + 41 + 41 is clearly divisible by 41.

  Using computers, the incredible formula  n^2  79n + 1601 was discovered, which 
  produces 80 primes for the consecutive values n = 0 to 79. The product of the 
  coefficients, 79 and 1601, is 126479.

  Considering quadratics of the form:

      n^2 + an + b, where |a| < 1000 and |b| < 1000

      where |n| is the modulus/absolute value of n
      e.g. |11| = 11 and |4| = 4

  Find the product of the coefficients, a and b, for the quadratic 
  expression that produces the maximum number of primes for consecutive 
  values of n, starting with n = 0.
  
  """ 


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.91s
euler27 =>
    T = 999,
    BestLen = 0,
    BestA = 0,
    BestB = 0,
    foreach(A in -T..T, B in -T..T)
       % Len = p2(A,B),
       Len = 0,
       PP = Len**2 + A*Len + B,
       while (PP > 1, prime_cached(PP)) 
          Len := Len + 1,
          PP := Len**2 + A*Len + B
       end,

       if Len > BestLen then
           BestLen := Len,
           BestA := A,
           BestB := B
       end
    end,
    % println([besta=BestA,bestB=BestB,bestLen=BestLen, answer=BestA*BestB]).
    println(BestA*BestB).

% 7.6s
euler27b =>
    T = 999,
    L = [[Len,A*B,A,B] : A in -T..T, B in -T..T, Len = p2(A,B)].sort_down(),
    M = L[1],
    writeln([len=M[1],value=M[2],a=M[3],b=M[4]]).

% 1.16s
euler27c =>
    T = 999,
    BestLen = 0,
    BestA = 0,
    BestB = 0,
    foreach(A in -T..T, B in -T..T, Len = p2(A,B), Len > BestLen)
       BestLen := Len,
       BestA := A,
       BestB := B
    end,
    println([besta=BestA,bestB=BestB,bestLen=BestLen, answer=BestA*BestB]).

% 1.18s
euler27d =>
   T = 999,
   L = [[Len,A*B] : A in -T..T, B in -T..T, Len = p2(A,B), Len > 0],
   Max = max([X[1] : X in L]),
   println([X : X in L, X[1] == Max]).


p2(A,B) = N =>
  N1 = 0,
  PP = N1**2 + A*N1 + B,
  % PP := pp(A,B,N1),
  while (PP > 1, prime_cached(PP)) 
    N1 := N1 + 1,
    PP := N1**2 + A*N1 + B
    % PP := pp(A,B,N1) % N1**2 + A*N1 + B
  end,
  N = N1.

pp(A,B,N1) = N1**2 + A*N1 + B.

% just caching the built-in prime/1 function
table
prime_cached(N) => prime(N).
/* 

  Euler #28 in Picat.

  Problem 28
  """
  Starting with the number 1 and moving to the right in a clockwise 
  direction a 5 by 5 spiral is formed as follows:
  
     21 22 23 24 25
     20  7  8  9 10
     19  6  1  2 11
     18  5  4  3 12
     17 16 15 14 13

  It can be verified that the sum of the numbers on the diagonals is 101.
  
  What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler28 => 
   S = 1,
   N = 3,
   while (N <= 1001)
      S := S + 4 * N**2 - 6 * N + 6,
      N := N + 2
   end,
   println(S).

% list comprehension
euler28b => 
   println( 1 + sum([ 4*N**2 - 6*N + 6 : N in 3..2..1001]))./* 

  Euler #29 in Picat.

  """
  Consider all integer combinations of a^b for 2 <= a <= 5 and 2 <= b <= 5:

      2^2=4, 2^3=8, 2^4=16, 2^5=32
      3^2=9, 3^3=27, 3^4=81, 3^5=243
      4^2=16, 4^3=64, 4^4=256, 4^5=1024
      5^2=25, 5^3=125, 5^4=625, 5^5=3125

  If they are then placed in numerical order, with any repeats removed, we get the 
  following sequence of 15 distinct terms:

  4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

  How many distinct terms are in the sequence generated by a^b for 
  2 <= a <= 100 and 2 <= b <= 100?
  """ 


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.180s
euler29 => 
  Min = 2,
  Max = 100,
  Hash = new_map(),
  foreach (A in Min..Max, B in Min..Max)
     Hash.put(A**B,1)
  end,
  println(Hash.keys().length).

% 0.188s
euler29b => 
  Min = 2,
  Max = 100,
  println(new_map([(A**B=1) : A in Min..Max, B in Min..Max]).keys().length).

% 1.267s
euler29c => 
  Range = 2..100,
  println([A**B : A in Range, B in Range].remove_dups().length).


% 1.22s
euler29d =>
  Min = 2,
  Max = 100,
  Found = [],
  foreach(A in Min..Max, B in Min..Max) 
    AB = A**B,
    if not(membchk(AB, Found)) then
      Found := Found ++ [AB]
    end
  end,
  println(Found.length).  

% 0.188s
euler29e =>
  Min = 2,
  Max = 100,
  Found = new_map(),
  foreach(A in Min..Max, B in Min..Max) 
    AB = A**B,
    if not(Found.has_key(AB)) then
      Found.put(AB,1)
    end
  end,
  println(Found.keys().length).  

/* 

  Euler #2 in Picat.

  Problem 2
  """
  Each new term in the Fibonacci sequence is generated by adding the 
  previous two terms. By starting with 1 and 2, the first 10 terms will be:

  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

  Find the sum of all the even-valued terms in the sequence which do not 
  exceed four million.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler2 => 
   writeln(sum([F : N in 1..100, F = fibt(N), F < 4000000, F mod 2 =:= 0])).

% from exs.pi
table
fibt(0)=1.
fibt(1)=1.
fibt(N)=F,N>1 => F=fibt(N-1)+fibt(N-2).


euler2b => 
  I = 1,
  Sum = 0,
  F = fibt(I),
  while (F < 400000) 
     if F mod 2 == 0 then
        Sum := Sum + F
     end,
     I := I + 1,
     F := fibt(I)
  end,
  writeln(Sum).

%
% Using non tabled fib. Very slow.
%
euler2c => 
   writeln(sum([F : N in 1..100, F = fibt2(N), F < 4000000, F mod 2 =:= 0])).


% acumulator
euler2d =>
  e2d(1,4000000,0,0,S),
  println(S).

e2d(_N,Limit,F, S1,S2) ?=>
  F >=  Limit,
  S2 = S1.
e2d(N,Limit,F,S1,S2) ?=> 
  F < Limit,
  F2 = fibt(N),
  F2 mod 2 = 0,
  e2d(N+1,Limit,F2, S1+F,S2).
e2d(N,Limit,F,S1,S2) =>
  e2d(N+1,Limit,F,S1,S2).

% Not tabled
% table
fibt2(0)=1.
fibt2(1)=1.
fibt2(N)=F,N>1 => F=fibt2(N-1)+fibt2(N-2).
/* 

  Euler #30 in Picat.

  Problem 30  
  """
  Surprisingly there are only three numbers that can be written 
  as the sum of fourth powers of their digits:

     1634 = 1^(4) + 6^(4) + 3^(4) + 4^(4)
     8208 = 8^(4) + 2^(4) + 0^(4) + 8^(4)
     9474 = 9^(4) + 4^(4) + 7^(4) + 4^(4)

  As 1 = 1^(4) is not a sum it is not included.

  The sum of these numbers is 1634 + 8208 + 9474 = 19316.

  Find the sum of all the numbers that can be written as the sum of 
  fifth powers of their digits.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.584s
euler30 =>
   println(sum([N : N in 10..6*9**5,
                N == sum([I**5 : I in [J.to_integer() : J in N.to_string()]])])).

% 0.634s
euler30b => 
   T = 0,
   M = 5,
   foreach(N in 10..6*9**5)
     println(n=N),
     if N == sum([I**M : I in [J.to_integer() : J in N.to_string() ]]) then
       println(xxxxx=N),
       T := T + N
     end
   end,
   println(T).


% Caching .to_integer() it's slower: 0.674s
euler30c =>
   println(sum([N : N in 10..6*9**5,
                N == sum([I**5 : I in [toint(J) : J in N.to_string()]])])).


euler30d => 
   Sum = 0,
   N = 10,
   while(N <= 6*9**5)
     Sum := Sum + cond(N==sum([I**5 : I in [J.to_integer() : J in N.to_string()]]),N,0),
     N := N+1
   end,
   println(Sum),
   nl.


table
toint(J) = J.to_integer().
/* 

  Euler #31 in Picat.

  Problem 31
  """
  In England the currency is made up of pound, , and pence, p, and 
  there are eight coins in general circulation:

     1p, 2p, 5p, 10p, 20p, 50p, 1 (100p) and 2 (200p).

  It is possible to make 2 in the following way:

     11 + 150p + 220p + 15p + 12p + 31p

  How many different ways can 2 be made using any number of coins?
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.000s
euler31 => 
   Coins = [200,100,50,20,10,5,2,1],
   T = coins(Coins, 200, 1),
   println(T).

% using cp: 0.076s
euler31b => 
   Coins = [200,100,50,20,10,5,2,1],
   X = new_list(Coins.length),
   X :: 0..200,
   scalar_product(Coins, X, 200),
   writeln(solve_all(X).length).


% using cp with some stricter domains: 0.072s
euler31c => 
   Coins = [200,100,50,20,10,5,2,1],
   X = new_list(Coins.length),
   Max = max(Coins),
   foreach(I in 1..Coins.length)
     X[I] :: 0..Max div Coins[I]
   end,
   scalar_product(Coins, X, 200),
   writeln(solve_all(X).length).

% From http://picat-lang.org/euler/p31.pi
% 0.48s
euler31d => 
   Vars = [A, B, C, D, E, F, G, H],
   Vars :: 0 .. 200,
   1 * A + 2 * B + 5 * C + 10 * D + 20 * E + 50 * F + 100 * G + 200 * H #= 200,
   println(solve_all(Vars).length).



% without table: 0.048s
% with table: 0.000s
table
coins(Coins, Money, M) = Sum =>
    Sum1 = 0,
    Len = Coins.length,
    if M == Len then
      Sum1 := 1
    else 
       foreach(I in M..Len)
         if Money - Coins[I] == 0 then
            Sum1 := Sum1 + 1
         end,
         if Money - Coins[I] > 0 then
            Sum1 := Sum1 + coins(Coins, Money-Coins[I], I)
         end
       end
    end,
    Sum = Sum1.



scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).

/* 

  Euler #32 in Picat.

  Problem 32
  """
  We shall say that an n-digit number is pandigital if it makes use of 
  all the digits 1 to n exactly once; for example, the 5-digit number, 
  15234, is 1 through 5 pandigital.

  The product 7254 is unusual, as the identity, 39  186 = 7254, 
  containing multiplicand, multiplier, and product is 1 through 9 
  pandigital.

  Find the sum of all products whose multiplicand/multiplier/product 
  identity can be written as a 1 through 9 pandigital.
  HINT: Some products can be obtained in more than one way so be sure 
  to only include it once in your sum.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% using CP: 0.02s
euler32 =>
  L = findall(Res, pandigital(Res)).remove_dups(),
  writeln(sum(L)).


% % 1.5s
euler32b => 
  Sum = 0,
  ProdHash = new_map(),
  foreach (A in 2..98, B in A+1..9876)
     Prod = A*B,
     L = A.to_string() ++ B.to_string() ++ Prod.to_string(),
     if L.length == 9, not(membchk('0',L)) then
        Hash = new_map([(I.to_int()=1) : I in L]),
        if Hash.keys().length == 9, not ProdHash.has_key(Prod) then
           % println([a=A, b=B, prod=Prod,l=L]),
           Sum := Sum + Prod,
           ProdHash.put(Prod,1)
        end
     end
  end,
  println(Sum).

% slightly different version: skipping Sum
euler32c => 
  ProdHash = new_map(),
  foreach (A in 2..98, B in A+1..9876)
     Prod = A*B,
     L = A.to_string() ++ B.to_string() ++ Prod.to_string(),
     if L.length == 9, not(membchk('0',L)) then
        Hash = new_map([(I.to_int()=1) : I in L]),
        if Hash.keys().length == 9, not ProdHash.has_key(Prod) then
           % println([a=A, b=B, prod=Prod,l=L]),
           ProdHash.put(Prod,1)
        end
     end
  end,
  println(ProdHash.keys().sum()).



%
% converts a number Num to/from a list of integer List given a base Base
%
to_num(List, Base, Num) =>
  Len = length(List),
  Num #= sum([List[I]*Base**(Len-I) : I in 1..Len]).

% cp approach: Find a proper pandigial number
pandigital(Res) =>

  % the different lengths
  Len1 :: 1..2,
  Len2 :: 3..4,
  Len3 #= 4,

  % must be a 9 digit number
  Len1 + Len2 + Len3 #= 9,

  indomain(Len1), % must be instantiated

  X1 = new_list(Len1),
  X1 :: 1..9,

  X2 = new_list(Len2),
  X2 :: 1..9,

  X3 = new_list(Len3), % the result
  X3 :: 1..9,

  Vars = X1 ++ X2 ++ X3,
  all_different(Vars),

  % convert to number
  Base = 10,
  to_num(X1, Base, Num1),
  to_num(X2, Base, Num2),
  to_num(X3, Base, Res),

  % calculate result
  Num1 * Num2 #= Res,


  solve([ff,split],Vars).

/* 

  Euler #33 in Picat.

  """
  The fraction 49/98 is a curious fraction, as an inexperienced mathematician in 
  attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, 
  is obtained by cancelling the 9s.

  We shall consider fractions like, 30/50 = 3/5, to be trivial examples.

  There are exactly four non-trivial examples of this type of fraction, less than 
  one in value, and containing two digits in the numerator and denominator.

  If the product of these four fractions is given in its lowest common terms, find 
  the value of the denominator.
  """ 


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler33 => 
  S = 1,
  foreach(Y in 1..9,Z in Y..9)
     X = 9.0*Y*Z/(10.0*Y-Z),
     if 1.0*floor(X)==X*1.0, Y/Z < 1.0, X < 10.0 then
       S := (S*Y)/Z % ,
       % ,println([x=X,y=Y, z=Z, (floor(10*Y+X)),"/", (floor(Z+10*X)), "s*y"=(S*Y), Y,"/",Z, floor(1/S)])
     end
  end,
  println(floor(1/S)).
/* 

  Euler #34 in Picat.

  Problem 34
  """
  145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.
  
  Find the sum of all numbers which are equal to the sum of the 
  factorial of their digits.

  Note: as 1! = 1 and 2! = 2 are not sums they are not included.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% caching .to_integer().factorial()
% 0.112s
euler34 =>
  Sum = 0,
  foreach(N in 10..100_000)
    if N = sum([I.tointfact() : I in N.to_string()]) then
      Sum := Sum + N
    end
  end,
  println(Sum).

% 0.168s
euler34b =>
  Sum = 0,
  foreach(N in 10..100000)
     % if N = sum([I.to_integer().factorial() : I in N.to_string()]) then
     if N = sum([tointfact(I) : I in N.to_string()]) then
        Sum := Sum + N
     end
  end,
  println(Sum).

% 0.172s
euler34c => 
  Sum = sum([ N : N in 10..100000, 
              % N = sum([I.to_integer().factorial() : I in N.to_string()])]),
              N = sum([I.tointfact() : I in N.to_string()])]),
  println(Sum).

% 0.036
euler34d => 
    Total = 0,
    foreach(N in 2..5)
       All = findall(Sum,find_fact(N, Sum, _Digits)),
       if All != [] then
          Total := Total + sum(All)
       end
    end,
    println(total=Total),
    nl.


table
tointfact(I) = I.to_integer().factorial().


% plain cp, using element/3
find_fact(N, Value, Digits) =>
    Digits = new_list(N),
    Digits :: 0..9,
    Digits[N] #> 0,
    Factorial = [factorial(I) : I in 0..9],
    Value #= sum([Digits[I] * 10**(I-1) : I in 1..N]),
    Fact = new_list(N),
    Fact :: Factorial,
    Value #= sum(Fact),
    foreach(I in 1..N) 
      D #= Digits[I]+1, % adjusting for 0
      element(D, Factorial, Fact[I])
    end,
    solve([ffc,split], Fact ++ Digits ++ [Value]).
/* 

  Euler #35 in Picat.

  Problem 35
  """
  The number, 197, is called a circular prime because all rotations 
  of the digits: 197, 971, and 719, are themselves prime.

  There are thirteen such primes below 100: 
  2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.

  How many circular primes are there below one million?
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% Using a map: 0.46s
euler35 => 
  garbage_collect(200_000_000),
  % PrimesMap = new_map([P=1 : P in primes(1000000)]),
  PrimesMap = new_map(100000,[P=1 : P in primes(1000000)]),
  % PrimesMap = new_set(primes(1000000)),
  NumCircularPrimes = 0,
  foreach(N=_V in PrimesMap) 
    if is_circular_prime2(N,PrimesMap) then
       NumCircularPrimes := NumCircularPrimes + 1
    end
  end,
  println(NumCircularPrimes).


% 2.88s
euler35b => 
  NumCircularPrimes = 0,
  Primes = primes(1000000),
  foreach(N in Primes) 
    if is_circular_prime(N) then
       NumCircularPrimes := NumCircularPrimes + 1
    end
  end,
  println(NumCircularPrimes).


% Note: Running euler35c after euler35b gives
%       unreliable results since then prime_cached/1 are then cached.
% 2.688s
euler35c =>
  println([1:P in primes(1000000), is_circular_prime(P)].length). 


%
% check is a number (a prime) is a circular prime
%
% table
is_circular_prime(P) =>
  S = P.to_string(),
  Size = S.length,
  V = P,
  foreach(I in 2..Size, prime_cached(V)) 
      V := ([S[J] : J in I..Size] ++ [S[J] : J in 1..I-1]).to_integer()
  end,
  prime_cached(V).


% using a map of the primes/1 instead of via prime_chaced/1
is_circular_prime2(P,PrimeMap) =>
  S = P.to_string(),
  Size = S.len,
  V = P,
  foreach(I in 2..Size,PrimeMap.has_key(V)) 
      V := ([S[J] : J in I..Size] ++ [S[J] : J in 1..I-1]).to_integer()
  end,
  PrimeMap.has_key(V).


table
prime_cached(N) => prime(N).

/* 

  Euler #36 in Picat.

  Problem 36
  """
  The decimal number, 585 = 1001001001_(2) (binary), is palindromic 
  in both bases.
  
  Find the sum of all numbers, less than one million, which are palindromic 
  in base 10 and base 2.

  (Please note that the palindromic number, in either base, may not 
   include leading zeros.)
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.528s
euler36 =>
   println(sum([N : N in 1..999999, is_palindromic(N), 
                                    Bin = dec_to_base(N,2),
                                    Bin == Bin.reverse()])).

% 0.554s
euler36a =>
   Res = 0,
   foreach(N in 1..999999)
       if is_palindromic(N) then
          Bin = dec_to_base(N, 2),
          if Bin == Bin.reverse() then
            Res := Res + N
          end
       end
   end,
   println(Res).

% 0.54s
euler36b =>
   println(sum([N : N in 1..999999, is_palindromic(N), 
                                    is_palindromic(N.to_binary_string())])).



% 0.552
euler36c =>
   println(sum([N : N in 1..999999, is_palindromic(N), 
                                    is_palindromic(dec_to_base(N,2))])).


% test binary first is much slower: 4.996s
euler36d =>
   println(sum([N : N in 1..999999, is_palindromic(dec_to_base(N,2)),
                                    is_palindromic(N)
                                    ])).

% 1.76s
euler36e =>
   println(sum([N : N in 1..999999, is_palindromic(N.to_radix_string(10)),
                                    is_palindromic(N.to_radix_string(2))
                                    ])).



% for integers
is_palindromic(A), integer(A) => A.to_string().is_palindromic().

% for lists
is_palindromic(A), list(A) => A == A.reverse().

   

%
% convert a decimal number to base base (as a list)
%
dec_to_base(N, Base) = reverse(Res) =>
  Res = [],
  while (N > 0) 
    R := N mod Base,
    N := N div Base,
    Res := Res ++ [R]
  end.

dec_to_base2(N, Base) = Conv =>
  Res = [],
  while (N > 0) 
    R := N mod Base,
    N := N div Base,
    Res := [R|Res]
  end,  
  Conv = Res.

dec_to_base3(N, Base) = Res =>
  Res = [],
  while (N > 0) 
    R := N mod Base,
    N := N div Base,
    Res := [R] ++ Res
  end.


dec_to_bin(N) = N.to_binary_string()./* 

  Euler #37 in Picat.

  """
  The number 3797 has an interesting property. Being prime itself, it is possible to 
  continuously remove digits from left to right, and remain prime at each stage: 
  3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.

  Find the sum of the only eleven primes that are both truncatable from left to right 
  and right to left.

  NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.

  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.25s
euler37 =>
  % 2, 3, 5, and 7 are not considered truncable primes
  %  so we start on 9
  P = 11, 
  Sum = 0,
  C = 0,
  while (C < 11) 
     if check2(P), is_prime3(P) then
        C := C+1,
        Sum := Sum + P
     end,
     P := P + 2
     % this is slower
     % next_prime(P,P2),  
     % P := P2
  end,
  println(Sum).


% 0.915s
euler37b =>
  % 2, 3, 5, and 7 are not considered truncable primes
  %  so we start on 9
  P = 9, 
  Sum = 0,
  C = 0,
  while (C < 11) 
     if is_prime3(P), check2(P) then
        C := C+1,
        Sum := Sum + P
     end,
     P := P + 2
     % this is slower
     % next_prime(P,P2),  
     % P := P2
  end,
  println(Sum).


% table
check(N) =>
  L = N.to_string(),
  Len = L.length,
  Tmp1 = N,
  foreach(I in 1..Len, is_prime3(Tmp1)) 
     Tmp1 := [L[J] : J in I..Len].to_integer()
  end,
  is_prime3(Tmp1),
  L2 = L.reverse(),
  Tmp2 = N,
  foreach(I in 1..Len,is_prime3(Tmp2)) 
    % note the reverse again.
    Tmp2 := reverse([L2[J] : J in I..Len]).to_integer()
  end,
  is_prime3(Tmp2).

%
% this is slightly faster than check/1
%
% table
check2(N) =>
  OK = 1,
  foreach(I in 1..nlen(N)-1, OK == 1) 
     II = 10**I,
     if not is_prime3(N mod II); not is_prime3(N div II) then 
        OK := 0 
     end
  end,
  OK == 1.

% table
check3(N) =>
  NLen1 = nlen(N)-1,
  NLen1 = [1 : I in 1..NLen1, II = 10**I, is_prime3(N mod II), is_prime3(N div II)].length.



nlen(N) = floor(log10(N))+1.


table
prime_cached(N) => prime(N).

table
is_prime3(2) => true.
is_prime3(3) => true.
is_prime3(P) => P > 3, P mod 2 =\= 0, not has_factor3(P,3).  

% (improvement suggested by Neng-Fa)
has_factor3(N,L), N mod L == 0 => true.
has_factor3(N,L) => L * L < N, L2 = L + 2, has_factor3(N,L2).


% next prime
next_prime(Num, P) => Num2 = Num + 1, next_prime2(Num2, P).
next_prime2(Num, P) ?=> is_prime3(Num), P = Num.
next_prime2(Num, P) =>
   Num2 = Num+1,
   next_prime2(Num2,P).
/* 

  Euler #38 in Picat.

  """
  Take the number 192 and multiply it by each of 1, 2, and 3:

      192  1 = 192
      192  2 = 384
      192  3 = 576

  By concatenating each product we get the 1 to 9 pandigital, 
  192384576. We will call 192384576 the concatenated product of 192 
  and (1,2,3)

  The same can be achieved by starting with 9 and multiplying by 
  1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the 
  concatenated product of 9 and (1,2,3,4,5).

  What is the largest 1 to 9 pandigital 9-digit number that can be 
  formed as the concatenated product of an integer with 
  (1,2, ... , n) where n > 1?
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler38 =>
    MaxN = 0,
    foreach(N in 9876..-1..9, S = N.to_string(), S[1] != 49+9, MaxN == 0)
        I = 2,
        while(S.length < 9) 
            S := S ++ (N*I).to_string(),
            I := I + 1
        end,
        SLen = S.length,
        if SLen == 9, is_pandigital(S) then
            MaxN := S
        end

    end,

    println(MaxN).


is_pandigital(L) => 
   L.length == 9, not(member('0',L)), [I=1 : I in L.to_string()].new_map().keys().length == 9.
/* 

  Euler #39 in Picat.

  """
  If p is the perimeter of a right angle triangle with integral length sides, 
  {a,b,c}, there are exactly three solutions for p = 120.
   
  {20,48,52}, {24,45,51}, {30,40,50}
   
  For which value of p <= 1000, is the number of solutions maximised?
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.20s
euler39 =>
  N = 1000-1,
  Squares = new_map([(X*X)=1 : X in 1..N]),
  Valid = [[X,Y] : X in Squares.keys(), Y in Squares.keys(),
            X < Y, (sqrt(X) + sqrt(X) + sqrt(X+Y)) < 1000, Squares.has_key(X+Y)],
  Counts = new_map(),
  foreach([X2,Y2] in Valid) 
    C = (sqrt(X2) + sqrt(Y2) + sqrt(X2+Y2)).toint(),
    Counts.put(C, Counts.get(C,0)+1)
  end,
  P = max([V : _K=V in Counts]),
  println([[n=I,c=C] : I=C in Counts, C == P].first()).


% slightly different (and slower) approach
% 0.54s
euler39a =>
  N = 1000-1,
  Squares = [X*X : X in 1..N],
  Valid = [[X,Y] : X in Squares, Y in Squares,
            X < Y, (sqrt(X) + sqrt(X) + sqrt(X+Y)) < 1000, membchk(X+Y,Squares)],

  Counts = new_map(),
  foreach([X2,Y2] in Valid) 
    C = (sqrt(X2) + sqrt(Y2) + sqrt(X2+Y2)).toint(),
    Counts.put(C, Counts.get(C,0)+1)
  end,
  P = max([V : _K=V in Counts]),
  println([[n=I,c=C] : I=C in Counts, C == P].first()).



table
toint(I) = to_integer(I).

euler39b => 
  Max = 0,
  N = 0,
  foreach(I in 2..1000) 
     Num = p39b(I) -> 
       if Num > Max then
          Max := Num,
          N := I
       end
     ;  
     true
  end,
  writeln([n=N, max=Max]),
  nl.

% 8.26s
p39b(I) = N =>
    Vars = [A, B, C],
    Vars :: 1..I div 2 + 1,
    increasing(Vars),
    % A #=< B, B #=< C,
    A + B #> C,
    A + B + C #= I,
    A * A + B * B #= C * C,
    N = solve_all([forward, split], Vars).length.


increasing(List) =>
   foreach(I in 2..List.length) List[I-1] #=< List[I] end.
/* 

  Euler #3 in Picat.

  Problem 3
  """
  The prime factors of 13195 are 5, 7, 13 and 29.
  What is the largest prime factor of the number 600851475143 ?
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.0s
euler3 => 
   600851475143.factors().max().println(),
   600851475143.factors().println(),
   nl.

% slower: 0.54s
euler3b =>
   prime_decomp(600851475143, P), 
   Max = max(P),
   writeln(Max).

% 0.2s
euler3c =>
   V=600851475143,
   writeln(max([P : P in V.sqrt().floor().primes(), V mod P == 0])).


prime_decomp(N, P) =>
     P = [J: J in 1..1+ceiling(sqrt(N)), N mod J == 0, prime_cached(J)].


alldivisorsM(N,Div) = [Divisors,NewN] =>
   M = N,
   Divisors1 = [],
   while (M mod Div == 0) 
      Divisors1 := Divisors1 ++ [Div],
      M := M div Div
   end,
   NewN := M,
   Divisors = Divisors1.

factors(N) = Factors =>
     M = N,
     Factors1 = [],
     while (M mod 2 == 0) 
         Factors1 := Factors1 ++ [2],  
         M := M div 2 
     end,
     T = 3,
     
     while (M > 1, T < 1+(sqrt(M)))
        if M mod T == 0 then
           [Divisors, NewM] = alldivisorsM(M, T),
           Factors1 := Factors1 ++ Divisors,
           M := NewM
        end,
        T := T + 2
     end,
     if M > 1 then Factors1 := Factors1 ++ [M] end,
     Factors = Factors1.

table
prime_cached(N) => prime(N).
/* 

  Euler #40 in Picat.

  """
  An irrational decimal fraction is created by concatenating the positive integers:
   
  0.123456789101112131415161718192021...
   
  It can be seen that the 12th digit of the fractional part is 1.

  If dn represents the nth digit of the fractional part, find the 
  value of the following expression.
  
  d1  d10  d100  d1000  d10000  d100000  d1000000
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% Improved version of euler40d by Neng-Fa: 0.09s
euler40 =>
    I = 1,
    DLen = 1,
    Prod = 1,
    Index = 10,   % Index = 10, 100, 1000, ..., 1000000
    while (DLen <= 1000000)
       I := I + 1,
       IStr = I.to_string(),
       IStrLen = IStr.length,
       if (DLen+IStrLen>=Index) then
          Prod := Prod*IStr[Index-DLen].toint(),
          Index := Index*10
       end,
       DLen := DLen+IStrLen
    end,
    println(Prod).



euler40a =>
    D=to_string(flatten([to_string(I) : I in 1..210000])),
    Prod = prod([D[10**I].to_integer() : I in 1..6]),
    println(Prod).


euler40b =>
    /*
    % This version is _extremely_ slow
    D = "",
    foreach(I in 1..1000000) 
       D := D ++ I.to_integer(),
       if I mod 10000 == 0 then
         writeln(i=I),
         printf("%s\n", [D[J] : J in 1..10])
       end
    end,
    */
    % This is much faster, though still very slow (~8s)
    % D=to_string(flatten([to_string(I) : I in 1..1000000])),
    % This is acceptable: ~1.3s
    D=to_string(flatten([to_string(I) : I in 1..210000])),
    println(len=D.length),
    writeln([D[10**I].to_integer() : I in 1..6]),
    Prod = prod([D[10**I].to_integer() : I in 1..6]),
    println(Prod).

% Very slow
euler40c =>
    I = 1,
    Len = 1,
    D = "1",
    while (Len <= 1000000) 
       I := I + 1,
       S := I.to_string(),
       D := D ++ S,
       Len := Len + S.length,
       if I mod 1000 == 0 then
         writeln([i=I,len=Len])
       end
    end,
    println(len=D.length),
    writeln([D[10**J].to_integer() : J in 1..6]),
    Prod = prod([D[10**J].to_integer() : J in 1..6]),
    println(Prod).

% Very slow
euler40d =>
    I = 1,
    D = "1",
    while (D.length <= 1000000) 
    % while (D.length <= 200000) 
       I := I + 1,
       D := D ++ I.to_string(),
       if I mod 100 == 0 then
         % writeln([i=I,len=D.length])
         writeln([i=I])
       end
    end,
    println(len=D.length),
    writeln([D[10**J].to_integer() : J in 1..6]),
    Prod = prod([D[10**J].to_integer() : J in 1..6]),
    println(Prod).

% Very slow
euler40e =>
    writeln(euler40e),
    I = 1,
    D = "",
    while (int_len(I) <= 1000000) 
       I := I + 1,
       D := D ++ I.to_string(),
       if I mod 10000 == 0 then
         writeln(I)
       end
    end,
    println(len=D.length),
    writeln([D[10**J].to_integer() : J in 1..6]),
    Prod = prod([D[10**J].to_integer() : J in 1..6]),
    println(Prod).


int_len(V) = Len =>
  Len = 1,
  while (V > 9)
     Len := Len + 1,
     V := V div 10
  end.

toint(I) = to_integer(I).
/* 

  Euler #41 in Picat.

  """
  We shall say that an n-digit number is pandigital if it makes use of all 
  the digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital 
  and is also prime.

  What is the largest n-digit pandigital prime that exists?
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler41 =>
  % Simplification:
  % n=9 is not possible since 1+2+3+4+5+6+7+8+9=45 is divisible by 3
  % n=8 is not possible since 1+2+3+4+5+6+7+8=36 is divisible by 3
  N = 7,
  M = 0,
  while (M == 0, N >= 4) 
    P = (1..N).reverse(),
    % note: it's reversed sorted so we stop at first prime
    Perms = permutations(P).sort_down(),
    V = 4, % dummy value for the foreach loop
    foreach(PP in Perms, not prime_cached(V)) 
      V := [J.to_string() : J in PP].flatten().to_integer(),
      if prime_cached(V) then
        M := V % found it
      end
    end,
    N := N-1
  end,
  println(M).


% Without the simplification (i.e. starting on N=7): 7.16s
euler41b =>
  % Simplification (from one of the answers)
  N =9, % is not possible since 1+2+3+4+5+6+7+8+9=45 is divisible by 3
  % N=8 is not possible since 1+2+3+4+5+6+7+8=36 is divisible by 3
  % N = 7,
  M = 0,
  while (M == 0, N >= 4) 
    P = (1..N).reverse(),
    % note: it's reversed sorted so we stop at first prime
    Perms = permutations(P).sort_down(),
    V = 4, % dummy value for the foreach loop
    foreach(PP in Perms, not prime_cached(V)) 
      V := [J.to_string() : J in PP].flatten().to_integer(),
      if prime_cached(V) then
        M := V % found it
      end
    end,
    N := N-1
  end,
  println(M).

table
prime_cached(N) => prime(N).

table
toint(I) = to_integer(I)./* 

  Euler #42 in Picat.

  """
  The nth term of the sequence of triangle numbers is given by, 
      tn = 1/2*n*(n+1); 
  so the first ten triangle numbers are:

  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

  By converting each letter in a word to a number corresponding to its 
  alphabetical position and adding these values we form a word value. For example, 
  the word value for SKY is 19 + 11 + 25 = 55 = t10. If the word value 
  is a triangle number then we shall call the word a triangle word.

  Using words.txt (right click and 'Save Link/Target As...'), a 16K text file 
  containing nearly two-thousand common English words, how many 
  are triangle words?
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler42 =>
   Words = [[W : W in Word, W != '"'] : Word in split(read_file_chars("words.txt"), ",")],
   T20 = [triangle_number(I) : I in 1..20],
   Len = [WW : WW in Words,  membchk(get_score(WW),T20)].length,
   println(Len).


triangle_number(N) = (N*(N+1)) div 2.

get_score(Name) = Total =>
    Total = 0,
    foreach(I in 1..Name.length)
       Total := Total+(ord(Name[I])-64)
    end.
/* 

  Euler #43 in Picat.

  """  
  The number, 1406357289, is a 0 to 9 pandigital number because it is made up of 
  each of the digits 0 to 9 in some order, but it also has a rather interesting 
  sub-string divisibility property.
  
  Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we 
  note the following:
  
      * d2d3d4=406 is divisible by 2
      * d3d4d5=063 is divisible by 3
      * d4d5d6=635 is divisible by 5
      * d5d6d7=357 is divisible by 7
      * d6d7d8=572 is divisible by 11
      * d7d8d9=728 is divisible by 13
      * d8d9d10=289 is divisible by 17
  
  Find the sum of all 0 to 9 pandigital numbers with this property.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% using CP is fast: 0.05s
euler43 => 
   Primes = [2,3,5,7,11,13,17],
   X = new_list(10),
   X :: 0..9,

   all_different(X),
   foreach({I,P} in zip(2..8, Primes))
      (100*X[I]+10*X[I+1]+X[I+2]) mod P #= 0
   end,

   All=solve_all(X),
   println(sum([Num : A in All, to_num(A, 10,Num)])).


to_num(List, Base, Num) =>
   Len = length(List),
   Num = sum([List[I]*Base**(Len-I) : I in 1..Len]).


% Here is Neng-Fa's simplification of euler43/0:
euler43b => 
   Primes = [2,3,5,7,11,13,17],
   X = new_list(10),
   X :: 0..9,

   all_different(X),
   foreach({I,P} in zip(2..8, Primes))
      (100*X[I]+10*X[I+1]+X[I+2]) mod P #= 0
   end,

   All=solve_all(X),
   writeln(sum([to_num2(A) : A in All])),
   nl.

to_num2(List) = Num =>
   Str = [Char : D in List, D.to_string()=[Char]],
   Num = Str.to_integer().

% 3.8s
% Same idea as euler43 but without CP.
euler43c =>
  garbage_collect(400_000_000),
  Primes = [2,3,5,7,11,13,17],
  Perms = permutations(0..9),
  Sum = 0,
  foreach(P in Perms) 
    I = 1,
    Found = true,
    while(I <= 7, Found == true)
      if (100*(P[I+1]).to_int() + 10*(P[I+2]).to_int() + P[I+3].to_int()) mod Primes[I] != 0 then
         Found := false
      end,
      I := I+1
    end,
    if Found then
      % println(found=P),
      Sum := Sum + [X.to_string() : X in P].flatten().to_int()
    end
  end,
  println(Sum),
  nl.


%
% using next_permutation/1 instead of permutations/1: 4.6s
%
euler43d =>
  garbage_collect(400_000_000),
  Primes = [2,3,5,7,11,13,17],
  P = [1,0,2,3,4,5,6,7,8,9],
  Stop = (0..9).reverse(),
  Sum = 0,
  while (P != Stop)  
    I = 1,
    Found = true,
    while(I <= 7, Found == true)
      if (100*(P[I+1]).to_int() + 10*(P[I+2]).to_int() + P[I+3].to_int()) mod Primes[I] != 0 then
         Found := false
      end,
      I := I+1
    end,
    if Found then
      % println(found=P),
      Sum := Sum + [X.to_string() : X in P].flatten().to_int()
    end,
    P := next_permutation(P)
  end,
  println(Sum),
  nl.


/* 
% Notes:
% 
%   - got this error/warning ** Error  : assignment_in_condition:while
%   - it eats a lot of memory
%   - it's very slow
% 
% 34.7s
euler43d =>
  PP = [2, 3, 5, 7, 11, 13, 17],
  % skipping all permutations that starts with [0,..]
  S = [1, 0, 2, 3, 4, 5, 6, 7, 8, 9],
  Sum = 0,
  Sdown = S.sort_down(),
  while (S != Sdown)
    S2 = S.to_string(),
    I = 1,
    % it's here the "assignment_in_condition:while" error come
    while (I =< 7, [S[J].to_string() : J in 1+I..I+3].flatten().to_integer() mod PP[I] == 0)
      I := I + 1
    end,
    if I == 8 then
      println(s2=S2),
      Sum := Sum + [S[J].to_string() : J in 1..S.length].flatten().to_integer()
    end,
    S := next_permutation(S)
  end,

  println(Sum)
*/

next_permutation(P) = Perm =>
   Perm1 = P,
   N = Perm1.length,
   K = N - 1,
   if K == 0 then Perm1 := []  end,  % return
   while (Perm1[K] > Perm1[K+1], K >= 0) 
      K := K - 1,
      if K == 0 then Perm1 := []  end  % return
   end,
   if K > 0 then
      J = N,
      while (Perm1[K] > Perm1[J])  J := J - 1 end,      
      Tmp := Perm1[K],
      Perm1[K] := Perm1[J],
      Perm1[J] := Tmp,
      R = N, 
      S = K + 1,
      while (R > S) 
         Tmp := Perm1[R],
         Perm1[R] := Perm1[S],
         Perm1[S] := Tmp,
         R := R - 1, 
         S := S + 1
      end
   end,
   Perm = Perm1.

/* 

  Euler #44 in Picat.

  """  
  Pentagonal numbers are generated by the formula, P(n)=n(3n1)/2. 
  The first ten pentagonal numbers are:

  1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

  It can be seen that P(4) + P(7) = 22 + 70 = 92 = P(8). However, 
  their difference,  70  22 = 48, is not pentagonal.

  Find the pair of pentagonal numbers, P(j) and P(k), for which their sum 
  and difference is pentagonal and D = |P(k)  P(j)| is minimised; what 
  is the value of D?  
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler44 =>
  garbage_collect(200_000_000),
  % S = [pent(N) : N in 1..2500],
  S = [N*(3*N-1) div 2 : N in 1..2500],
  % T = new_map(2500,[V=1 : V in S]),
  T = new_set(2500,S),
  D = 10000000,
  foreach(J in S.reverse(), K in S,
            J < K, 
            A = J+K, 
            A < D,
            T.has_key(A), 
            B = abs(J-K),
            B < D,
            T.has_key(B)) 
        D := B
  end,
  println(D).


% slower
euler44b =>
  garbage_collect(200_000_000),
  % S = [pent(N) : N in 1..2500],
  S = [N*(3*N-1) div 2 : N in 1..2500],
  % T = new_map(2500,[V=1 : V in S]),
  T = new_set(2500,S),
  D = [B : J in S, K in S,
            J < K, 
            A = J+K, 
            T.has_key(A), 
            B = abs(J-K),
            T.has_key(B)],
  println(D.first()).

% same idea, another approach, slower
euler44c => 
  garbage_collect(200_000_000),
  M = 2500,
  T = new_set(M,[N*(3*N-1) div 2 : N in 1..M]),
  Min = 100000000,
  foreach(A in T.keys(), B in T.keys(), A <= B) 
     Diff = abs(A-B),
     Sum = A+B,
     if Diff < Min, T.has_key(Diff), T.has_key(Sum) then
        Min := Diff
     end
  end,
  println(Min),
  nl.

pent(N) = N*(3*N-1) div 2.
/* 

  Euler #45 in Picat.

  """  
  Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

  Triangle 	  	Tn=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
  Pentagonal 	  	Pn=n(3n1)/2 	  	1, 5, 12, 22, 35, ...
  Hexagonal 	  	Hn=n(2n1) 	  	1, 6, 15, 28, 45, ...

  It can be verified that T(285) = P(165) = H(143) = 40755.

  Find the next triangle number that is also pentagonal and hexagonal.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler45 =>
    T = 285+1,
    TT = tri(T),
    P = 165,
    PP = pent(P),
    H = 143,
    HH = hex(H), 
    while (TT != PP; PP != HH) 
        T := T+1,
        TT := tri(T),
        if TT > PP then P := P+1, PP := pent(P) end,
        if PP > HH then H := H+1, HH := hex(H) end,
        if TT > HH then H := H+1, HH := hex(H) end
    end,
    println(TT).


pent(N) = N*(3*N-1) div 2.
tri(N)  = N*(N+1) div 2.
hex(N)  = N*(2*N-1).
/* 

  Euler #46 in Picat.

  """  
  It was proposed by Christian Goldbach that every odd composite number can be 
  written as the sum of a prime and twice a square.

  9 = 7 + 21^2
  15 = 7 + 22^2
  21 = 3 + 23^2
  25 = 7 + 23^2
  27 = 19 + 22^2
  33 = 31 + 21^2

  It turns out that the conjecture was false.

  What is the smallest odd composite that cannot be written as the 
  sum of a prime and twice a square?
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler46 =>
  Res = 0,
  GotIt = 0,
  foreach(I in 3..2..10000, not prime(I), GotIt == 0)
    S = round(sqrt(I/2)),
    Found = 0,
    foreach(J in 1..S, Found == 0)
      Ts = J*J*2,
      if prime(abs(I-Ts)) then
        Found := 1
      end
    end,
    if Found == 0 then
      Res := I,
      GotIt := 1
    end
  end,

  println(res=Res).

/* 

  Euler #47 in Picat.

  """  
  The first two consecutive numbers to have two distinct prime factors are:

  14 = 2 x 7
  15 = 3 x 5

  The first three consecutive numbers to have three distinct 
  prime factors are:

  644 = 2^2 x 7 x 23
  645 = 3 x 5 x 43
  646 = 2 x 17 x 19.

  Find the first four consecutive integers to have four distinct primes 
  factors. What is the first of these numbers?
   """ 


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler47 =>
    garbage_collect(100_000_000),
    MaxN = 1000000,
    % F = [0 : I in 1..MaxN],
    % It's much faster using an array.
    F = new_array(MaxN),
    % foreach(I in 1..MaxN) F[I] := 0 end, 
    bind_vars(F,0), % faster
    foreach(I in 2..MaxN-1) 
       if F[I] == 0 then
           foreach(J in 2*I..I..MaxN-1)
              F[J] := F[J] + 1
            end
       end
    end,
    
    Goal = [4,4,4,4],
    % println(goal=Goal),
    Found = 0,
    foreach(I in 2..MaxN-3, Found==0) 
       if [F[J] : J in I..I+3] == Goal then
          println(I),
          Found := 1
        end
    end.
/* 

  Euler #48 in Picat.

  Problem 48
  """
  The series, 1^(1) + 2^(2) + 3^(3) + ... + 10^(10) = 10405071317.
  
  Find the last ten digits of the series, 
  1^(1) + 2^(2) + 3^(3) + ... + 1000^(1000).
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.4s
euler48 =>
  Sum = 0,
  T = 10000000000,
  foreach(I in 1..1000)
     N = I,
     foreach(_J in 2..I)
         N := (N * I) mod T
     end,
     Sum := (Sum + N) mod T
  end,
  println(Sum).

% 2.9s
euler48b =>
   S = 1,
   foreach(I in 2..1000) S := S + I**I end,
   SS := S.to_string(),
   Len = SS.length,
   println([SS[J] : J in Len-9..Len]).


% This is slightly slower: 3.0s
euler48c =>
   S = sum([I**I : I in 1..1000]).to_string(),
   Len = S.length,
   println([S[J] : J in Len-9..Len]).


/* 

  Euler #49 in Picat.

  """  
  The arithmetic sequence, 1487, 4817, 8147, in which each of the terms 
  increases by 3330, is unusual in two ways: (i) each of the three terms are 
  prime, and, (ii) each of the 4-digit numbers are permutations of one another.

  There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, 
  exhibiting this property, but there is one other 4-digit increasing sequence.

  What 12-digit number do you form by concatenating the three terms 
  in this sequence?
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler49 =>
  Diff = 3330,
  Res := 0,
  foreach(N in 1001..2..9999, 
               N != 1487,
               prime(N), 
               C = check_perms(N, Diff), 
               C != [])
     Res := C
  end,  
  println(join([R.to_string():R in Res],'')).


euler49b =>
  Diff = 3330,
  Res := 0,
  foreach(N in 1001..2..9999, prime(N))
    C = check_perms(N, Diff),
    if C != [], N != 1487 then
      Res := C
    end
  end,  
  Result = "",
  foreach(I in Res) Result := Result ++ I.to_string() end,
  println(Result).


check_perms(N, Diff) = LL =>
  LL := [],
  AllPerms := permutations([I.toint() : I in N.to_string()]),
  if AllPerms.length > 0 then
     P1 = 0,
     P2 = 0,
     P1 := get_element(N, AllPerms, Diff),
     if P1 > 0 then
       P2 := get_element(P1, AllPerms, Diff)
     end,
     if P2 > 0 then
       LL := [N, P1, P2]
     end
  end.

get_element(N, LL, Diff) = Res =>
  Res := 0,
  foreach(P in LL) 
    PP = [I.to_string() : I in P].flatten().to_integer(),
    if PP > N, PP-N == Diff then
      Res := PP
    end
  end.


table
toint(I) = to_integer(I)./* 

  Euler #4 in Picat.

  Problem 4
  """
  A palindromic number reads the same both ways. The largest palindrome made 
  from the product of two 2-digit numbers is 9009 = 91  99.

  Find the largest palindrome made from the product of two 3-digit numbers.
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler4 =>
  euler4e.

% 0.066
% faster since palindromic is just used whenever IJ > Max.
% The recursive version (euler4e) is slightly faster.
euler4a =>
   Max = 0,
   From = 100,
   To   = 999,
   foreach(I in From..To, J in I..To)
     IJ = I*J,
     if IJ > Max, palindromic2(IJ) then
       Max := IJ
     end
   end,
   println(Max).

% 0.227s
euler4b =>
   From = 100,
   To   = 999,
   L = [IJ : I in From..To, J in I..To, IJ = I*J, palindromic2(IJ)],
   writeln(max(L)).

% 0.223s
euler4c =>
   writeln(max([IJ : I in 100..999, J in I..999, (IJ = I*J, palindromic2(IJ))])).


% 0.35s
euler4d =>
   Max=max(findall(AB,
              (between(100,999,A),
               between(100,A,B),
               AB=A*B,
               palindromic2(AB)))),
   println(Max).

%
% pure recursion (could probably be neater)
% 0.061s (slightly faster than euler4a)
% 
%
euler4e => 
  e4e(100,999,Max),
  println(Max).

e4e(From,To,Max) =>
  e4e_loopI(From,To,From,To,0,Max).


e4e_loopI(FromI,LimitI,_FromJ,_LimitJ, Max0,Max), FromI > LimitI ?=> 
  Max = Max0.

e4e_loopI(FromI,LimitI,FromJ,_LimitJ,Max0,Max) =>
  % Note that we have LimitI both on FromI and FromJ as well
  % (i.e. stating that I <= J).
  % This gave a speedup from 0.092s to 0.061s.
  e4e_loopJ(FromJ,FromI,LimitI,Max0,MaxJ),
  e4e_loopI(FromI+1,LimitI,FromJ,LimitI,MaxJ,Max).

% base case for 
e4e_loopJ(FromJ,_FromI,LimitJ,Max0,Max), FromJ > LimitJ ?=>
  Max = Max0.

% FromJ: J counter
% FromI: I counter 
% Limit is FromI
e4e_loopJ(FromJ,FromI,_LimitJ,Max0,Max) =>
  Prod = FromJ*FromI,
  (Prod > Max0, palindromic2(Prod) -> 
     Max1 = Prod
   ; 
     Max1 = Max0
  ),
  e4e_loopJ(FromJ+1,FromI,FromI,Max1,Max).

%
% Another recursive version using lists, which is probably 
% more natural. Though slightly slower than euler4e: 0.081s
%
euler4f => 
  e4flist_loopI(100..999,100..999,0,Max),
  println(Max).

e4flist_loopI([],_ListJ,Max0,Max) => 
  Max = Max0.

e4flist_loopI([I|ListI],ListJ,Max0,Max) => 
  e4flist_loopJ(ListJ,I,Max0,MaxJ),
  e4flist_loopI(ListI,ListJ,MaxJ,Max).

e4flist_loopJ([],_,Max0,Max) =>
  Max = Max0.

e4flist_loopJ([J|JList],I,Max0,Max) =>
  Prod = I*J,
  (J =< I, Prod > Max0, palindromic2(Prod) -> 
     Max1 = Prod
   ; 
     Max1 = Max0
  ),
  e4flist_loopJ(JList,I,Max1,Max).


% table
palindromic2(N) => L = number_chars(N), L=reverse(L).
/* 

  Euler #50 in Picat.

  Problem 50
  """
  The prime 41, can be written as the sum of six consecutive primes:
  41 = 2 + 3 + 5 + 7 + 11 + 13

  This is the longest sum of consecutive primes that adds to a prime 
  below one-hundred.

  The longest sum of consecutive primes below one-thousand that adds to a prime, 
  contains 21 terms, and is equal to 953.
  
  Which prime, below one-million, can be written as the sum of the most 
  consecutive primes?
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler50 =>
  N = 10000,
  Primes = [P : P in 1..N, prime(P)].to_array(),
  Found = 0,
  foreach(Len in 550..-1..21, Found == 0) 
    foreach(Offset in 1..549, Found == 0)
       PP = sum([Primes[J] : J in Offset+1..Offset+Len]),
       if PP < 1000000, prime(PP) then
          Found := PP
       end
    end
  end,
  writeln(Found).
/* 

  Euler 55 in Picat.

  http://projecteuler.net/problem=55
  """
  If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.

  Not all numbers produce palindromes so quickly. For example,

    349 + 943 = 1292,
    1292 + 2921 = 4213
    4213 + 3124 = 7337

  That is, 349 took three iterations to arrive at a palindrome.

  Although no one has proved it yet, it is thought that some numbers, like 196, 
  never produce a palindrome. A number that never forms a palindrome through the reverse 
  and add process is called a Lychrel number. Due to the theoretical nature of these 
  numbers, and for the purpose of this problem, we shall assume that a number is Lychrel 
  until proven otherwise. In addition you are given that for every number below ten-thousand, 
  it will either 
      (i) become a palindrome in less than fifty iterations, or, 
     (ii) no one, with all the computing power that exists, has managed so far 
  to map it to a palindrome. In fact, 10677 is the first number to be shown to require 
  over fifty iterations before producing a palindrome: 4668731596684224866951378664 
  (53 iterations, 28-digits).

  Surprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first 
  example is 4994.

  How many Lychrel numbers are there below ten-thousand?

  NOTE: Wording was modified slightly on 24 April 2007 to emphasise the theoretical 
  nature of Lychrel numbers.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
  Limit = 50,
  Count = 0, 
  foreach(N in 1..9999,lychrel(N,Limit)) 
     Count := Count + 1
  end,
  println(count=Count),
  nl.

go2 =>
  Limit = 50,
  Lychrel = [],
  foreach(N in 1..9999, lychrel(N,Limit)) 
     Lychrel := Lychrel ++ [N]
  end,
  println(Lychrel),
  nl.


go3 => 
  Limit = 1000,
  Lychrel = [],
  foreach(N in 1..9999, lychrel(N,Limit)) 
     Lychrel := Lychrel ++ [N]
  end,
  println(Lychrel),
  println(Lychrel.length),
  nl.



lychrel(N, Limit) => 
   Count = 0,
   Found = 0,
   while (Found == 0, Count <= Limit)
       Count := Count + 1,
       N := reverse_and_add(N),
       if palindromic(N) then
         Found := 1
       end
   end,
   Found == 0.

table
reverse_and_add(N) = M => 
  L = number_chars(N),
  L2 = reverse(L),
  M := N + parse_term(L2).

table
palindromic(N) =>
  L=number_chars(N),
  L=reverse(L).
/* 

  Euler #5 in Picat.

  Problem 5
  """
  2520 is the smallest number that can be divided by each of the numbers 
  from 1 to 10 without any remainder.

  What is the smallest number that is evenly divisible by all of the numbers 
  from 1 to 20?
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler5 =>
   A = 1,
   foreach(E in 2..20) 
      lcm(A,E,L),
      A := L
   end,
   writeln(A).

% alternative version
euler5b =>
   List = findall(E,between(2,20, E)),
   A = fold(lcm, 1, List),
   writeln(A).

% using reduce
euler5c => writeln(reduce(lcm, 2..20)).

% plain recursion
euler5d => 
 e5d(2,1,LCM),
 println(LCM). 

e5d(20,S1,S2) =>
  S1=S2.

e5d(N,S1,S2) =>
  e5d(N+1,lcm(N,S1),S2).


% lcm/2
lcm(X,Y)=LCM => GCD=gcd(X,Y), LCM = X*Y//GCD.
% lcm/3
lcm(X,Y,LCM) => GCD=gcd(X,Y), LCM = X*Y//GCD.


/* 

  Euler #6 in Picat.

  Problem 6
  """
  The sum of the squares of the first ten natural numbers is,
  1^(2) + 2^(2) + ... + 10^(2) = 385

  The square of the sum of the first ten natural numbers is,
  (1 + 2 + ... + 10)^(2) = 55^(2) = 3025

  Hence the difference between the sum of the squares of the first ten 
  natural numbers and the square of the sum is 3025  385 = 2640.

  Find the difference between the sum of the squares of the first one 
  hundred natural numbers and the square of the sum.
   """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

euler6 => 
  writeln(sum(1..100)**2 - sum([I**2:I in 1..100])).

euler6b =>
     List1 = [], List2 = [],
     foreach(I in 1..100)
       List1 := [I**2|List1],
       List2 := [I|List2]
     end,
     Diff = sum(List2)**2 - sum(List1),
     writeln(Diff).

pow2(N) = N**2.
euler6c => 
  writeln(sum(1..100)**2 - sum(map(pow2,1..100))).


euler6d => 
  e6d(S), 
  println(S).

e6d(Sum) =>
  e6d(1,0,0,Sum).

e6d(N,S,T,Sum) ?=> 
   N > 100,
   Sum = T**2 - S.

e6d(N,S,T,Sum) => 
  S2 = S + N**2,
  T2 = T + N,
  e6d(N+1,S2,T2,Sum).
/* 

  Euler #7 in Picat.

  Problem 7
  """
  By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see 
  that the 6^(th) prime is 13.

  What is the 10001^(st) prime number?
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% Neng-Fa's solution from http://picat-lang.org/euler/p7.pi
% slightly faster than euler7a
% 0.12s
euler7 => 
    I = 11,
    Count = 4,
    while (Count !== 10001)
        if (prime(I)) then    % prime defined in module math.
            Count := Count+1
	end,
	I := I + 2
    end,
    writef("The 10001st prime number is %w%n",I-2).
	


% slightly faster than euler7b
% 0.124s
euler7a =>
  P = 2,
  N = 1,
  while(N < 10001)      
     N := N+1,
     next_prime(P,P2),
     P := P2
  end,
  println(P).

% 0.125s
euler7b =>
   nth_prime(10001, P), 
   writeln(P).

next_prime(Num, P) => Num2 = Num + 1, next_prime2(Num2, P).
next_prime2(Num, P) ?=> prime(Num), P = Num.
next_prime2(Num, P) =>
   Num2 = Num+1,
   next_prime2(Num2,P).

nth_prime(Choosen, P) => 
   nth_prime(1,0,Choosen, P).

nth_prime(Num, Choosen, Choosen, P) ?=> prime(Num), P = Num.
nth_prime(Num, Ix, Choosen, P) =>
   Ix < Choosen,
   Ix2 = Ix + 1,
   next_prime(Num, P2),
   nth_prime(P2, Ix2, Choosen, P).


% This is faster, but it's cheating 
% since it's a too appropriate upper bound...
% 0.036s
euler7c =>
  P=primes(200000), 
  println(P[10001]).

% 
% Same idea as euler7c but little less cheating:
% Create a incrementally larger list of Primes 
% and see if we reached the 10001th prime.
%
% 0.04s
euler7d =>
  Found = false,
  foreach(I in 1..300, Found = false) 
    Primes=primes((2**I).to_integer()),
    if Primes.length >= 10001 then
      Found := Primes[10001]
    end
  end,
  println(Found).
/* 

  Euler #8 in Picat.

  Problem 8:
  """
  Find the greatest product of five consecutive digits in the 
  1000-digit number.
  ...
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

%
% Euler 8
%
p8b(A) => 
  A = [7,3,1,6,7,1,7,6,5,3,1,3,3,0,6,2,4,9,1,9,2,2,5,1,1,9,6,7,4,4,2,6,5,7,4,7,4,2,3,5,5,3,4,9,1,9,4,9,3,4,9,6,9,8,3,
5,2,0,3,1,2,7,7,4,5,0,6,3,2,6,2,3,9,5,7,8,3,1,8,0,1,6,9,8,4,8,0,1,8,6,9,4,7,8,8,5,1,8,4,3,8,5,8,6,1,5,6,0,7,8,9,1,1,2
,9,4,9,4,9,5,4,5,9,5,0,1,7,3,7,9,5,8,3,3,1,9,5,2,8,5,3,2,0,8,8,0,5,5,1,1,1,2,5,4,0,6,9,8,7,4,7,1,5,8,5,2,3,8,6,3,0,5,
0,7,1,5,6,9,3,2,9,0,9,6,3,2,9,5,2,2,7,4,4,3,0,4,3,5,5,7,6,6,8,9,6,6,4,8,9,5,0,4,4,5,2,4,4,5,2,3,1,6,1,7,3,1,8,5,6,4,0
,3,0,9,8,7,1,1,1,2,1,7,2,2,3,8,3,1,1,3,6,2,2,2,9,8,9,3,4,2,3,3,8,0,3,0,8,1,3,5,3,3,6,2,7,6,6,1,4,2,8,2,8,0,6,4,4,4,4,
8,6,6,4,5,2,3,8,7,4,9,3,0,3,5,8,9,0,7,2,9,6,2,9,0,4,9,1,5,6,0,4,4,0,7,7,2,3,9,0,7,1,3,8,1,0,5,1,5,8,5,9,3,0,7,9,6,0,8
,6,6,7,0,1,7,2,4,2,7,1,2,1,8,8,3,9,9,8,7,9,7,9,0,8,7,9,2,2,7,4,9,2,1,9,0,1,6,9,9,7,2,0,8,8,8,0,9,3,7,7,6,6,5,7,2,7,3,
3,3,0,0,1,0,5,3,3,6,7,8,8,1,2,2,0,2,3,5,4,2,1,8,0,9,7,5,1,2,5,4,5,4,0,5,9,4,7,5,2,2,4,3,5,2,5,8,4,9,0,7,7,1,1,6,7,0,5
,5,6,0,1,3,6,0,4,8,3,9,5,8,6,4,4,6,7,0,6,3,2,4,4,1,5,7,2,2,1,5,5,3,9,7,5,3,6,9,7,8,1,7,9,7,7,8,4,6,1,7,4,0,6,4,9,5,5,
1,4,9,2,9,0,8,6,2,5,6,9,3,2,1,9,7,8,4,6,8,6,2,2,4,8,2,8,3,9,7,2,2,4,1,3,7,5,6,5,7,0,5,6,0,5,7,4,9,0,2,6,1,4,0,7,9,7,2
,9,6,8,6,5,2,4,1,4,5,3,5,1,0,0,4,7,4,8,2,1,6,6,3,7,0,4,8,4,4,0,3,1,9,9,8,9,0,0,0,8,8,9,5,2,4,3,4,5,0,6,5,8,5,4,1,2,2,
7,5,8,8,6,6,6,8,8,1,1,6,4,2,7,1,7,1,4,7,9,9,2,4,4,4,2,9,2,8,2,3,0,8,6,3,4,6,5,6,7,4,8,1,3,9,1,9,1,2,3,1,6,2,8,2,4,5,8
,6,1,7,8,6,6,4,5,8,3,5,9,1,2,4,5,6,6,5,2,9,4,7,6,5,4,5,6,8,2,8,4,8,9,1,2,8,8,3,1,4,2,6,0,7,6,9,0,0,4,2,2,4,2,1,9,0,2,
2,6,7,1,0,5,5,6,2,6,3,2,1,1,1,1,1,0,9,3,7,0,5,4,4,2,1,7,5,0,6,9,4,1,6,5,8,9,6,0,4,0,8,0,7,1,9,8,4,0,3,8,5,0,9,6,2,4,5
,5,4,4,4,3,6,2,9,8,1,2,3,0,9,8,7,8,7,9,9,2,7,2,4,4,2,8,4,9,0,9,1,8,8,8,4,5,8,0,1,5,6,1,6,6,0,9,7,9,1,9,1,3,3,8,7,5,4,
9,9,2,0,0,5,2,4,0,6,3,6,8,9,9,1,2,5,6,0,7,1,7,6,0,6,0,5,8,8,6,1,1,6,4,6,7,1,0,9,4,0,5,0,7,7,5,4,1,0,0,2,2,5,6,9,8,3,1
,5,5,2,0,0,0,5,5,9,3,5,7,2,9,7,2,5,7,1,6,3,6,2,6,9,5,6,1,8,8,2,6,7,0,4,2,8,2,5,2,4,8,3,6,0,0,8,2,3,2,5,7,5,3,0,4,2,0,
7,5,2,9,6,3,4,5,0].
 
%
% recursive version
%
% 0.021s
euler8 =>
   p8b(P),
   e8(P,Max),
   println(Max).

e8(P,Max) =>
   e8(P,0,Max).

% table

% base case (exactly 5 elements)
e8([X1,X2,X3,X4,X5],Max0,Max) => 
  Prod = X1*X2*X3*X4*X5,
  e8_check(Max0,Prod,Max1),
  Max = Max1.
  % Max = max(Max0,Prod). % slightly slower

% more than 5 elements
e8([X1,X2,X3,X4,X5|T], Max0, Max) =>
  Prod = X1*X2*X3*X4*X5,
  e8_check(Max0,Prod,Max1),
  % Max1 = max(Max0,Prod), % slighly slower
  e8([X2,X3,X4,X5|T], Max1, Max).

e8_check(Max0,Prod,Max1) =>
   Prod > Max0 ->
     Max1 = Prod
   ; 
     Max1 = Max0.

% 0.024s
euler8a =>
   p8b(P),
   List = array_slice(P, 5),
   L2 = [Prod : L in List, Prod = prod(L)],
   Max = max(L2),
   writeln(Max).

% explicit loop instead of list comprehension
% 0.036s
euler8b =>
   p8b(P),
   List = array_slice(P, 5),
   L2 = [],
   foreach(T in List) 
      PL = prod(T),
      L2 := L2 ++ [PL]
   end,
   Max = max(L2),
   writeln(Max).

% 0.024
euler8c => 
   p8b(P),
   writeln(array_slice(P,5).map(prod).max()).


% using builtin slice/3
% 0.028s
euler8d =>
   p8b(P),
   Len = P.length,
   SliceLen = 5,
   println([prod(P.slice(I,I+SliceLen-1)): I in 1..Len-SliceLen+1].max()).



%
% slices an array A [...] into slices of length SliceLen
% and returns a list List
%
array_slice(A, SliceLen) = List =>
   List = [A2 : I in 1..A.length-SliceLen,
           A2 = [ A[J] : J in I..I+SliceLen-1] ].

/* 

  Euler #96 in Picat.

  http://projecteuler.net/problem=96
  """
  Su Doku (Japanese meaning number place) is the name given to a popular puzzle concept. 
  Its origin is unclear, but credit must be attributed to Leonhard Euler who invented a 
  similar, and much more difficult, puzzle idea called Latin Squares. The objective of 
  Su Doku puzzles, however, is to replace the blanks (or zeros) in a 9 by 9 grid in such 
  that each row, column, and 3 by 3 box contains each of the digits 1 to 9. Below is an 
  example of a typical starting puzzle grid and its solution grid.

  [ ... ]

  A well constructed Su Doku puzzle has a unique solution and can be solved by logic, although 
  it may be necessary to employ "guess and test" methods in order to eliminate options (there 
  is much contested opinion over this). The complexity of the search determines the difficulty 
  of the puzzle; the example above is considered easy because it can be solved by straight 
  forward direct deduction.

  The 6K text file, [http://projecteuler.net/project/sudoku.txt]  (right click and 
  'Save Link/Target As...'), contains fifty different Su Doku puzzles ranging in difficulty, 
  but all with unique solutions (the first puzzle in the file is the example above).

  By solving all fifty puzzles find the sum of the 3-digit numbers found in the top left corner 
  of each solution grid; for example, 483 is the 3-digit number found in the top left 
  corner of the solution grid above.
  """

  [Note to the above: I think that they mean Graeco-Latin Squares (and not Latin Squares) 
   which Euler invented/studied.]

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


euler96 =>
  Sudokus = read_file("sudoku.txt"),
  % println(len=Sudokus.length),
  Total = 0,
  foreach(S in Sudokus) 
     Solved = sudoku(3, S),
     Total := Total + [Solved[1,J].to_string() : J in 1..3].flatten().parse_term()
  end,
  println(Total),
  nl.


% convert from char representation
convert(Sudoku) = [[ R.to_integer() : R in Row] : Row in Sudoku].


%
% Also see http://www.hakank.org/picat/sudoku.pi for some other approaches
%
sudoku(N, Board) = Board2 =>
   N2 = N*N,
   Board2 = new_array(N2,N2),
   foreach(I in 1..N2, J in 1..N2)
      if Board[I,J] > 0 then
         Board2[I,J] #= Board[I,J]
      end
   end,
   Vars = Board2.vars(),
   Vars :: 1..N2,
   latin_square(Board2),
   foreach(I in 1..N..N2, J in 1..N..N2)
      all_different([Board2[I+K,J+L] : K in 0..N-1, L in 0..N-1])
   end,
   solve([ff,split], Vars).


latin_square(Board) => 
   foreach(Row in Board.rows()) all_different(Row) end,
   foreach(Column in Board.columns()) all_different(Column) end.

 
   
% Read "sudoku.txt"
read_file(File) = Sudokus => 
   FD = open(File),
   Sudokus = [],
   Sudoku = [],
   C = 0,
   while (not at_end_of_stream(FD))
      Line = read_line(FD),
      if once(find(Line, "Grid",1,_To)) then
         if C > 0 then Sudokus := Sudokus ++ [Sudoku.convert()] end,
          Sudoku := [],
          C := C + 1
      else
          Sudoku := Sudoku ++ [Line]
      end
   end,
   % the last
   Sudokus := Sudokus ++ [Sudoku.convert()],
   close(FD).

print_board(Board) =>
   N = Board.length,
   foreach(I in 1..N)
      foreach(J in 1..N)
         X = Board[I,J],
         if var(X) then printf("  _") else printf("  %w", X) end
      end,
      nl
   end,
   nl.


print_board2(Board) =>
   N = Board.length,
   foreach(I in 1..N)
      foreach(J in 1..N)
         X = Board[I,J],
         printf("  %w", X)
      end,
      nl
   end,
   nl.
/* 

  Euler #9 in Picat.

  Problem 9
  """
  A Pythagorean triplet is a set of three natural numbers, a  b  c, for which,
  a^2 + b^2 = c^2

  For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.

  There exists exactly one Pythagorean triplet for which a + b + c = 1000.
  Find the product abc.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

triplet(A,B,C) = Prod =>
    LD = [A,B,C],
    LD :: 1..500,
    A + B + C #= 1000,
    A #=< B, % symmetry breaking
    B #=< C, 
    A**2 + B**2 - C**2 #= 0,
    Prod #= A * B *C,
    solve([degree,split], LD).

% 0.032s
euler9 =>
       Prod = triplet(A,B,C),
       writeln([A,B,C]),
       writeln(Prod).


% 7.17s
euler9b =>
   N = 500,
   Sol = findall(Prod, 
               (between(1,N,C),
                between(1,C,B),
                between(1,B,A),
                A + B + C = 1000,
                A**2 + B**2 - C**2 = 0,
                Prod = A*B*C)),
   println(Sol).

% 1.53s
euler9c =>
   P = [],
   foreach(C in 1..500, B in 1..C, A in 1..B) 
      if A + B + C = 1000, A**2 + B**2 - C**2 = 0 then
         Prod = A*B*C,
         P := P ++ [Prod]
      end
   end,
   println(P)./* 

  Evens puzzle in Picat.

  From Martin Chlond Integer Programming Puzzles:

  http://www.chlond.demon.co.uk/puzzles/puzzles1.html, puzzle nr. 4. 
  Description  : Evens puzzle
  Source       : Boris Kordemsky - The Moscow Puzzles (P8)
  """
  4. Take 16 coins and put them in four rows of four each. Remove 6 leaving an even 
  number of coins in each row and each column.
  
  (Kordemsky)
  """

  This model was inspired by the XPress Mosel model created by Martin Chlond.
  http://www.chlond.demon.co.uk/puzzles/sol1s4.html

  From Model example k4even_ka.mos
  """
  Placing a given number of chips on a 4x4 grid 
  such that every row and every column contains
  an even number of chips.
  """ 

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
  NPos = 4,
  Pos = 1..NPos,
  NChip = 10,

  Place = new_array(NPos,NPos),
  Place :: 0..1,

  sum([Place[R,C] : R in Pos, C in Pos]) #= NChip,
  foreach(R in Pos)
     sum([Place[R,C] : C in Pos]) mod 2 #= 0
  end,
  foreach(C in Pos)
     sum([Place[R,C] : R in Pos]) mod 2 #= 0
  end,

  solve(Place),

  println("Place:"),
  foreach(Row in Place) writeln(Row.to_list()) end,
  nl.


% IP version 
% Inspired by http://www.chlond.demon.co.uk/puzzles/sol1s4.html
go2 =>
  Square = 4,
  Coin = 10,

  X = new_array(Square,Square),
  X :: 0..1,
  N = new_list(Square),
  N :: 0..10000,
  M = new_list(Square),
  M :: 0..10000,

  sum([X[I,J] : I in 1..Square, J in 1..Square]) #= Coin,
  foreach(I in 1..Square)
     sum([X[I,J] : J in 1..Square]) #= 2*N[I]
  end,
  foreach(J in 1..Square)
     sum([X[I,J] : I in 1..Square]) #= 2*M[J]
  end,


  solve(X.to_list() ++ N ++ M),

  writeln(n=N),
  writeln(m=M),
  foreach(Row in X) writeln(Row.to_list()) end,

  nl.



/*

  Decomposition of global constraint exactly in Picat.

  From MiniZinc:
  """
  Requires exactly 'n' variables in 'x' to take the value 'v'.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


%
% exactly(?N,?X,?N)
%
% Requires exactly N variables in X to take the value V.
%
exactly(N, X, V) =>
   Len = X.length,
   BB = new_list(Len),
   BB :: 0..1,
   foreach(I in 1..Len)
       % B in 0..1,
       X[I] #= V #<=> BB[I] #=1
   end,
   N #= sum(BB),
   solve(BB).

% using count
exactly2(N,X,V) => 
  count(V,X,#=,N).

go ?=>
   N :: 2..3, % N: number of V in X
   V :: 1..4, % V: the value

   Len = 4,
   X = new_list(Len),
   X :: 1..Len,
   exactly2(N,X,V),

   Vars = X ++ [N,V],
   solve([],Vars),

   writeln([v=V,n=N]),
   writeln(x=X),
   nl,
   fail.

  
go =>

   N = 5,

   Bernice = 1,
   Carl    = 2,
   Debby   = 3,
   Sammy   = 4, 
   Ted     = 5,
   Children = [Bernice, Carl, Debby, Sammy, Ted],
   ChildrenS = ["Bernice", "Carl", "Debby", "Sammy", "Ted"],

   Story = [BurningBush, Captivity, MosessYouth, Passover,TenCommandments],
   Story :: 1..N,
   StoryS = ["Burning Bush", "Captivity", "MosessYouth", "Passover","Ten Commandments"],

   Age = new_list(N),
   Age :: [3,5,7,8,10],

   Country = [Ethiopia, Kazakhstan, Lithuania, Morocco, Yemen],
   Country :: 1..N,
   CountryS = ["Ethiopia", "Kazakhstan", "Lithuania", "Morocco", "Yemen"],

   all_different(Story),
   all_different(Age),
   all_different(Country),

   % constraints 
   Debby #= Lithuania,

   element(Ted,Age,AgeTed),
   element(Ethiopia,Age,AgeEthiopia),
   element(Passover,Age,AgePassover),
   element(Bernice,Age,AgeBernice),
   element(Yemen,Age,AgeYemen),
   element(Morocco,Age,AgeMorocco),
   element(Sammy,Age,AgeSammy),
   element(MosessYouth,Age,AgeMosessYouth),
   element(TenCommandments,Age,AgeTenCommandments),
   element(BurningBush,Age,AgeBurningBush),
   element(Kazakhstan,Age,AgeKazakhstan),

   AgePassover #= AgeBernice + 2,
   AgeYemen #< AgeEthiopia,
   AgeMorocco #= AgeTed + 3,
   AgeSammy #= AgeMosessYouth + 3,
   Carl #= Captivity,
   AgeTenCommandments #= 5,
   ( 
       (AgeBurningBush #= AgeKazakhstan + 2)
       #\/
       (AgeBurningBush #= AgeKazakhstan + 3)
   ),

   % search
   Vars = Story ++ Age ++ Country,
   solve([],Vars),

   % print solution
   writeln(children=Children),
   writeln(story=Story),
   writeln(country=Country),
   writeln(age=Age),
   nl,
   MaxLen = max([length(SS) : SS in (ChildrenS ++ StoryS ++ CountryS)]),
   MaxLenString = ("%" ++ MaxLen.to_string() ++ "w"),
   print_all(Children,ChildrenS, MaxLenString),
   print_all(Story,StoryS, MaxLenString),
   print_all(Country,CountryS, MaxLenString),
   foreach(A in Age) printf(MaxLenString, A) end,
   nl.

% Original version
print_all1(X,S,MaxLenString) =>
   foreach(I in 1..X.length)
       nth(IX,X,I),
       nth(IX,S,This),
       printf(MaxLenString, This)
   end,
   nl.

%
% Using assignment (inverse) instead.
%
print_all(X,S,MaxLenString) =>
   assignment(X, Inv),
   foreach(I in 1..X.length)
       printf(MaxLenString, S[Inv[I]])
   end,
   nl.


/*

  Optimize eye drops in Picat.

  After a Cataract operation that didn't go well - they 
  didn't put back the lens - I am ordinated three different 
  eye drops to take each day (for a couple of some weeks from now):

    6 drops per day of kind 1 (later: 4 drops)
    3 drops per day of kind 2
    1 drop per day of kind 3 (for the night)

  What is the (an) optimal way of distributing these drops, provided:

   - the day start at 7:00 and end at 23:00
   - the different types should be distributed as "even as possible"
     (whatever that mean)
   - there may just be one drop per hour
   - drop 3 is taken last ("for the night")

  The objective is then to separate the times to take an eye drop type 
  as much as possible (variables z is the sum of dispersion).

  For more about Cataract surgery:
  https://en.wikipedia.org/wiki/Cataract_surgery


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   % Original problem
   % Start = 1, % note: We always start at time 1
   % End = 16, % 23-7
   % Occ = [6,3,1],

   % This is a later ordination:
   % Start = 1,
   % End = 16,
   % Occ = [4,3,1],

   % Even later ordination:
   % Start = 1,
   % End = 16,
   % Occ = [4,2,1,1],

   % % Test
   % Start = 1,
   % End = 16,
   % Occ = [5,5,3,2,1],

   % Test 2
   Start = 1,
   End = 30,
   Occ = [8,5,4,3,2,1],

   StartReal = 7, % The real time to start
   NumTypes = Occ.length,

   MaxTimes = max(Occ),
   Hours = End - Start + 1,

   if sum(Occ) > Hours then
      printf("This is an impossible problem. sum(Occ) [%d] > Hours [%d]\n", sum(Occ), Hours)
   end,

   %
   % decision variables
   % 

   % Note: this is from 1..Hours
   X = new_list(Hours),
   X :: 0..NumTypes,

   % total dispersion
   Z :: 0..1000,

   DropTable = new_array(NumTypes, MaxTimes),
   DropTable :: Start..End,
   % DropTableVars = DropTable.array_matrix_to_list(),
   % DropTableVars :: Start..End,

   DistsTable = new_array(NumTypes, MaxTimes-1),
   DistsTable :: 0..Hours*NumTypes,
   % DistsTableVars = DistsTable.array_matrix_to_list(),
   % DistsTableVars :: 0..Hours*NumTypes,


   % 
   % constraints
   %

   foreach(I in 1..NumTypes) count(I,X,#=, Occ[I]) end,

   foreach(T in 1..NumTypes) 
      make_drop(X, 
                T, 
                Occ[T], 
                [DropTable[T,J] : J in 1..Occ[T]], 
                [DistsTable[T, J] : J in 1..Occ[T]-1], 
                Start, 
                End),
      % fix the unknowns (after occ[t]) in drop_table and dists_table since
      % they are not used in make_drop
      foreach(J in Occ[T]+1..MaxTimes) 
         DropTable[T,J] #= Start
      end,
      foreach(J in Occ[T]..MaxTimes-1) 
         DistsTable[T,J] #= 0
      end
   end,


   % Heuristic to maximize the dispersion
   Z #= sum([(DistsTable[T,J] * (DistsTable[T,J] #= DistsTable[T,I])) 
              : 
              T in 1..NumTypes, I in 1..Occ[T]-1, J in 1..Occ[T]-1, I < J]),

   % Specific constraint: 
   % Type 3 is the last drop to take (not necessarily at the last hour)
   % Note: It assume a single occurrence of the drop type.
   if Occ[NumTypes] == 1 then
        foreach(I in Start..End) 
            X[I] #= NumTypes #=> sum([X[J] #= 0 : J in I+1..End]) #= (I+1..End).length
        end
   end,

   Vars = X ++ DistsTable.to_list() ++ DropTable.to_list(),
   solve($[max,reverse_split,max(Z),$report(printf("Found %d\n", Z))],Vars),

   writeln(z=Z),
   writeln(x=X),

   foreach(H in Start..End)
     printf("%2dh: %d\n", H+StartReal-1, X[H])
   end,

   nl.


% make_drop(_A, _T, _N, _Y, [], _Start, _End) => true.
make_drop(A, T, N, Y, YDist, Start, End) =>
   all_different(Y),
   increasing(Y),
   if YDist.length > 0 then
      foreach(I in 1..N-1) YDist[I] #= Y[I+1]-Y[I] end,
      % Connect the time table (a) with the times of this drop
      foreach(I in Start..End) 
          (A[I] #= T) #<=> (sum([Y[J] #= I : J in 1..N]) #> 0)
      end
   end.



increasing(List) =>
   foreach(I in 2..List.length) List[I-1] #=< List[I] end.

/*

  Mr Greenguest puzzle (fancy dress) in Picat.

  Problem (and LPL) code in
 
  http://diuflx71.unifr.ch/lpl/GetModel?name=/demo/demo2
 
  """
  (** Mr. Greenfan wants to give a dress party where the male guests
   * must wear green dresses. The following rules are given:
   * 1 If someone wears a green tie he has to wear a green shirt.
   * 2 A guest may only wear green socks and a green shirt 
   *   if he wears a green tie or a green hat.
   * 3 A guest wearing a green shirt or a green hat or who does
   *   not wear green socks must wear a green tie.
   * 4 A guest who is not dressed according to rules 1-3 must
   *   pay a $11 entrance fee.
   * Mr Greenguest wants to participate but owns only a green shirt 
   * (otherwise he would have to pay one for $9). He could buy 
   * a green tie for $10, a green hat (used) for $2 and green socks
   * for $12.
   * What is the cheapest solution for Mr Greenguest to participate?
   *)
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   LD = [T,H,R,S,N],
   LD :: 0..1,

   Cost :: 0..10000,

   % This is a straight translation from the LPL 
   ( ((T #=1) #=> (R #=1)) #\/ N#=1),
   ( ((S #=1 #\/ R#=1) #=> (T#=1 #\/ H#=1)) #\/ N#=1),
   ( ((R#=1 #\/ H#=1 #\/ (S#!=1)) #=> T#=1) #\/ N#=1 ),
   Cost #= 10*T + 2*H + 12*S + 11*N,

   Vars = LD ++ [Cost],
   solve([$min(Cost)], Vars),

   writeln(t=T),
   writeln(h=H),
   writeln(r=R),
   writeln(s=S),
   writeln(n=N),
   writeln(cost=Cost),nl.
/* 

  Farmer's planning problem in Picat.

  This is an adjusted version of the Farmer's problem example
  at http://picat-lang.org/download/exs.pi

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
   initial_state(Init),
   time(bplan(Init,L)),
   % time(plan2(Init,L,Cost)),
   write(L.reverse()), nl,
   writeln(len=L.length),
   % writeln(cost=Cost),
   nl.

initial_state(Init) => Init=[s,s,s,s].

goal_state(Goal) => Goal=[n,n,n,n].

table
legal_move(From, Move, To) ?=>
   From= [F,F,G,C],
   Move=farmer_wolf,
   To = [F1,F1,G,C],
   safe(To),
   opposite(F,F1).

legal_move(From,Move,To) ?=> 
   From=[F,W,F,C],
   Move=farmer_goat,
   To=[F1,W,F1,C],
   safe(To),
   opposite(F,F1).
    
legal_move(From,Move,To) ?=> 
   From=[F,W,G,F],
   Move=farmer_cabbage,
   To=[F1,W,G,F1],
   safe(To),
   opposite(F,F1).

legal_move(From,Move,To) => 
   From=[F,W,G,C],
   Move=farmer_alone,
   To=[F1,W,G,C],
   safe(To),
   opposite(F,F1).

index (+,-) (-,+)
opposite(n,s).
opposite(s,n).

safe(Goal) => not unsafe(Goal).

unsafe([F,W,G,_C]),W==G,F!==W => true.
unsafe([F,_W,G,C]),G==C,F!==G => true.

/*

  Fill-a-pix problem in Picat.

  From http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/basiclogic
  """
  Each puzzle consists of a grid containing clues in various places. The 
  object is to reveal a hidden picture by painting the squares around each 
  clue so that the number of painted squares, including the square with 
  the clue, matches the value of the clue. 
  """
 
  http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/rules
  """
  Fill-a-Pix is a Minesweeper-like puzzle based on a grid with a pixilated 
  picture hidden inside. Using logic alone, the solver determines which 
  squares are painted and which should remain empty until the hidden picture 
  is completely exposed.
  """
  
  Fill-a-pix History:
  http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/history

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
    problem(1,Problem),
    fill_a_pix(Problem).

go2 =>
    foreach(P in 1..3)
       writef("\nProblem %w\n",P),
       problem(P,Problem),
       fill_a_pix(Problem)
    end.


fill_a_pix(Problem) =>

    N = Problem.length,

    X = new_array(N,N),
    X :: 0..1,

    foreach(I in 1..N)
       foreach(J in 1..N) 
          ProblemIJ = Problem[I,J],
            if ground(ProblemIJ) then
                ProblemIJ #= sum([XIAJB :  A in -1..1, B in -1..1,
                                  I+A >  0, J+B >  0,
                                  I+A =< N, J+B =< N,
                                  XIAJB = X[I+A,J+B]])
            end
        end
    end,

    % search
    solve(X),

    pretty_print(X),
    nl.



pretty_print(X) =>
    N = X.length,
    foreach(I in 1..N)
       foreach(J in 1..N)
          if X[I,J] == 1 then writef("#") else writef(" ") end
       end,
       nl
    end.



% Puzzle 1 from 
% http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/rules
% 
problem(1, P) => 
      P = [[_,_,_,_,_,_,_,_,0,_],
           [_,8,8,_,2,_,0,_,_,_],
           [5,_,8,_,_,_,_,_,_,_],
           [_,_,_,_,_,2,_,_,_,2],
           [1,_,_,_,4,5,6,_,_,_],
           [_,0,_,_,_,7,9,_,_,6],
           [_,_,_,6,_,_,9,_,_,6],
           [_,_,6,6,8,7,8,7,_,5],
           [_,4,_,6,6,6,_,6,_,4],
           [_,_,_,_,_,_,3,_,_,_]].





% Puzzle 2 from 
% http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/rules
% 
problem(2, P) => 
       P = [[0,_,_,_,_,_,3,4,_,3],
            [_,_,_,4,_,_,_,7,_,_],
            [_,_,5,_,2,2,_,4,_,3],
            [4,_,6,6,_,2,_,_,_,_],
            [_,_,_,_,3,3,_,_,3,_],
            [_,_,8,_,_,4,_,_,_,_],
            [_,9,_,7,_,_,_,_,5,_],
            [_,_,_,7,5,_,_,3,3,0],
            [_,_,_,_,_,_,_,_,_,_],
            [4,4,_,_,2,3,3,4,3,_]].


% Puzzle from 
% http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/basiclogic
%
% Code: 030.15x15
% ID: 03090000000
% 
problem(3, P) => 
       P = [[_,5,_,6,_,_,_,_,_,_,6,_,_,_,_],
            [_,_,7,6,_,4,_,_,4,_,_,8,9,_,5],
            [5,_,_,5,_,5,_,3,_,6,_,7,_,_,6],
            [4,_,2,_,4,_,4,_,3,_,2,_,_,9,_],
            [_,_,_,5,_,4,_,3,_,4,_,4,5,_,6],
            [_,4,3,3,4,_,_,_,4,_,2,_,_,_,_],
            [_,_,_,_,_,_,_,_,_,5,_,_,_,4,_],
            [3,_,3,_,_,3,_,_,_,5,_,4,4,_,_],
            [_,_,_,4,3,_,3,3,_,_,5,7,6,_,_],
            [4,_,_,_,2,_,3,3,2,_,8,9,_,5,_],
            [_,_,3,_,_,_,_,5,_,_,7,_,8,_,_],
            [4,_,_,3,2,_,_,_,_,_,7,_,_,6,_],
            [_,_,4,_,5,4,4,_,_,9,6,_,_,_,_],
            [_,3,5,7,_,6,_,_,_,_,_,_,7,_,_],
            [_,_,4,6,6,_,_,_,6,5,_,_,_,4,_]].



/*

  Fill-in the squares problem (Brainjammer) in Picat.

  This problem is from the ZDC system, available from 
  http://www.bracil.net/CSP/cacp/cacpdemo.html , in the
  file 
     Brainjammer.txt 
  from 2003-01-26, which states:
  """
  Only Solution is:
        1	2	3	4	5
  ====================================================
  A  	 7	11	2	17	1
  B	13	19	23	22	3
  C	9	20	24	14	12
  D	16	21	25	18	10
  E	4	8	15	6	5

  22mins55secs of CPU time to find first solution
  50mins42secs of CPU time with duplicate induced variables removed?
  Maybe this has something to do with the variable ordering...as this might change
  as a result of removing duplicate induced variables.
  1hr:34 mins of CPU time to find a single solution and determine no other solutions
  exist.

  Statistics for finding the first solution:
  (with duplicate induced nodes removed)
  CPU seconds: 		4880.63	(On a Pentium Pro 200Mhz, VC++)
  Node count:			4036162
  Induced node count:	1849214
  Backtracks:			5885311
  """

  Notes:
  - On my 8 core 2.8 Mhz (Linux Ubuntu) it takes about 0.02 seconds 
    and 0 backtracks to solve this problem (include proving the 
    uniqueness of the solution), but the comparison is really 
    not fair considering the difference in machines then and now.

  - The only references to this problem I've found are the following pages:
    http://discuss.fogcreek.com/techInterview/default.asp?cmd=show&ixPost=2787
    http://notdarkandstormy.blogspot.com/2005/05/funky-logic-problem.html
    and especially 
    http://perplexus.info/show.php?pid=2683
    which has a lot of comments about manually solving the problem.

  I've yet to know the original source.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go1 =>
   time2($findall(_,problem(_))).



problem(ALL) =>

   N = 5,

   A = new_list(N), A :: 1..N**2,
   B = new_list(N), B :: 1..N**2,
   C = new_list(N), C :: 1..N**2,
   D = new_list(N), D :: 1..N**2,
   E = new_list(N), E :: 1..N**2,

   ASum #= sum(A),
   BSum #= sum(B),
   CSum #= sum(C),
   DSum #= sum(D),
   ESum #= sum(E),

   % Each number from 1-25, used only once
   % N2 = N**2,
   % ALL = new_list(N2),
   % foreach(I in 1..N)
   %    ALL[I] #= A[I],
   %    ALL[I+N] #= B[I],
   %    ALL[I+2*N] #= C[I],
   %    ALL[I+3*N] #= D[I],
   %    ALL[I+4*N] #= E[I]
   % end,
   ALL = A ++ B ++ C ++ D ++ E,

   all_different(ALL),

   %1.Sum of each column is odd
   foreach(I in 1..N) (A[I] + B[I] + C[I] + D[I] + E[I]) mod 2 #= 1 end,

   %2.Sum of each row, except C is even
   ASum mod 2 #= 0,
   BSum mod 2 #= 0,
   CSum mod 2 #= 1,
   DSum mod 2 #= 0,
   ESum mod 2 #= 0,
   
   
   %3.Sum of row A is not greater than the sum of any other row
   ASum #=< BSum,
   ASum #=< CSum,
   ASum #=< DSum,
   ASum #=< ESum,
  
   %4.The sum of diagonal A1 to E5 is greater than the sum of
   %  diagonal E1 to A5
   A[1] + B[2] + C[3] + D[4] + E[5]  #> E[1] + D[2] + C[3] + B[4] + A[5],
  
   %5.(A4 + B4) is greater than (C4+D4+E4)
   A[4] + B[4] #> C[4] + D[4] + E[4],
  
   %6. A1 + B1 = D1 + E1
   A[1] + B[1] #= D[1] + E[1],
    
   %7. A1 > E1
   A[1] #> E[1],
  
   %8. A1, A3 and B1 are primes
   is_prime(A[1]),
   is_prime(A[3]),
   is_prime(B[1]),

   %9.(A3 + E3) is a prime number
   A3E3 #= A[3]+E[3],
   is_prime(A3E3),


   %10. A5,D1,D3 and E1 are squares
   is_square(A[5]),
   is_square(D[1]),
   is_square(D[3]),
   is_square(E[1]),

   %11. B2, C2, and D2 are ascending consecutive numbers
   B[2] + 1 #= C[2],
   C[2] + 1 #= D[2],
  
   %12. B3, C3, and D3 are ascending consecutive numbers
   B[3] + 1 #= C[3],
   C[3] + 1 #= D[3],
   
   %13. B5 + D5 = A5 + C5
   B[5] + D[5] #= A[5] + C[5],

   %14. (c1)^2 + (c5)^2 = (e3)^2
   C1s #= C[1]*C[1],
   C5s #= C[5]*C[5],
   E3s #= E[3]*E[3],
   C1s + C5s #= E3s,

   %15. C5 is a two-digit number
   C[5] #> 9,
   
   %16. D5 is a multiple of E5
   D[5] mod E[5] #= 0,
         
   %17. E1 + E3 = E2 + E4 + E5
   E[1] + E[3] #= E[2] + E[4] + E[5],

   solve([ffd,down],ALL),

   % writeln(all=ALL),
   writeln(a=A),
   writeln(b=B),
   writeln(c=C),
   writeln(d=D),
   writeln(e=E),
   nl.


is_prime(V) =>
   member(V, [2,3,5,7,11,13,17,19,23]).

is_square(V) =>
   member(V, [1,4,9,16,25]).
/*

  Finding celebrities problem in Picat.

  From Uwe Hoffmann
  "Finding celebrities at a party"
  http://www.codemanic.com/papers/celebs/celebs.pdf
  """
  Problem: Given a list of people at a party and for each person the list of
  people they know at the party, we want to find the celebrities at the party. 
  A celebrity is a person that everybody at the party knows but that 
  only knows other celebrities. At least one celebrity is present at the party.
  """
  (This paper also has an implementation in Scala.)
  
  Note: The original of this problem is 
    Richard Bird and Sharon Curtis: 
    "Functional pearls: Finding celebrities: A lesson in functional programming"
    J. Funct. Program., 16(1):1320, 2006.

  The problem from Hoffmann's paper is to find of who are the 
  celebrity/celebrities in this party graph:
    Adam  knows {Dan,Alice,Peter,Eva},
    Dan   knows {Adam,Alice,Peter},
    Eva   knows {Alice,Peter},
    Alice knows {Peter},
    Peter knows {Alice}
  
  Solution: the celebrities are Peter and Alice.

  I blogged about this problem in "Finding celebrities at a party"
  http://www.hakank.org/constraint_programming_blog/2010/01/finding_celebrities_at_a_party.html

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   foreach(P in 1..4)
      writeln(problem=P),
      if find_celebrities(P,Celebrities) then
         println(celebrities=Celebrities),
         printf("celebs: %w\n", [I : I in 1..Celebrities.length, Celebrities[I] #= 1])
      else
         println("no solution")
      end,
      nl
   end.


% Find the celebrities of problem P
find_celebrities(P,Celebrities) =>

   problem(P,N,Party),

   Celebrities = new_list(N),
   Celebrities :: 0..1, % is this a celebrity
   NumCelebrities #= sum(Celebrities),

   % There is at least one celebrity
   % NumCelebrities #> 0,

   % All persons know the celebrities,
   % and the celebrities only know celebrities.
   foreach(I in 1..N)
      Celebrities[I] #<=> sum([(Party[J,I]#=1) : J in 1..N]) #= N,
      Celebrities[I] #<=> sum([(Party[I,J]#=1) : J in 1..N]) #= NumCelebrities
   end,

   solve(Celebrities).


%
% The party graph of the example above:
%
%  Adam  knows [Dan,Alice,Peter,Eva],  [2,3,4,5]
%  Dan   knows [Adam,Alice,Peter],     [1,4,5]
%  Eva   knows [Alice,Peter],     [4,5]
%  Alice knows [Peter],      [5]
%  Peter knows [Alice]       [4]
%
% Solution: Peter and Alice (4,5) are the celebrities.
%
problem(1, N, Party) => 
  N = 5,
  Party = [
    [1,1,1,1,1], % 1
    [1,1,0,1,1], % 2
    [0,0,1,1,1], % 3
    [0,0,0,1,1], % 4
    [0,0,0,1,1]  % 5
   ].



% In this example Alice (4) also knows Adam (1),
% which makes Alice a non celebrity, and since
% Peter (5) knows Alices, Peter is now also a
% non celebrity. Which means that there are no
% celebrities at this party.
% 
problem(2, N, Party) => 
   N = 5,
   Party = [
            [1,1,1,1,1],
            [1,1,0,1,1],
            [0,0,1,1,1],
            [1,0,0,1,1],
            [0,0,0,1,1]
           ].

%
% Here is another example. It has the following
% cliques:
%  [1,2]
%  [4,5,6]
%  [6,7,8]
%  [3,9,10]
%
% The celebrities are [3,9,10]
%
problem(3,N, Party) => 
   N = 10,
   Party = [
      %   1 2 3 4 5 6 7 8 9 10
          [0,1,1,0,0,0,0,1,1,1],
          [1,0,1,0,0,0,0,0,1,1],
          [0,0,1,0,0,0,0,0,1,1],
          [0,1,1,0,1,1,0,0,1,1],
          [0,0,1,1,0,1,0,0,1,1],
          [0,0,1,1,1,0,1,1,1,1],
          [0,0,1,0,0,1,0,1,1,1],
          [0,0,1,0,0,1,1,0,1,1],
          [0,0,1,0,0,0,0,0,1,1],
          [0,0,1,0,0,0,0,0,1,1]
   ].

%
% This is the same graph as the one above
% with the following changes:
%   - 9 don't know 3 or 10
% This party graph know consists of just 
% one celebrity: [9]
%
problem(4,N,Party) => 
   N = 10,
   Party = [
            [0,1,1,0,0,0,0,1,1,1],
            [1,0,1,0,0,0,0,0,1,1],
            [0,0,1,0,0,0,0,0,1,1],
            [0,1,1,0,1,1,0,0,1,1],
            [0,0,1,1,0,1,0,0,1,1],
            [0,0,1,1,1,0,1,1,1,1],
            [0,0,1,0,0,1,0,1,1,1],
            [0,0,1,0,0,1,1,0,1,1],
            [0,0,0,0,0,0,0,0,1,0],
            [0,0,1,0,0,0,0,0,1,1]
          ].
/*

  Find the missing permutation in Picat.

  From http://rosettacode.org/wiki/Find_the_missing_permutation
  """
  These are all of the permutations of the symbols A, B, C and D, 
  except for one that's not listed. Find that missing permutation.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 

   P1 = ["ABCD","CABD","ACDB","DACB","BCDA","ACBD",
         "ADCB","CDAB","DABC","BCAD","CADB","CDBA",
         "CBAD","ABDC","ADBC","BDCA","DCBA","BACD",
         "BADC","BDAC","CBDA","DBCA","DCAB"],
   Perms = permutations("ABCD"),

   % very imperative
   Missing = _,
   foreach(P in Perms, Missing = _)
      Found = false,
      foreach(T in P1) 
         if P == T then
            Found := true
          end
      end,
      if not Found then
        Missing := P
      end
   end,
   println(missing1=Missing),

   % somewhat less imperative
   Missing2 = _,
   foreach(P in Perms, Missing2 = _)
      if not member(P,P1) then
        Missing2 := P
      end
   end,
   println(missing2=Missing2),


   % using findall (predicate)
   println(missing3=difference(Perms,P1)),

   % findall approach as a one-liner
   println(missing4=findall(X,(member(X,Perms),not(member(X,P1))))),

   % using ordsets
   println(missing5=subtract(new_ordset(Perms),new_ordset(P1))),

   % list comprehension (and member for the check)
   println(missing6=[P:P in Perms,not member(P,P1)]),

   % maps
   Map = new_map(),
   foreach(P in P1) Map.put(P,1) end,
   println(missing7=[P:  P in Perms, not Map.has_key(P)]),


   % "merge sort" variant, using sorted lists
   % (zip/2 requires that the length of the two lists are the same, hence the dummy)
   PermsSorted = Perms.sort(),
   P1Sorted = P1.sort(),
   Found2 = false,
   foreach({P,PP} in zip(PermsSorted,P1Sorted ++ ["DUMMY"]), Found2 = false)
     if P != PP then
        println(missing8=P),
        Found2 := true
     end
   end,

   % variant with list comprehension
   A = [cond(P == PP,1,0) : {P,PP} in zip(PermsSorted,P1Sorted ++ ["DUMMY"])],
   println(missing9=[PermsSorted[I] : I in 1..PermsSorted.length, A[I] = 0].first()),

   % shorter
   println(missing10=[P:{P,PP} in zip(PermsSorted,P1Sorted ++ ["DUMMY"]), P != PP].first()),

   
   % CP variant
   ABCD = new_map(['A'=1,'B'=2,'C'=3,'D'=4]),
   % convert to integers (for the table constraint)
   P1Table = [ [ABCD.get(C,0) : C in P].to_array() : P in P1],
   Missing3 = new_list(4), Missing3 :: 1..4,
   all_different(Missing3),
   table_notin({Missing3[1],Missing3[2],Missing3[3],Missing3[4]},P1Table),
   solve(Missing3),
   ABCD2 = "ABCD",
   println(missing11=[ABCD2[I] : I in Missing3]),
   

   % matrix approach
   PermsLen = Perms.length,
   P1Len = P1.length,
   A2 = new_array(PermsLen,P1Len), bind_vars(A2,0),
   foreach(I in 1..PermsLen, J in 1..P1Len, Perms[I] = P1[J])
     A2[I,J] := 1
   end,
   println(missing12=[Perms[I] : I in 1..PermsLen, sum([A2[I,J] : J in 1..P1Len])=0]),


   % inspired by the Perl 6 xor variant
   println(missing13=to_fstring("%X",reduce(^,[parse_term("0x"++P):P in P1]))),

   % count the character with the least occurrence (=5) for each positions (1..4)
   % (based on my K version)
   println(missing14=[[O:O=5 in Occ]:Occ in [occurrences([P[I]:P in P1]):I in 1..4]]),

   % variant using sorting the occurrences
   println(missing15a=[C:C=_ in [sort2(Occ).first():Occ in [occurrences([P[I]:P in P1]):I in 1..4]]]),
   % transpose instead of array index
   println(missing15b=[C:C=_ in [sort2(O).first():T in transpose(P1),O=occurrences(T)]]),
   % extract the values with first
   println(missing15c=[sort2(O).first():T in transpose(P1),O=occurrences(T)].map(first)),
   println(missing15d=[sort2(O).first().first():T in transpose(P1),O=occurrences(T)]),
   println(missing15e=[S[1,1]:T in transpose(P1),S=sort2(occurrences(T))]),

   % delete/2
   Perms2 = Perms,
   foreach(P in P1) Perms2 := delete(Perms2,P) end,
   println(missing16=Perms2),

   nl.


difference(Xs,Ys) = findall(X,(member(X,Xs),not(member(X,Ys)))).

% return a map with the elements and the number of occurrences
occurrences(List) = Map =>
  Map = new_map(),
  foreach(E in List)
     Map.put(E, cond(Map.has_key(E),Map.get(E)+1,1))
  end.

% sort a map according to values
sort2(Map) = [K=V:_=(K=V) in sort([V=(K=V): K=V in Map])]/* 

  First 100 Pi Digits in Picat.

  From "Fun With Num3ers": "First 100 Pi Digits| Forming primes"
  http://benvitalenum3ers.wordpress.com/2013/08/16/first-100-pi-digits-forming-primes/

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
  foreach(N in 1..8)
     Pi = [P.to_string() : P in pi(N)].flatten(),
     println(pi=Pi),
     All = [P : P in permutations(Pi), prime(P.parse_term())],
     println([n=N,All, len=All.length])
  end,
  nl.

% Another approach: slices
go2 =>

  % Pi = "3141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067",
  Pi = [P.to_string() : P in pi(100)].flatten(), % converts to string
  println(pi=Pi),
  foreach(Len in 2..13)
     println(len=Len),
     foreach(P in [parse_term(I) : I in array_slice(Pi,Len)])
        IsP = cond(prime(P),prime,no_prime),
        print([P,IsP]),
        nl
     end
  end,
  nl.


%
% slices an array A [...] into slices of length SliceLen
% and returns a list List
%
array_slice(A, SliceLen) = List =>
        List = [A2 : I in 1..A.length-SliceLen,
                A2 = [ A[J] : J in I..I+SliceLen-1] ].


% Get first Len digits of Pi
pi(Len) = Res => 
   Ndigits = 0,
   Q = 1,
   R = 0,
   T = Q,
   K = Q,
   N = 3,
   L = N,

   Res = "",
   C = 1, % counter for presentation
   while (C <= Len)
       if 4 * Q + R - T < N * T then
           Res := Res ++ [N],
           C := C + 1,
           Ndigits := Ndigits + 1,
           NR := 10 * (R - N * T),
           N := ((10 * (3 * Q + R)) // T) - 10 * N,
           Q := Q* 10,
           R := NR
       else
           NR := (2    * Q + R) * L,
           NN := (Q * (7 * K + 2) + R * L) // (T * L),
           Q := Q * K,
           T := T* L,
           L := L + 2,
           K := K+1,
           N := NN,
           R := NR
       end
   end,
   nl.
/*

  Five brigands problem in Picat.

  From http://www.comp.nus.edu.sg/~henz/projects/puzzles/arith/index.html
  """
  The Five Brigands    from "Amusements in Mathematics, Dudeney",
  number 133.

  The five Spanish brigands, Alfonso, Benito, Carlos, Diego, and Esteban,
  were counting their spoils after a raid, when it was found that they
  had captured altogether exacly 200 doubloons. One of the band pointed
  out that if Alfonso had twelve times as much, Benito three times as
  much, Carlos the same amount, Diego half as much, and Esteban one-
  third as much, they would still have altogether just 200 doubloons.
  How many doubloons had each?

  There are a good many equally correct answers to this problem. The
  puzzle is to discover exactly how many different answers there are, it
  being understood that every man had something and there is to be no
  fractional money. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   L = findall(LD, $brigands(LD)),
   Len = length(L),
   writeln(len=Len),
   foreach(El in L) writeln(El) end.

brigands(LD) =>

   LD = [A,B,C,D2,E3],
   LD :: 8..160, % Everybody has at least 8d.; nobody has more than 160
   A + B + C + 2*D2 + 3*E3 #= 200,
   A * 12 + B * 3 + C + D2 + E3  #= 200,
   D2 :: 8..100,
   E3 :: 8..66,

   solve(LD).
/*

  Five elements problem in Picat.

  From 
  Charles W. Trigg, PI MU EPSILON JOURNAL, Valume 6, Fall 1977, Number 5
  """
  From the following square array of the first 25 positive integers, 
  choose five, no two of the same row or column, so that the maximum of
  the five elements is as small as possible.

     2 13 16 11 23
    15  1  9  7 10
    14 12 21 24  8
     3 25 22 18  4
    20 19  6  5 17
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   matrix(1,Matrix),
   N = Matrix.len,

   % decision variables
   X = new_array(N,N),
   X :: 0..1,
   XVars = vars(X),

   Y = new_list(N),
   Y :: 1..N*N,

   % constraints

   % ensure unicity of rows and columns
   foreach(I in 1..N)
      sum([X[I,J] : J in 1..N]) #= 1,
      sum([X[J,I] : J in 1..N]) #= 1
   end,

   % Find the specific row I for which X[I,J] is 1.
   %
   % Using freeze/2 and the Is list in the labeling 
   % seems to be the only way (when using this matrix approach)
   Is = [],
   foreach(J in 1..N)
      I :: 1..N,
      freeze(I, 1 #= X[I,J]),
      freeze(I, Y[I] #= Matrix[I,J]),
      Is := Is ++ [I]
    end,

   MaxY #= max(Y),

   Vars = XVars ++ Y ++ Is,

   solve([$min(MaxY), ff], Vars),

   println(values=Y),
   println(maxY=MaxY),
   println(is=Is),
   foreach(Row in X) println(Row) end,
   nl.


%
% Using reification instead of element for connecting between
% X and Y.
%
go2 =>

   matrix(1,Matrix),
   N = Matrix.len,

   X = new_array(N,N),
   X :: 0..1,
   XVars = vars(X),

   Y = new_list(N),
   Y :: 1..max(Matrix.flatten()),

   % ensure unicity of rows and columns
   foreach(I in 1..N)
      sum([X[I,J] : J in 1..N]) #= 1,
      sum([X[J,I] : J in 1..N]) #= 1
   end,

   % Find the specific row I for which X[I,J] is 1.
   foreach(J in 1..N, I in 1..N)
     (X[I,J] #= 1) #<=> (Y[I] #= Matrix[I,J])
   end,

   MaxY #= max(Y),

   Vars = XVars ++ Y,
   solve([$min(MaxY), ff], Vars),

   println(values=Y),
   println(maxY=MaxY),
   foreach(Row in X) println(Row) end,
   nl.

%
% Direct IP approach: we don't need Y at all.
% 
go3 =>

   matrix(1,Matrix),
   N = Matrix.len,

   X = new_array(N,N),
   X :: 0..1,
   XVars = vars(X),

   % ensure unicity of rows and columns
   foreach(I in 1..N)
      sum([X[I,J] : J in 1..N]) #= 1,
      sum([X[J,I] : J in 1..N]) #= 1
   end,

   MaxY #= max([sum([X[J,I]*Matrix[I,J] : J in 1..N]) : I in 1..N]),

   Vars = XVars,
   solve([$min(MaxY), ff], Vars),

   foreach(Row in X)
     println(Row)
   end,
   println(values=[sum([X[J,I]*Matrix[I,J] : J in 1..N]) : I in 1..N]),
   println(maxY=MaxY),
   nl.


%
% Another approach, not using the 0/1 matrix at all: 
% We already know that each row must distinct (cf the approach 
% most often used in the n-queens problem).
%
%   - X contains the Matrix values for each row
%   - Cols is the column selected for each row.
%     Cols must be distinct
%
go4 =>
   matrix(1,Matrix),
   N = Matrix.len,

   X = new_list(N),
   X :: 1..max(Matrix.flatten()),

   Cols = new_list(N),
   Cols :: 1..N,

   % ensure unicity of rows and columns
   foreach(I in 1..N)
      element(J,Matrix[I],X[I]),
      Cols[I] #= J
   end,
   all_different(Cols),

   MaxX #= max(X),

   Vars = X ++ Cols,
   solve([$min(MaxX), ff], Vars),

   println(values=X),
   println(cols=Cols),
   println(maxX=MaxX),
   nl.


matrix(1,Matrix) =>
   Matrix = 
       [[ 2, 13, 16, 11, 23],
        [15,  1,  9,  7, 10],
        [14, 12, 21, 24,  8],
        [ 3, 25, 22, 18,  4],
        [20, 19,  6,  5, 17]].

/* 

  5x5 puzzle in Picat.


  From Martin Chlond Integer Programming Puzzles:
  http://www.chlond.demon.co.uk/puzzles/puzzles1.html, puzzle nr. 11.
  Description  : 5 X 5 puzzle
   Source       : Unknown

  This model was inspired by the XPress Mosel model created by Martin Chlond.
  http://www.chlond.demon.co.uk/puzzles/sol1s11.html


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
  N = 5,
  X = new_array(N,N),
  X :: 0..1,

  D = new_array(N,N),
  D :: 0..10000,

  Moves #= sum([X[I,J] : I in 1..N, J in 1..N]),  

  foreach(I in 1..N, J in 1..N)
        sum([X[I,K] : K in J-1..J+1, K >= 1, K <= N, K != J]) +
        sum([X[K,J] : K in I-1..I+1, K >= 1, K <= N]) #= 2*D[I,J]+1
  end,

  solve($[min(Moves)], X.to_list() ++ D.to_list() ++ [Moves]),

  writeln(moves=Moves),
  foreach(Row in X) println(Row.to_list()) end,

  nl.

/* 

  Fixed charge in Picat.

  Ported from the B-Prolog model:
  http://www.probp.com/cp_sat_lp/fixed_charge.pl
  """
  by Wen Wei Rong, Feb. 2012
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
	machines(Machine),
	NbMachine = Machine.length,
	
	resourceName(ResName),
	NbRes = ResName.length,
	
	products(Product),
	NbProd = Product.length,
	
	go(NbMachine, NbRes,NbProd).


go(NbMachine, NbRes, NbProd) =>
	Rent = new_list(NbMachine),
	Produce = new_list(NbProd),
	
	%accessing the database
	resources(Use),
	profit(Profit),
	rentingCost(RCost),
	capacity(Cap),
	MaxCap = max(Cap),	%obtaining the max capacity
	
	%domains
	Rent :: 0..1,
	Produce :: 0..MaxCap,
	
	%constraints
	foreach(R in 1..NbRes)
	   sum([Use[P,R]*Produce[P]: P in 1..NbProd]) #=< Cap[R]
        end,
	
	foreach(P in 1..NbProd)
            % Rent[P] is actually Rent[M]
	   Produce[P] #=< Rent[P] * MaxCap
        end,

	%objective
	TotalCost #= sum([Profit[P]*Produce[P]: P in 1..NbProd])-sum([RCost[M]*Rent[M]: M in 1..NbMachine]),

        append(Rent,Produce,AllVars),	
        solve($[max(TotalCost)],AllVars),
	writeln($total_cost(TotalCost)),
	writeln($rent(Rent)),
	writeln($produce(Produce)).

%data
index(-)
products([shirts, shorts, pants]). 

index(-)
resourceName([labor, cloth]).

index(-)
capacity([150, 160]).

index(-)
rentingCost([200, 150, 100]).
%product data
index(-)
profit([6,4,7]).
index(-)
machines([shirtM, shortM, pantM]).
index(-)
resources([[3,4],
           [2,3],
	  [6,4]]).
/*

  FizzBuzz in Picat.

  http://rosettacode.org/wiki/FizzBuzz
  """
  Write a program that prints the numbers from 1 to 100. 
  But for multiples of three print "Fizz" instead of the number 
  and for the multiples of five print "Buzz". For numbers which 
  are multiples of both three and five print "FizzBuzz".
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 

    fizzbuzz(100, fb1),
    fizzbuzz(100, fb2),
    fizzbuzz(100, fb3),
    fizzbuzz4(100),
    fizzbuzz(100, fb5),
    fizzbuzz6(100),
    fizzbuzz7(100),
    fizzbuzz7b(100),
    fizzbuzz8(100),
    fizzbuzz9(100),
    fizzbuzz9b(100),
    nl.

go2 => 
    foreach(I in 1..100) 
      FB = fb2(I),
      printf("%w,%w\n",I,FB)
    end,
    nl.  

fizzbuzz(N, Goal) => 
    printf("Testing %w\n", $Goal),
    foreach(I in 1..N)
       printf("%w ", apply(Goal,I))
    end,
    nl.

% using a map
fizzbuzz4(N) => 
    println("fizzbuzz4"),
    FB = [I : I in 1..N],
    Map = [(3="Fizz"),(5="Buzz"),(15="FizzBuzz")],
    foreach(I in FB,K=V in Map) 
       if I mod K == 0 then
          FB[I] := V
       end
    end,
    println(FB).

% another approach: use a template for the pattern
fizzbuzz6(N) => 
   println("\nfizzbuzz6"),
   F = [_,_,fizz,_,buzz,fizz,_,_,fizz,buzz,_,fizz,_,_,fizzbuzz],
   FF = [F : _I in 1..1+N div F.length].flatten(),
   foreach(I in 1..N)
      (var(FF[I]) -> print(I) ; print(FF[I])),
      print(" ")
   end,
   nl.

% a little of the same idea as fizzbuzz6
fizzbuzz7(N) => 
   println("\nfizzbuzz7"),
   F = new_list(N),
   FV = [3,5,15],
   FN = ["Fizz","Buzz","FizzBuzz"],
   foreach(I in 1..N, {Val,Name} in zip(FV,FN)) 
      if I mod Val == 0 then F[I] := Name end
   end,
   foreach(I in 1..N)
      printf("%w ", cond(var(F[I]),I, F[I]))
   end,
   nl.

fizzbuzz7b(N) => 
   println("\nfizzbuzz7bx"),
   F = [0 : _I in 1..N],
   FV = [3,5,15],
   FN = ["Fizz","Buzz","FizzBuzz"],
   foreach(I in 1..N, {Val,Name} in zip(FV,FN)) 
      if I mod Val == 0 then F[I] := Name end
   end,
   foreach(I in 1..N)
      printf("%w ", cond(F[I] == 0, I, F[I]))
   end,
   nl.

fizzbuzz8(N) => 
   println("\nfizzbuzz8"),
   plan(N,Plan),
   println(Plan.reverse()),
   nl.

fizzbuzz9(N) => 
  println("\nfizzbuzz9"),
  fb9(N,[],L),
  println(L),
  nl.

fizzbuzz9b(N) => 
  println("\nfizzbuzz9b"),
  fb9b(N,[],L),
  println(L),
  nl.


%   
% plain imperative approach
%
fb1(I) = V =>
   V = I.to_string(),
   if     I mod 15 == 0 then V := "FizzBuzz"
   elseif I mod  3 == 0 then V := "Fizz" 
   elseif I mod  5 == 0 then V := "Buzz" 
   end.

%  
% pattern matching + conditions in head
%
fb2(I) = "FizzBuzz", I mod 15 == 0 => true.
fb2(I) = "Fizz",     I mod  3 == 0 => true.
fb2(I) = "Buzz",     I mod  5 == 0 => true.
fb2(I) = I.to_string()             => true.


%
% string concatenation and cond/3
%
fb3(I) = cond(I mod 3 == 0, "Fizz", "") ++ 
         cond(I mod 5 == 0, "Buzz", "")  ++
         cond(not ((I mod 3 == 0; I mod 5==0)), I.to_string(), "").

%
% pattern matching
%
fb5(I) = fb5b(I, I mod 3, I mod 5).
fb5b(_I,0,0) = "FizzBuzz".
fb5b(_I,_,0) = "Buzz".
fb5b(_I,0,_) = "Fizz".
fb5b(I,_,_)  = I.

%
% Traditional LP
%
fb9(N,L1,L) ?=>
  N = 0,
  L = L1.reverse().

fb9(N,L1,L) ?=>
  N mod 15 == 0,
  fb9(N-1,L1 ++ ["FizzBuzz"], L).

fb9(N,L1,L) ?=>
  N mod 5 == 0,
  fb9(N-1,L1 ++ ["Buzz"], L).

fb9(N,L1,L) ?=>
  N mod 3 == 0,
  fb9(N-1,L1 ++ ["Fizz"], L).

fb9(N,L1,L) =>
  % N mod 3 > 0,
  % N mod 5 > 0,
  fb9(N-1,L1 ++ [N.to_string()], L).

%
% LP variant with conditions
%
fb9b(N,L1,L), N = 0 ?=>
  L = L1.reverse().

fb9b(N,L1,L),N mod 15 == 0 ?=>
  fb9b(N-1,L1 ++ ["FizzBuzz"], L).

fb9b(N,L1,L), N mod 5 == 0 ?=>
  fb9b(N-1,L1 ++ ["Buzz"], L).

fb9b(N,L1,L), N mod 3 == 0 ?=>
  fb9b(N-1,L1 ++ ["Fizz"], L).

fb9b(N,L1,L), N mod 3 > 0, N mod 5 > 0 =>
  fb9b(N-1,L1 ++ [N.to_string()], L).


%
% planner variant, for fizzbuzz8
%
final(Goal) => Goal == 0.

action(H,To,Move,Cost) ?=> 
  H mod 15 == 0,
  Move = "FizzBuzz",
  To = H-1,
  Cost = 1.

action(H,To,Move,Cost) ?=> 
  H mod 5 == 0,
  Move = "Buzz",
  To = H-1,
  Cost = 1.

action(H,To,Move,Cost) ?=> 
  H mod 3 == 0,
  Move = "Fizz",
  To = H-1,
  Cost = 1.

action(H,To,Move,Cost) => 
  H mod 3 > 0,
  H mod 5 > 0,
  Move = H.to_string(),
  To = H-1,
  Cost = 1.
/* 

  Flag problem in Picat.

  From
  "How to Solve it With B-Prolog?"
  http://www.cs.nmsu.edu/ALP/2010/08/how-to-solve-it-with-b-prolog/
  (Prolog Programming Contest 2010)

  """
  The Prolog Programming Contest flag grows bigger with every edition. 
  Here are those for the first, second and third edition:
  _              _                    _
 (_)            (_)                  (_)
<___>          <___>                <___>
 | |_____       | |_____             | |_____
 | |    |       | |     )            | |     )
 | |    |       | |    (_____        | |    (_____
 | |    |       | |    |    |        | |    |     )
 | |~~~~~       | |~~~~|    |        | |~~~~|    (_____
 | |            | |    |    |        | |    |    |    |
                | |    ~~~~~~        | |    ~~~~~|    |
                | |                  | |         |    |
                                     | |         ~~~~~~
                                     | |

  Write a general flag/1 predicate that generates the flag for 
  any edition N on the screen by the goal ?-flag(N). Do not add 
  extra spaces to the left!
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
  flag(3),
  flag(4),
  flag(5),
  nl.


flag(N) =>
   printf("  _%n (_)%n<___>%n"),
   NR = 2*N+4,
   NC = 5*N+5,
   A = new_array(NR,NC),
   p(A,1,5,N),
   foreach(I in 1..NR) A[I,2] = "|", A[I,4] = "|" end,
   foreach(I in 1..NR, J in 1..NC)
      Aij = A[I,J],
      (var(Aij) -> printf(" ") ; printf(Aij)),
      (J == NC -> nl ; true )
   end.

p(A,I,J,1) => 
   foreach(C in 0..4) A[I,J+C] ="_", A[I+4,J+C] = "~" end,
   foreach(C in 1..3) A[I+C,J+4] ="|" end.
p(A,I,J,N) =>
   foreach(C in 0..4) A[I,J+C] = "_" end,
   foreach(C in 0..3) A[I+4,J+C] = "~" end,
   A[I+1,J+5] =")",
   A[I+2,J+4] ="(",
   A[I+3,J+4] ="|",
   A[I+4,J+4] ="|",
   A[I+5,J+4] ="|",
   A[I+6,J+4] ="~",
   In = I + 2, Jn = J + 5,
   Nn = N - 1,
   p(A,In,Jn,Nn).
/*

  Forward difference in Picat.

  From http://rosettacode.org/wiki/Forward_difference
  """
  Provide code that produces a list of numbers which is the n-th order 
  forward difference, given a non-negative integer (specifying the order) 
  and a list of numbers. The first-order forward difference of a list of 
  numbers (A) is a new list (B) where Bn = An+1 - An. List B should have 
  one less element as a result. The second-order forward difference of 
  A will be the same as the first-order forward difference of B. That 
  new list will have two fewer elements than A and one less than B. 
  The goal of this task is to repeat this process up to the desired order. 
  """

  Also, see http://mathworld.wolfram.com/ForwardDifference.html

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
   L = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73],
   Diff = diff(L),
   writeln(Diff),

   foreach(I in 1..L.length-1)
      writeln([d=I,diffi(L,I)])
   end,

   println(alldiffs(L)),

   nl.


diff(L) = Diff => 
   Diff = [L[I]-L[I-1] : I in 2..L.length].

diffi(L,D) = Diff =>
   Diff1 = L,
   foreach(_I in 1..D) 
      Diff1 := diff(Diff1)
   end,
   Diff = Diff1.


alldiffs(L) = Diffs =>
   Diffs1 = [],
   Diff = L,
   foreach(_I in 1..L.length-1) 
      Diff := diff(Diff),
      Diffs1 := Diffs1 ++ [Diff]
   end,
   Diffs = Diffs1.
   /*

  Four Islands puzzle (Dell Logic Puzzles) in Picat.

  http://brownbuffalo.sourceforge.net/FourIslandsClues.html
  """
  Title: Four Islands
  Author: Humphrey Dudley
  Publication: Dell Logic Puzzles
  Issue: April, 1998
  Page: 9
  Stars: 1
  
  A tiny nation in the South Pacific contains four islands connected by bridges
  as shown (see below). Each of the four islands (Pwana, Quero, Rayou, and Skern)
  boasts a different primary export (alabaster, bananas, coconuts, and durian
  fruit) and a different tourist attraction (hotel, ice skating rink, jai alai 
  stadium, and koala preserve). Can you find the name, export, and tourist 
  attraction of each island on the map?
  
    N
  W   E     *compass directions
    S
  
  A, B, C, D are the islands
  
  (A) -- (B)
   |      |
   |      |
  (C) -- (D)
  
  
  1. The island noted for its koala preserve is due south of Pwana.
  2. The island with the largest alabaster quarry is due west of Quero.
  3. The island with the resort hotel is due east of the one that exports 
     durian fruit.
  4. Skern and the island with the jai alai stadium are connected by a 
     north-south bridge. 
  5. Rayou and the island that exports bananas are connected by an east-west
     bridge.
  6. The islands noted for the South Pacific's largest ice skating rink and 
     for the jai alai stadium are not connected by a bridge.
  
  Determine: Island island -- Island name -- Export -- Tourist Attraction
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   N = 4,
   Range = 1..N,

   A = 1,
   B = 2,
   C = 3,
   D = 4,

   Island =[Pwana, Quero, Rayou, Skern],
   Island :: Range,

   Export = [Alabaster, Bananas, _Coconuts, DurianFruit],
   Export :: Range,
   
   Attraction = [ResortHotel, IceSkatingRink, JaiAlaiStadium, KoalaPreserve],
   Attraction :: Range,
   
   all_different(Island),
   all_different(Export),
   all_different(Attraction),


   % 1. The island noted for its koala preserve is due south of Pwana.
   (
       (Pwana #= A#/\KoalaPreserve #= C)
       #\/
       (Pwana #= B#/\KoalaPreserve #= D)
   ),
   
   % 2. The island with the largest alabaster quarry is due west of Quero.
   ( 
       (Alabaster #= A#/\Quero #= B) 
       #\/
       (Alabaster #= C#/\Quero #= D) 
   ),

   % 3. The island with the resort hotel is due east of the one 
   %    that exports durian fruit.
   ( 
       (DurianFruit #= A#/\ResortHotel #=  B )
       #\/
       ( DurianFruit #= C#/\ResortHotel #=  D)
   ),

   % 4. Skern#/\the island with the jai alai stadium are connected by a 
   %    north-south bridge. 
   (
       (Skern #= A#/\JaiAlaiStadium #= C) 
       #\/
       (Skern #= C#/\JaiAlaiStadium #= A) 
       #\/
       (Skern #= B#/\JaiAlaiStadium #= D) 
       #\/
       (Skern #= D#/\JaiAlaiStadium #= B) 
   ),

   % 5. Rayou#/\the island that exports bananas are connected by an 
   %    east-west bridge.
   (
       (Rayou #= A#/\Bananas #= B) 
       #\/
       (Rayou #= B#/\Bananas #= A) 
       #\/
       (Rayou #= C#/\Bananas #= D) 
       #\/
       (Rayou #= D#/\Bananas #= C) 
   ),

   % 6. The islands noted for the South Pacific's largest ice skating rink 
   %   #/\for the jai alai stadium are not connected by a bridge.
   ( 
       (IceSkatingRink #= A#/\JaiAlaiStadium #= D)
       #\/
       (IceSkatingRink #= D#/\JaiAlaiStadium #= A)
       #\/
       (IceSkatingRink #= B#/\JaiAlaiStadium #= C)
       #\/
       (IceSkatingRink #= C#/\JaiAlaiStadium #= B)
   ),


   % search
   Vars = Island ++ Export ++ Attraction,
   solve(Vars),

   writeln(island=Island),
   writeln(export=Export),
   writeln(attraction=Attraction).
/* 

  Four number problem in Picat.

  From
  http://stackoverflow.com/questions/17720465/given-4-numbers-of-array-of-1-to-10-elements-find-3-numbers-whose-sum-can-gener
  "Given 4 numbers of array of 1 to 10 elements. 
   Find 3 numbers whose sum can generate all the four numbers?"
  """
  I am given an array containing a list of 4 random numbers (1 to 10 inclusive). 
  I am supposed to generate a list of 3 numbers (1 to 10 inclusive) so that I can 
  generate all the 4 numbers of the initial list by adding the 3 numbers of 
  the generated list.
  Someone Please provide an algorithm for doing this. 
  """
  
  For the problem instance mentioned in a comment [1,3,7,8], there are 5 solutions:

    r: [1, 3, 7, 8]
    x: [1, 3, 4]
    ----------
    r: [1, 3, 7, 8]
    x: [1, 2, 5]
    ----------
    r: [1, 3, 7, 8]
    x: [1, 2, 6]
    ----------
    r: [1, 3, 7, 8]
    x: [1, 2, 7]
    ----------
    r: [1, 3, 7, 8]
    x: [1, 3, 7]


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>

   R = [1,3,7,8], % random number
   N = 3,
   four_numbers(R,N,All),
   foreach(X in All)
     writeln(X)
   end,
   nl.

% generate random numbers
go2 => 
   M = 4,
   N = 3,
   rand_perm(1..10, M, R1),
   R = R1.sort(),
   writeln(r=R),
   nl,
   four_numbers(R,N,All),
   foreach(X in All)
     writeln(x=X)
   end,
   nl.
   


four_numbers(R,N, All) =>
  
   M = R.length,

   X = new_list(N),
   X :: 1..10,

   % coefficient matrix
   Tmp = new_array(M,N),
   Tmp :: 0..1,

   foreach(I in 1..M)
      sum([Tmp[I,J]*X[J] : J in 1..N]) #= R[I]
   end,

   increasing(X),

   All=solve_all([split], X).



increasing(List) =>
   foreach(I in 2..List.length) List[I-1] #=< List[I] end.


rand_perm(L) = L, L.length == 1 => true.
rand_perm(L) = L => rand_perm(L, L.length, _Perm).

rand_perm(_,0,R) ?=> R = [].
rand_perm(Xs,N,R) ?=> 
    R = [X|Zs],
    N > 0,
    L = length(Xs),
    I = 1+random2() mod L,
    remove_at(X,Xs,I,Ys),
    N1 = N - 1,
    rand_perm(Ys,N1,Zs).

remove_at(X,L,1,R) => L=[X|Xs], R=Xs.
remove_at(X,L,K,R) => L=[Y|Xs], R=[Y|Ys], K #> 1, K1 #= K - 1, remove_at(X,Xs,K1,Ys).

% random selection _with_ replacement
rnd_select2(L,N,R) =>
    R1 = [],
    Len = L.length,
    foreach(_I in 1..N)
       E = L[1+random2() mod Len],
       R1 := R1 ++ [E]
    end,
    R = R1.
/*

  Fractions problem in Picat.

  Prolog benchmark problem (BProlog)
  """
  Find distinct non-zero digits such that the following equation holds:
         A        D        G
      ------  + ----- + ------  = 1
        B*C      E*F      H*I
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go ?=>
   fractions(Digits),
   writeln(Digits),
   fail.

fractions(Digits) =>

   Digits = [A,B,C,D,E,F,G,H,I],
   Digits :: 1..9,

   all_different(Digits),

   DD = [D1,D2,D3],
   DD :: 1..81,

   D1 #= 10*B+C,
   D2 #= 10*E+F,
   D3 #= 10*H+I,
   A*D2*D3 + D*D1*D3 + G*D1*D2 #= D1*D2*D3,

   % break the symmetry
   A*D2 #>= D*D1,
   D*D3 #>= G*D2,

   %redundant constraints
   3*A #>= D1,
   3*G #=< D2,


   % search
   solve([ffc,split],Digits).

/*

  Furniture moving (scheduling) in Picat.

  From Marriott & Stukey: "Programming with constraints", page  112f

  One result:
     Sp Sc Sb  St
    [0, 0, 30, 45]

  Where the values are the start time for each task:
   Starts with piano time 0  : 3 persons  (30 min)
               chair time 0  : 1 person   (10 min)
               bed   time 30 : 3 persons  (15 min)
               table time 45 : 2 persons  (15 min)

   0       10   15    30      45      60

   piano --------------|bed---|       
   piano --------------|       table----|
   piano --------------|bed---|
   chair --|            bed---|table----| 

  There are many other solutions...


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
        L = findall([Sp, Sc, Sb, St], move([Sp, Sc, Sb, St])),
        NumSolutions = length(L),
        writef("start_times: %w\n", L),
        writef("number_of_solutions: %d\n", NumSolutions).

go2 =>
        L = findall([Sp, Sc, Sb, St], move2([Sp, Sc, Sb, St])),
        NumSolutions = length(L),
        writef("start_times: %w\n", L),
        writef("number_of_solutions: %d\n", NumSolutions).



% Minimize end time
go3 =>
        move3.



move([Sp, Sc, Sb, St]) =>

        NumPersons :: 0..3,
        
        Sp :: 0..30, % piano: 60 - 30 
        Sc :: 0..50, % chair: 60 - 10
        Sb :: 0..45, % bed  : 60 - 15
        St :: 0..45, % table: 60 - 15
        
        Duration = [30,10,15,15],
        MenNeeded = [3,1,3,2],
        cumulative([Sp, Sc, Sb, St], Duration, MenNeeded, NumPersons),


        % to get the end time of the tasks
        SpEnd #= Sp + 30,
        ScEnd #= Sc + 10,
        SbEnd #= Sb + 15,
        StEnd #= St + 15,

        Vars = [Sp,Sc,Sb,St] ++ NumPersons,

        % get all solutions
        % NumPersons = 3,
        solve(Vars),

        writeln([piano=(Sp,SpEnd), chair=(Sc,ScEnd), 
                 bed=(Sb,SbEnd), table=(St,StEnd), 
                 num=NumPersons]).
        
        

move2(X) =>
        N = 4,
        X = new_list(N),
        X :: 0..60,
        NumPersons :: 0..3,
        
        Duration = [30,10,15,15],
        MenNeeded = [3,1,3,2],
        cumulative(X, Duration, MenNeeded, NumPersons),


        % to get the end time of the tasks
        End = new_list(N),
        End :: 0..60,
        foreach(I in 1..N) End[I] #= X[I]+Duration[I] end,

        Vars = X ++ End ++ [NumPersons],

        solve([ff,updown],Vars),

        writeln([X, persons=NumPersons]).

%
% Minimize the end time (min span)
%
move3 =>
        N = 4,
        X = new_list(N),
        X :: 0..60,
        NumPersons :: 0..3,
        
        Duration = [30,10,15,15],
        MenNeeded = [3,1,3,2],
        cumulative(X, Duration, MenNeeded, NumPersons),


        % to get the end time of the tasks
        End = new_list(N),
        End :: 0..60,
        foreach(I in 1..N) End[I] #= X[I]+Duration[I] end,

        Vars = X ++ End ++ [NumPersons],

        EndTime #= max(End),
        solve([$min(EndTime),ff,down],Vars),

        writeln([X, persons=NumPersons,endTime=EndTime]).

/*

  Futoshiki problem in Picat.
 
  http://en.wikipedia.org/wiki/Futoshiki
  """
  The puzzle is played on a square grid, such as 5 x 5. The objective
  is to place the numbers 1 to 5 (or whatever the dimensions are) such 
  that each row, and column contains each of the digits 1 to 5. Some 
  digits may be given at the start. In addition, inequality
  constraints are also initially specifed between some of the squares, 
  such that one must be higher or lower than its neighbour. These 
  constraints must be honoured as the grid is filled out.
  """

 

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   foreach(I in 1..3) 
      _ = findall(_,$futoshiki(I))
   end .

futoshiki(P) =>
   
   writef("\nProblem %d\n",P),
   problem(P,Problem,LessThans),

   N = Problem.length,
   X = new_array(N,N),
   X :: 1..N,

   % Fill the data
   foreach(I in 1..N, J in 1..N)
      if Problem[I,J] > 0 then
         X[I,J] #= Problem[I,J]
      end
   end,

   % constraints
   latin_square(X),
   foreach([I1,J1,I2,J2] in LessThans) X[I1,J1] #< X[I2,J2] end,

   % search
   solve(X),

   % output
   foreach(Row in X) println(Row.to_list()) end,
   nl.

latin_square(Board) =>
   foreach(Row in Board) all_different(Row) end,
   foreach(Column in Board.columns()) all_different(Column) end.


% Example from Tailor model futoshiki.param/futoshiki.param
%
% Solution:
% 5 1 3 2 4
% 1 4 2 5 3
% 2 3 1 4 5
% 3 5 4 1 2
% 4 2 5 3 1
% 
% Futoshiki instance, by Andras Salamon
%
problem(1, Problem, LessThan) =>
Problem =
   [[0,0,3,2,0],  % problem grid
    [0,0,0,0,0],
    [0,0,0,0,0],
    [0,0,0,0,0],
    [0,0,0,0,0]],

LessThan = 
   [[1,2,1,1], % [i1,j1, i2,j2] requires that values[i1,j1] < values[i2,j2]
    [1,4,1,5],
    [2,3,1,3],
    [3,3,2,3],
    [3,4,2,4],
    [2,5,3,5],
    [3,2,4,2],
    [4,4,4,3],
    [5,2,5,1],
    [5,4,5,3],
    [5,5,4,5]].


% Example from http://en.wikipedia.org/wiki/Futoshiki
% Solution:
% 5 4 3 2 1
% 4 3 1 5 2
% 2 1 4 3 5
% 3 5 2 1 4
% 1 2 5 4 3
%
problem(2, Problem, LessThan) =>
Problem =
   [[0,0,0,0,0],
    [4,0,0,0,2],
    [0,0,4,0,0],
    [0,0,0,0,4],
    [0,0,0,0,0]],
LessThan =
   [[1,2, 1,1],
    [1,4, 1,3],
    [1,5, 1,4],
    [4,4, 4,5],
    [5,1, 5,2],
    [5,2, 5,3]].


% From http://www.sudoku-puzzles.net/futoshiki06x6.html
problem(3, Problem, LessThan) =>
Problem = 
   [[5,0,2,0,1,0],
    [6,0,1,0,0,0],
    [0,0,3,0,0,0],
    [0,0,4,0,0,0],
    [0,0,0,4,2,5],
    [0,0,0,1,3,0]],
LessThan = 
   [[1,6, 2,6],
    [4,1, 3,1]].
/*

  General store problem in Picat.
 
  From
  http://www.comp.nus.edu.sg/~henz/projects/puzzles/digits/index.html

  """
  The General Store  from "Mathematical Puzzles of Sam Loyd", number 30

  The owner of a general store, who is something of a puzzlist, has put
  up this sign to see if any of his mathematical friends can translate
  it properly. Each different letter stands for a different digit. The
  words above the horizontal line represent numbers that add to the
  total of "ALL WOOL". The problem is to change all the letters to the
  correct digits.

         C H E S S
   +       C A S H
   +   B O W W O W
   +     C H O P S
   +   A L S O P S
   + P A L E A L E
   +       C O O L
   +       B A S S
   +       H O P S
   +       A L E S
   +       H O E S
   +   A P P L E S
   +       C O W S 
   +   C H E E S E
   +   C H S O A P
   +     S H E E P
   _______________
     A L L W O O L
   """

  Here are three different models, inspired by the Oz solutions from
  the page above.


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   writef("Model 1: "),
   L1 = findall([c=C, h=H, e=E, s=S, a=A, b=B, o=O, w=W, p=P, l=L], $store1([C, H, E, S, A, B, O, W, P, L])),
   writeln([sort(T) : T in L1]),

   writef("Model 2: "),
   L2 = findall([c=C, h=H, e=E, s=S, a=A, b=B, o=O, w=W, p=P, l=L], $store2([C, H, E, S, A, B, O, W, P, L])),
   writeln([sort(T) : T in L2]),

   writef("Model 3: "),
   L3 = findall([a=A, b=B, c=C, e=E, h=H, l=L, o=O, p=P, s=S, w=W], $store3([A, B, C, E, H, L, O, P, S, W])),
   writeln([sort(T) : T in L3]).


store1(LD) =>

   LD = [C, H, E, S, A, B, O, W, P, L],
   LD :: 0..9,
 
   all_different(LD),
   
   10000*C + 1000*H + 100*E + 10*S + S
   + 1000*C + 100*A + 10*S + H
   + 100000*B + 10000*O + 1000*W + 100*W + 10*O + W
   + 10000*C + 1000*H + 100*O + 10*P + S
   + 100000*A + 10000*L + 1000*S + 100*O + 10*P + S
   + 1000000*P + 100000*A + 10000*L + 1000*E + 100*A + 10*L + E
   + 1000*C + 100*O + 10*O + L
   + 1000*B + 100*A + 10*S + S
   + 1000*H + 100*O + 10*P + S
   + 1000*A + 100*L + 10*E + S
   + 1000*H + 100*O + 10*E + S
   + 100000*A + 10000*P + 1000*P + 100*L + 10*E + S
   + 1000*C + 100*O + 10*W + S
   + 100000*C + 10000*H + 1000*E + 100*E + 10*S + E
   + 100000*C + 10000*H + 1000*S + 100*O + 10*A + P
   + 10000*S + 1000*H + 100*E + 10*E + P
   
   #= 1000000*A + 100000*L + 10000*L + 1000*W + 100*O + 10*O + L,

   solve(LD).
   


store2(LD) =>
   LD=[C, H, E, S, A, B, O, W, P, L],
   LD :: 0..9,

   all_different(LD),

   Carries= [C11, C12, C21, C22, C31, C32, C41, C42, C51, C52, C61, C62],
   Carries :: 0..9,

   S+H+W+S+S+E+L+S+S+S+S+S+S+E+P+P       #= L+ 10*C11+ 100*C12,
   S+S+O+P+P+L+O+S+P+E+E+E+W+S+A+E+ C11       #= O+ 10*C21+ 100*C22,
   E+A+W+O+O+A+O+A+O+L+O+L+O+E+O+E+ C21 + C12 #= O+ 10*C31+ 100*C32,
   H+C+W+H+S+E+C+B+H+A+H+P+C+E+S+H+ C31 + C22 #= W+ 10*C41+ 100*C42,
   C+  O+C+L+L+     P+  H+H+S+ C41 + C32 #= L+ 10*C51+ 100*C52,
   B+ A+A+     A+  C+C  + C51 + C42 #= L+ 10*C61+ 100*C62,
   P          + C61 + C52 #= A,

   solve(LD),
   solve(Carries).



store3(LD) =>

   CarriesLow = [C11, C21, C31, C41, C51, C61],
   CarriesHigh =[C12, C22, C32, C42, C52],
   LD = [A, B, C, E, H, L, O, P, S, W],
   LD :: 0..9,

   all_different(LD),

   CarriesLow :: 0..9,
   CarriesHigh :: 0..1,
   
   10000*C + 1000*H + 100*E + 10*S + S
   + 1000*C + 100*A + 10*S + H
   + 100000*B + 10000*O + 1000*W + 100*W + 10*O + W
   + 10000*C + 1000*H + 100*O + 10*P + S
   + 100000*A + 10000*L + 1000*S + 100*O + 10*P + S
   + 1000000*P + 100000*A + 10000*L + 1000*E + 100*A + 10*L + E
   + 1000*C + 100*O + 10*O + L
   + 1000*B + 100*A + 10*S + S
   + 1000*H + 100*O + 10*P + S
   + 1000*A + 100*L + 10*E + S
   + 1000*H + 100*O + 10*E + S
   + 100000*A + 10000*P + 1000*P + 100*L + 10*E + S
   + 1000*C + 100*O + 10*W + S
   + 100000*C + 10000*H + 1000*E + 100*E + 10*S + E
   + 100000*C + 10000*H + 1000*S + 100*O + 10*A + P
   + 10000*S + 1000*H + 100*E + 10*E + P   
   #= 1000000*A + 100000*L + 10000*L + 1000*W + 100*O + 10*O + L,
   
   S+H+W+S+S+E+L+S+S+S+S+S+S+E+P+P       #= L+ 10*C11+ 100*C12,
   S+S+O+P+P+L+O+S+P+E+E+E+W+S+A+E+ C11       #= O+ 10*C21+ 100*C22,
   E+A+W+O+O+A+O+A+O+L+O+L+O+E+O+E+ C21+ C12  #= O+ 10*C31+ 100*C32,
   H+C+W+H+S+E+C+B+H+A+H+P+C+E+S+H+ C31+ C22  #= W+ 10*C41+ 100*C42,
   C+  O+C+L+L+     P+  H+H+S+ C41+ C32  #= L+ 10*C51+ 100*C52,
   B+  A+A+     A+  C+C      + C51+ C42  #= L+ 10*C61,
   P               + C61+ C52  #= A,


   solve(LD ++ CarriesLow ++ CarriesHigh).

/*

  Decomposition of global constraint global_cardinality in Picat.

  See Global Constraint Catalog
  http://www.emn.fr/x-info/sdemasse/gccat/Cglobal_cardinality.html
  """
  Example:
  <3,3,8,6>,
   (val-3 noccurrence-2,
    val5 noccurrence-0,
    val-6 noccurrence-1)

  The global_cardinality constraint holds since values 3, 5 and 6 
  respectively occur 2, 0 and 1 times within the collection 
  <3,3,8,6> and since no constraint was specified for value 8.
  """

  Notes: 
     - The version here is limited. See below for details.
     - Picat has already a global_cardinality/2, but the details
       of the parameters are different.


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go ?=>
   N = 5,
   A = new_list(N),
   A :: 1..N,
   % A = [1,2,1,1,1],

   GCC = new_list(N),
   GCC :: 0..N,
   global_cardinality2(A, GCC),

   Vars = A ++ GCC,
   solve(Vars),

   writeln(a=A),
   writeln(gcc=GCC), 
   nl,
   fail.

% The same problem using Picat's built-in global_cardinality
go2 =>
   N = 5,
   A = new_list(N),
   A :: 1..N,
   % A = [1,2,1,1,1],

   V = new_list(N),
   V :: 0..N,
    
   V[1] :: [4],
   V[2] :: [1],
   V[3] :: [0],
   V[4] :: [0],
   V[5] :: [0],
   GCC = $[1-V[1],
           2-V[2],
           3-V[3],
           4-V[4],
           5-V[5]],
   global_cardinality(A, GCC),

   Vars = A ++ GCC,
   solve(Vars),

   writeln(a=A),
   writeln(gcc=GCC), 
   nl,
   fail.

%
% Both A and Gcc are lists.
% 
% This version is bidirectional but limited:
% 
% The list A can contain only values 1..Max (i.e. the length of Gcc).
% This means that the caller must know the max values of A.
% Or rather: if A contains another values they will not be counted.
% 
global_cardinality2(A, Gcc) =>
   Len = length(A),
   Max = length(Gcc),
   Gcc :: 0..Len,
   foreach(I in 1..Max) count(I,A,#=,Gcc[I]) end.
/*

  Global constraint global contiguity in Picat.

  From Global constraint catalog
  http://www.emn.fr/x-info/sdemasse/gccat/Cglobal_contiguity.html
  """
  Enforce all variables of the VARIABLES collection to be assigned to 
  0 or 1. In addition, all variables assigned to value 1 appear contiguously.
  """

  The implementation of global contiguity below was inspired by 
  Toby Walsh's presentation "Sliding Constraints"
     http://www.cse.unsw.edu.au/~tw/samos/slide.ppt
  where he defines it in terms of the global constraint slide.


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go ?=>

   N = 15,
   X = new_list(N),
   X :: 0..1,

   global_contiguity(X),
   
   solve([],X),
   writeln(X), 
   % nl,
   fail.


%
% contiguity: all variables assigned to value 1 appear contiguously.
%
global_contiguity(X) =>

   Len = length(X),
   Y = new_list(Len),
   Y :: 0..2,
    
   increasing(Y),
   foreach({XVal,YVal} in zip(X,Y))
      BX :: 0..1,
      BY :: 0..1,
      (XVal #= 1) #<=> BX #= 1,
      (YVal #= 1) #<=> BY #= 1,
      BX #= BY
   end.


increasing(List) =>
   foreach(I in 2..List.length) List[I-1] #=< List[I] end.
/*

  Golomb ruler in Picat.

  A Golomb ruler is a set of integers (marks) a(1) < ...  < a(n) such
  that all the differences a(i)-a(j) (i > j) are distinct.  Clearly we
  may assume a(1)=0.  Then a(n) is the length of the Golomb ruler.
  For a given number of marks, n, we are interested in finding the
  shortest Golomb rulers.  Such rulers are called optimal. 

  See http://www.research.ibm.com/people/s/shearer/grule.html


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   time2(golomb(8, Xs)),
   println(Xs),
   nl.

go2 => 
  foreach(N in 2..15)
    time2(golomb(N,Xs)),
    println(Xs),
    nl
  end,
  nl.

go3 => 
  foreach(N in 2..15)
    time2(golomb2(N,Xs)),
    println(Xs),
    nl
  end,
  nl.



golomb(N, Xs) =>
  writeln(n=N),
  Xs = new_list(N),
  NN = 2**(N-1)-1,
  Xs :: 0..NN,

  Xn #= Xs[N], % to minimize
  Xs[1] #= 0,

  all_different(Xs),
  increasing(Xs),

  Diffs = [Diff : I in 1..N, J in 1..N, I != J, Diff #=  Xs[I]-Xs[J]],
  all_different(Diffs),

  % Symmetry breaking
  Xs[2] - Xs[1] #< Xs[N] - Xs[N-1],
  Diffs[1] #< Diffs[N],

  Vars = Xs ++ Diffs,
  solve($[split,min(Xn)],Vars).


%
% Another approach.
% Inspired by 
% Barbara M. Smith, Kostas Stergiou, and Toby Walsh:
% "Modelling the Golomb Ruler Problem"
%
golomb2(N, Xs) =>
  writeln(n=N),
  Xs = new_list(N),
  Xs :: 0..N**2,

  % Xn #= Xs[N], % to minimize
  Xs[1] #= 0,

  % all_distinct(Xs),
  % increasing(Xs), % note: this is #=<, not #<

  foreach(I in 2..N)
    Xs[I-1] #< Xs[I]
  end,

  foreach(I in 1..N, J in 1..N, K in 1..N, I < J, J < K)
    2*Xs[J] - Xs[I] - Xs[K] #!= 0
  end,

  foreach(I in 1..N, J in 1..N, K in 1..N, L in 1..N, 
                          I < J, K < L, [I,J] @< [K,L])
     Xs[J] - Xs[I] #!= Xs[L] - Xs[K]
  end,

  % println(xs=Xs),

  % Symmetry breaking
  Xs[2] - Xs[1] #< Xs[N] - Xs[N-1],

  solve($[ffc,updown,min(Xs[N])],Xs).

/*

  Gray code in Picat.

  From Rosetta Code:
  http://rosettacode.org/wiki/Gray_code
  """
  Gray code

  Gray code is a form of binary encoding where transitions between consecutive numbers 
  differ by only one bit. This is a useful encoding for reducing hardware data hazards 
  with values that change rapidly and/or connect to slower hardware as inputs. 
  It is also useful for generating inputs for Karnaugh maps in order from left to 
  right or top to bottom.

  Create functions to encode a number to and decode a number from Gray code. Display the 
  normal binary representations, Gray code representations, and decoded Gray code values 
  for all 5-bit binary numbers (0-31 inclusive, leading 0's not necessary).

  There are many possible Gray codes. The following encodes what is called "binary 
  reflected Gray code."

  Encoding (MSB is bit 0, b is binary, g is Gray code):

    if b[i-1] = 1
       g[i] = not b[i]
    else
       g[i] = b[i]

  Or:

    g = b xor (b logically right shifted 1 time)

  Decoding (MSB is bit 0, b is binary, g is Gray code):

    b[0] = g[0]

  for other bits:
    b[i] = g[i] xor b[i-1]
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
   foreach(I in 0..2**5-1)
      G = gray_encode1(I),
      E = gray_decode1(G),
      println([I,I.to_binary_string(), G, G.to_binary_string(),E.to_binary_string(), E])
   end,
   nl,
   N2=2**300,
   G2=gray_encode1(N2),
   E2=gray_decode1(G2),
   println([N2,G2,E2,cond(N2==E2,same,not_same)]),
   nl.


gray_encode1(N) = N ^ (N >> 1).
gray_decode1(N) = P =>
    P = N,
    N := N >> 1,
    while (N != 0)
      P := P ^ N,
      N := N >> 1
    end. /*

  Greatest subsequential sum Picat.

  From http://rosettacode.org/wiki/Greatest_subsequential_sum
  """
  Given a sequence of integers, find a continuous subsequence which maximizes 
  the sum of its elements, that is, the elements of no other single 
  subsequence add up to a value larger than this one. An empty subsequence 
  is considered to have the sum 0; thus if all elements are negative, the 
  result must be the empty sequence. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   LL = [[-1 , -2 , 3 , 5 , 6 , -2 , -1 , 4 , -4 , 2 , -1],
         [-1,-2, 3],
         [-1,-2],
         [0],
         [],
         [144,  5, -8,  7, 15],
         [144,  -145, -8,  7, 15],
         [-144,  5, -8,  7, 15]
        ],

   foreach(L in LL)
     printf("%w: ", L),
     G = greatest_subsequential_sum1(L),
     println([G, sum(G)])
   end,
   nl,
   foreach(L in LL)
     printf("%w: ", L),
     G = greatest_subsequential_sum2(L),
     println([G, sum(G)])
   end,

   nl,
   foreach(L in LL)
     printf("%w: ", L),
     G = greatest_subsequential_sum3(L),
     println([G, sum(G)])
   end,

   nl.

greatest_subsequential_sum1([]) = [] => true.
greatest_subsequential_sum1(A) = Seq => 
   Len = A.length,
   BeginMax = 0,
   EndMax = -1,
   MaxSum = 0,
   foreach(Begin in 1..Len)
      Sum = 0,
      foreach(End in Begin..Len)
         Sum := Sum + A[End],
         if Sum > MaxSum then
            MaxSum := Sum,
            BeginMax := Begin,
            EndMax := End
         end
      end
   end,
   Seq1 = [],
   if MaxSum > 0 then
     Seq1 := [A[I] : I in BeginMax..EndMax]
   else 
     Seq1 := []
   end,
   Seq = Seq1.


%
% alternative version: 
%  first build a map with all the combinations
%  then pick the one with greatest sum.
%
greatest_subsequential_sum2([]) = [] => true.
greatest_subsequential_sum2(A) = Seq =>

    P = allcomb(A),
    Total = max([Tot : Tot=_T in P]),
    Seq1 = [],
    if Total > 0 then
       [B,E] = P.get(Total),
       Seq1 := [A[I] : I in B..E]
    else 
      Seq1 := []
    end,
    Seq = Seq1.


allcomb(A) = Comb => 
   Len = A.length,
   Comb = new_map([(sum([A[I]:I in B..E])=([B,E])) : B in 1..Len, E in B..Len]).


%
% CP version
% Inspired by a MiniZinc model created by Claudio Cesar de S
%
greatest_subsequential_sum3([]) = [] => true.
greatest_subsequential_sum3(A) = Seq =>

   N = A.length,

   % decision variables
   Begin :: 1..N,
   End :: 1..N,

   X = new_list(N),
   X :: 0..1,

   TotalSum #= sum([X[I]*A[I] : I in 1..N]),
   SizeWindow #= sum(X),
   
   End #>= Begin,
   End - Begin #= SizeWindow -1,
   foreach(I in 1..N) 
      (Begin #=< I #/\ End #>= I) #<=> X[I] #= 1
   end,
   
   Vars = X ++ [Begin,End],
   solve($[ff,max(TotalSum)], Vars),

   if TotalSum > 0 then
     Seq = [A[I] : I in Begin..End]
   else 
     Seq = []
   end.
/*

  Hailstone sequence (Collatz sequence) in Picat.

  From http://rosettacode.org/wiki/Hailstone_sequence
  """
  The Hailstone sequence of numbers can be generated from a starting 
  positive integer, n by:

   * If n is 1 then the sequence ends.
   * If n is even then the next n of the sequence = n/2
   * If n is odd then the next n of the sequence = (3 * n) + 1 

  The (unproven), Collatz conjecture is that the hailstone sequence for 
  any starting number always terminates.

  Task Description:

   1. Create a routine to generate the hailstone sequence for a number.
   2. Use the routine to show that the hailstone sequence for the number 
      27 has 112 elements starting with 27, 82, 41, 124 and ending with 
      8, 4, 2, 1
   3. Show the number less than 100,000 which has the longest hailstone 
      sequence together with that sequences length. (But don't show the 
      actual sequence)! 
  """
   
  Also see:
    http://en.wikipedia.org/wiki/Collatz_conjecture


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   H27 = hailstoneseq1(27),
   writeln(H27),   

   MaxN = 0,
   MaxLen = 0,
   foreach(N in 1..99999) 
      Len = hailstoneseq2(N).length,
      if Len > MaxLen then
         MaxN := N,
         MaxLen := Len
      end
   end,

   writeln([maxN=MaxN, maxLen=MaxLen]),

   nl.

%
% Using a map for the lengths: 
% Much faster 0.23 seconds
%
go2 =>
   longest_seq(99999).


% This is project euler problem #14
% (2.7s)
go3 => 
   longest_seq(999999).

%
% without table: 3.4s
% with table: 16.38s (> 4Gb memory)
%
hailstone1(N) = N // 2, N mod 2 == 0 => true.
hailstone1(N) = 3*N+1, N mod 2 == 1 => true.


% without table: 3.78s
% with table: out_of_memory (stack_heap)
hailstone2(N) = H => 
   if N mod 2 == 0 then
      H := N // 2
   else 
      H := 3*N+1
   end.

hailstoneseq1(N) = Seq =>
   Seq := [N],
   while (N > 1)
      N := hailstone1(N),
      Seq := Seq ++ [N]
   end.

hailstoneseq2(N) = Seq =>
   Seq := [N],
   while (N > 1)
      N := hailstone2(N),
      Seq := Seq ++ [N]
   end.

%
% We just care about the lengths of the sequence.
% Using a map is much faster: 0.23s
%
longest_seq(Limit) =>

   Lens = new_map(),
   MaxLen = 0,
   MaxN = 1,

   foreach(N in 1..Limit-1) 
      M = N,
      CLen = 1,
      while (M > 1) 
         if Lens.has_key(M) then
            CLen := CLen + Lens.get(M) - 1,
            M := 1
         else
            M := hailstone1(M),
            CLen := CLen + 1
         end
      end,

      Lens.put(N, CLen),

      if CLen > MaxLen then
         MaxLen := CLen,
         MaxN := N
      end
   end,

   writeln([maxLen=MaxLen, maxN=MaxN]),

   nl.

/*

  Hamming distance in Picat.
 
  I.e. the number of bits differing in two (binary) arrays.
  See http://en.wikipedia.org/wiki/Hamming_distance

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 
% We can now either
% - Calculate the hamming distance from two arrays
% - Given the distance, generate all arrays which has the 
%   Hamming distance.
% 

go ?=>

   N = 6, % length of the arrays
   A = new_list(N),
   A :: 0..1,
   B = new_list(N), 
   B :: 0..1,

   Diffs :: 0..N, % The number of differences 
   % Diffs #= 2,
   indomain(Diffs),


   A = [1,1,1,1,1,1],

   hamming_distance(A,B,Diffs),

   Vars = A ++ B ++ [Diffs],
   solve(Vars),

   writeln(diffs=Diffs),
   writeln(a=A),
   writeln(b=B),nl,
   fail.

hamming_distance(As, Bs, Diffs) =>
   Diffs #= sum([(A #!= B) : {A,B} in zip(As,Bs)]).
/*

  Hamming numbers in Picat.

  From Rosetta code:
  http://rosettacode.org/wiki/Hamming_numbers
  """
  Hamming numbers are numbers of the form
    H = 2**i * 3**j * 5**k, where  i, j, k >= 0. 

  Hamming numbers are also known as ugly numbers and also 5-smooth numbers 
  (numbers whose prime divisors are less or equal to 5).
  
  Generate the sequence of Hamming numbers, in increasing order. In particular:

   * Show the first twenty Hamming numbers.
   * Show the 1691st Hamming number (the last one below 231).
   * Show the one millionth Hamming number (if the language  or a 
     convenient library  supports arbitrary-precision integers). 
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   println("using hamming1/1 (map)"),
   writeln([hamming(I) : I in 1..20]),
   time(writeln(hamming(1691))),
   time(writeln(hamming(1000000))), % about 10s

   garbage_collect(),

   println("using hamming2/1 (array)"),
   writeln([hamming2(I) : I in 1..20]),
   time(writeln(hamming2(1691))),
   time(writeln(hamming2(1000000))), % about 1.5s

   nl.

go2 =>
   writeln(hamming_life(10)),
   nl.


%
% Using map. Slower.
%
hamming(1) = 1.
hamming(2) = 2.
hamming(3) = 3.
hamming(N) = Hamming =>
   writeln($hamming(N)),
   H = new_map(N),
   [Next2, Next3, Next5] = [2,3,5],

   H.put(1,1),
   H.put(4,0),
   H.put(Next2,1),
   H.put(Next3,2),
   H.put(Next5,3),

   I = 0,
   J = 0,
   K = 0,
   M = 1,

   while (M < N) 
      H.put(M, min([Next2,Next3,Next5])),
      if H.get(M) == Next2 then I := I+1, Next2 := 2*H.get(I) end,
      if H.get(M) == Next3 then J := J+1, Next3 := 3*H.get(J) end,
      if H.get(M) == Next5 then K := K+1, Next5 := 5*H.get(K) end,
      M := M + 1
   end,

   HH := H.values(), % adjust for 1-based
   Hamming = HH[N-1].


%
% Using arrays. 
%
hamming2(1) = 1.
hamming2(2) = 2.
hamming2(3) = 3.
hamming2(N) = Hamming2 =>
   writeln($hamming2(N)),
   A = new_array(N),
   [Next2, Next3, Next5] = [2,3,5],

   A[1] := Next2,
   A[2] := Next3,
   A[3] := Next5,

   I = 0,
   J = 0,
   K = 0,
   M = 1,  
   while (M < N) 
      A[M] := min([Next2,Next3,Next5]),
      if A[M] == Next2 then I := I+1, Next2 := 2*A[I] end,
      if A[M] == Next3 then J := J+1, Next3 := 3*A[J] end,
      if A[M] == Next5 then K := K+1, Next5 := 5*A[K] end,
      M := M + 1
   end,
   Hamming2 = A[N-1].
   
% 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36
/*

  Halmos' handshake problem in Picat.

  Problem formulation from Alloy (examples/puzzles/handshake)
  """
  Alloy model of the Halmos handshake problem
  
  Hilary and Jocelyn are married. They invite four couples who are friends for dinner. When
  they arrive, they shake hands with each other. Nobody shakes hands with him or herself
  or with his or her spouse. After there has been some handshaking, Jocelyn jumps up on
  a chair and says "Stop shaking hands!", and then asks how many hands each person has
  shaken. All the answers are different. How many hands has Hilary shaken?
  
  The Alloy model represents the problem as a set of constraints. Properties of the spouse
  relationship and of handshaking in general are given as facts. The particular situation
  is cast as a function.
  
  There are 9 people answering, and all answers are different. Nobody can shake more than
  8 hands. So answers must be 0..8. The one (p8 say) who answered 8 has shaken everybody's
  hand except for his or her own, and his or her spouse's. Now consider the person who shook
  0 hands (p0 say). The persons p0 and p8 are distinct. If they are not married, then p8 cannot
  have shaken 8 hands, because he or she did not shake the hand of p0 or of his or her spouse.
  So p8's spouse to p0. Now imagine Jocelyn asking the question again, with p0 and p8 out of
  the room, and excluding hand shakes with them. Since p8 shook hands with everyone else
  except p0 and p8, everyone gives an answer one smaller than they did before, giving 0..6.
  The argument now applies recursively. So Hilary is left alone, having shaken 4 hands. 
  """
  Alloy is here: http://alloy.mit.edu/alloy
  
  Also, see the following that discuss Halmos' Handshake problem
  http://docs.law.gwu.edu/facweb/jsiegel/Personal/math/mathhome.htm#halmos
      http://docs.law.gwu.edu/facweb/jsiegel/Personal/math/shakeanswer.htm
  
  The origin of the problem seems to be
  P.R. Halmos: "To Count or to Think, That is the Question", page 1ff
  http://bernoulli.math.rug.nl/vorigelezingen/lezing03/lezing03.pdf


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

/*

  The solution for N=10 (with symmetry breaking)

  x:[4,4,0,8,1,7,2,6,3,5]

  Who shake hands with whom:
  [0,0,0,1,0,1,0,1,0,1]
  [0,0,0,1,0,1,0,1,0,1]
  [0,0,0,0,0,0,0,0,0,0]
  [1,1,0,0,1,1,1,1,1,1]
  [0,0,0,1,0,0,0,0,0,0]
  [1,1,0,1,0,0,1,1,1,1]
  [0,0,0,1,0,1,0,0,0,0]
  [1,1,0,1,0,1,0,0,1,1]
  [0,0,0,1,0,1,0,1,0,0]
  [1,1,0,1,0,1,0,1,0,0]

  Person 1 shake hands with [4,6,8,10] (4 shakes)
  Person 2 shake hands with [4,6,8,10] (4 shakes)
  Person 3 shake hands with [] (0 shakes)
  Person 4 shake hands with [1,2,5,6,7,8,9,10] (8 shakes)
  Person 5 shake hands with [4] (1 shakes)
  Person 6 shake hands with [1,2,4,7,8,9,10] (7 shakes)
  Person 7 shake hands with [4,6] (2 shakes)
  Person 8 shake hands with [1,2,4,6,9,10] (6 shakes)
  Person 9 shake hands with [4,6,8] (3 shakes)
  Person 10 shake hands with [1,2,4,6,8] (5 shakes)


*/


go =>
   N = 10, % 5 pairs
   time2($handshake(N,symmetrybreaking,print)).

go2 =>
   N = 10,
   L=findall(_,$handshake(N,nosymmetrybreaking,print)),
   writeln(len=L.length),
   nl.

go3 =>
   N = 300,
   time2($handshake(N,symmetrybreaking,noprint)).

go4 =>
   N = 350,
   time2($handshake(N,symmetrybreaking,print)).



handshake(N,Symmetry,Print) =>

   % decision variables

   % can shake max n-2 hands
   %   coded Pair1a,Pair1b,  Pair2a,Pair2b, ...
   X = new_list(N),
   X :: 0..N-2,

   % who shake with whom:
   %  (not him/herself and not his/her spouse)
   Y = new_array(N,N),
   Y :: 0..1,

   
   % We assume that Hilary is in position x[1]
   % (and Hilary's spouse - Jocelyn - in x[2])
   % All except Hilary's counts are different
   X2 = [X[I] : I in 2..N],
   all_different(X2),
   % all_distinct(X2),
   
   foreach(I in 0..(N / 2)-1)
      % don't shake hand with spouse
      Y[2*I+1,2*I+2] #= 0,
      Y[2*I+2,2*I+1] #= 0 
   end,

   foreach(I in 1..N) 
          % don't shake hand with oneself
          Y[I,I] #= 0,
          
          % how many hands has x[i] shaken
          X[I] #= sum([Y[I,J] : J in 1..N]) 
   end,

   foreach(I in 1..N, J in 1..N)
      % symmetry of handshaking:
      %    a shake hands with b <-> b shake hands with a
      Y[I,J] #= 1 #<=> Y[J,I] #= 1
   end,

   % symmetry breaking which orders the other couples (besides the hosts)
   % Without it: 384 solutions (all x = [4,4,.....])
   % With it: 1 solution: x: [4, 4, 0, 8, 1, 7, 2, 6, 3, 5] 
   %          (since we order 0,1,2,3 shakes)
   % 
   % Note that all number of handshaking of the pairs sums to 8, 
   % i.e. 4+4, 0+8, 1+7, 2+6, 3+5
   % More general: The number of handshaking per pair sums to n-2.
   % 
   % use symmetry breaking?
   if Symmetry = symmetrybreaking then
      X3 = [X[3+2*I] : I in 0..(N div 2)-2],
      increasing(X3),
      foreach(I in 0..(N / 2)-2) X[3+2*I] #< X[3+2*I+1] end
   end,

   %
   % search
   %
   Vars = X,
   solve([ff,split],Vars),

   if Print = print then
        writeln(x=X),
        nl,
        println('Who shake hands with whom:'),
        foreach(Row in Y) writeln(Row) end,
        nl,
        foreach(I in 1..N)
           S = [J : J in 1..N, Y[I,J] == 1],
           printf("Person %d shake hands with %w (%d shakes)\n", I,S,S.length)
        end,
        nl
  end.
   

increasing(List) =>
   foreach(I in 2..List.length) List[I-1] #=< List[I] end.
/*

  Hanging weights problem in Picat.
 
  From 
  "Using LINQ to solve puzzles"
  http://blogs.msdn.com/lukeh/archive/2007/03/19/using-linq-to-solve-puzzles.aspx
  """
  Here's a puzzle similar to the one in the puzzle hunt.  The diagram 
  below is a bunch of weights (A-M) hanging from a system of bars.  
  Each weight has an integer value between 1 and 13, and the goal is 
  to figure out what each weight must be for the the diagram below to 
  balance correctly as shown: 

                           |
                           |
               +--+--+--+--+--+--+--+
               |                    |
               |                    |
            +--+--+--+--+--+        |
            |     L        M        |
            |                       |
   +--+--+--+--+--+--+     +--+--+--+--+--+
   H              |  I     |  J        K  |
                  |        |              |
         +--+--+--+--+--+  |     +--+--+--+--+--+
         E              F  |     G              |
                           |                    |
               +--+--+--+--+--+  +--+--+--+--+--+--+
               A              B  C                 D

  The rules for this kind of puzzle are: 
  (1) The weights on either side of a given pivot point must be equal, 
      when weighted by the distance from the pivot, and 
  (2) a bar hanging beneath another contributes it's total weight as 
      through it were a single weight.  For instance, the bar on the bottom 
      right must have 5*C=D, and the one above it must have 3*G=2*(C+D).
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   hanging_weights(All,Total),
   writeln(all=All),
   writeln(total=Total).

hanging_weights(All, Total) =>

   All = [A,B,C,D,E,F,G,H,I,J,K,L,M],
   All :: 1..13,

   all_different(All),

   Total #= sum(All),

   4 * A #= B, 
   5 * C #= D, 
   3 * E #= 2 * F, 
   3 * G #= 2 * (C + D), 
   3 * (A + B) + 2 * J #= K + 2 * (G + C + D), 
   3 * H #= 2 * (E + F) + 3 * I, 
   (H + I + E + F) #= L + 4 * M, 
   4 * (L + M + H + I + E + F) #= 3 * (J + K + G + A + B + C + D),

   solve(All).
   /*

  Happy numbers in Picat.

  From Rosetta code:
  http://rosettacode.org/wiki/Happy_numbers#SETL
  """
  From Wikipedia, the free encyclopedia:

     A happy number is defined by the following process. Starting 
     with any positive integer, replace the number by the sum of 
     the squares of its digits, and repeat the process until the 
     number equals 1 (where it will stay), or it loops endlessly 
     in a cycle which does not include 1. Those numbers for which 
     this process ends in 1 are happy numbers, while those that do 
     not end in 1 are unhappy numbers. Display an example of 
     your output here. 

  Task: Find and print the first 8 happy numbers. 
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   writeln([H : H in 1..40, happy(H)]),
   writeln(happy_len(8)),
   nl.


happy(N) => 
   S = [N],
   Happy = 1,
   while (Happy == 1, N > 1)
     N := sum([to_integer(I)**2 : I in N.to_string()]),
     if member(N,S) then
       Happy := 0
     else
        S := S ++ [N]
     end
   end,
   Happy == 1.


happy_len(Limit) = S => 
   S = [],
   N = 1,
   while (S.length < Limit) 
      if happy(N) then
         S := S ++ [N]
      end,
      N := N + 1
   end.


/* 

  Harshad numbers in Picat.

  http://en.wikipedia.org/wiki/Harshad_number
  """
  A Harshad number, or Niven number in a given number base, is an integer that is 
  divisible by the sum of its digits when written in that base. Harshad numbers were 
  defined by D. R. Kaprekar, a mathematician from India. The word "Harshad" comes 
  from the Sanskrit hara (joy) + da (give), meaning joy-giver. The Niven numbers 
  take their name from Ivan M. Niven from a paper delivered at a conference on 
  number theory in 1977. All integers between zero and n are Harshad numbers 
  in base n.
  """

  Also see: http://oeis.org/A005349
  1,2,3,4,5,6,7,8,9,10,12,18,20,21,24,27,30,36,40,42,45,48,50,54,60,63,70,72,80,81,84,90,100,102,108,110,111,112,114,117,120,126,132,133,135,140,144,150,152,153,156,162,171,180,190,192,195,198,200,201,204

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
     Limit = 10000,
     Base = 10,
     X :: 1..Limit,
     IntLen = int_len(Limit,Base),
     List = new_list(IntLen+1),
     List :: 0..Base-1,

     to_num(List, Base, X),
     X mod sum(List) #= 0,

     % Vars = List ++ [X],
     All=solve_all(X),

     writeln(all=All),
     % writeln(list=List),
     nl.

% check if N is a Harshad number
harshad(N, Base) => 

     IntLen = int_len(N,Base),
     List = new_list(IntLen+1),
     List :: 0..Base-1,

     X #= N,
     to_num(List, Base, X),
     X mod sum(List) #= 0,

     Vars = List ++ [X],
     solve(Vars).



%
% converts a number Num to/from a list of integer List given a base Base
%
to_num(List, Base, Num) =>
   Len = length(List),
   Num #= sum([List[I]*Base**(Len-I) : I in 1..Len]).


int_len(V,Base) = Len =>
  Len1=1,
  while (V > Base-1)
     Len1 := Len1 + 1,
     V := V div Base
  end,
  Len = Len1.
/*

  Heterosquare problem in Picat.
 
  From http://willow.engr.uconn.edu/cometPubWiki/index.php/Heterosquare
  """
  A heterosquare of order n is a n*n square whose elements are
  distinct integers from 1 to n^2 such that the sums of the rows,
  columns and diagonals are all different. Here is an example of
  heterosquare of order 3 
             19
  
  1  2  3    6
  8  9  4    21
  7  6  5    18
  
  16 17 12   15  (Sums)
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go ?=>
   N = 3,
   heterosquare(N, Mat, RowSums, ColSums, Diag1, Diag2),
   foreach(I in 1..N, J in 1..N)
      writef("%3d ", Mat[I,J]),
      if J == N then nl end
   end,

   writeln(rowsums=RowSums),
   writeln(colsums=ColSums),
   writeln(diag1=Diag1),
   writeln(diag2=Diag2),
   nl,nl,
   fail.


heterosquare(N, Mat, RowSums, ColSums, Diag1, Diag2) =>

   Mat = new_array(N,N),
   Mat :: 1..N*N,
   MatVars = vars(Mat),

   RowSums = new_list(N),
   RowSums :: 1..N*N*N,

   ColSums = new_list(N),  
   ColSums :: 1..N*N*N,      

   % diagonals
   Diag1 :: 1..N*N*N,
   Diag2 :: 1..N*N*N,

   % all entries in the matrix should be different
   all_different(MatVars),

   % and all sums should be different
   AllSums = RowSums ++ ColSums ++ [Diag1, Diag2],
   all_different(AllSums),

   % calculate rows sums
   foreach(I in 1..N)
      RowSums[I] #= sum([Mat[I,J] : J in 1..N])
   end,

   % calculate column sums
   foreach(J in 1..N)
      ColSums[J] #= sum([Mat[I,J] : I in 1..N])
   end,

   Diag1 #= sum([Mat[I,I] : I in 1..N]),
   Diag2 #= sum([Mat[I,N-I+1] : I in 1..N]),

   Vars = MatVars ++ RowSums ++ ColSums,
   solve(Vars).
  /*

  Hidato puzzle in Picat.

  http://www.shockwave.com/gamelanding/hidato.jsp
  http://www.hidato.com/
 
  """
  Puzzles start semi-filled with numbered tiles.
  The first and last numbers are circled.
  Connect the numbers together to win. Consecutive
  number must touch horizontally, vertically, or
  diagonally.
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go2 =>
   % NumProblems = 8,
   foreach(P in [1,2,3,4,5,6,8]) time2($solveit(P)) end.

go3 => 
   time2($solveit(7)).

solveit(Problem) =>
   printf("\nProblem %d\n", Problem),
   problem(Problem,X),
   hidato(X).


hidato(X) =>

   N = X.length,
   XList = array_matrix_to_list(X),
   XList :: 1..N*N,

   % Valid connections, used by the table constraint below
   Connections = [{I1,J1,I2,J2} :
                  I1 in 1..N, J1 in 1..N, 
                  I2 in 1..N, J2 in 1..N,
                  abs(I1-I2) =< 1,
                  abs(J1-J2) =< 1,
                  (I1 !=I2; J1 != J2)],

   % place all integers from 1..r*c
   all_different(XList),

   NN1 = (N*N)-1,

   Extras = [],
   Connect = [],
   % table constraint
   table_in(Connect,Connections),

   foreach(K in 1..NN1)

       % define temporary variables for finding
       % the index of this and the next number (K)
       I :: 1..N, % index I
       J :: 1..N, % index J
       A :: -1..1, % offset from K's position
       B :: -1..1, % ibid

       % needed for element
       IA :: 1..N,
       JB :: 1..N,
       IA #= I+A,
       JB #= J+B,
       
       % some extra constraints
       abs(A)+abs(B) #>= 1, % both A and B cannot be 0, i.e. it must be a move

       % 1. First: fix this k, i.e.
       % K #= X[I,J], % don't work (instantiation fault)
       IJ #= (I-1)*N + J,
       element(IJ, XList, K),
       

       % 2. Then, find the position of the next value, i.e.
       % K+1 #= X[I+A,J+B], % this don't work
       IA_JB #= (I-1+A)*N + JB,
       K1 = K+1,
       element(IA_JB, XList, K1),

       Extras := Extras ++ [IJ,IA_JB,A,B],
       Connect := Connect ++ [(I,J,IA,JB)]
   end,

   % search
   % Vars = XList ++ Extras ++ Connect,
   % Vars = Extras ++ Connect ++ XList,
   Vars = Connect ++ XList ++ Extras,
   % solve([inout,down],Vars),
   solve([],Vars),

   pretty_print(X).


pretty_print(X) =>
   N = X.length,
   foreach(I in 1..N)
      foreach(J in 1..N)
          printf("%3d ", X[I,J])
      end,
      nl
   end, 
   nl.   



%
% Problems
%


% Simple problem
%
% solution:
%   6 7 9
%   5 2 8
%   1 4 3
% 
problem(1, P) => 
    P = {{6,_,9},
         {_,2,8},
         {1,_,_}}.



problem(2, P) => 
    P = {{ _,44,41, _, _, _, _},
         { _,43, _,28,29, _, _},
         { _, 1, _, _, _,33, _},
         { _, 2,25, 4,34, _,36},
         {49,16, _,23, _, _, _},
         { _,19, _, _,12, 7, _},
         { _, _, _,14, _, _, _}}. 



% Problems from the book:
% Gyora Bededek: "Hidato: 2000 Pure Logic Puzzles"

% problem 1 (Practice}
problem(3, P) => 
    P = {{_, _,20, _, _},
         {_, _, _,16,18},
         {22, _,15, _, _},
         {23, _, 1,14,11},
         {_,25, _, _,12}}.
         


% problem 2 (Practice}
problem(4, P) => 
    P = {{_, _, _, _,14},
         {_,18,12, _, _},
         {_, _,17, 4, 5},
         {_, _, 7, _, _},
         {9, 8,25, 1, _}}.


% problem 3 (Beginner}
problem(5, P) => 
    P = {{ _,26, _, _, _,18},
         { _, _,27, _, _,19},
         {31,23, _, _,14, _},
         { _,33, 8, _,15, 1},
         { _, _, _, 5, _, _},
         {35,36, _,10, _, _}}.



% Problem 15 (Intermediate}
problem(6,P) => 
   P = {{64, _, _, _, _, _, _, _},
        { 1,63, _,59,15,57,53, _},
        { _, 4, _,14, _, _, _, _},
        { 3, _,11, _,20,19, _,50},
        { _, _, _, _,22, _,48,40},
        { 9, _, _,32,23, _, _,41},
        {27, _, _, _,36, _,46, _},
        {28,30, _,35, _, _, _, _}}.


% Problem 156 (Master}
% (This is harder to solve than the 12x12 prolem 188 below...%}
problem(7, P) => 
    P = {{88, _, _,100, _, _,37,_, _,34},
         { _,86, _,96,41, _, _,36, _, _},
         { _,93,95,83, _, _, _,31,47, _},
         { _,91, _, _, _, _, _,29, _, _},
         {11, _, _, _, _, _, _,45,51, _},
         { _, 9, 5, 3, 1, _, _, _, _, _},
         { _,13, 4, _, _, _, _, _, _, _},
         {15, _, _,25, _, _,54,67, _, _},
         { _,17, _,23, _,60,59, _,69, _},
         {19, _,21,62,63, _, _, _, _, _}}.


% Problem 188 (Genius}
problem(8, P) => 
    P = {{  _,  _,134,  2,  4,  _,  _,  _,  _,  _,  _,  _},
         {136,  _,  _,  1,  _,  5,  6, 10,115,106,  _,  _},
         {139,  _,  _,124,  _,122,117,  _,  _,107,  _,  _},
         {  _,131,126,  _,123,  _,  _, 12,  _,  _,  _,103},
         {  _,  _,144,  _,  _,  _,  _,  _, 14,  _, 99,101},
         {  _,  _,129,  _, 23, 21,  _, 16, 65, 97, 96,  _},
         { 30, 29, 25,  _,  _, 19,  _,  _,  _, 66, 94,  _},
         { 32,  _,  _, 27, 57, 59, 60,  _,  _,  _,  _, 92},
         {  _, 40, 42,  _, 56, 58,  _,  _, 72,  _,  _,  _},
         {  _, 39,  _,  _,  _,  _, 78, 73, 71, 85, 69,  _},
         { 35,  _,  _, 46, 53,  _,  _,  _, 80, 84,  _,  _},
         { 36,  _, 45,  _,  _, 52, 51,  _,  _,  _,  _, 88}}.



% Variable selection
selection(Selection) => 
  Selection = [backward,constr,degree,ff,ffc,forward,inout,leftmost,max,min].

% Value selection
choice(Choice) => Choice = [down,updown,split,reverse_split].
/* 

  (Hitchcock-Koopmans) Transportation problem in Picat.

  Given sum of rows and columns, calculate a minimum transportation matrix.
  
  Data and principal model from
  http://www.math.niu.edu/~rusin/known-math/99/transport


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
  NumRows = 5,
  Rows = 1..NumRows,
  NumCols = 5,
  Cols = 1..NumCols,

  MinVal = 0, % minimum value
  RR = [101, 200, 350, 1400, 600],
  CC = [1250, 200, 300, 401, 500],

  X = new_array(NumRows,NumCols),
  % X in MinVal..1000,
  
  % minimum value in the transportation matrix
  foreach(I in Rows, J in Cols) X[I,J] #>= MinVal end,

  Total #= sum([X[I,J] : I in Rows, J in Cols]),
  
  % sum rows 
  foreach({Row,R} in zip(X.rows(), RR))
     sum(Row.to_list()) #= R
  end,

  % sum cols
  foreach({Col,C} in zip(X.columns(), CC))
     sum(Col.to_list()) #= C
  end,

  %% Inferred domains of Total and X
  % writeln(total=Total),
  % foreach(I in Rows) 
  %   foreach(J in Cols) 
  %      printf("%w ", X[I,J])
  %   end,
  %   nl
  % end,


  Vars = X.to_list() ++ [Total],
  solve($[min(Total),report(print_sol(X,Total))], Vars),

  print_sol(X,Total),
  
  nl.


print_sol(X,Total) => 
  writeln(total=Total),
  foreach(Row in X) writeln(Row.to_list()) end,
  nl./* 

  Honey division puzzle in Picat.

  From Martin Chlond Integer Programming Puzzles:
  http://www.chlond.demon.co.uk/puzzles/puzzles1.html, puzzle nr. 6.
  Description  : Honey division puzzle
  Source       : H E Dudeney - Amusements in Mathematics
  """
  6. Once upon a time there was an aged merchant of Baghdad who was much respected by all 
  who knew him. He had three sons, and it was a rule of his life to treat them all exactly 
  alike. Whenever one received a present, the other two were each given one of equal 
  value. One day this worthy man fell sick and died, bequeathing all his possessions to his three 
  sons in equal shares.

  The only difficulty that arose was over the stock of honey. There were exactly twenty-one 
  barrels. The old man had left instructions that not only should every son receive an equal 
  quantity of honey, but should receive exactly the same number of barrels, and that no honey 
  should be transferred from barrel to barrel on account of the waste involved. Now, as seven 
  of these barrels were full of honey, seven were half full, and seven were empty, this was found 
  to be quite a puzzle, especially as each brother objected to taking more than four barrels 
  of the same description - full, half full, or empty.

  Can you show how they succeeded in making a correct division of the property? 
  (Dudeney)
  """

  This model was inspired by the XPress Mosel model created by Martin Chlond.
  http://www.chlond.demon.co.uk/puzzles/sol1s6.html


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
  Son = 3,
  Cap = 3,
  S = 1..Son,
  C = 1..Cap,

  % Howfull = [1, 0.5, 0]
  HowFull = [2, 1, 0], % multiplies with 2 for the integer version

  X = new_array(Son,Cap),
  X :: 1..4,

  SumX #= sum([X[I,J] : I in S, J in C]),

  %  each son gets 7 barrels
  foreach(I in S)
      sum([X[I,J] : J in C]) #= 7
  end,

  %  each son gets 3.5 units
  foreach(I in S)
     % multiplies with 2 for the integer version
     sum([HowFull[J]*X[I,J] : J in C]) #= 7
  end,

  %  use 7 of each barrel capacity
  foreach(J in C)
     sum([X[I,J] : I in S]) #= 7
  end,

  solve([ff], X.to_list() ++ [SumX]),

  writeln(sumX=SumX),
  foreach(Row in X) writeln(Row.to_list()) end,
  
  nl.

/*

  Huey, Dewey and Louie problem in Picat.
 
  From Marriott & Stuckey, Programming with Constraints, page 42
  """
  Huey, Dewey and Louie are being questioned by their uncle. These are the 
  statements the make:
   Huey: Dewey and Louie has equal share in it; if one is quitly, so
         is the other.
   Dewey: If Huey is guilty, then so am I.
   Louie: Dewey and I are not both quilty.
  
  Their uncle, knowing that they are cub scouts, realises that they
  cannot tell a lie. Has he got sufficient information to decide who 
  (if any) are quilty?
  """
 
  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   huey_dewey_louie(L),
   writeln(L),nl.

huey_dewey_louie(L) =>

   L = [Huey,Dewey,Louie],
   L :: 0..1,

   %  Huey: Dewey and Louie has equal share in it; if one is 
   % quitly, so is the other.
   ((Dewey #=1) #<=> (Louie #=1)),
  
   %  Dewey: If Huey is guilty, then so am I.
   (Huey #=1 #=> Dewey #=1),

   %  Louie: Dewey and I are not both quilty.
   (#~(Dewey #=1  #/\ Louie #=1)),

   solve(L).
/*

  Some explorations of ISBN13 in Picat.

  See http://en.wikipedia.org/wiki/ISBN
 
  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% Test ISBN:
% 978-0262720304: The OPL Optimization Programming Language 
% [9,7,8,0,2,6,2,7,2,0,3,0]
%
% isbn = 978-0262220774: Constraint-based Local Search
% [9,7,8,0,2,6,2,2,2,0,7,7];

% Constraint Solving and Planning with Picat
% book: http://www.springer.com/gp/book/9783319258812
% [9,7,8,3,3,1,9,2,5,8,8,1,2]
% Ebook: [9,7,8,3,3,1,9,2,5,8,8,3,6]


go ?=>
   N = 13,
   % Mult0 = 3,
   % Mult1 = 1,
   % test ISBN
   % ISBN = [9,7,8,0,2,6,2,7,2,0,3,0,_], % get check digit
   % ISBN = [9,7,8,0,2,_,2,7,2,0,3,0,4], % get some other digit
   % ISBN = [9,7,8,0,2,_,_,7,2,0,3,0,4], % get some other digit
   % ISBN = [9,7,8,0,2,6,2,_,_,_,_,_,_],

   % Picat book: http://www.springer.com/gp/book/9783319258812
   ISBN = [9,7,8,3,3,1,9,2,5,8,8,_,_],


   isbn(N, ISBN,Mult0,Mult1,Check),
   writeln(isbn=ISBN),
   writeln(check=Check),
   writeln([mult0=Mult0,mult1=Mult1]),
   nl,
   fail.
   
go2 => 
   % The Picat book: http://www.springer.com/gp/book/9783319258812
   ISBN = [9,7,8,3,3,1,9,2,5,8,8,_,_],
   isbn2(ISBN),
   println(ISBN),
   fail,
   nl.
   

isbn(N, ISBN,Mult0,Mult1,Check) =>
   
   ISBN = new_list(N),
   ISBN :: 0..9,

   Mult0 :: 1..9,
   Mult1 :: 1..9,

   Mult0 #= 3,
   Mult1 #= 1,

   % Mult0 #\= Mult1, % extra constraint

   % The first N-1 digits, for the check sum
   N1 = N-1,
   TT = new_list(N1),
   TT :: 0..100,

   % ISBN starts with 978 or 979
   ISBN[1] #= 9,
   ISBN[2] #= 7,
   ISBN[3] #>=8,

   % Prepare for the check sum
   foreach({T,C} in zip(TT,1..N1))
      element(C,ISBN,I),
      if C mod 2 == 0 then 
         T #= I*Mult0 
      else
         T #= I*Mult1
      end
   end,

   sum(TT) #= TSum,

   % check digit
   Check #= ISBN[N],
   Check #= (10 - TSum mod 10) mod 10,

   Vars = ISBN ++ TT ++ [Mult0,Mult1,TSum],
   solve([ff],Vars).


%
% Simpler version: fixed Mult0 and Mult1
%
isbn2(ISBN) =>

   N=13,   
   ISBN = new_list(N),
   ISBN :: 0..9,

   % The first N-1 digits, for the check sum
   N1 = N-1,
   TT = new_list(N1),
   TT :: 0..100,

   % ISBN starts with 978 or 979
   ISBN[1] #= 9,ISBN[2] #= 7,ISBN[3] #>=8,

   % Prepare for the check sum
   foreach({T,C} in zip(TT,1..N1))
      element(C,ISBN,I),
      if C mod 2 == 0 then 
         T #= I*3 % I*Mult0
      else
         T #= I*1 % I*Mult1
      end
   end,

   sum(TT) #= TSum,
   Check #= ISBN[N],
   Check #= (10 - TSum mod 10) mod 10,

   Vars = ISBN ++ TT ++ [TSum],
   solve([ff,split],Vars)./* 

  Jive turkeys puzzle in Picat.

  From Martin Chlond Integer Programming Puzzles:
  http://www.chlond.demon.co.uk/puzzles/puzzles2.html, puzzle nr. 5. 
  Description  : Jive turkeys
  Source       : rec.puzzles

  """
  5. A butcher received an invoice for a consignment of 72 turkeys, but unfortunately it 
  was smudged and a couple of figures were unreadable. All he could read was '-67.9-', with 
  the first and last figures illegible. Nevertheless, being a 'rec.puzzler', he was able to 
  work out the price of a turkey immediately. What was the price of a turkey? (rec.puzzles)
  """

  This model was inspired by the XPress Mosel model created by Martin Chlond.
  http://www.chlond.demon.co.uk/puzzles/sol2s5.html



  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
  N = 3,
  X = new_list(N),

  foreach(I in 1..2) X[I] #>= 0, X[I] #=< 9 end,

  10000*X[1] + 6790 + X[2] #= 72*X[3],

  solve($[min(X[3])], X),
  writeln(X),
  printf("Price: %2.2f\n", X[3]/100),
  
  nl.

/*

  Jobs puzzle in Picat.

  This is a standard problem in Automatic Reasoning.
  
  From http://www-unix.mcs.anl.gov/~wos/mathproblems/jobs.html
  """
  Jobs Puzzle
  
  There are four people:  Roberta, Thelma, Steve, and Pete.
  Among them, they hold eight different jobs.
  Each holds exactly two jobs.
  The jobs are chef, guard, nurse, clerk, police officer (gender 
  not implied), teacher, actor, and boxer.
  The job of nurse is held by a male.
  The husband of the chef is the clerk.
  Roberta is not a boxer.
  Pete has no education past the ninth grade.
  Roberta, the chef, and the police officer went golfing together.
 
  Question:  Who holds which jobs?
  """
 
 
  The answer:
  Chef       Thelma
  Guard      Roberta
  Nurse      Steve
  Clerk      Pete
  Police     Steve
  Teacher    Roberta
  Actor      Pete
  Boxer      Thelma

 
  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   Roberta = 1,
   Thelma = 2,
   Steve = 3,
   Pete = 4,
   
   Persons = [Roberta, Thelma, Steve, Pete],
   
   Jobs = [Chef, _Guard, Nurse, Clerk, PoliceOfficer, Teacher, Actor, Boxer],
   Jobs :: 1..4,
   
   
   % Each holds exactly two jobs.
   foreach(I in 1..4) count(I, Jobs,#=, 2) end,
   
   %  The job of nurse is held by a male.
   (Nurse #= Steve #\/ Nurse #= Pete),

   %  The husband of the chef is the clerk.
   (Clerk #= Steve   #\/ Clerk #= Pete),
   (Chef  #= Roberta #\/ Chef #= Thelma),
   Chef #!= Clerk,

   %  Roberta is not a boxer.
   Roberta #!= Boxer,

   %  Pete has no education past the ninth grade.
   Pete #!= Teacher, 
   Pete #!= PoliceOfficer, 
   Pete #!= Nurse,

   % Roberta, [and] the chef, and the police officer 
   % went golfing together.
   all_different([Roberta,Chef,PoliceOfficer]),
   % Roberta #\= Chef , 
   % Chef    #\= PoliceOfficer ,
   % Roberta #\= PoliceOfficer ,

   % From the name of the job
   (Actor #= Steve #\/ Actor #= Pete),

   % search
   solve(Jobs),

   % output
   writeln(Jobs),nl,
   PersonsStr = ["Roberta", "Thelma", "Steve", "Pete"],
   JobsStr    = ["Chef", "Guard", "Nurse", "Clerk", "Police", "Teacher", "Actor", "Boxer"],
   foreach({J,JS} in zip(Jobs,JobsStr))
      foreach({P,PS} in zip(Persons,PersonsStr))
         if P == J then
             printf("%w\t%w",JS,PS)
          end
      end,
      nl
   end.
/*

  Just forgotten puzzle (Enigma 1517) in Picat.

  From http://www.f1compiler.com/samples/Enigma 201517.f1.html
  """
  Enigma 1517 Bob Walker, New Scientist magazine, October 25, 2008.
 
  Joe was furious when he forgot one of his bank account numbers. 
  He remembered that it had all the digits 0 to 9 in some order, so he tried
  the following four sets without success:
 
      9 4 6 2 1 5 7 8 3 0
      8 6 0 4 3 9 1 2 5 7 
      1 6 4 0 2 9 7 8 5 3
      6 8 2 4 3 1 9 0 7 5
 
  When Joe finally remembered his account number, he realised that in each set
  just four of the digits were in their correct position and that, if one knew
  that, it was possible to work out his account number.
  What was it? 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   A = [[9,4,6,2,1,5,7,8,3,0],
        [8,6,0,4,3,9,1,2,5,7],
        [1,6,4,0,2,9,7,8,5,3],
        [6,8,2,4,3,1,9,0,7,5]],

   Xs = new_list(10),
   Xs :: 0..9,

   all_different(Xs),
   foreach(Row in A) sum([(X #= R) : {R,X} in zip(Row,Xs)]) #= 4 end,

   solve(Xs),
   
   println(Xs),
   nl.


/*

  K4P2 Graceful Graph in Picat.

  Problem from Tailor/Minion summer_school/examples/K4P2GracefulGraph.eprime
  Also see
  http://mathworld.wolfram.com/GracefulGraph.html


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   M = 16,
   N = 8,
   graph(Graph),
   graceful_graph(Graph, M,N,Nodes,Edges),
   writeln(nodes=Nodes),
   writeln(edges=Edges).


% Just count the number of solutions
go2 =>
   M = 16,
   N = 8,
   graph(Graph),
   L = findall(_, $graceful_graph(Graph, M,N,_Nodes,_Edges)),
   writef("Number of solutions: %d\n", L.length).
   

graceful_graph(Graph, M,N,Nodes,Edges) =>

   Nodes = new_list(N),
   Nodes :: 0..M,

   Edges = new_list(M),
   Edges :: 1..M,

   all_different(Edges),
   all_different(Nodes),

   foreach({[From,To],Edge} in zip(Graph,Edges))
       abs(Nodes[From] - Nodes[To]) #= Edge       
   end,

   Vars = Nodes ++ Edges,
   solve(Vars).



graph(Graph) => 
  Graph = 
       [[1, 2],
       [1, 3],
       [1, 4],
       [2, 3],
       [2, 4],
       [3, 4],
       
       [5, 6],
       [5, 7],
       [5, 8],
       [6, 7],
       [6, 8],
       [7, 8],
       
       [1, 5],
       [2, 6],
       [3, 7],
       [4, 8]].
/*
  Kakuro solver based on constraint programming.
	
  Problem Input implemented as 2D matrix containing local horizontal/
  vertical constraint sums in sub lists

  Model created by Lorenz Schiffmann, lorenz.schiffmann@gmail.com
  [with some small additions by Hakan Kjellerstrand, hakank@gmail.com]

*/

go => 
  time2($kakuro(1)),
  time2($kakuro(2)).

free(X) => not number(X), not list(X).
stop(X,Y) => free(X), list(Y).

kakuro(Id) =>
   printf("\nSolving problem %w\n", Id),
   problem(Id,A),  
   NC := length(A[1]), NR := length(A),
   IJ := 0,   
   foreach(Row in 2..NR, Col in reverse(2..NC))  % prepare all horizontal constraints from right to left for each row
     ( free(A[Row,Col]) -> member(A[Row,Col], 1..9); true),
     ((free(A[Row,Col]), IJ=0) -> IJ:=Col; true),     
     ( stop(A[Row,Col],A[Row,Col-1]) -> (A[Row,Col-1,2] #= sum([A[Row,J] : J in Col..IJ]), all_different([A[Row,J] : J in Col..IJ]), IJ:=0); true)                   
   end,  
   IJ := 0,
   foreach(Col in 2..NC, Row in reverse(2..NR))  % prepare all vertical constraints from bottom to top for each col
     ( free(A[Row,Col]) -> member(A[Row,Col],1..9); true),
     ((free(A[Row,Col]), IJ=0) -> IJ:=Row; true),     
     ( stop(A[Row,Col],A[Row-1,Col]) -> (A[Row-1,Col,1] #= sum([A[I,Col] : I in Row..IJ]), all_different([A[I,Col] : I in Row..IJ]), IJ:=0); true)                   
   end,      
   solve(A),   
   foreach(Row in 1..NR, Col in 1..NC) 
     printf("%8w", A[Row,Col]),
     if Col=NC then printf("%n") end 
   end,
   nl.
   
problem(1, A) => 
  % http://krazydad.com/kakuro/books/KD_Kakuro_6x6_s0_b100.pdf   (7)
    A={{0      , [13,0], [6,0]    ,  0     , [27,0] , [16,0] , 0    },
      {[0,10]  , _     ,  _       ,  [16,4], _      , _      , 0    },
      {[0,17]  , _     ,  _       ,  _     , _      , _      , 0    },
      { 0      , 0     ,  [11,19] ,  _     , _      , _      , 0    },
      { 0      ,[0,10] , _        ,  _     , _      , [14,0] , [8,0]},
      { 0      ,[0,27] , _        ,  _     , _      , _      , _    },
      { 0      ,[0,8]  , _        ,  _     , [0,16] , _      , _    }}.
      
problem(2, A) => 
 % http://www.kakuros.org/?s=9x8   (randomly generated)
   A={{0      ,  0    ,   0      ,   [16,0], [7,0]  , 0       , 0     , 0      },
      {0      ,  0    ,   [0,8]  ,   _     , _      , [15,0]  , 0     , 0      },
      {0      ,  0    ,   [24,20],   _     , _      , _       , [29,0], [13,0] },
      {0      , [0,5] ,   _      ,   _     , [0,21] , _       , _     , _      },
      {0      , [5,10],   _      ,   _     , 0      , [18,15] , _     , _      },
      {[0,4]  , _     ,   _      ,  [13,0] , [0,13] , _       , _     , 0      },
      {[0,21] , _     ,   _      ,   _     , [14,8] , _       , _     , 0      },
      {0      ,  0    ,   [0,14] ,   _     , _      , _       , 0     , 0      },
      {0      ,  0    ,   0      ,  [0,15] , _      , _       , 0     , 0      }}.
/*

  Kakuru puzzle in Picat.

  http://en.wikipedia.org/wiki/Kakuro
  """
  The object of the puzzle is to insert a digit from 1 to 9 inclusive 
  into each white cell such that the sum of the numbers in each entry 
  matches the clue associated with it and that no digit is duplicated in 
  any entry. It is that lack of duplication that makes creating Kakuro 
  puzzles with unique solutions possible, and which means solving a Kakuro 
  puzzle involves investigating combinations more, compared to Sudoku in 
  which the focus is on permutations. There is an unwritten rule for 
  making Kakuro puzzles that each clue must have at least two numbers 
  that add up to it. This is because including one number is mathematically 
  trivial when solving Kakuro puzzles; one can simply disregard the 
  number entirely and subtract it from the clue it indicates.
  """

  This model solves the problem at the Wikipedia page. 
  For a larger picture, see
  http://en.wikipedia.org/wiki/File:Kakuro_black_box.svg

  The solution:
    9 7 0 0 8 7 9
    8 9 0 8 9 5 7
    6 8 5 9 7 0 0
    0 6 1 0 2 6 0
    0 0 4 6 1 3 2
    8 9 3 1 0 1 4
    3 1 2 0 0 2 1


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 

  problem(P, N, Hints, Blanks),
  writef("Kakuro problem %d\n",P),

  X = new_array(N,N),
  X :: 0..9, 

  % Fill the blanks

  foreach([RR,CC] in Blanks)  X[RR,CC] #= 0 end,


  % The hints
  foreach([Sum|List] in Hints)
     XLine = [X[R,C] : [R,C] in List, X[R,C] #> 0],
     sum(XLine) #= Sum,
     all_different(XLine)
  end,

  solve(X),

  foreach(Row in X)
     foreach(R in Row) 
        if R > 0 then
           writef("%2d",R) 
        else
           writef(" _")
        end
     end,
     nl
  end,
  nl.


%
% This is the problem cited above.
%
% problem(Id, Size, Hints, Blanks).
problem(Id,Size, Hints, Blanks) =>
  Id = 1,
  Size = 7,
     % [Sum, [List of indices in X]]
  Hints =  [ 
      [16, [1,1],[1,2]],
      [24, [1,5],[1,6],[1,7]],
      [17, [2,1],[2,2]],
      [29, [2,4],[2,5],[2,6],[2,7]],
      [35, [3,1],[3,2],[3,3],[3,4],[3,5]],
      [ 7, [4,2],[4,3]],
      [ 8, [4,5],[4,6]],
      [16, [5,3],[5,4],[5,5],[5,6],[5,7]],
      [21, [6,1],[6,2],[6,3],[6,4]],
      [ 5, [6,6],[6,7]],
      [ 6, [7,1],[7,2],[7,3]],
      [ 3, [7,6],[7,7]],
      
      [23, [1,1],[2,1],[3,1]],
      [30, [1,2],[2,2],[3,2],[4,2]],
      [27, [1,5],[2,5],[3,5],[4,5],[5,5]],
      [12, [1,6],[2,6]],
      [16, [1,7],[2,7]],
      [17, [2,4],[3,4]],   
      [15, [3,3],[4,3],[5,3],[6,3],[7,3]],
      [12, [4,6],[5,6],[6,6],[7,6]],
      [ 7, [5,4],[6,4]],   
      [ 7, [5,7],[6,7],[7,7]],
      [11, [6,1],[7,1]],
      [10, [6,2],[7,2]]
  ],

   % indices of blanks
   Blanks = 
      [
       [1,3], [1,4],
       [2,3],
       [3,6], [3,7],
       [4,1], [4,4],[4,7],
       [5,1], [5,2],
       [6,5],
       [7,4], [7,5]
   ].

/*

  KenKen puzzle in Picat.

  http://en.wikipedia.org/wiki/KenKen
  """
  KenKen or KEN-KEN is a style of arithmetic and logical puzzle sharing 
  several characteristics with sudoku. The name comes from Japanese and 
  is translated as "square wisdom" or "cleverness squared".
  ...
  The objective is to fill the grid in with the digits 1 through 6 such that:

    * Each row contains exactly one of each digit
    * Each column contains exactly one of each digit
    * Each bold-outlined group of cells is a cage containing digits which 
      achieve the specified result using the specified mathematical operation: 
        addition (+), 
        subtraction (-), 
        multiplication (x), 
        and division (). 
        (Unlike in Killer sudoku, digits may repeat within a group.)

  ...
  More complex KenKen problems are formed using the principles described 
  above but omitting the symbols +, -, x and , thus leaving them as 
  yet another unknown to be determined.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
    problem(1,N, Problem),
    time2($kenken2(N, Problem)).

        
latin_square(Board) =>
   foreach(Row in Board) all_different(Row) end,
   foreach(Column in Board.columns()) all_different(Column) end.


kenken2(N, Problem) =>

    Len = length(Problem),

    % decision variables
    X = new_array(N,N),
    X :: 1..N,

    % all rows and columns must be unique
    latin_square(X),

    foreach(I in 1..Len)
       % extract the hints
       [Result, Coeffs] = Problem[I],
       % calculate this hint
       calc(Result, Coeffs,X)
    end,

    % solve([ff,updown],X),
    solve(X),

    pretty_print(X).


calc(Result, Coeffs,X) =>
        Len = length(Coeffs),
        if Len == 2 then
            % special handling for size 2
            [[AR,AC],[BR,BC]] = Coeffs,
            A #= X[AR,AC],
            B #= X[BR,BC],
            % check2(A,B,Result)
            (
            A + B #= Result #\/
            A * B #= Result #\/
            A * Result #= B #\/ % B/A = Result
            B * Result #= A #\/ % A/B = Result
            A - B #= Result #\/
            B - A #= Result
            )

        else 
            % or size > 2
            CoeffRes = [X[R,C] : [R,C] in Coeffs],
            check_many(Result, CoeffRes)
        end.


% either sum or product
check_many(Result, CoeffRes) ?=> Result #= prod(CoeffRes).
check_many(Result, CoeffRes) ?=> Result #= sum(CoeffRes).



% product of a list

prodlist(List, Product) =>
   Product1 = 1, 
   foreach(L in List)
      % We must "taint" the variable to be a CP variable
      Product1 := $Product1 * L
   end,
   Product #= Product1.


pretty_print(Board) =>
   N = Board.length,
   foreach(I in 1..N)
      foreach(J in 1..N)
          X = Board[I,J],
          if var(X) then writef("  _") else writef("  %w", X) end
       end,
       nl
   end,
   nl.

%
% State the problem, i.e. the hints. 
%
% For a better view of the problem, see 
%  http://en.wikipedia.org/wiki/File:KenKenProblem.svg  
%
%
%   The solution is:
%     5 6 3 4 1 2
%     6 1 4 5 2 3
%     4 5 2 3 6 1
%     3 4 1 2 5 6
%     2 3 6 1 4 5
%     1 2 5 6 3 4
%
problem(1, Size, M) => 
      Size = 6,
         M = [
               [ 11, [[1,1], [2,1]]],
               [  2, [[1,2], [1,3]]],
               [ 20, [[1,4], [2,4]]],
               [  6, [[1,5], [1,6], [2,6], [3,6]]],
               [  3, [[2,2], [2,3]]],
               [  3, [[2,5], [3,5]]],
               [240, [[3,1], [3,2], [4,1], [4,2]]],
               [  6, [[3,3], [3,4]]],  
               [  6, [[4,3], [5,3]]],
               [  7, [[4,4], [5,4], [5,5]]],
               [ 30, [[4,5], [4,6]]],  
               [  6, [[5,1], [5,2]]],
               [  9, [[5,6], [6,6]]],
               [  8, [[6,1], [6,2], [6,3]]],
               [  2, [[6,4], [6,5]]]
           ].


/*

  Killer Sudoku in Picat.

  http://en.wikipedia.org/wiki/Killer_Sudoku
  """
  Killer sudoku (also killer su doku, sumdoku, sum doku, addoku, or 
  samunamupure) is a puzzle that combines elements of sudoku and kakuro. 
  Despite the name, the simpler killer sudokus can be easier to solve 
  than regular sudokus, depending on the solver's skill at mental arithmetic; 
  the hardest ones, however, can take hours to crack.

  ...

  The objective is to fill the grid with numbers from 1 to 9 in a way that 
  the following conditions are met:

    * Each row, column, and nonet contains each number exactly once.
    * The sum of all numbers in a cage must match the small number printed 
      in its corner.
    * No number appears more than once in a cage. (This is the standard rule 
      for killer sudokus, and implies that no cage can include more 
      than 9 cells.)

  In 'Killer X', an additional rule is that each of the long diagonals 
  contains each number once.
  """

  Here we solve the problem from the Wikipedia page, also shown here
  http://en.wikipedia.org/wiki/File:Killersudoku_color.svg

  The output is:
    2 1 5 6 4 7 3 9 8
    3 6 8 9 5 2 1 7 4
    7 9 4 3 8 1 6 5 2
    5 8 6 2 7 4 9 3 1
    1 4 2 5 9 3 8 6 7
    9 7 3 8 1 6 4 2 5
    8 2 1 7 3 9 5 4 6
    6 5 9 4 2 8 7 1 3
    4 3 7 1 6 5 2 8 9

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   problem(1, Board),
   killer_sudoku(Board,X),
   print_board(X).


killer_sudoku(Hints,X) =>

   N = 3,
   N2 = N*N,

   X = new_array(N2,N2),
   X :: 1..9,

   % The hints (from kakuro.pl)
   foreach([Sum|List] in Hints)
       XLine = [X[R,C] : [R,C] in List],
       sum(XLine) #= Sum,
       all_different(XLine)
   end,

   sudoku(N, X),
   solve([ff,down], X).
        

%
% Ensure a Latin square, 
% i.e. all rows and all columns are different
%
latin_square(Board) =>
   foreach(Row in Board) all_different(Row) end,
   foreach(Column in Board.columns()) all_different(Column) end.



sudoku(N, Board) =>
   N2 = N*N,
   % BoardVar = [BB : I in 1..N2, J in 1..N2, BB = Board[I,J]],
   % BoardVar :: 1..N2,

   latin_square(Board),
   foreach(I in 1..N..N2, J in 1..N..N2)
       SubSquare = [X : K in 0..N-1, L in 0..N-1, 
                    X = Board[I+K,J+L]],
       all_different(SubSquare)
   end,
   solve([ff,down], Board).




print_board(Board) =>
   N = Board.length,
   foreach(I in 1..N)
      foreach(J in 1..N)
          X = Board[I,J],
          if var(X) then writef("  _") else writef("  %w", X) end
       end,
       nl
   end,
   nl.


problem(P, Hints) =>
  P = 1,
  Hints = 
        [% The hints:
         %  [Sum, [list of indices in X]]
            [ 3, [1,1], [1,2]],
            [15, [1,3], [1,4], [1,5]],
            [22, [1,6], [2,5], [2,6], [3,5]],
            [ 4, [1,7], [2,7]],
            [16, [1,8], [2,8]],
            [15, [1,9], [2,9], [3,9], [4,9]],
            [25, [2,1], [2,2], [3,1], [3,2]],
            [17, [2,3], [2,4]],
            [ 9, [3,3], [3,4], [4,4]],
            [ 8, [3,6], [4,6],[5,6]],
            [20, [3,7], [3,8],[4,7]],
            [ 6, [4,1], [5,1]],
            [14, [4,2], [4,3]],
            [17, [4,5], [5,5],[6,5]],
            [17, [4,8], [5,7],[5,8]],
            [13, [5,2], [5,3],[6,2]],
            [20, [5,4], [6,4],[7,4]],
            [12, [5,9], [6,9]],
            [27, [6,1], [7,1],[8,1],[9,1]],
            [ 6, [6,3], [7,2],[7,3]],
            [20, [6,6], [7,6], [7,7]],
            [ 6, [6,7], [6,8]],
            [10, [7,5], [8,4],[8,5],[9,4]],
            [14, [7,8], [7,9],[8,8],[8,9]],
            [ 8, [8,2], [9,2]],
            [16, [8,3], [9,3]],
            [15, [8,6], [8,7]],
            [13, [9,5], [9,6],[9,7]],
            [17, [9,8], [9,9]]
        ].

/*

  Knapsack (investment) problem in Picat.

  From the Swedish book
  Lundgren, Ronnqvist, Varbrand: 
  "Optimeringslara" (Optimization theory),
  page 393ff.
  
  A company shall invest in some building projects with the following
  limits:
 
   - budget of 225 Mkr (million Swedish kronor)
   - 28 persons available
   - maximum 9 projects can be selected
   - some project may not be selected together with other projects, 
     and some projects must be selected together with other.
  
  (I'm keeping the Swedish object names.)
 
  No.  Object   Value(kkr) Budget(Mkr) Personell  Not with  Requires
  1  Ishall      600        35            5        10        -
  2  Sporthall   400        34            3        -         -
  3  Hotell      100        26            4        -         15
  4  Restaurang  150        12            2        -         15
  5  Kontor A     80        10            2        6         -
  6  Kontor B    120        18            2        5         -
  7  Skola       200        32            4        -         -
  8  Dagis       220        11            1        -         7
  9  Lager        90        10            1        -         -
  10 Simhall     380        22            5        1         -
  11 Hyreshus    290        27            3        15        -
  12 Bilverkstad 130        18            2        -         -
  13 Tennishall   80        16            2        -         2
  14 Idrottsanl. 270        29            4        -         2
  15 Bthamn     280        22            3        11        -
  
 
  Solution (page 395): 
  The following projects is selected
    1,2,4,6,7,8,12,14,15
  and optimal value is 2370kkr.
 


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   num_projects(NumProjects), % number of projects to select from
   max_budget(MaxBudget),   % budget limit 
   max_persons(MaxPersons),  % persons available
   max_projects(MaxProjects), % max number of projects to select

   % the values of each project
   values(Values),
   budgets(Budgets),
   personell(Personell),

   % project i cannot be selected with project j
   not_with(NotWith),

   % project i requires project j
   requires(Requires),

   % decision variable: what project to select
   X = new_list(NumProjects),
   X :: 0..1,

   scalar_product(Personell,X,TotalPersons),
   scalar_product(Budgets,X,TotalBudget),
   TotalProjects #= sum(X),
   % the objective to maximize
   scalar_product(Values,X,TotalValues),

   % TotalValues #>= 2370, % for checking unicity of solutions
   
   % resource limits
   TotalBudget   #=< MaxBudget,
   TotalPersons  #=< MaxPersons,
   TotalProjects #=< MaxProjects,

   % projects that require other projects
   foreach([P1,P2] in Requires)
      % X[P1] - X[P2] #=< 0 # IP version
      X[P1] #=> X[P2]
   end,

   % projects excluding other projects
   foreach([P1,P2] in NotWith)
      % X[P1] + X[P2] #=< 1 # IP version
      X[P1] #=1 #=> X[P2] #= 0
   end,


   % search
   solve([$max(TotalValues),ff,down], X),

   % output
   nl,
   write(X),nl,
   println("selected projects:"),
   foreach({XX,P} in zip(X,1..NumProjects))
      if XX == 1 then
         print(P), print(" ")
      end
   end,
   nl,
   writeln(total_persons=TotalPersons),
   writeln(total_budget=TotalBudget),
   writeln(total_projects=TotalProjects),
   writeln(total_values=TotalValues),
   nl.

scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).


%
% data
%
num_projects(N) => N = 15.
max_budget(M) => M = 225.
max_projects(M) => M = 9.
max_persons(Max) => Max = 28.
values(Values) => Values = [600,400,100,150, 80,120,200,220, 90,380,290,130, 80,270,280].
budgets(Budgets) => Budgets = [35,34,26,12,10,18,32,11,10,22,27,18,16,29,22].
not_with(NotWith) => 
  NotWith = 
       [[1, 10],
        [5, 6],
        [6, 5],
        [10, 1],
        [11, 15],
        [15, 11]].
requires(Requires) => 
   Requires = 
   [[3, 15],
    [4, 15],
    [8, 7],
    [13, 2],
    [14, 2]].
personell(Personell) => Personell = [5,3,4,2,2,2,4,1,1,5,3,2,2,4,3].

/*

  0/1 Knapsack in Picat.

  From http://rosettacode.org/wiki/Knapsack_problem/0-1
  """
  A tourist wants to make a good trip at the weekend with his friends.
  They will go to the mountains to see the wonders of nature, so he 
  needs to pack well for the trip. He has a good knapsack for carrying 
  things, but knows that he can carry a maximum of only 4kg in it and 
  it will have to last the whole day. He creates a list of what he
  wants to bring for the trip but the total weight of all items is too 
  much. He then decides to add columns to his initial list detailing 
  their weights and a numerical value representing how important the item is for the trip.

  Here is the list:
  Table of potential knapsack items item 	weight (dag) 	value
  map 	9 	150
  compass 	13 	35
  water 	153 	200
  sandwich 	50 	160
  glucose 	15 	60
  tin 	68 	45
  banana 	27 	60
  apple 	39 	40
  cheese 	23 	30
  beer 	52 	10
  suntan cream 	11 	70
  camera 	32 	30
  T-shirt 	24 	15
  trousers 	48 	10
  umbrella 	73 	40
  waterproof trousers 	42 	70
  waterproof overclothes 	43 	75
  note-case 	22 	80
  sunglasses 	7 	20
  towel 	18 	12
  socks 	4 	50
  book 	30 	10
  knapsack 	<=400 dag 	 ?

  The tourist can choose to take any combination of items from the
  list, but only one of each item is available. He may not cut or
  diminish the items, so he can only take whole units of any item.

  Which items does the tourist carry in his knapsack so that their
  total weight does not exceed 400 dag [4 kg], and their total value 
  is maximised?
  """

  These are the items to pick:
    Item                    Weight Value
  * map                          9 150
  * compass                     13  35
  * water                      153 200
  * sandwich                    50 160
  * glucose                     15  60
  * banana                      27  60
  * suntancream                 11  70
  * waterproof trousers         42  70
  * waterproof overclothes      43  75
  * note-case                   22  80
  * sunglasses                   7  20
  * socks                        4  50

  Total weight: 396
  Total value: 1030



  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   items(Items),
   Rows = length(Items),

   Weights = [],
   Values = [],
   AllItems = [],
   foreach([Item, Weight, Value] in Items)
          Weights  := Weights ++ [Weight],
          Values   := Values ++ [Value],
          AllItems := AllItems ++ [Item]
   end,

   % 
   % Variables
   % 
   X = new_list(Rows),
   X :: 0..1,

   %
   % Constraints
   % 
   scalar_product(Weights,X,TotalWeight),
   scalar_product(Values,X,TotalValues),
   TotalWeight #=< 400,

   %
   % Search
   %
   Vars = X ++ [TotalWeight, TotalValues],
   solve([$max(TotalValues)], Vars),

   %
   % Solutions
   % 
   println("\nThese are the items to pick:"),
   println("  Item                    Weight Value"),

   % foreach({Pick,I,Weight,Value} in zip(X,AllItems,Weights,Values))
   foreach(I in 1..Rows) 
      if X[I] == 1 then
         printf("* %29w%3d %3d\n", AllItems[I],Weights[I], Values[I])
      end
   end,
   nl,

   printf("Total weight: %d\n", TotalWeight),
   printf("Total value: %d\n", TotalValues).



       % Item          Weight   Value
items(Items) => Items = 
     [["map",           9,       150],
       ["compass",       13,      35],
       ["water",         153,     200],
       ["sandwich",      50,      160],
       ["glucose",       15,      60],
       ["tin",           68,      45],
       ["banana",        27,      60],
       ["apple",         39,      40],
       ["cheese",        23,      30],
       ["beer",          52,      10],
       ["suntancream",        11,      70],
       ["camera",        32,      30],
       ["T-shirt",       24,      15],
       ["trousers",      48,      10],
       ["umbrella",      73,      40],
       ["waterproof trousers",     42,      70],
       ["waterproof overclothes",  43,      75],
       ["note-case",          22,      80],
       ["sunglasses",         7,       20],
       ["towel",         18,      12],
       ["socks",         4,       50],
       ["book",          30,      10]].


scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).
/*

  Knapsack (Bounded) in Picat.

  From 
  http://rosettacode.org/wiki/Knapsack_problem/Bounded
  """
   A tourist wants to make a good trip at the weekend with his 
   friends. They will go to the mountains to see the wonders of 
   nature. So he needs some items during the trip. Food, clothing, 
   etc. He has a good knapsack for carrying the things, but he knows 
   that he can carry only 4 kg weight in his knapsack, because they 
   will make the trip from morning to evening. He creates a list of 
   what he wants to bring for the trip, but the total weight of all 
   items is too much. He adds a value to each item. The value represents 
   how important the thing for the tourist. The list contains which 
   items are the wanted things for the trip, what is the weight and 
   value of an item, and how many units does he have from each items.
  
   This is the list:
   Table of potential knapsack items item 	weight (dag) (each) 	value (each) 	piece(s)
   map 	9 	150 	1
   compass 	13 	35 	1
   water 	153 	200 	2
   sandwich 	50 	60 	2
   glucose 	15 	60 	2
   tin 	68 	45 	3
   banana 	27 	60 	3
   apple 	39 	40 	3
   cheese 	23 	30 	1
   beer 	52 	10 	3
   suntan cream 	11 	70 	1
   camera 	32 	30 	1
   T-shirt 	24 	15 	2
   trousers 	48 	10 	2
   umbrella 	73 	40 	1
   waterproof trousers 	42 	70 	1
   waterproof overclothes 	43 	75 	1
   note-case 	22 	80 	1
   sunglasses 	7 	20 	1
   towel 	18 	12 	2
   socks 	4 	50 	1
   book 	30 	10 	2
   knapsack 	<=400 dag 	 ? 	 ? 
  
  
   The tourist can choose to take any combination of items from the 
   list, and some number of each item is available (see the column 
   "Piece(s)" of the list!). He may not cut the items, so he can only 
   take whole units of any item.
   
   Which items does the tourist carry in his knapsack so that their 
   total weight does not exceed 4 kg, and their total value is maximised?
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   items(Items),
   Rows = length(Items),
   Weights = [],
   Values = [],
   AllItems = [],
   Pieces = [],
   foreach([Item, Weight,Value,Piece] in Items)
          Weights  := Weights ++ [Weight],
          Values   := Values ++ [Value],
          AllItems := AllItems ++ [Item],
          Pieces   := Pieces ++ [Piece]
   end,

   WeightLimit = 400,

   % 
   % Variables
   % 
   MaxPieces = max(Pieces),
   X = new_list(Rows),
   X :: 0..MaxPieces,

   %
   % Constraints
   % 
   SumValues = sum(Values),
   TotalValue :: 0..SumValues,
   TotalWeight :: 0..WeightLimit,

   scalar_product(Weights,X,TotalWeight),
   scalar_product(Values,X,TotalValue),

   % check number of pieces
   foreach((XX,Piece) in (X,Pieces)) XX #=< Piece end,

   %
   % Search
   %
   solve([$max(TotalValue),down],X ++ [TotalWeight, TotalValue]),

   %
   % Solutions
   % 
   println("\nThese are the items to pick:"),
   println("  Item                        Weight Value"),
   foreach(I in 1..Rows)
       if X[I] > 0 then
           printf("* %d %29w %3d %3d\n", X[I],AllItems[I],Weights[I],Values[I])
       end
   end,
   nl,
   printf("Total weight: %d\n", TotalWeight),
   printf("Total value: %d\n", TotalValue).



items(Items) => 
   Items = 
     % Item          Weight   Value  Pieces
     [["map",           9,       150,   1],
       ["compass",       13,      35,    1],
       ["water",         153,     200,   2],
       ["sandwich",      50,      60,    2],
       ["glucose",       15,      60,    2],
       ["tin",           68,      45,    3],
       ["banana",        27,      60,    3],
       ["apple",         39,      40,    3],
       ["cheese",        23,      30,    1],
       ["beer",          52,      10,    3],
       ["suntancream",   11,      70,    1],
       ["camera",        32,      30,    1],
       ["T-shirt",       24,      15,    2],
       ["trousers",      48,      10,    2],
       ["umbrella",      73,      40,    1],
       ["waterproof trousers",     42,      70,    1],
       ["waterproof overclothes",  43,      75,    1],
       ["note-case",          22,      80,    1],
       ["sunglasses",         7,       20,    1],
       ["towel",         18,      12,    2],
       ["socks",         4,       50,    1],
       ["book",          30,      10,    2]].

scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).

/* 

  Knapsack in Picat.

  Port of B-Prolog program
  http://www.probp.com/examples/tabling/knapsack.pl
  """
  Taken from "Simplifying Dynamic Programming via Mode-directed Tabling"
  Software Practice and Experience, 38(1): 75-94, 2008, by Hai-Feng Guo, Gopal Gupta
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
   statistics(_, _),
   knapsack([50, 10, 400, 30, 30, 20, 10, 5, 30, 20,
       6, 20, 20, 30, 9, 30, 20, 500, 20, 40,
      30, 8, 3, 5, 9, 200, 10, 400, 20, 30,
      50, 10, 400, 30, 30, 20, 10, 5, 30, 20,
       6, 20, 20, 30, 9, 30, 20, 500, 20, 40,
       6, 20, 20, 30, 9, 30, 20, 500, 20, 40,
      30, 8, 3, 5, 9, 200, 10, 400, 20, 30,
      50, 10, 400, 30, 30, 20, 10, 5, 30, 20,
       6, 20, 20, 30, 9, 30, 20, 500, 20, 40,
      30, 8, 3, 5, 9, 200, 10, 400, 20, 30], 4000, V),
   statistics(_, [_, B]),
   print("There is a solution for this knapsack problem"), nl,
   print('The maximal number of items is '), print(V), nl,
   print('execution time = '), print(B), print(' ms'), nl.


table(+, +, max)
knapsack(_, Z1, Z2) ?=> Z1=0, Z1=Z2.
knapsack(FL, K, V) ?=>
    FL=[_ | L],
    knapsack(L, K, V).
knapsack(FL, K, V) =>
    FL = [F | L],
    K1 = K - F,
    K1 >= 0,
    knapsack(L, K1, V1),
    V = V1 + 1.

/* 

  Krypto puzzle in Picat.

  From http://en.wikipedia.org/wiki/Krypto_%28game%29
  """
  The Krypto deck consists of 56 cards: three each of numbers 1-6, four each of 
  the numbers 7-10, two each of 11-17, one each of 18-25. Six cards are dealt: 
  a common objective card at the top and five other cards below. Each player must 
  use all five of the cards' numbers exactly once, using any combination of arithmetic 
  operations (addition, subtraction, multiplication, and division), to form the 
  objective card's number. The first player to come up with a correct formula is the winner.

  ...
  Example of Play:

       Cards:  2, 1, 2, 2, 3 = 24 (Objective Card)
       2 x   1 =  2
       2 x   2 =  4
       4 x   2 =  8
       8 x   3 = 24 (Krypto)

  All five cards were used once and only once to equal the Objective Card.

  Another Example:

       Cards:  1, 3, 7, 1, 8 = 1 (Objective Card)
       3 -  1 =  2
       7 +  2 =  9
       9 /  1 =  9
       9 -  8 =  1 (Krypto)

  Here is a more difficult hand:

       Cards:  24, 22, 23, 20, 21 = 1  (Objective Card)
       24 + 22 = 46
       46 / 23 =  2
        2 + 20 = 22
       22 - 21 =  1 (Krypto)
  """

  Also, see
    http://www.math.niu.edu/~rusin/uses-math/games/krypto/

  Note: This model use a restricted version where we don't handle
        parenthesis around the some of the arguments.

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
    % The three examples shown above:
    krypto([2, 1, 2, 2, 3],24),
    krypto([1, 3, 7, 1, 8],1),
    krypto([24, 22, 23, 20, 21],1),

    % Testing some failures
    % Cards=[24,11,17,19,20],Objective=7,
    % Cards=[25,5,1,9,9],Objective=14,
    % Cards=[7,2,20,7,7],Objective=4,
    % krypto(Cards,Objective, 390625),

    nl.

% All solutions
go1 ?=> 
    krypto([24, 22, 23, 20, 21],1),
    fail,
    nl.

go1 => true.

%
% Random problems
%
go2 =>
   Size = 6,
   Rand = rand_deck(Size),
   Cards = [Rand[I] : I in 1..Size-1],
   Objective = Rand[Size],
   (krypto(Cards,Objective) -> writeln(ok) ; writeln(fail)),
   nl.


%
% It's about 5% probability of a failure on a random problem.
%
go3 =>
   N = 100, % = 10000, 
   Size = 6,
   OK = [],
   Fails = [],
   foreach(_K in 1..N) 
      Rand = rand_deck(Size),
      Cards = [Rand[I] : I in 1..Size-1],
      Objective = Rand[Size],
      (krypto(Cards,Objective) -> 
          OK := OK ++ [Cards]
       ; 
          Fails := Fails ++ [Cards]
      )
   end,
   writeln(ok=OK),
   writeln(fails=Fails),
   writeln([numOK=OK.length,numFails=Fails.length]),
   printf("Failure: %2.2f%%%n", Fails.length / N * 100 ),
   nl.

%
% More Cards
%
go4 =>
   Size = 10,
   Rand = rand_deck(Size),
   Cards = [Rand[I] : I in 1..Size-1],
   Objective = Rand[Size],
   krypto(Cards,Objective,max(100,sum(Cards))),
   nl.

%
% 24-game, restricted to just integer operations 
% and don't handle parenthesis.
%
go5 => 
   Size = 4,
   Cards = [1+random2() mod 10 : _I in 1..Size],
   krypto(Cards,24,1000),
   nl.


go6 => 
  krypto(1..10,2013),
  nl.

krypto(Cards,Objective) =>
   krypto(Cards,Objective,100).

krypto(Cards,Objective,Max) =>
    writeln($krypto(cards=Cards,objective=Objective,max=Max)),
    writeln(cards=Cards),
    writeln(objective=Objective),

    N = Cards.length,
    println(n=N),    

    X = new_list(N),
    X :: 1..max(Max,Objective),

    % The operations +:1,-:2, *:3, /:4
    Ops = new_list(N-1),
    Ops :: 1..4,

    % The permutation to use
    permutation(Cards,CardsP),

    X[1] #= CardsP[1],
    foreach(I in 2..N)
       op(X[I],X[I-1],CardsP[I], Ops[I-1])
    end,
    X[N] #= Objective,

    % solve
    Vars = X ++ Ops, %  ++ CardsP,
    % solve($[min(max(X)),ff,split],Vars), % "minimum" solution
    solve([ff,split],Vars),

    % output
    write_krypto(CardsP, X, Ops).

% X1 = X2 op C 
op(X1,X2,C,Op) =>
 (X1 #= X2 + C #/\ Op #= 1) #\/
 (X1 #= X2 - C #/\ Op #= 2) #\/
 (X1 #= X2 * C #/\ Op #= 3) #\/
 (C #> 0 #/\ X2 mod C #= 0 #/\ X1 #= X2 div C #/\ Op #= 4).

ops(1) = "+" => true.
ops(2) = "-" => true.
ops(3) = "*" => true.
ops(4) = "/" => true.



% L2 is a permutation of L1
% permutation(L1,L2) =>
%     foreach(V in L1.remove_dups())
%        count(V, L1,#=,C),
%        count(V, L2,#=,C)
%     end.

%
% Randomize a Krypto deck.
% 
% - three each of numbers 1-6, 
% - four each of  the numbers 7-10, 
% - two each of 11-17, 
%  -one each of 18-25. 
%
rand_deck(Size) = Rand  =>
  Deck = ([rep(N,3) : N in 1..6] ++ 
          [rep(N,4) : N in 7..10] ++
          [rep(N,2) : N in 11..17] ++
          [rep(N,1) : N in 18..25]).flatten(),
  DeckLen = Deck.length,
  Ixes = new_map(),
  while(Ixes.keys().length < Size)
     Ixes.put(1+random2() mod DeckLen,1)
  end,
  Rand = [Deck[Ix] : (Ix=_) in Ixes].


% Repeat Num Rep times         
rep(Num, Rep) = [Num : _I in 1..Rep].

write_krypto(CardsP,X,Ops) =>
    println(cardsP=CardsP),
    println('x     '=X),
    println('ops   '=[ops(Op) : Op in Ops ]),

    foreach(I in 2..length(CardsP))
       printf("%2d %w %2d = %2d\n", X[I-1],ops(Ops[I-1]),CardsP[I],X[I])
    end, 
    nl.

/*

  Labeled dice and Building blocks problems in Picat.

  Labeled dice
  --------------
  From Jim Orlin "Colored letters, labeled dice: a logic puzzle"
  http://jimorlin.wordpress.com/2009/02/17/colored-letters-labeled-dice-a-logic-puzzle/
  """
  My daughter Jenn bough a puzzle book, and showed me a cute puzzle.  There 
  are 13 words as follows:  BUOY, CAVE, CELT, FLUB, FORK, HEMP, JUDY, 
  JUNK, LIMN, QUIP, SWAG, VISA, WISH.

  There are 24 different letters that appear in the 13 words.  The question 
  is:  can one assign the 24 letters to 4 different cubes so that the 
  four letters of each word appears on different cubes.  (There is one 
  letter from each word on each cube.)  It might be fun for you to try 
  it.  I'll give a small hint at the end of this post. The puzzle was 
  created by Humphrey Dudley.
  """

  Building blocks
  ---------------
  From http://brownbuffalo.sourceforge.net/BuildingBlocksClues.html
  """
  Each of four alphabet blocks has a single letter of the alphabet on each 
  of its six sides. In all, the four blocks contain every letter but 
  Q and Z. By arranging the blocks in various ways, you can spell all of 
  the words listed below. Can you figure out how the letters are arranged 
  on the four blocks?

  BAKE ONYX ECHO OVAL
  GIRD SMUG JUMP TORN
  LUCK VINY LUSH WRAP
  """

  Note: This is a somewhat generalized model for solving both 
        Building blocks and Labeled Dice problems. 


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   go(labeling_dice),
   go(building_blocks).


go(Problem) =>
   L = findall(Res,solveit(Problem, Res)),
   writef("It was %d solutions.\n", length(L)).


solveit(Problem,Res) =>

   writef("\nProblem %w\n", Problem),
   problem(Problem, NumCubes, NumSides, Letters, Words),


   % Convert the letters to integers so we can use ic

   % create the integer array
   LettersInt = [I : I in 1..Letters.length],
   NumWords = length(Words),
   WordsIC = new_list(NumWords),
   convert_words(Words,WordsIC,Letters,LettersInt),
  
   CubeLen = NumCubes * NumSides,
   Cube = new_list(CubeLen),
   Cube :: 1..NumCubes,

   % each letters in a word must be on a different die
   foreach(I in 1..NumWords)
      writeln(i=I),
      % element(I,WordsIC,Word),
      Word = WordsIC[I],
      ThisDie = [D : W in Word, element(W,Cube,D)],
      all_different(ThisDie)
   end,

   % there must be exactly NumSides (6) letters of each die
   foreach(I in 1..NumCubes)
      sum([(R #= I) : J in 1..CubeLen, element(J,Cube,R)]) #= NumSides
   end,

   % simple symmetry breaking: place first letter on cube 1
   Cube[1] #= 1,

   % search
   solve(Cube),

   writeln(cube=Cube),

   % print this solution

   % Letters placed
   Res = [[L,D]  : I in 1..CubeLen, double_index(Cube,Letters, I,D,L)],
   writef("Letters placed: %w\n", Res),

   writef("\nWords:\n"),
   foreach(Word in Words)
      foreach(W in Word)
          double_index(Cube,Letters,_Ix, C,W),
          writef("%w: %w ",W,C)
      end,
      nl
   end,

   % print the cubes
   writef("\nCubes:\n"),
   foreach(C in 1..NumCubes)
       writef("Cube %w: ",C),
       ThisCube = [],
       foreach(J in 1..CubeLen)
          % is this letter on the C'th cube?
          double_index(Cube,Letters, J, Val,L),
          if Val == C then
             ThisCube := ThisCube ++[L]
          end
       end,
       writeln(ThisCube)
   end,
   nl, nl.


%
% Lookup a value given an index and/or some value Val1 or Val2
%
double_index(List1,List2,Ix,Val1,Val2) =>
   % element(Ix, List1, Val1),
   nth(Ix, List1, Val1),
   % element(Ix, List2, Val2).
   nth(Ix, List2, Val2).
   
   

    
% convert the matrix of letters (Words) to
% a matrix of integers.
convert_words(Words,WordsIC,Letters,LettersInt) =>
   WordsIC2 = [],
   foreach(Word in Words)
      ThisWord = [WI : W in Word, double_index(Letters, LettersInt,_Ix,W,WI)],
      WordsIC2 := WordsIC2 ++ [ThisWord]
   end,
   WordsIC = WordsIC2.


%
% Labeling Dice
% 
problem(labeling_dice, N, S, Letters, Words) => 
   % number of cubes
   N = 4,  
   % number of sides of of a cube
   S = 6,  
   % the letters to use
   Letters = [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,y], 
   % the words to place
   Words = [[b,u,o,y],               
            [c,a,v,e], 
            [c,e,l,t], 
            [f,l,u,b], 
            [f,o,r,k], 
            [h,e,m,p], 
            [j,u,d,y], 
            [j,u,n,k], 
            [l,i,m,n], 
            [q,u,i,p], 
            [s,w,a,g], 
            [v,i,s,a], 
            [w,i,s,h]].


%
% Building Blocks
%   From http://brownbuffalo.sourceforge.net/BuildingBlocksClues.html
%   """
%   Each of four alphabet blocks has a single letter of the alphabet on each 
%   of its six sides. In all, the four blocks contain every letter but 
%   Q and Z. By arranging the blocks in various ways, you can spell all of 
%   the words listed below. Can you figure out how the letters are arranged 
%   on the four blocks?
%
%   BAKE ONYX ECHO OVAL
%   GIRD SMUG JUMP TORN 
%   LUCK VINY LUSH WRAP
%   """
problem(building_blocks, N, S, Letters, Words) =>
   N = 4,
   S = 6,
   Letters = [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,r,s,t,u,v,w,x,y],
   Words = [[b,a,k,e],
            [o,n,y,x],
            [e,c,h,o],
            [o,v,a,l],
            [g,i,r,d],
            [s,m,u,g],
            [j,u,m,p],
            [t,o,r,n],
            [l,u,c,k],
            [v,i,n,y],
            [l,u,s,h],
            [w,r,a,p]].
/* 

  Lace problem in Picat.

  From 
  http://www.sci.brooklyn.cuny.edu/~zhou/prolog_contest/pc2012.txt
  """
  Solutions in B-Prolog for the 2012 Prolog Programming Contest 
  Team members: Christian Theil Have, Nuno Lopes, and Neng-Fa Zhou 
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


%% 1. lace.pl
% Example query ?-lace(5).


go2 =>
  foreach(N in 1..11)
    writeln(n=N),
    lace(N),
    nl
  end,
  nl.

lace(N) =>
    grid_size(N,S),
    Grid = new_array(S,S),
    R0 = S//2+1, 
    C0 = R0,
    foreach(I in 1..N) draw(I,Grid,R0,C0) end,
    foreach(R in 1..S)
       foreach(C in 1..S)
	   var(Grid[C,R]) -> printf(" ") ; printf("*")
       end,
       nl
    end.
    
draw(I,Grid,R0,C0), I mod 2 == 0 =>
    grid_size(I,S), 
    foreach(Offset in 0..S//2) (Grid[R0-Offset,C0-S//2+Offset] = '*',
				Grid[R0-Offset,C0+S//2-Offset] = '*',
				Grid[R0+Offset,C0-S//2+Offset] = '*',
				Grid[R0+Offset,C0+S//2-Offset] = '*') end.
draw(I,Grid,R0,C0) =>
    grid_size(I,S), 
    foreach(C in C0-S//2..C0+S//2) (Grid[R0-S//2,C] = '*',
				    Grid[R0+S//2,C] = '*') end,
    foreach(R in R0-S//2..R0+S//2) (Grid[R,C0-S//2] = '*',
				    Grid[R,C0+S//2] = '*') end.
	
table (+,-)
grid_size(1,S) => S = 3.
grid_size(N,S) ?=>
    0 == N mod 2,% !,
    N1 = N-1,
    grid_size(N1,S1),
    S = S1 + S1 // 2 * 2.
grid_size(N,S) ?=>
    N1 = N - 1,
    grid_size(N1,S).

/*

  Langford's number problem L(2,N) in Picat.

  Langford's number problem (CSP lib problem 24)
  http://www.csplib.org/prob/prob024/
  """
  Arrange 2 sets of positive integers 1..k to a sequence,
  such that, following the first occurence of an integer i, 
  each subsequent occurrence of i, appears i+1 indices later
  than the last. 
  For example, for k=4, a solution would be 41312432
  """
  
  * John E. Miller: Langford's Problem
    http://www.lclark.edu/~miller/langford.html
  
  * Encyclopedia of Integer Sequences for the number of solutions for each k
    http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=014552


  Note: For k=4 there are two different solutions:
     solution:[4,1,3,1,2,4,3,2]
     position:[2,5,3,1,4,8,7,6]
  and
     solution:[2,3,4,2,1,3,1,4]
     position:[5,1,2,3,7,4,6,8]

  Which this symmetry breaking

     Solution[1] #< Solution[K2],

  then just the second solution is shown.

  Note: There are only solutions when K mod 4 == 0 or K mod 4 == 3.

  - For a generalized version L(k,n) where k >= 2, see http://hakank.org/langford_generalized.pi
  - For Nickerson's variant, see http://hakank.org/langford_nickerson.pi

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
    K = 4,
    printf("K: %d\n", K),
    time2($langford(K, Solution, Position)),
    printf("Solution: %w\n", Solution),
    printf("Position: %w\n", Position).

%
% Get the first (if any) solutions for K in 2..40
%
go2 => 
  foreach(K in 2..60) 
     printf("K: %d\n", K),
     if time2(langford(K, Solution, Position)) then
         if nonvar(Solution) then 
           printf("Solution: %w\n", Solution)
           % printf("Position: %w\n", Position)
         else 
           printf("No solution\n")
         end,
        printf("\n"),
        flush(stdout)
     end
  end.

% Count the number of solutions
go3 => 
  Map = get_global_map(),
  foreach(K in 2..40) 
    println(k=K),
    Map.put(count,0),
    ((langford(K, Solution, Position), Map.put(count, Map.get(count)+1), fail) ; true),
    printf("K: %d = %d solutions\n", K, Map.get(count)),
    flush(stdout)
  end.


 
langford(K, Solution, Position) =>

  if not ((K mod 4 == 0; K mod 4 == 3)) then
     println("There is no solution for K unless K mod 4 == 0 or K mod 4 == 3"),
     fail
  end,

  K2 = 2*K,
  Position = new_list(K2),
  Position :: 1..K2,

  Solution = new_list(K2),
  Solution :: 1..K,

  % all_different(Position),
  all_distinct(Position),

  % symmetry breaking:
  Solution[1] #< Solution[K2],

  foreach(I in 1..K)
      Position[K+I] #= Position[I] + I+1,
      element(Position[I],Solution,I),  
      element(Position[K+I],Solution,I)
  end,

  Vars = Solution ++ Position,
  solve([ffc,updown], Vars).
/*

  Latin squares in Picat.

  http://en.wikipedia.org/wiki/Latin_square:
  """
  A Latin square is an n X n table filled with n different symbols in
  such a way that each symbol occurs exactly once in each row and
  exactly once in each column. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   N = 40,
   latin_square(N, X),
   solve([ff],X),
   pretty_print(X),
   nl.

go2 =>
   N = 100,
   latin_square(N, X),
   writeln(solve),
   solve([ff],X),
   pretty_print(X),
   nl.


latin_square(N, X) =>
   X = new_array(N,N),
   X :: 1..N,
   foreach(Row in X) all_distinct(Row) end,
   foreach(Column in X.columns()) all_distinct(Column) end.

   % symmetry breaking: value in row R must not be R
   % foreach(R in 1..N) X[R,R] #\= R end.


pretty_print(X) =>
   foreach(Row in X) writeln(Row) end.



/* 

  Longest common subsequence in Picat.
 
  Ported from the B-Prolog program
  http://www.probp.com/examples/tabling/lcs.pl
  """
  Taken from "Simplifying Dynamic Programming via Mode-directed Tabling"
  Software Practice and Experience, 38(1): 75-94, 2008, by Hai-Feng Guo, Gopal Gupta
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
   statistics(_, _),
   lcs([50, 10, 400, 30, 30, 20, 10, 5, 30, 20,
       6, 20, 20, 30, 9, 30, 20, 500, 20, 40,
      30, 8, 3, 5, 9, 200, 10, 400, 20, 30,
      50, 10, 400, 30, 30, 20, 10, 5, 30, 20,
       7, 3, 60, 38, 20, 39, 83, 92, 30, 19,
       6, 20, 20, 30, 9, 30, 20, 20, 30, 9, 
       30, 20, 500, 20, 40, 4, 92, 30, 92, 20,
       6, 20, 20, 30, 9, 30, 20, 500, 20, 40,
      30, 8, 3, 5, 9, 200, 10, 400, 20, 30,
       30, 20, 500, 20, 40, 4, 92, 30, 92, 20,
      50, 10, 400, 30, 30, 20, 10, 5, 30, 20,
       6, 20, 20, 30, 9, 30, 20, 500, 20, 40,
      30, 8, 3, 5, 9, 200, 10, 400, 20, 30], 
     [ 7, 20, 25, 30, 9, 35, 20, 500, 20, 40,
      30, 8, 3, 5, 9, 200, 10, 400, 20, 30,
      50, 10, 405, 30, 35, 20, 10, 5, 30, 20,
      30, 8, 3, 5, 9, 200, 10, 400, 20, 30,
      50, 10, 405, 30, 35, 20, 10, 5, 30, 20,
      30, 8, 3, 5, 9, 200, 10, 400, 20, 30,
      30, 8, 3, 5, 9, 200, 10, 400, 20, 30,
      50, 10, 403, 30, 30, 20, 10, 5, 30, 20,
       6, 20, 20, 30, 9, 37, 20, 500, 20, 40,
     50, 10, 400, 30, 30, 20, 10, 5, 30, 20,
       6, 20, 20, 30, 9, 39, 20, 500, 20, 40,
       6, 20, 20, 30, 19, 30, 20, 500, 20, 40,
      30, 8, 3, 5, 9, 210, 10, 400, 22, 30
     ],  V),
   statistics(_, [_, B]),
   print('The length of the longest common subsequence is '), print(V), nl,
   print('execution time = '), print(B), print(' ms'), nl.


table (+,+,max)
lcs(L1, L2, N) ?=> N=0,emptyOr(L1, L2).
lcs(FL1, FL2, N) ?=>
   FL1 = [F|L1],
   FL2 = [F|L2],
   lcs(L1, L2, N1),
   N = N1 + 1.
lcs(F1L1, F2L2, N) ?=>
   F1L1 = [F1|L1],
   F2L2 = [F2|L2],
   F1 != F2,
   lcs(L1, [F2|L2], N).
lcs(F1L1, F2L2, N) =>
   F1L1 = [F1|L1],
   F2L2 = [F2|L2],
   F1 =\= F2,
   lcs([F1|L1], L2, N).

emptyOr([], _) ?=> true.
emptyOr(_, []) => true.

/*

  Least diff problem in Picat.

  The model solves the following problem:
  
  What is the smallest difference between two numbers X - Y
  if you must use all the digits (0..9) exactly once, i.e.
  Minimize the difference 
    ABCDE - FGHIJ

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

scalar_product(A, X) = Product => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).

make_base(N, Base) = List =>
   List = [T : I in 1..N, T = Base**(N-I)].

least_diff(L,Diff) =>
  L = [A,B,C,D,E,  F,G,H,I,J],
  L :: 0..9,

  all_different(L),

  X #= 10000*A + 1000*B + 100*C + 10*D + E,
  Y #= 10000*F + 1000*G + 100*H + 10*I + J,

  Diff #= X - Y,
  Diff #> 0,
  solve([$min(Diff)], L).


% Alternative version using scalar_product
least_diff2(L,Diff) =>
  L = [A,B,C,D,E,  F,G,H,I,J],
  L :: 0..9,
  all_different(L),
  M = L.length // 2,

  % Base = make_base(M, 10),
  Base = [T : I2 in 1..M, T = 10**(M-I2)],
  X = scalar_product(Base, [A,B,C,D,E]),
  Y = scalar_product(Base, [F,G,H,I,J]),

  Diff #= X - Y,
  Diff #> 0,
  solve([$min(Diff)], L).

 
go =>
   least_diff(L, Diff),
   writeln(L),
   writeln(Diff),
   least_diff2(L2, Diff2),
   writeln(L2),
   writeln(Diff2).
/*

  Lecture series puzzle (Dell Logic Puzzles) in Picat.

  From http://brownbuffalo.sourceforge.net/LectureSeriesClues.html
  """
  Title: Lecture Series
  Author: Alex Knight
  Publication: Dell Logic Puzzles
  Issue: April, 1998
  Page: 10
  Stars: 2

  Last week at school was made varied by a series of lectures, one
  each day 
   (Monday through Friday), 
  in the auditorium. None of the lectures was particularly 
  interesting 
     (on choosing a college, physical hygiene, modern art, nutrition, 
     and study habits), 
   but the students figured that anything that got them out of fourth 
   period was okay. The lecturers were 
       two women named Alice and Bernadette, and three men 
       named Charles, Duane, and Eddie; 
   last names were 
       Felicidad, Garber, Haller, Itakura, and Jeffreys. 
   Can you find each day's lecturer and subject?

  1. Alice lectured on Monday.
  2. Charles's lecture on physical hygiene wasn't given on Friday.
  3. Dietician Jeffreys gave the lecture on nutrition.
  4. A man gave the lecture on modern art.
  5. Ms. Itakura and the lecturer on proper study habits spoke on 
     consecutive days, in one order or the other.
  6. Haller gave a lecture sometime after Eddie did.
  7. Duane Felicidad gave his lecture sometime before the modern art lecture. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   N = 5,

   Monday = 1,
   Tuesday = 2,
   Wednesday = 3,
   Thursday = 4,
   Friday = 5,
   Days = [Monday,Tuesday,Wednesday,Thursday,Friday],
   DaysS = ["Monday","Tuesday","Wednesday","Thursday","Friday"],

   Lectures = [_ChoosingCollege, PhysicalHygiene, ModernArt, Nutrition, 
          StudyHabits],
   LecturesS = ["Choosing College", "Physical Hygiene", "Modern Art", "Nutrition", 
          "Study Habits"],

   Lectures :: 1..N,

   FirstName = [Alice, Bernadette, Charles, Duane, Eddie],
   FirstNameS = ["Alice", "Bernadette", "Charles", "Duane", "Eddie"],
   FirstName :: 1..N,

   LastName  = [Felicidad, _Garber, Haller, Itakura, Jeffreys],
   LastNameS = ["Felicidad", "Garber", "Haller", "Itakura", "Jeffreys"],
   LastName :: 1..N,

   all_different(Lectures),
   all_different(FirstName),
   all_different(LastName),


   % 1. Alice lectured on Monday.
   Alice #= Monday,

   % 2. Charles"s lecture on physical hygiene wasn"t given on
   % Friday.
   Charles #= PhysicalHygiene,
   Charles #!= Friday,
   PhysicalHygiene #!= Friday,

   % 3. Dietician Jeffreys gave the lecture on nutrition.
   Jeffreys #= Nutrition,

   % 4. A man gave the lecture on modern art.
   (
       ModernArt #= Charles 
   #\/ 
       ModernArt #= Duane   
   #\/
       ModernArt #= Eddie
   ),

   % 5. Ms. Itakura and the lecturer on proper study habits spoke on 
   %    consecutive days, in one order or the other.
   (
       Itakura #= Alice 
   #\/ 
       Itakura #= Bernadette
   ),
   (
     abs(Itakura - StudyHabits) #= 1
   ),
   
   % 6. Haller gave a lecture sometime after Eddie did.
   Haller #> Eddie,

   % 7. Duane Felicidad gave his lecture sometime before the
   %    modern art lecture. 
   Duane #= Felicidad,
   Duane #< ModernArt,
   Felicidad #< ModernArt,

   % search
   Vars = Lectures ++ FirstName ++ LastName,
   solve([], Vars),

   % print solution
   print_all(Days,DaysS),
   print_all(FirstName,FirstNameS),
   print_all(LastName,LastNameS),
   print_all(Lectures,LecturesS),
   nl.


print_all(X,S) =>
   foreach(I in 1..X.length)
      % element(IX,X,I),
      IX = find_first_of(X,I),
      % element(IX,S,This),
      This = S[IX],
      printf("%-18s ", This)
   end,
   nl.
/*

  Lectures problem in Picat.

  Biggs: Discrete Mathematics (2nd ed), page 187.
  """   
  Suppose we wish to schedule six one-hour lectures, v1, v2, v3, v4, v5, v6.
  Among the the potential audience there are people who wish to hear both
 
   - v1 and v2
   - v1 and v4
   - v3 and v5
   - v2 and v6
   - v4 and v5
   - v5 and v6
   - v1 and v6
 
  How many hours are necessary in order that the lectures can be given
  without clashes?
  """    

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   N = 6,   % number of lectures (nodes)
   g(Graph),

   MaxC :: 1..N,
   V = new_list(N),
   V :: 1..N,

   MaxC #= max(V),
   foreach([L1,L2] in Graph) V[L1] #!= V[L2] end,

   % symmetry breaking: 
   % v1 has the color 1, v2 has either color 1 or 2
   % (this should be enough for a general model)
   V[1] #= 1,
   V[2] #=< 2,

   solve([$min(MaxC)], V),
   
   writeln(v=V),
   writeln(max_c=MaxC),nl.



% The schedule requirements:
%   lecture a cannot be held at the same time as b
g(Graph) => 
 Graph = [[1, 2],
     [1, 4],
     [3, 5],
     [2, 6],
     [4, 5],
     [5, 6],
     [1, 6]].
/* 

  Global constraints lex_less, lex_lesseq, lex2, etc in Picat.

  Theese is some decomposition of the lex family constraints.

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 

   N = 4,
   X = new_list(N),
   X :: 1..N,
   Y = new_list(N),
   Y :: 1..N,

   Y = [3,2,1,4],
   
   all_different(X),
   all_different(Y),

   % lex_less(X,Y,5), % Base = 5
   lex_less(X,Y),

   % lex_lesseq(X,Y),
   % lex_greater(X,Y),
   % lex_greatereq(X,Y),

   Vars = X ++ Y,
   solve(Vars),

   writeln(x=X),
   writeln(y=Y),
   nl.


% Testing lex2
go2 =>
  N = 4,
  X = new_array(N,N),
  X :: 1..N,

  foreach(I in 1..N) all_different([X[I,J] : J in 1..N]) end,
  lex2(X),
  solve($[ff], X),
  foreach(Row in X) writeln(Row.to_list())  end,
  nl.


% Port of MiniZinc's lex2.mzn 
% """
%-----------------------------------------------------------------------------%
% Require adjacent rows and adjacent columns in the array 'x' to be
% lexicographically ordered.  Adjacent rows and adjacent columns may be equal.
%-----------------------------------------------------------------------------%
% """
% Note: This use lex_less/1.
lex2(X) =>
   Len = X[1].length,
   foreach(I in 2..X.length) 
      lex_less([X[I-1,J] : J in 1..Len], [X[I,J] : J in 1..Len])
   end.

% This use lex_lesseq/1
lex2eq(X) =>
   Len = X[1].length,
   foreach(I in 2..X.length) 
      lex_lesseq([X[I-1,J] : J in 1..Len], [X[I,J] : J in 1..Len])
   end.


% Port of MiniZinc's lex_less_int.mzn
% """
%-----------------------------------------------------------------------------%
% Requires that the array 'x' is strictly lexicographically less than array 'y'.
% Compares them from first to last element, regardless of indices
%-----------------------------------------------------------------------------%
% """
lex_less(X,Y) =>
   LX = 1,
   UX = X.length,
   LY = 1,
   UY = Y.length,
   Size = max(UX-LX,UY-LY),
   B = new_list(Size+2), % (Note: The MiniZinc version is 0-based.)
   B :: 0..1,
   B[1] #= 1,
   foreach(I in 1..Size+1) 
      B[I] #= ( X[I] #<= Y[I] #/\ (X[I] #< Y[I] #\/ B[I+1] #= 1) )
   end,
   B[Size + 2] #= (Size - 1 #< Size - 1).


% Port of MiniZinc's lex_lesseq_in.mzn
% """
%-----------------------------------------------------------------------------%
% Requires that the array 'x' is lexicographically less than or equal to
% array 'y'.  Compares them from first to last element, regardless of indices
%-----------------------------------------------------------------------------%
% """
lex_lesseq(X,Y) =>
   LX = 1,
   UX = X.length,
   LY = 1,
   UY = Y.length,
   Size = max(UX-LX,UY-LY),
   B = new_list(Size+2), % (Note: The MiniZinc version is 0-based.)
   B :: 0..1,
   B[1] #= 1,
   foreach(I in 1..Size+1) 
      B[I] #= ( X[I] #<= Y[I] #/\ (
                ((I #= Size) #=> 1)
                #/\ 
                ((I #< Size) #=> X[I] #< Y[I] #\/ B[I+1] #= 1) 
                )
              )
   end.


lex_greater(X,Y) => lex_less(Y,X).
lex_greatereq(X,Y) => lex_lesseq(Y,X).



%
% Alternative approach where we convert to two
% numbers and ensure that the first number is < second number.
%
lex_less2(X,Y,Base) =>
  to_num(X,Base,NumX),
  to_num(Y,Base,NumY),
  NumX #<= NumY.

to_num(List, Base, Num) =>
        Len = length(List),
        Num #= sum([List[I]*Base**(Len-I) : I in 1..Len]).
/*

  Lichtenstein coloring problem  in Picat.

  From 
  http://bit-player.org/2008/the-chromatic-number-of-liechtenstein
  and
  """
  It seems that Liechtenstein is divided into 11 communes, which 
  emphatically do not satisfy the connectivity requirement of the four 
  color map theorem. Just four of the communes consist of a single 
  connected area (Ruggell, Schellenberg and Mauren in the north, and 
  Triesen in the south). 
  ...
  In the map above, each commune is assigned its own color, and so we 
  have an 11-coloring. Its easy to see we could make do with fewer 
  colors, but how many fewer? I have found a five-clique within the map; 
  that is, there are five communes that all share a segment of border 
  with one another. It follows that a four-coloring is impossible. Is 
  there a five-coloring? What is the chromatic number of Liechtenstein?
  """

  One solution:
  n_colors       : 5
  color_used     : [1,1,1,1,1,0,0,0,0,0,0]
  color          : [1,1,1,1,1,1,4,4,2,2,2,2,2,1,3,3,3,3,3,3,2,4,4,5,5,5,5,5,5]
  color_communes : [1,1,4,2,2,1,3,3,2,4,5]
 
  Also see
  http://blog.mikael.johanssons.org/archive/2008/10/on-the-chromatic-number-of-lichtenstein/


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   %
   % communes
   %
   BalzersC = 1,
   EschenC = 2,
   GamprinC = 3,
   MaurenC = 4,
   PlankenC = 5,
   RuggellC = 6,
   SchaanC = 7,
   SchellenbergC = 8,
   TriesenC = 9,
   TriesenbergC = 10,
   VaduzC = 11,
   
   %
   % enclaves/exclaves
   %
   Balzers1 = 1,
   Balzers2 = 2,
   Balzers3 = 3,
   Eschen1 = 4,
   Eschen2 = 5,
   Eschen3 = 6,
   Gamprin1 = 7,
   Gamprin2 = 8,
   Mauren = 9,
   Planken1 = 10,
   Planken2 = 11,
   Planken3 = 12,
   Planken4 = 13,
   Ruggell = 14,
   Schaan1 = 15,
   Schaan2 = 16,
   Schaan3 = 17,
   Schaan4 = 18,
   Schaan5 = 19,
   Schellenberg = 20,
   Triesen = 21,
   Triesenberg1 = 22,
   Triesenberg2 = 23,
   Vaduz1 = 24,
   Vaduz2 = 25,
   Vaduz3 = 26,
   Vaduz4 = 27,
   Vaduz5 = 28,
   Vaduz6 = 29,
   
   
   NumCommunes = 11,
   NumColors = 11, % num_communes, % 6
   NumEnclaves = 29,
   
   %
   % the enclaves and corresponding commune
   %
   CC = 
   [
       BalzersC, BalzersC, BalzersC, 
       EschenC, EschenC, EschenC, 
       GamprinC, GamprinC, 
       MaurenC, 
       PlankenC, PlankenC, PlankenC, PlankenC, 
       RuggellC, 
       SchaanC, SchaanC, SchaanC, SchaanC, SchaanC, 
       SchellenbergC, 
       TriesenC, 
       TriesenbergC, TriesenbergC,
       VaduzC, VaduzC, VaduzC, VaduzC, VaduzC, VaduzC
   ],
   

   % This map of Lichtenstein is from
   % http://blog.mikael.johanssons.org/archive/2008/10/on-the-chromatic-number-of-lichtenstein/
   Lichtenstein = [
            [Ruggell, Schellenberg],
            [Ruggell, Gamprin1],
            [Schellenberg, Mauren],
            [Schellenberg, Eschen1],
            [Mauren, Eschen1],
            [Gamprin1, Eschen2],
            [Gamprin1, Vaduz2],
            [Gamprin1, Schaan1],
            [Gamprin1, Planken3],
            [Gamprin1, Eschen1],
            [Eschen1, Gamprin2],
            [Eschen1, Planken1],
            [Eschen2, Schaan1],
            [Vaduz3, Schaan1],
            [Vaduz2, Schaan1],
            [Planken3, Schaan1],
            [Planken2, Schaan1],
            [Schaan1, Planken1],
            [Schaan1, Planken4],
            [Schaan1, Vaduz1],
            [Gamprin2, Eschen3],
            [Eschen3, Vaduz4],
            [Eschen3, Schaan2],
            [Vaduz4, Schaan2],
            [Vaduz4, Planken1],
            [Schaan2, Planken1],
            [Planken1, Schaan3],
            [Vaduz1, Triesenberg1],
            [Vaduz1, Triesen],
            [Planken4, Triesenberg1],
            [Planken4, Balzers2],
            [Balzers2, Vaduz5],
            [Balzers2, Schaan4],
            [Vaduz5, Schaan4],
            [Schaan4, Triesenberg1],
            [Schaan4, Vaduz6],
            [Schaan4, Triesenberg2],
            [Triesenberg1, Vaduz6],
            [Triesenberg1, Triesen],
            [Triesenberg1, Balzers3],
            [Triesen, Balzers3],
            [Triesen, Balzers1],
            [Triesen, Schaan5],
            [Vaduz6, Schaan5],
            [Triesenberg2, Schaan5]
             ],

      
   % colors for the en-/exclaves
   Color = new_list(NumEnclaves),
   Color :: 1..NumCommunes,

   % colors for the communes
   ColorCommunes = new_list(NumCommunes),
   ColorCommunes :: 1..NumColors,

   % what colors are used (for minimizing number of colors)
   ColorUsed= new_list(NumColors),
   ColorUsed :: 0..1,

   % all neighbours must have different colors
   foreach([N1,N2] in Lichtenstein) Color[N1] #!= Color[N2] end,
      
   % first commune (Balzers) has color 1
   ColorCommunes[1] #= 1,

   % exclaves of the same commune must have the same color
   foreach(I in 1..NumEnclaves, J in 1..NumEnclaves)
       if I != J then
         (CC[I] #= CC[J]) #=> (Color[I] #= Color[J])
       end 
   end,
     
   % connection between commune and en-/exclaves
   foreach(C in 1..NumCommunes)
       E :: 1..NumEnclaves,
       CCC = ColorCommunes[C],
       element(E,Color,CCC),
       element(E,CC,C)
   end,


   % Color used
   foreach({CU,IC} in zip(ColorUsed,1..NumCommunes))
      CU #= 1 #<=> sum([(IC #= C) : C in Color]) #> 0
   end,
   % number of colors used (to minimize)
   NColors #= sum(ColorUsed),

   % symmetry breaking, i.e. pick the used colors from the left
   decreasing(ColorUsed),


   % search
   Vars = Color ++ ColorCommunes ++ ColorUsed,
   solve([$min(NColors), ff],Vars),


   % output
   printf("N colors      : %w\n", NColors),
   printf("Colors Used   : %w\n", ColorUsed),
   printf("Color         : %w\n",Color),
   printf("Color communes: %w\n", ColorCommunes),
   nl.


decreasing(List) =>
   foreach(I in 2..List.length) List[I-1] #>= List[I] end.
/*

  Local art theft in Picat.

  From Stack Overflow:
  "Local theft art in prolog program"
  http://stackoverflow.com/questions/16862293/local-theft-art-in-prolog-program
  """
  I have to write program in prolog to solve this logic problem:

  After a local art theft, six suspects were being interviewed. Below is a summary 
  of their statements. Police know that exactly four of them told one lie each and all 
  of the other statements are true. From this information can you tell who committed 
  the crime?

  Alan said:
  It wasn't Brian It wasn't Dave It wasn't Eddie

  Brian said:
  It wasn't Alan It wasn't Charlie It wasn't Eddie

  Charlie said:
  It wasn't Brian It wasn't Freddie It wasn't Eddie

  Dave said:
  It wasn't Alan It wasn't Freddie It wasn't Charlie

  Eddie said:
  It wasn't Charlie It wasn't Dave It wasn't Freddie

  Freddie said:
  It wasn't Charlie It wasn't Dave It wasn't Alan
  ...
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   % The no blame table
   NoBlame = [   
      % A B C D E F 
       [0,1,0,1,1,0], % Alan said ..
       [1,0,1,0,1,0], % Brian
       [0,1,0,0,1,1], % Charlie
       [1,0,1,0,0,1], % Dave
       [0,0,1,1,0,1], % Eddie
       [1,0,1,1,0,0]  % Freddie
      ],

   N = NoBlame.length,

   Names = ["Alan", "Brian", "Charlie", "Dave", "Eddie", "Freddie"],

   B = new_list(N),
   B :: 0..1,

   Counts = new_list(N),
   Counts :: 2..3,

   foreach(I in 1..N) 
     L = [B[J] : J in 1..N, NoBlame[I,J] == 1],
     C #= sum([(J #= 0) : J in L]),
     Counts[I] #= C,
     (B[I] #= 1) #=> C #= L.length
   end,

   count(2, Counts, #=, 4),

   solve(Counts ++ B),

   writeln(counts=Counts),
   writeln(b=B),
   foreach({BB, Name} in zip(B,Names))
     if BB == 1 then
       printf("The thief is %s.\n", Name)
     end
   end,
   printf("The thief: %w.\n", [Name : {BB, Name} in zip(B,Names), BB == 1]),
   nl.
/*

   Longest common subsequence in Picat.

  From http://rosettacode.org/wiki/Longest_common_subsequence
  """
  The longest common subsequence (or LCS) of groups A and B is the 
  longest group of elements from A and B that are common between the 
  two groups and in the same order in each group. For example, the 
  sequences "1234" and "1224533324" have an LCS of "1234":

  1234
  1224533324

  For a string example, consider the sequences "thisisatest" and 
  "testing123testing". An LCS would be "tsitest":

  thisisatest
  testing123testing

  In this puzzle, your code only needs to deal with strings. Write a 
  function which returns an LCS of two strings (case-sensitive). 
  You don't need to show multiple LCS's. 
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
   println("lcs():"),
   time(println(lcs("thisisatest","testing123testing"))),
   time(println(lcs("XMJYAUZ", "MZJAWXU"))),
   time(println(lcs("1234", "1224533324"))),

   println("lcs2():"),
   time(println(lcs2("thisisatest","testing123testing"))),
   time(println(lcs2("XMJYAUZ", "MZJAWXU"))),
   time(println(lcs2("1234", "1224533324"))),

   println("lcs3():"),
   time(println(lcs3("thisisatest","testing123testing"))),
   time(println(lcs3("XMJYAUZ", "MZJAWXU"))),
   time(println(lcs3("1234", "1224533324"))),

   println("lcs4():"),
   time(println(lcs4("thisisatest","testing123testing"))),
   time(println(lcs4("XMJYAUZ", "MZJAWXU"))),
   time(println(lcs4("1234", "1224533324"))),


   nl.


lcs(X,Y) = V => 
  [C, _Len] = lcs_length(X,Y),
  V = backTrace(C,X,Y,X.length+1,Y.length+1).


% From 
% http:%en.wikipedia.org/wiki/Longest_common_subsequence
% with added trickery for a 1-based language.
%
lcs_length(X, Y) = V=>
  M = X.length, 
  N = Y.length,
  C = [[0 : J in 1..N+1]  : I in 1..N+1],
  foreach(I in 2..M+1,J in 2..N+1)
     if X[I-1] == Y[J-1] then
        C[I,J] := C[I-1,J-1] + 1
     else
        C[I,J] := max([C[I,J-1], C[I-1,J]])
     end
  end,
  V = [C, C[M+1,N+1]].

% table
backTrace(C, X, Y, I, J) = V =>
  if I == 1; J == 1 then
    V := ""
  elseif X[I-1] == Y[J-1] then
    V := backTrace(C, X, Y, I-1, J-1) ++ [X[I-1]]
  else 
    if C[I,J-1] > C[I-1,J] then
      V := backTrace(C, X, Y, I, J-1)
    else 
      V := backTrace(C, X, Y, I-1, J)
    end
  end.


% From the ADA solution
% Using table speed it up considerably.
table
lcs2(A,B) = V =>
  ALen = A.length,
  BLen = B.length,
  A1 = [A[I] : I in 1..ALen-1],
  B1 = [B[I] : I in 1..BLen-1],
  if A == ""; B == "" then 
     V := ""
  elseif A[ALen] == B[BLen] then
     V := lcs2(A1, B1) ++ [A[ALen]]
  else 
     X = lcs2(A, B1),
     Y = lcs2(A1, B),
     if X.length > Y.length then
        V := X
     else 
        V := Y
     end
  end.


%
% Inspired by the SETL version
% http:%rosettacode.org/wiki/Longest_common_subsequence#SETL 
%
longest(A, B) = V =>
    V := cond(A.length > B.length, A, B).

% without table lcs3/2 is faster than lcs2/2 without table, 
% but slower than lcs/2. 
table
lcs3(A, B) = V =>
  if A == ""; B == "" then
    V := ""
  elseif A[1] == B[1] then
    V := [A[1]] ++ lcs3(butfirst(A), butfirst(B))
  else 
    V := longest(lcs3(butfirst(A), B), lcs3(A, butfirst(B)))
  end.

% but first
butfirst(A) = [A[I] : I in 2..A.length].


% Rule based version of lcs3/2 (as a proof-of-concept).
% Note: using table don't work for some reason 
%       (and is therefore slower than lcs3/2)
table
lcs4(A, B) = "", (A == ""; B == "") => true.
lcs4(A, B) = [A[1]] ++ lcs4(butfirst(A), butfirst(B)), A[1] == B[1] => true.
lcs4(A, B) = longest(lcs4(butfirst(A), B), lcs4(A, butfirst(B))) => true.
/*

  Look and say sequence in Picat.


  From http://rosettacode.org/wiki/Look-and-say_sequence
  """
  Sequence Definition

  * Take a decimal number
  * Look at the number, visually grouping consecutive runs of the 
    same digit.
  * Say the number, from left to right, group by group; as how 
    many of that digit there are - followed by the digit grouped. 

  * This becomes the next number of the sequence. 

  The sequence is from John Conway, of Conway's Game of Life fame.

  An example:

   * Starting with the number 1, you have one 1 which produces 11.
   * Starting with 11, you have two 1's i.e. 21
   * Starting with 21, you have one 2, then one 1 i.e. (12)(11) 
     which becomes 1211
   * Starting with 1211 you have one 1, one 2, then two 1's i.e. 
     (11)(12)(21) which becomes 111221 
  """

  Also, see:
    http://en.wikipedia.org/wiki/Look-and-say_sequence
    http://www.research.att.com/~njas/sequences/A005150

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 

   S1 = "1",
   foreach(_I in 1..11) 
      println(S1),
      S1 := runs(S1)
   end,
   println(S1),
   
   nl,
   S2 := "1",
   foreach(_I in 1..20) 
      println(S2),
      S2 := runs(S2)
   end,
   println(S2),

   nl.

go2 => 
   S1 = "1",
   foreach(_I in 1..11) 
      println(S1),
      S1 := runs2(S1)
   end,
   println(S1),

   nl,
   S2 = "1",
   foreach(_I in 1..20) 
      println(S2),
      S2 := runs2(S2)
   end,
   println(S2),

   nl.

% Runs of a string, direct approach
runs(X) = V =>
  S = "",
  Last = X[1], 
  C = 1,
  foreach(I in 2..X.length)
    if X[I] == Last then
       C := C + 1
    else 
       S := S ++ C.to_string() ++ [X[I-1]],
       C := 1,  
       Last := X[I]
    end
  end,
  V := S ++ C.to_string() ++ [Last].


%
% another approach, using same_seq_len/2
% This is slower than runs/1.
%
runs2(L) = V =>
  V = [],
  Pos = 1,
  Len = L.length,
  while (Pos <= Len)
    P = same_seq_len(L,Pos),
    V := V ++ [P.to_string(),L[Pos]].flatten(),
    Pos := Pos + P
  end.


% find the length of the sequence of (same) characters to the right of pos Pos in list L.
same_seq_len(L,Pos) = same_seq_len1(L ++ _, Pos) => 
  Pos <= L.length.

same_seq_len1(L,Pos) = M =>
  P = [I : I in Pos+1..L.length, L[I] != L[Pos]],
  M = cond(P.length > 0, P.first()-Pos, L.length-Pos+1).
   

/*

  Luhn tests of credit card numbers in Picat.

  From http://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers
  """
  The Luhn test is used by some credit card companies to distinguish 
  valid credit card numbers from what could be a random selection of digits.

  Those companies using credit card numbers that can be validated by the 
  Luhn test have numbers that pass the following test:

   1. Reverse the order of the digits in the number.
   2. Take the first, third, ... and every other odd digit in the 
      reversed digits and sum them to form the partial sum s1
   3. Taking the second, fourth ... and every other even digit in the 
      reversed digits: 

         1. Multiply each digit by two and sum the digits if the answer 
            is greater than nine to form partial sums for the even digits
         2. Sum the partial sums of the even digits to form s2 

     1. If s1 + s2 ends in zero then the original number is in the form 
        of a valid credit card number as verified by the Luhn test. 

  For example, if the trail number is 49927398716:

  Reverse the digits:
    61789372994
  Sum the odd digits:
    6 + 7 + 9 + 7 + 9 + 4 = 42 = s1
  The even digits:
      1,  8,  3,  2,  9
    Two times each even digit:
      2, 16,  6,  4, 18
    Sum the digits of each multiplication:
      2,  7,  6,  4,  9
    Sum the last:
      2 + 7 + 6 + 4 + 9 = 28 = s2

   s1 + s2 = 70 which ends in zero which means that 49927398716 
  passes the Luhn test

  The task is to write a function/method/procedure/subroutine that will 
  validate a number with the Luhn test, and use it to validate the 
  following numbers:

      49927398716 
      49927398717 
      1234567812345678 
      1234567812345670 
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
   Nums = ["49927398716","49927398717","1234567812345678","1234567812345670"],
   foreach (N in Nums) 
      println([N, isluhn10(N)])
   end,
   nl.



%
% isluhn10(num) returns 1 is valid, else 0
%
% Assumption: input num is a string.
%
isluhn10(Num) = V =>
  X = [I : I in Num.reverse()] ++ [""],
  Digits = "0246813579",
  M = new_map([(I.to_string()=Digits[I+1]) : I in 0..9]),
  V1 = sum([X[I].to_integer() + M.get2(X[I+1].to_string(),0) : I in 1..2..Num.length]),
  V := cond(V1 mod 10 == 0, 1, 0). 

get2(M, Key, Default)=V =>
   if M.has_key(Key) then V= M.get(Key).to_integer() else V=Default end.





/* 

  M12 problem in Picat.

  See 
  Igor Kriz and Paul Siegel: 
      Rubik's Cube Inspired Puzzles Demonstrate Math's "Simple Groups"
  http://www.sciam.com/article.cfm?id=simple-groups-at-play

  Programs:
   http://www.math.lsa.umich.edu/~ikriz/
   http://www.sciam.com/article.cfm?id=puzzles-simple-groups-at-play

  This model implements the M12 puzzle:
   - length is 12 (2*6)
   - the two operations are 
       * merge (shuffle) and 
       * inverse (reverse)
   - some init configuration

  For a group theoretic solution of the M12 puzzle using the abstract algebra system GAP, 
  see http://www.hakank.org/group_theory/M12_gap.txt
  It is presented in my (Swedish) blog post
  "Gruppteoretisk lsning av M12 puzzle i GAP" [Group theoretical solution of the M12 puzzle in GAP]
  http://www.hakank.org/webblogg/archives/001226.html

  Note: Earlier this model used the old and experimental bplan module. Now it use the
        official planner module.

  Here we have two different approaches:
    %  - backtracking via bplan/2: go, go2, go3, and go4
    - backtracking via bplan*: go, go2, go3, and go4
    - CP approach: go_cp


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>

   % Init = [8,11,6,1,10,9,4,3,12,7,2,5], % 27 steps
   % Init = [10,5,4,7,1,2,8,3,12,11,9,6], % this is random generated from M12proj.exe. 15 steps
   % Init = [10,8,6,12,5,2,1,4,11,7,9,3], % generated from M12proj.exe. harder  22 steps
   % Init = [11,7,3,8,5,2,12,1,9,10,4,6], % generated from M12proj.exe 22 steps
   % Init = [7,5,8,3,1,11,2,9,4,12,6,10], % generated from M12proj.exe 19 steps
   % Init = [8,11,6,1,10,9,4,3,12,7,2,5], % 27 steps
   % Init = [3,8,6,12,4,7,5,11,1,10,9,2], % 19 steps
   % Init = [4,1,10,7,9,12,3,6,5,2,11,8], % 4 steps, generated from the following moves:  M2I1M
   % Init = [7,1,8,9,12,5,3,10,4,11,6,2], % 9 steps
   % Init = [5,6,11,10,8,2,3,12,7,4,9,1], % 13 steps
   % Init = [5,6,10,4,1,11,9,2,12,8,3,7], % 12 steps
   % Init = [3,4,6,10,11,1,9,7,8,2,12,5], % 22 steps
   % Init = [1,12,2,11,3,10,4,9,5,8,6,7], % 1 step: m
   % Init = [1,4,7,10,12,9,6,3,2,5,8,11], % 3 steps: mmm
   % Init = [11,2,9,7,1,10,6,5,8,3,12,4], % 7 steps, mmmrmmm
   % Init = [12,11,10,9,8,7,6,5,4,3,2,1], % 1 step: r

   Init = [10,7,5,3,12,11,9,1,8,6,2,4],
   % Init = [11,8,6,3,7,2,1,9,4,12,10,5],

   % Init = [4,2,7,12,1,5,10,9,3,8,11,6], % [r,m,m,m,r,m,r,m]
   % Init = [6,7,10,9,2,11,12,5,3,4,8,1],
   % Init=[10,9,7,4,6,5,11,1,8,3,2,12], % 15 steps m,r,m,r,m,r,m,r,m,m,m,r,m,m,m

   % Init = [1,4,9,3,11,6,8,5,10,2,7,12], % if there is a solution then it's > 600 steps...

   % time(best_plan_bb(Init, 100,L)),
   time(best_plan(Init, L)),
   println(L),
   println(len=L.len),
   nl.

%
% completely random inits. Perhaps quite silly...
%
go2 =>
  Timeout = 5000,
  Found = 0,
  while (Found == 0) 
    Init = rand_perm(1..12),
    println(rand_init=Init),
    time(time_out(best_plan(Init, L), Timeout, Status)),
    if Status == time_out then
       println(nope)
      else 
       println(L.reverse()),
       Found := 1
    end
  end,
  nl.

% 
% Generate one problem of length TheLen.
% Note that solution might not of be the same length as
% TheLen.
%
go3 => 
   TheLen = 40,
   m12_generate(TheLen, Moves, Init),
   println(gener_moves=Moves),
   println(init=Init),
   time(best_plan(Init, L)),
   println(L),
   Len=length(L),
   println(len=Len),
   nl.


% Generate 10 problems of length TheLen.
% Note that solution might not of be the same length.
go4 => 
   Lens = [],
   TheLen = 40,
   garbage_collect(200_000_000),
   foreach(_I in 1..10)
     % reset the table cache, otherwise
     % the generating takes (increasingly) long time
     initialize_table, 

     time(m12_generate(TheLen, Moves, Init)),
     println(gener_moves=Moves),
     println(init=Init),
     time(once(best_plan(Init, L))),
     println(L),
     Len=length(L),
     println(len=Len),
     Lens := Lens ++ [Len],
     nl
   end,
   println(lens=Lens),
   nl.


go5 =>
  foreach(P in 1..21) 
    problem(P,Init),
    println(init=Init),
    time(best_plan(Init,Plan)),
    println(Plan),
    println(len=Plan.len),
    nl
  end,

  nl.

final(Goal) => Goal=[1,2,3,4,5,6,7,8,9,10,11,12].

% merge
action([M1,M12,M2,M11,M3,M10,M4,M9,M5,M8,M6,M7], To,Move,Cost) ?=>
           Move=m,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12],Cost=1.
% reverse
action([M12,M11,M10,M9,M8,M7,M6,M5,M4,M3,M2,M1], To, Move, Cost) => 
           Move=r,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12],Cost=1.



rand_perm(List) = List, List.length == 1 => true.
rand_perm(List) = Perm => _ = random2(), rand_perm(List, List.length, Perm).

remove_at(X,L,1,R) => L=[X|Xs], R=Xs.
remove_at(X,L,K,R) => L=[Y|Xs], R=[Y|Ys], K > 1, K1 = K - 1, remove_at(X,Xs,K1,Ys).

rand_perm(_,0,R) ?=> R = [].
rand_perm(Xs,N,R) ?=> 
    R = [X|Zs],
    N > 0,
    L = length(Xs),
    I = 1+random() mod L,
    remove_at(X,Xs,I,Ys),
    N1 = N - 1,
    rand_perm(Ys,N1,Zs).


% For generating
table
legal_move_gen([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12], M, To) ?=>
           M=m,To=[M1,M12,M2,M11,M3,M10,M4,M9,M5,M8,M6,M7]. % merge

legal_move_gen([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12], M, To) => 
           M=r,To=[M12,M11,M10,M9,M8,M7,M6,M5,M4,M3,M2,M1]. % reverse


% Generate a (random) problem of length Len
m12_generate(Len, X, Res) => 
   println(generate),
   Ops = [m,r],
   X = new_list(Len),
   Res1 = 1..12,
   _ = random2(),
   foreach(I in 1..Len) 
      Move = Ops[1+random() mod 2],
      % No repeating reverses
      if I > 1, Move == r, X[I-1] == r then
         Move := m
      end, 
      X[I] := Move,
      legal_move_gen(Res1, Move, Res2),
      Res1 := Res2 % ,
      % println([res1=Res1,move=Move])
   end,
   Res = Res1,
   % println(Res),
   nl.
   
   
%
% CP approach
%
go_cp => 
  % Note: The number of steps is 1+the steps since we have the init as the first.

  % Init = [8,11,6,1,10,9,4,3,12,7,2,5], % 27 steps
  % Init = [10,5,4,7,1,2,8,3,12,11,9,6], % this is random generated from M12proj.exe. 15 steps
  % Init = [10,8,6,12,5,2,1,4,11,7,9,3], % generated from M12proj.exe. harder  22 steps
  % Init = [11,7,3,8,5,2,12,1,9,10,4,6], % generated from M12proj.exe 22 steps
  % Init = [7,5,8,3,1,11,2,9,4,12,6,10], % generated from M12proj.exe 19 steps
  Init = [8,11,6,1,10,9,4,3,12,7,2,5], % 27 steps
  % Init = [1,4,9,3,11,6,8,5,10,2,7,12], % if there is a solution then it's 60 steps...
  % Init = [3,8,6,12,4,7,5,11,1,10,9,2], % 19 steps
  % Init = [4,1,10,7,9,12,3,6,5,2,11,8], % 4 steps, generated from the following moves:  M2I1M
  % Init = [7,1,8,9,12,5,3,10,4,11,6,2], % 9 steps
  % Init = [5,6,11,10,8,2,3,12,7,4,9,1], % 13 steps
  % Init = [5,6,10,4,1,11,9,2,12,8,3,7], % 12 steps
  % Init = [3,4,6,10,11,1,9,7,8,2,12,5], % 22 steps
  % Init = [1,12,2,11,3,10,4,9,5,8,6,7], % 1 step: m
  % Init = [1,4,7,10,12,9,6,3,2,5,8,11], % 3 steps: mmm
  % Init = [11,2,9,7,1,10,6,5,8,3,12,4], % 7 steps, mmmrmmm
  % Init = [12,11,10,9,8,7,6,5,4,3,2,1], % 1 step: r

  % Init = [10,7,5,3,12,11,9,1,8,6,2,4],
  % Init = [11,8,6,3,7,2,1,9,4,12,10,5],
  % Init = [4,2,7,12,1,5,10,9,3,8,11,6], % [r,m,m,m,r,m,r,m]
  % Init = [6,7,10,9,2,11,12,5,3,4,8,1],
  % Init=[10,9,7,4,6,5,11,1,8,3,2,12], % 15 steps m,r,m,r,m,r,m,r,m,m,m,r,m,m,m

  m12_cp(Init, Moves),
  println(moves=Moves),
  nl.

% The permutation from A <-> B using the permutation P
permutation3(A,P,B) =>
   foreach(I in 1..A.length)
       %  B[I] #= A[P[I]]
       PI #= P[I], 
       BI #= B[I], 
       element(PI, A, BI)
   end.

% CP approach
%
% Using indomain(Len) find the shortest solution.
% However, for problems of steps > 14 it's slower than the above solution.
%
m12_cp(Init, Moves) => 
    N = 12,

    Len :: 2..100,
    indomain(Len),
    println(len=Len),

    Moves = new_list(Len-1),
    Moves :: 1..2,
    X = new_array(Len, N),    
    X :: 1..12,

    % The valid moves
    Permutations = [[1,12,2,11,3,10,4,9,5,8,6,7],  % merge
                    [12,11,10,9,8,7,6,5,4,3,2,1]], % reverse

    % init
    foreach(J in 1..N) X[1,J] #= Init[J] end,
    % the moves
    foreach(Move in 2..Len)
       all_different([X[Move,J] : J in 1..N]),
       % all_distinct([X[Move,J] : J in 1..N]),
       permutation3([X[Move,J] : J in 1..N], 
                    [P : J in 1..N, matrix_element(Permutations, Moves[Move-1],J,P)],
                    [X[Move-1,J] : J in 1..N])
    end,
    % the goal
    foreach(J in 1..N) X[Len,J] #= J end,

    Vars = Moves,% ++ X.to_list(),
    solve([ffc,split], Vars),

    foreach(Row in X) println(Row.to_list()) end,
    println(moves=Moves),
    nl.

    
% matrix_element(X, I, J, Val) =>
%  nth(I, X, Row),
%  element(J, Row, Val).

% matrix_element(X, I, J, Val) =>
%  nth(I, X, Row),
%  nth(J, Row, Val).

matrix_element(X, I, J, Val) =>
      freeze(I, (nth(I, X, Row),freeze(J,nth(J,Row,Val)))).

%matrix_element(X, I, J, Val) =>
%   freeze(I, (element(I, X, Row),freeze(J,element(J,Row,Val)))).


problem(1, Problem) => Problem = [8,11,6,1,10,9,4,3,12,7,2,5]. % 27 steps
problem(2, Problem) => Problem = [10,5,4,7,1,2,8,3,12,11,9,6]. % this is random generated from M12proj.exe. 15 steps
problem(3, Problem) => Problem = [10,8,6,12,5,2,1,4,11,7,9,3]. % generated from M12proj.exe. harder  22 steps
problem(4, Problem) => Problem = [11,7,3,8,5,2,12,1,9,10,4,6]. % generated from M12proj.exe 22 steps
problem(5, Problem) => Problem = [7,5,8,3,1,11,2,9,4,12,6,10]. % generated from M12proj.exe 19 steps
problem(6, Problem) => Problem = [8,11,6,1,10,9,4,3,12,7,2,5]. % 27 steps
problem(7, Problem) => Problem = [3,8,6,12,4,7,5,11,1,10,9,2]. % 19 steps
problem(8, Problem) => Problem = [4,1,10,7,9,12,3,6,5,2,11,8]. % 4 steps. generated from the following moves:  M2I1M
problem(9, Problem) => Problem = [7,1,8,9,12,5,3,10,4,11,6,2]. % 9 steps
problem(10, Problem) => Problem = [5,6,11,10,8,2,3,12,7,4,9,1]. % 13 steps
problem(11, Problem) => Problem = [5,6,10,4,1,11,9,2,12,8,3,7]. % 12 steps
problem(12, Problem) => Problem = [3,4,6,10,11,1,9,7,8,2,12,5]. % 22 steps
problem(13, Problem) => Problem = [1,12,2,11,3,10,4,9,5,8,6,7]. % 1 step: m
problem(14, Problem) => Problem = [1,4,7,10,12,9,6,3,2,5,8,11]. % 3 steps: mmm
problem(15, Problem) => Problem = [11,2,9,7,1,10,6,5,8,3,12,4]. % 7 steps. mmmrmmm
problem(16, Problem) => Problem = [12,11,10,9,8,7,6,5,4,3,2,1]. % 1 step: r

problem(17, Problem) => Problem = [10,7,5,3,12,11,9,1,8,6,2,4].
problem(18, Problem) => Problem = [11,8,6,3,7,2,1,9,4,12,10,5].

problem(19, Problem) => Problem = [4,2,7,12,1,5,10,9,3,8,11,6]. % [r,m,m,m,r,m,r,m]
problem(20, Problem) => Problem = [6,7,10,9,2,11,12,5,3,4,8,1].
problem(21, Problem) => Problem = [10,9,7,4,6,5,11,1,8,3,2,12]. % 15 steps m,r,m,r,m,r,m,r,m,m,m,r,m,m,m
/*

  Magic hexagon in Picat.

  Prob023: Magic Hexagon
  http://www.comp.rgu.ac.uk/staff/ha/ZCSP/prob023/prob023.pdf
  http://www.cse.unsw.edu.au/~tw/csplib/prob/prob023/


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   LD = [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S],
   LD :: 1..19,

   all_different(LD),

   A + B + C #=  38,
   D + E + F + G #=  38,
   H + I + J + K + L #=  38, 
   M + N + O + P #=  38, 
   Q + R + S #=  38, 
   A + D + H #=  38, 
   B + E + I + M #=  38, 
   C + F + J + N + Q #=  38, 
   G + K + O + R #=  38, 
   L + P + S #=  38, 
   C + G + L #=  38, 
   B + F + K + P #=  38, 
   A + E + J + O + S #=  38, 
   D + I + N + R #=  38, 
   H + M + Q #=  38, 
   
   A #< C,
   A #< H,
   A #< L,
   A #< Q,
   A #< S,
   C #< H,
   
   solve([ff], LD),

   writeln(LD),
   nl.

/*

  Magic sequence problem in Picat.

  http://www.dcs.st-and.ac.uk/~ianm/CSPLib/prob/prob019/spec.html
  """
  A magic sequence of length n is a sequence of integers x0 . . xn-1 between 
  0 and n-1, such that for all i in 0 to n-1, the number i occurs exactly xi 
  times in the sequence. For instance, 6,2,1,0,0,0,1,0,0,0 is a magic sequence 
  since 0 occurs 6 times in it, 1 occurs twice, ...
  """

  As a one-liner (without redundant constraints):

    Picat> N=10,L=new_list(N),L::0..N,global_cardinality(L,$[I-L[I+1]:I in 0..N-1]),solve(L)


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
  magic_sequence(7,Sequence),
  println(Sequence).


go2 =>
  foreach(N in 4..40)
    if magic_sequence(N,Sequence) then
      println(Sequence)
    else 
      println("No solution")
    end
  end.

go3 =>
  magic_sequence_no_cp(1400,Sequence),
  println(Sequence).


scalar_product(A, X,Product) => 
  Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).

magic_sequence(N, Sequence) =>

  printf("\n%d:\n",N),

  Sequence = new_list(N),
  Sequence :: 0..N-1,

  % println(sequence1=print_domains(Sequence)),

  % extra constraints
  N #= sum(Sequence),

  % println(sequence2=print_domains(Sequence)),

  Integers = [ I : I in 0..N-1],
  scalar_product(Integers, Sequence, N),

  % println(sequence3=print_domains(Sequence)),

  % using global_cardinality/2: or N=400: 0.8s
  % GC = [ $I-Sequence[I+1] : I in 0..N-1],
  % global_cardinality(Sequence,GC),

  % using count/4 for N=400: 0.22s
  foreach(I in 0..N-1) count(I,Sequence,#=,Sequence[I+1]) end,

  % println(sequence4=print_domains(Sequence)),

  solve([ff], Sequence).


print_domains(Vars) = [print_domain(Var) : Var in Vars].

print_domain(Var) = to_fstring("%2d..%2d", Min,Max) =>
  fd_min_max(Var,Min,Max).
  


% Magic sequence, algorithmic approach
magic_sequence_no_cp(N, Sequence) =>
  Sequence = new_list(N,0),
  Sequence[1] := N - 4,
  Sequence[2] := 2,
  Sequence[3] := 1,
  Sequence[N-3] := 1.

  /*

  Magic squares and cards in Picat.

  Martin Gardner (July 1971)
  """
  Allowing duplicates values, what is the largest constant sum for an order-3
  magic square that can be formed with nine cards from the deck.
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   N = 3,
   X = new_array(N,N),
   Vars = vars(X),
   Vars :: 1..13,
   S :: 0..13*4, % the sum

   % there are 4 cards of each value in a deck
   foreach(I in 1..13) count(I, Vars,#=<,4) end,

   % the standard magic square constraints (sans all_different)
   foreach(C in 1..N) sum([X[R,C] : R in 1..N]) #= S end,
   foreach(R in 1..N) sum([X[R,C] : C in 1..N]) #= S end,   

   sum([X[I,I] : I in 1..N]) #= S,
   sum([X[I,N+1-I] : I in 1..N]) #= S,


   Vars2 = Vars ++ [S],
   solve([$max(S)], Vars2),
   % solve(Vars2),

   writeln(s=S),
   foreach(Row in X) writeln(Row.to_list()) end,

   nl.
   
/*

  Magic squares in Picat.


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


%
% Simple run
%
go =>
  magic(6,Square),
  print_square(Square),
  nl.

%
% Run for different sizes
% 
% ffd/updown solves N= 6 in 0.06s and 7099 backtracks (symmetry breaking)
%        10 in 2.99s and 312671 backtracks (symmetry breaking)
%
% ff/inout (odd N):
%        11 in 0.056s and 7847 backtracks (no symmetry breaking)
%        13 in 0.8 and 137676 backtracks (no symmetry breaking)
go2 =>
  foreach(N in 3..2..15) 
      time2(magic(N,Square)),
      print_square(Square) 
  end.


%
% All solutions.
%
go3 =>
  N = 4,
  L = findall(Square,magic(N,Square)),
  Len = length(L),
  printf("Len: %d\n",Len).


go4 =>
  N = 4,
  Count = count_all(magic(N,_Square)),
  printf("Count: %d\n",Count).


magic(N,Square) =>

  writef("\n\nN: %d\n", N),
  NN = N*N,
  Sum = N*(NN+1)//2,% magical sum
  writef("Sum = %d\n", Sum),

  Square = new_array(N,N),
  Square :: 1..NN,

  all_different(Square.vars()),
  % all_distinct(Square.vars()),

  foreach(I in 1..N)
     Sum #= sum([T : J in 1..N, T = Square[I,J]]), % rows
     Sum #= sum([T : J in 1..N, T = Square[J,I]])  % column
  end,

  % diagonal sums
  Sum #= sum([Square[I,I] : I in 1..N]),
  Sum #= sum([Square[I,N-I+1] : I in 1..N]),

  % Symmetry breaking
  % Square[1,1] #< Square[1,N],
  % Square[1,1] #< Square[N,N],
  % Square[1,1] #< Square[N,1],
  % Square[1,N] #< Square[N,1],

  % Symmetry breaking, Frenicle form
  % Square[1,1] #= min([Square[1,1], Square[1,N], Square[N,1], Square[N,N]]),
  % Square[1,2] #< Square[2,1],

  % solve([ffd,updown],Square),
  % solve([ffc,inout],Square),
  solve([ff,split],Square).
  
  % print_square(Square).

%
% Alternativt using rows(), columns(), diagonal1(), and diagonal2() 
% from the util module.
%
magic2(N,Square) =>

  printf("\n\nN: %d\n", N),
  NN = N*N,
  Sum = N*(NN+1)//2,% magical sum
  printf("Sum = %d\n", Sum),

  Square = new_array(N,N),
  Square :: 1..NN,

  all_different(Square.vars()),

  % Note that sum/1 requires a list, so Row and Column must be converted 
  % to a list with .to_list().
  foreach(Row in Square.rows()) Sum #= sum(Row.to_list()) end,
  foreach(Column in Square.columns()) Sum #= sum(Column.to_list()) end,


  % diagonal sums
  Sum #= sum(Square.diagonal1()),
  Sum #= sum(Square.diagonal2()),

  println(diagonals),

  % Symmetry breaking
  Square[1,1] #< Square[1,N],
  Square[1,1] #< Square[N,N],
  Square[1,1] #< Square[N,1],
  Square[1,N] #< Square[N,1],

  solve([ffd,updown],Square),

  print_square(Square).

%
% No symmetry breaking
%
magic3(N,Square) =>

  writef("\n\nN: %d\n", N),
  NN = N*N,
  Sum = N*(NN+1)//2,% magical sum
  writef("Sum = %d\n", Sum),

  Square = new_array(N,N),
  Square :: 1..NN,

  all_different(Square.vars()),
  % all_distinct(Square.vars()),

  foreach(I in 1..N)
     Sum #= sum([T : J in 1..N, T = Square[I,J]]),% rows
     Sum #= sum([T : J in 1..N, T = Square[J,I]]) % column
  end,

  % diagonal sums
  Sum #= sum([Square[I,I] : I in 1..N]),
  Sum #= sum([Square[I,N-I+1] : I in 1..N]),

  % Symmetry breaking
  % Square[1,1] #< Square[1,N],
  % Square[1,1] #< Square[N,N],
  % Square[1,1] #< Square[N,1],
  % Square[1,N] #< Square[N,1],

  solve([ffd,updown],Square),

  print_square(Square).


print_square(Square) =>
  N = Square.length,
  foreach(I in 1..N)
     foreach(J in 1..N)
         writef("%3d ", Square[I,J])
     end,
     writef("\n")
  end,
  writef("\n").

/*

  Mandelbrot set in Picat.

  See 
   * http://en.wikipedia.org/w/index.php?title=Mandelbrot_set
   * http://rosettacode.org/wiki/Mandelbrot_set

  This solution was inspired by the Icon/Unicon version:
    http://rosettacode.org/wiki/Mandelbrot_set#Icon_and_Unicon


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 

   Width = 90,
   Height = 50,
   Limit = 50,
   foreach(Y in 1..Height)
      P="",
      foreach (X in 1..Width) 
         Z=complex(0,0),
         C=complex(2.5*X/Width-2.0,2.0*Y/Height-1.0),
         J = 0,
         while (J < Limit, c_abs(Z)<2.0) 
            Z := c_add(c_mul(Z,Z),C),
            J := J + 1
         end,
         if J == Limit then
             P := P ++ "#"
         else 
             P := P ++ "."
         end
      end,
      printf("%s\n", P)
  end,
  nl.


complex(R,I) = [R,I].
c_add(X,Y) = complex(X[1]+Y[1],X[2]+Y[2]).
c_mul(X,Y) = complex(X[1]*Y[1]-X[2]*Y[2],X[1]*Y[2]+X[2]*Y[1]).
c_abs(X) = sqrt(X[1]*X[1]+X[2]*X[2]).
/* 

  Generate all spellings of Henning Mankell (and Kjellerstrand) in Picat.

  This is a recurring problem for me: Generating "all" possible
  spellings of Henning Mankell (and Kjellerstrand) given a grammar 
  (or regular expression).

  I have written about this before:
  - Regular expressions in Gecode
    http://www.hakank.org/constraint_programming_blog/2009/04/regular_expressions_in_gecode.html
    This blog post contains further links and references.

  - Icon program for the Henning Mankell problem:
    http://www.hakank.org/unicon/pattern_generation.icn

  - B-Prolog program 
    http://www.hakank.org/bprolog/mankell.pl


  Picat don't have Definite Clause Grammars but it's quite easy
  to simulate it.

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
   % go1,go2,go3,go4,go5,go6,go7,go8.
   % All predicates except kjellerstrand4 (goal6/0) is of the 
   % same form.
   Goals = $[smankell,smankell2,
             kjellerstrand,kjellerstrand2,kjellerstrand3,
             kjellerstrand5,kjellerstrand6
           ],
   foreach(Goal in Goals)
      find_flatten(("Testing " ++ Goal.to_string()),Goal)
   end,
   go6,
   nl.


go_x => 
   go1,go2,go3,go4,go5,go6,go7,go8.

   
%
% Find all the solutions of goal Goal.
%
find_flatten(Text,Goal) =>
   printf("%w (%w)\n", Text, Goal),
   List = findall(L,call(Goal,L)),
   println([LL.flatten() : LL in List]),
   println(len=List.length),
   nl.

go1 =>
   find_flatten("Variants of ""(Henning) Mankell""", $smankell).

go2 =>
   find_flatten("Variants of ""(Henning) Mankell""", $smankell2).

go3 => 
   find_flatten("Variants of ""kjellerstrand""", $kjellerstrand).

go4 => 
   find_flatten("Variants of ""kjellerstrand""", $kjellerstrand2).


%
% The Henning Mankell problem.
%
% Given this regular expression, generate all the
% possible spellings:
%  [hm][ea](nk|n|nn)(ing|ell|all)
% 
% Finds all 36 variants
smankell(L) => 
      m(hm,HM), m(ea,EA), m(nknnm,NKNNM), m(ingellall,INGELLALL),
      L = [HM,EA,NKNNM,INGELLALL].flatten().

% Finds all 36 variants
smankell2(L) => 
      m2(hm,HM), m2(ea,EA), m2(nknnm,NKNNM), m2(ingellall,INGELLALL),
      L = [HM,EA,NKNNM,INGELLALL].flatten().



m(hm,L) ?=> L = "h".
m(hm,L) ?=> L = "m".

m(ea,L) ?=> L = "e".
m(ea,L) ?=> L = "a".

m(nknnm,L) ?=> L = "nk".
m(nknnm,L) ?=> L = "n".
m(nknnm,L) ?=> L = "nn".

m(ingellall,L) ?=> L = "ing".
m(ingellall,L) ?=> L = "ell".
m(ingellall,L) ?=> L = "all".

% This is nicer
index (+,-)
m2(hm,"h").
m2(hm,"m").

m2(ea,"e").
m2(ea,"a").

m2(nknnm,"nk").
m2(nknnm,"n").
m2(nknnm,"nn").

m2(ingellall,"ing").
m2(ingellall,"ell").
m2(ingellall,"all").


%
% kjellerstrand
%
% This regular expression is for (most of) the misspellings
% of my last name, which actually is Kjellerstrand.
%
%    k(je|)ll(er|ar)?(st|b)r?an?d 
%
% skjellerstrand --> [k], je, [ll], erar, stb, r_star, [a], n_star, [d].
% je      --> [je] | [""].
% erar    --> [] | [er] | [ar].
% stb     --> [st] | [b].
% r_star  --> [] | [r].
% n_star  --> [] | [n].
% d       --> [d]. 

% This is more like the original regular expression. And that may be
% good or bad...
% kjellerstrand =>
%         [k], ([je]|['']), [ll], ([] | [er] | [ar]), 
%         ([st] | [b]),
%         ([] | [r]), [a], ([] | [n]), [d].


% Finds all 48 variants
kjellerstrand(L) =>
    k(k,K), k(je,JE), k(ll,LL), k(erar,ERAR), k(stb,STB), 
    k(r_star,R_STAR), k(a,A), k(n_star,N_STAR), k(d,D),
    L = [K,JE,LL,ERAR,STB,R_STAR,A,N_STAR,D].flatten().

index(+,-)
k(k,"k").
k(je,"je").
k(je,"").
k(ll,"ll").
k(erar,"").
k(erar,"er").
k(erar,"ar").
k(stb,"st").
k(stb,"b").
k(r_star,"").
k(r_star,"r").
k(a,"a").
k(n_star,"").
k(n_star,"n").
k(d,"d").

kjellerstrand2(L) =>
    k2(k,K),  % constant
    k2(je,JE), 
    k2(ll,LL), % constant
    k2(erar,ERAR), 
    k2(stb,STB), 
    k2(r_star,R_STAR), 
    k2(a,A), % constant
    k2(n_star,N_STAR), 
    k2(d,D), % constant
    L = [K,JE,LL,ERAR,STB,R_STAR,A,N_STAR,D].flatten().

         
% Explicit alternation and the "constants" ("k", "ll","a", and "d")
% are handled automatically
k2(je,S)     => S = "je"; S = "".
k2(erar,S)   => S = ""; S = "er"; S = "ar".
k2(stb,S)    => S = "st"; S = "b".
k2(r_star,S) => S = ""; S = "r".
k2(n_star,S) => S = ""; S = "n".
k2(A,S)      => S = atom_chars(A). % catch all


go5 => 
   find_flatten("Variants of ""kjellerstrand""", $kjellerstrand3).

%
% using member
%
kjellerstrand3(L) =>
    member(K,     ["k"]),  % constant
    member(JE,    ["je","a"]),
    member(LL,    ["ll"]), % constant
    member(ERAR,  ["","er","ar"]), 
    member(STB,   ["st","b"]), 
    member(R_STAR,["","r"]), 
    member(A,     ["a"]), % constant
    member(N_STAR,["","n"]), 
    member(D,     ["d"]), % constant
    L = [K,JE,LL,ERAR,STB,R_STAR,A,N_STAR,D].flatten().


go6 => 
   println("Variants of ""kjellerstrand"" (kjellerstrand4, DCG inspired)"),
   List = findall(L,$kjellerstrand4(L,[])),
   println([LL.flatten() : LL in List]),
   println(len=List.length),
   nl.

%
% DCG inspired
%
kjellerstrand4(S1,S) => 
   s6_k(S1,S2),
   s6_je(S2,S3),
   s6_ll(S3,S4),
   s6_erar(S4,S5),
   s6_stb(S5,S6),
   s6_r(S6,S7),
   s6_a(S7,S8),
   s6_n(S8,S9),
   s6_d(S9,S).

s6_k(S1,S2) => 
  member(V,["k"]),
  S1 = [V|S2].
s6_je(S1,S2)=> 
  member(V,["je",""]),
  S1 = [V|S2].
s6_ll(S1,S2)=> 
  member(V,["ll"]),
  S1 = [V|S2].
s6_erar(S1,S2)=> 
  member(V,["","er","ar"]),
  S1 = [V|S2].
s6_stb(S1,S2)=> 
  member(V,["st","b"]),
  S1 = [V|S2].
s6_r(S1,S2)=> 
  member(V,["","r"]),
  S1 = [V|S2].
s6_a(S1,S2)=> 
  member(V,["a"]),
  S1 = [V|S2].
s6_n(S1,S2)=> 
  member(V,["","n"]),
  S1 = [V|S2].
s6_d(S1,S2)=> 
  member(V,["d"]),
  S1 = [V|S2].


% more direct approach using alternatives
kjellerstrand5(X) =>
   K="k",
   (JE = "je";JE=""),
   LL = "ll",
   (ERAR = ""; ERAR = "er"; ERAR="ar"),
   (STB ="st";STB="b"),
   (RStar = ""; RStar="r"),
   A="a",
   (NStar = ""; NStar="n"),
   D="d",
   X = [K,JE,LL,ERAR,STB,RStar,A,NStar,D].

%
% using table of alternatives and member
%
kjellerstrand6(X) =>
   Table =[
          ["k"],
          ["je",""],
          ["ll"],
          ["","er","ar"],
          ["st","b"],
          ["","r"],
          ["a"],
          ["","n"],
          ["d"]
          ],
   X = new_list(Table.length),
   foreach({E,T} in zip(X,Table)) 
      member(E,T)
   end.


go7 => 
   find_flatten("Variants of ""kjellerstrand"" (kjellerstrand7)", $kjellerstrand5).

go8 => 
   find_flatten("Variants of ""kjellerstrand"" (kjellerstrand8)", $kjellerstrand6).
/*

  Map coloring in Picat.

  Simple map coloring problem.


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
        connections(Connections), 
        NumColors = 4,
        mapx(Connections, Countries, NumColors),
        writeln(Countries),

        All = findall(Countries2, $mapx(Connections, Countries2, NumColors)),
        Len = length(All),
        writef("It was %d different solutions using %d colors:\n", Len,NumColors),
        writeln(All).


%
% optimize the number of used colors
%
go2 =>
        connections(Connections), 
        NumColors = 5,
        map2(Connections, Countries, NumColors, MinColors),
        writeln(Countries),
        writef("We used %d colors\n", MinColors).



mapx(Connections, Countries, NumColors) =>

        N = Connections.length, 
        Countries = new_list(N),
        Countries :: 1..NumColors,
        foreach(C1 in 1..N, C2 in C1+1..N) 
                    if Connections[C1,C2] == 1 then
                        Countries[C1] #!= Countries[C2]
                    end
        end,

        % symmetry breaking
        Countries[1] #= 1,
        Countries[2] #=< 2,

        solve(Countries).


% optimization
map2(Connections, Countries, NumColors, MinColors) =>

        N = Connections.length, 
        Countries = new_list(N),
        Countries :: 1..NumColors,
        MinColors :: 1..NumColors, % to optimize

        MinColors #= max(Countries),
        foreach(C1 in 1..N, C2 in C1+1..N)
            if Connections[C1,C2] == 1 then
                Countries[C1] #!= Countries[C2]
             end
        end,

        % symmetry breaking
        Countries[1] #= 1,
        Countries[2] #=< 2,

        solve([$min(MinColors)], Countries).


% Connections between these countries:
% [belgium, denmark, france, germany, netherlands, luxembourg]
connections(A) => 
         A = [[0, 0, 1, 1, 1, 1],
             [0, 0, 0, 1, 0, 0],
             [1, 0, 0, 1, 1, 0],
             [1, 1, 1, 0, 1, 1],
             [1, 0, 1, 1, 0, 0],
             [1, 0, 0, 1, 0, 0]].
     


/*

  Marathon puzzle in Picat.

  From Xpress example
  http://www.dashoptimization.com/home/cgi-bin/example.pl?id=mosel_puzzle_5_3
  """
  Dominique, Ignace, Naren, Olivier, Philippe, and Pascal
  have arrived as the first six at the Paris marathon.
  Reconstruct their arrival order from the following
  information:
  a) Olivier has not arrived last
  b) Dominique, Pascal and Ignace have arrived before Naren
     and Olivier
  c) Dominique who was third last year has improved this year.
  d) Philippe is among the first four.
  e) Ignace has arrived neither in second nor third position.
  f) Pascal has beaten Naren by three positions.
  g) Neither Ignace nor Dominique are on the fourth position.
  
     (c) 2002 Dash Associates
    author: S. Heipcke, Mar. 2002
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   N = 6,
   Names = ["Dominique", "Ignace", "Naren", "Olivier", "Philippe", "Pascal"],
   Runners = [Dominique, Ignace, Naren, Olivier, Philippe, Pascal],
   Runners :: 1..6,

   all_different(Runners),
  
   % a: Olivier not last
   Olivier #!= N,

   % b: Dominique, Pascal and Ignace before Naren and Olivier
   Dominique  #< Naren,
   Dominique  #< Olivier,
   Pascal     #< Naren,
   Pascal     #< Olivier,
   Ignace     #< Naren,
   Ignace     #< Olivier,
   
   % c: Dominique better than third
   Dominique  #< 3, 
   
   % d: Philippe is among the first four
   Philippe   #=< 4 ,
   
   % e: Ignace neither second nor third
   Ignace     #!= 2, 
   Ignace     #!= 3, 
   
   % f: Pascal three places earlier than Naren
   Pascal + 3 #= Naren, 
   
   % g: Neither Ignace nor Dominique on fourth position
   Ignace     #!= 4,
   Dominique  #!= 4,

   % For the presentation (inverse)
   assignment(Runners, RunnersInv),

   solve(Runners),

   printf("runners   : %w\n",Runners),
   printf("assignment: %w\n",RunnersInv),
   printf("\nPlacings:\n"),
   foreach(I in 1..N) 
      printf("Place %d: %w\n", I, Names[Runners[I]])
   end,
   nl.

/* 

  List and matrix extraction in Picat.

  Note: Picat now has a built-in slice/1 and slice/2.

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   L = 1..10,
   writeln(L.slice2(3..4)),

   L = 1..10,
   writeln(L.slice2(5)),

   nl,
   writeln(array),
   N = 4,
   M = new_array(N,N),
   foreach(I in 1..M.length, J in 1..M[1].length)
      M[I,J] := (I-1)*N + J
   end,
   print_matrix(M),

   writeln(scalar=M.slice2(3,4)),
   writeln(range1=M.slice2(2,3..3)),
   writeln(range2=M.slice2(1..3,3)),
   writeln(range3=M.slice2(1..3,2..4)),

   nl,
   writeln(list),
   M2 = new_array(N,N).array_matrix_to_list_matrix(),
   foreach(I in 1..M2.length, J in 1..M2[1].length)
      M2[I,J] := (I-1)*N + J
   end,
   print_matrix(M2),

   writeln(scalar=M2.slice2(3,4)),
   writeln(range1=M2.slice2(2,3..3)),
   writeln(range2=M2.slice2(1..3,3)),
   writeln(range3=M2.slice2(1..3,2..4)),

   writeln(range3_flatten=M2.slicef(1..3,2..4)),


   nl.


% CP test
go2 =>

  N = 4,
  M = new_array(N,N),
  M :: 1..16,

  M.vars().all_different(),

  solve(M),
  print_matrix(M),

  nl.


% CP test
go3 =>

  N = 4,
  M = new_array(N,N),
  M :: 1..16,

  foreach(I in 1..N)
     M.slice2(I,1..N).all_different(),
     M.slice2(1..N,I).all_different()
  end,

  solve(M),
  print_matrix(M),

  nl.

%
% CP test.
% Using a list matrix we have do some conversions
%
go4 =>

  N = 4,
  M = new_list(N,N),
  M.vars() :: 1..16, % convert

  foreach(I in 1..N)
     M.slice2(I,1..N).all_different(),
     M.slice2(1..N,I).all_different()
  end,

  solve(M.vars()),  % convert
  print_matrix(M),

  nl.



%
% Note that we differ between a list and array and returns the same type 
% as input (where applicable).
%

% return the scalar List[I]
slice2(List, I) = List[I], list(List), integer(I) => true.

%
% return the list/array List[Range]
%
slice2(List, Range) = [List[I] : I in Range], list(List) => true.
slice2(Array, Range) = [Array[I] : I in Range].to_array(), array(Array) => true.

%
% Returns the scalar value M[I,J]
%
slice2(Matrix, I,J) = Matrix[I,J], integer(I),integer(J) => true.

%
% Returns the list/array M[I,Range2]
%
slice2(Matrix, I,Range2) = [ Matrix[I,J] : J in Range2], list(Matrix), integer(I),list(Range2) => true.
slice2(Matrix, I,Range2) = [ Matrix[I,J] : J in Range2].to_array(), array(Matrix), integer(I),list(Range2) => true.

%
% Returns the list/array M[Range1,J]
%
slice2(Matrix, Range1,J) = [Matrix[I,J] : I in Range1 ], list(Matrix), list(Range1), integer(J) => true.
slice2(Matrix, Range1,J) = [Matrix[I,J] : I in Range1 ].to_array(), array(Matrix), list(Range1), integer(J) => true.

%
% Returns the list/array matrix M[Range1,Range2]
%
slice2(Matrix, Range1,Range2) = [ [Matrix[I,J] : I in Range1 ] : J in Range2], list(Matrix) => true.
slice2(Matrix, Range1,Range2) = [ [Matrix[I,J] : I in Range1 ].to_array() : J in Range2].to_array(), array(Matrix) => true.

%
% Returns a flattened list/array matrix M[Range1,Range2]
%
slicef(Matrix, Range1,Range2) = [ [Matrix[I,J] : I in Range1 ] : J in Range2].flatten(), list(Matrix) => true.
slicef(Matrix, Range1,Range2) = [ [Matrix[I,J] : I in Range1 ].to_array() : J in Range2].to_array().flatten(), array(Matrix) => true.


print_matrix(M) =>
  Max = 0,
  if list(M) then
     Max := max(M.flatten())
  else
     Max := max(M.array_matrix_to_list_matrix().flatten())
  end,
  Len = Max.to_string().length + 1,
  Format = "%-" ++ Len.to_string() ++ "w",
  foreach(I in 1..M.length)
     foreach(J in 1..M[1].length)
        printf(Format, M[I,J])
     end,
     nl
  end.
 
%    
% create a 2D list matrix of dimension NxM
%
new_list(N,M) = new_array(N,M).array_matrix_to_list_matrix().
/* 

  Max flow problem  in Picat.
  
  Ported from the B-Prolog model:
  http://www.probp.com/cp_sat_lp/maxflow.pl
  """
  by Neng-Fa Zhou, Jan. 2012
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
   A= [[0,0,0,7,8,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,4,0,0,0,0,0,0,6,8,0,0,0,5,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,5,0],[0,9,5,0,0,0,0,0,8,1,0,0,0,0,9,4,5,0,0,0,6,4,8,2,0,3,7,0,0,0,2,0,0,0,6,4,0,0,5,1,0,0,0,0,0,0,0,0,8,0,0,4,0,0,0,5,0,0,0,0],[0,8,0,0,0,4,0,0,0,0,0,0,0,8,5,1,1,0,2,0,0,5,0,0,0,0,0,0,7,0,5,0,0,0,0,8,0,0,4,0,5,3,0,0,0,0,0,0,0,0,0,0,8,0,0,0,1,0,6,0],[0,0,0,9,0,0,0,0,1,4,7,4,0,7,0,0,4,0,8,0,0,5,0,0,2,0,0,0,0,4,3,0,0,0,0,2,0,0,0,7,1,5,9,0,0,0,0,0,6,0,0,0,3,0,0,4,8,1,0,8],[0,0,0,3,9,0,0,7,7,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,8,0,4,2,0,0,8,8,1,9,9,4,0,0,9,1,0,0,0,0,0,0,0,0,7,0,0,0,0],[8,0,3,0,0,0,0,0,8,7,0,7,0,0,7,0,0,0,9,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,6,0,0,0,0,0,0,6,7,0,4,0,0,2,4,0,0],[3,9,0,0,9,0,0,4,0,0,9,2,0,0,0,0,0,0,0,0,0,0,0,0,9,0,7,0,6,1,7,0,6,0,8,1,0,0,0,0,3,0,0,0,0,8,0,0,0,7,7,2,0,7,0,9,0,0,0,0],[0,0,8,6,0,0,0,0,0,0,0,6,0,0,0,0,0,2,7,0,3,1,0,9,4,9,3,0,2,0,0,0,0,8,0,0,0,2,9,0,0,0,0,0,0,0,1,9,0,0,0,0,0,0,0,7,5,0,0,0],[0,0,0,5,7,0,4,7,0,0,5,0,0,8,4,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,5,0,5,0,0,0,0,5,0,0,0,2,0,0,0,0,5,0,0,0,0,0,0,0,6,5,0,0,0,3],[0,0,0,6,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,3,0,0,0,6,0,0,7,9,0,0,0,0,3,0,1,0,0,0,0,0,0,5,0,0,0,0,0],[8,0,0,0,0,0,6,0,0,0,4,0,7,7,3,0,0,9,0,0,0,0,0,3,0,0,8,0,0,4,0,7,0,0,0,3,0,0,0,0,0,0,6,3,0,0,0,0,2,0,0,0,0,0,0,0,0,7,0,0],[0,0,3,5,3,0,0,0,2,0,0,0,7,0,0,0,0,0,0,0,4,5,0,0,9,0,0,0,0,0,0,2,6,0,0,0,0,0,9,0,0,0,0,0,0,0,3,0,0,0,0,0,0,2,6,0,0,8,0,0],[0,0,0,4,0,0,0,5,7,6,0,6,0,0,0,0,0,0,0,0,7,0,0,0,2,0,4,0,1,0,0,8,7,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,5,0,0,0,5,0,0,0,8,9,5,9],[0,0,0,0,6,5,0,0,0,0,8,0,1,0,4,6,0,0,0,5,0,0,0,0,8,0,0,0,0,1,0,5,0,0,0,0,0,6,0,0,0,0,0,0,1,0,4,2,0,4,0,0,0,2,0,0,3,0,8,0],[0,9,2,0,0,0,0,0,9,6,0,0,3,0,0,4,0,0,0,0,3,0,0,5,1,0,0,0,0,3,0,0,0,0,9,0,4,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,5,4],[0,7,0,0,0,1,9,1,0,4,0,4,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,2,6,8,0,0,0,0,1,0,0,0,0,0,0,9,7,7,9,0,0,0,6,3,4,0,5],[0,0,0,7,0,0,6,9,0,0,2,0,6,7,0,0,0,0,3,2,0,2,0,0,0,8,0,0,0,0,8,0,0,7,0,0,0,6,1,0,8,6,0,0,0,3,0,0,0,0,0,0,2,0,0,0,0,9,0,0],[6,8,0,0,0,0,0,3,0,0,0,0,0,0,5,1,2,2,2,2,0,0,9,0,4,0,2,0,5,8,0,0,0,0,0,1,0,0,5,0,0,0,0,8,0,0,0,0,0,5,0,0,0,3,5,5,0,0,0,0],[2,0,8,7,0,0,0,0,0,5,0,0,0,0,0,0,7,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,8,6,0,9,9,0,0,6,0,6,6,0,0,1,3,9,0,0,0,9,0,0],[3,7,0,0,0,0,0,0,0,0,0,8,0,9,0,0,0,0,0,0,8,5,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,1,4,0,0,0,0,0,0,0,7,6,8,0,5,2,9,0,0,0,0,0,0],[0,0,0,7,0,0,0,0,0,6,0,7,3,0,1,8,7,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,2,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,8,3,3,3,3,0,0,3,5,2,9,9,0,0,0,5,1,3,1,0,0,0,4,1,4,7,5,0,0,0,0,8,0,1,8,5,0,0,0,0,0,0,0,0,8,0,1,2,8,0,0,3],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,3,0,0,0,8,0,3,2,1,0,0,0,0,0,0,0,0,0,0,3,8,0,0,0,0,0,0,0,3,9,2,0,0,1,0,6,0],[0,0,0,0,0,4,0,9,0,4,8,6,8,6,0,2,0,1,1,0,0,0,0,0,0,0,6,0,0,0,0,1,0,0,0,0,8,0,4,4,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0],[0,0,6,9,0,0,9,2,0,5,0,0,6,4,0,5,5,0,6,0,0,0,0,8,0,5,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,6,0,0,1,8,0,0,0,0,0,0,8,0,0,0,0,5],[8,3,0,0,0,0,0,0,0,4,2,5,0,5,9,4,0,0,0,4,7,3,1,0,0,0,0,5,0,0,1,0,0,0,0,0,0,0,9,6,0,0,0,0,0,0,2,0,7,1,2,6,0,0,8,1,0,0,0,0],[1,4,3,4,0,0,0,0,1,8,0,3,5,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,4,0,9,4,0,0,0,0,0,0,0,0,0,8,0,0,0,0,9,0,6,4,0,0,0,0,0,0],[0,0,0,0,8,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,6,6,7,0,0,7,0,0,0,0,0,0,9,6,0,0,0,4,0,0,7,0,5,0,0,0,0,0,0,0,0,2,0,8,0,0],[0,0,0,7,0,7,9,0,0,0,0,6,0,0,0,0,0,0,0,0,3,6,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,9,0,5,0,0,0,6,0,0,2,4,8,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,9,0,0,3,0,0,2,2,9,2,6,3,2,0,4,0,0,0,0,6,4,0,1,0,0,0,7,0,2,4,0,0,4,0,0,0,7,0,0,9],[4,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,9,2,0,0,3,0,7,6,0,0,0,0,0,0,8,0,0,8,0,6,0,0,0,2,0,0,0,0,0,0,0,8,0,0,0,0,0,9,4,7,3,5,6,8],[4,9,0,0,0,0,2,0,1,4,9,0,0,8,0,0,0,5,0,0,0,0,0,1,4,0,8,0,0,0,0,0,0,0,4,0,0,0,0,0,1,0,2,4,0,7,5,0,0,5,0,0,0,2,6,4,0,0,9,0],[8,0,2,0,0,0,0,9,0,0,0,0,6,0,0,0,0,9,0,0,2,0,0,0,0,3,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,2,0,7,8,3,0,1,0,0,0,0,2,0,0],[5,0,0,9,1,3,3,4,0,0,0,0,8,0,0,0,0,0,4,0,9,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,6,0,2,0,0,9,9],[9,0,3,0,0,0,0,0,0,0,3,0,2,0,9,0,6,4,1,0,0,0,2,8,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,9,0,0,0,0,0,1,1,9,0,5,0,0,0,0,4,4],[4,5,8,2,1,5,0,0,0,0,4,0,0,3,0,8,0,0,6,0,0,2,0,0,0,0,0,0,0,0,5,9,0,0,0,0,0,3,2,0,0,0,0,0,0,5,7,6,8,0,0,0,7,0,0,0,3,5,0,0],[0,0,0,0,0,1,7,1,4,0,0,0,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,4,0,0,3,0,0,0,0,6,0,0,0,5,0,0,6,1,0,0,0,0,0,0,0,0,0,0,0,0,0,7],[0,0,1,0,2,0,5,0,0,0,6,6,0,0,0,0,0,0,0,0,0,0,0,4,0,3,5,0,0,0,0,0,0,0,0,0,5,6,4,0,6,7,8,0,0,0,0,0,0,0,0,1,1,0,0,4,7,0,0,0],[0,0,0,0,0,0,7,0,0,2,9,0,0,0,0,0,0,0,0,0,0,0,0,1,0,2,0,0,1,8,0,0,0,0,8,2,0,0,0,0,0,5,3,1,0,0,0,6,0,6,0,0,0,0,0,3,0,0,0,2],[0,0,0,0,0,0,0,0,0,2,0,0,0,0,1,0,2,7,0,4,2,0,0,0,0,0,0,0,0,0,3,7,0,0,1,7,4,0,3,0,0,0,0,0,0,0,0,0,0,1,5,2,0,8,0,7,0,3,7,9],[4,0,0,0,0,0,0,0,0,0,8,0,0,0,0,7,0,0,0,0,0,9,2,9,0,0,0,0,0,0,0,1,0,2,0,0,6,0,0,0,0,0,5,0,3,0,0,0,0,0,8,7,0,9,8,0,0,0,0,0],[7,9,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,5,6,0,1,0,0,4,0,8,0,1,0,0,4,0,0,7,3,0,5,0,0,0,9,0,0,0,5,4,0,0,7,0,0,0,0,0],[5,5,4,0,0,0,0,0,0,0,0,0,9,0,0,0,0,0,3,7,0,0,0,0,9,7,7,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,7,2,0,0,1,4,4,0,9,0,0,0,9],[3,0,0,0,2,0,0,0,0,0,2,0,0,0,6,0,0,0,0,0,0,2,7,5,0,8,0,9,0,0,0,9,0,0,4,0,1,6,0,7,0,0,0,5,3,0,6,0,0,4,2,0,0,6,0,0,0,0,0,0],[0,0,0,0,0,0,4,0,0,1,3,0,0,0,0,0,0,1,0,7,8,2,0,0,0,0,0,0,0,7,0,8,0,0,0,1,0,0,4,3,0,0,0,0,2,0,0,4,0,0,2,0,3,1,0,0,0,0,0,5],[0,0,0,6,0,0,2,0,0,0,0,0,0,0,3,4,0,0,0,0,0,7,9,6,2,0,1,0,3,3,0,2,0,0,6,4,0,0,0,0,0,6,5,0,2,0,5,0,0,0,7,1,0,0,4,0,0,0,0,0],[0,0,0,3,6,4,0,8,0,1,6,0,0,1,0,7,0,0,0,0,0,0,9,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,4,3,0,0,3,0,0,1,1,4,0,8,5,0,0,0,0,0,0,0,4,0],[0,0,0,0,7,0,4,0,0,8,0,6,2,0,0,0,2,0,3,0,1,6,0,0,0,0,0,0,0,0,5,6,0,7,0,0,8,0,0,3,0,6,0,0,0,0,0,0,7,0,0,4,0,0,0,0,0,0,7,0],[0,0,0,0,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,8,6,3,7,0,0,0,0,1,0,0,0,8,7,1,0,0,0,8,0,0,2,0,0,0,0,1,0,5,1,0,0,5,0],[0,0,0,0,0,0,0,0,0,7,7,4,7,0,5,4,0,4,5,0,0,0,0,0,0,0,1,0,0,8,8,0,0,5,0,2,0,8,7,0,8,8,7,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,3,0,0,3,0,3,5,7,0,0,0,0,0,0,2,0,0,3,0,0,0,0,0,0,0,0,0,5,3,0,9,0,4,9,0,8,2,0,0,9,0,7,0,5,0,0,0,9,2,0,0,0,0,0,3],[0,1,0,0,8,0,8,0,0,2,0,4,8,0,0,7,0,9,9,7,0,0,0,0,0,0,5,0,3,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,0,0,0,4,0,0,0,0,0,0],[2,0,7,1,3,0,2,6,8,0,0,0,1,0,0,4,0,4,0,9,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,6,5,6,0,1,0,0,1,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0],[8,7,3,0,6,4,0,9,0,8,0,9,6,0,0,5,0,0,0,0,0,0,7,7,0,0,0,0,0,0,0,0,0,0,0,5,0,5,0,0,2,0,0,1,7,4,3,0,5,0,0,0,0,8,7,8,1,2,0,0],[0,1,0,0,3,0,5,0,0,9,0,0,9,0,0,8,0,4,9,9,8,6,0,0,0,0,0,9,1,0,8,0,0,0,0,0,0,0,4,0,0,0,4,0,0,0,0,0,2,0,2,0,4,0,0,6,8,9,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,4,0,1,8,2,0,0,2,0,0,0,0,0,0,0,0,0,0,3,6,6,0,4,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,4],[0,0,0,0,6,0,0,0,0,5,2,0,0,0,0,0,0,0,0,0,6,7,0,0,0,0,0,0,0,0,0,3,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,8],[0,0,0,0,0,5,0,0,9,0,0,9,0,0,0,2,9,4,0,0,0,0,1,9,8,0,5,5,7,0,0,7,3,0,8,7,5,9,0,5,0,0,0,0,0,0,7,0,0,5,0,0,3,2,0,0,0,0,0,0],[8,0,0,1,0,3,5,0,0,0,0,0,0,0,9,0,7,0,0,0,0,4,9,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,9,0,6,0,3,0,7,9,7,0,0,0,0,0,8,1],[6,0,4,0,0,0,0,0,0,6,0,4,0,0,0,0,0,0,0,0,0,2,1,0,0,3,2,0,0,0,0,0,1,0,0,6,4,1,0,8,9,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0]],
        maxflow(A, 1, 60).




maxflow(M,Source,Sink) =>
    N = M.length,
    X = new_array(N,N),
    foreach(I in 1..N, J in 1..N)
        X[I,J] :: 0..M[I,J]
    end,
    foreach(I in 1..N)
        if I!=Source,I!=Sink then
          sum([X[J,I] : J in 1..N]) #= sum([X[I,J] : J in 1..N]) 
        end
    end,
    Total #= sum([X[Source,I] : I in 1..N]),
    Total #= sum([X[I,Sink]   : I in 1..N]),

    solve($[max(Total)],X),
    writeln(total=Total),
    % foreach(Row in X) writeln(Row) end,
    foreach(I in 1..N)
      T = [(J,X[I,J]) : J in 1..N, X[I,J] > 0],
      if T != [] then
        println(I=T)
      end
    end,

    nl.


/*

  Maximum flow problem in Picat.

  From http://taha.ineg.uark.edu/maxflo.txt
  Taha "Introduction to Operations Research", Example 6.4-2)


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   N = 5,
   Start = 1,
   End = 5,
   C = [[0, 20, 30, 10,  0],
        [0,  0, 40,  0, 30],
        [0,  0,  0, 10, 20],
        [0,  0,  5,  0, 20],
        [0,  0,  0,  0,  0]],
   CC = [C[I,J] : I in 1..N, J in 1..N],
   Min = min(CC),
   Max = max(CC),
   
   X = new_array(N,N),
   XVars = vars(X),
   XVars :: Min..Max,

   OutFlow = new_list(N),
   InFlow = new_list(N),

   Total #= sum([X[Start,J] : J in 1..N, C[Start,J] > 0]),

   foreach(I in 1..N, J in 1..N) X[I,J] #>= 0, X[I,J] #=< C[I,J] end,
   foreach(I in 1..N) InFlow[I] #= sum([X[J,I] : J in 1..N, C[J,I] >0]) end,
   foreach(I in 1..N) OutFlow[I] #= sum([X[I,J] : J in 1..N, C[I,J]>0]) end,
   foreach(I in 1..N)
      if I != Start, I != End then
          OutFlow[I]-InFlow[I] #= 0
      end
   end,
   sum([X[I,Start] : I in 1..N, C[I,Start]>0]) #= 0 ,
   sum([X[End,J] : J in 1..N, C[End,J]>0]) #= 0,

   Vars = XVars ++ InFlow ++ OutFlow,
   solve([$max(Total)],Vars),

   writeln(total=Total),
   foreach(Row in X)
       foreach(R in Row) printf("%3d ",R) end, 
       nl
   end,
   writeln(inFlow=InFlow),
   writeln(outFlow=OutFlow),

   nl.
/*

  Maximum flow problem in Picat.

  From Winston "Operations Research", page 420f, 423f
  Sunco Oil example.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   Cap =  [2,3,3,4,2,1,100],
   Arcs = [[1, 2],
           [1, 3],
           [2, 3],
           [2, 4],
           [3, 5],
           [4, 5],
           [5, 1]],

   NumArcs = length(Cap),
   N = 5,
   Nodes = 1..N,

   Flow = new_array(N,N),
   Z #= Flow[N,1],

   foreach(I in Nodes, J in Nodes) Flow[I,J] #>= 0 end,
   foreach(I in 1..NumArcs) Flow[Arcs[I,1], Arcs[I,2]] #=< Cap[I] end,
   foreach(I in Nodes)
      sum([Flow[Arcs[K,1], Arcs[K,2]] : K in 1..NumArcs,Arcs[K,1] == I])
      #=
      sum([Flow[Arcs[K,1], Arcs[K,2]] : K in 1..NumArcs,Arcs[K,2] == I])
   end,

   solve([$max(Z)], Flow),

   writeln(z=Z),
   foreach(Row in Flow) writeln(Row) end,
   nl./*

  Maximum density still life in Picat.

  CSPLib 032: http://www.csplib.org/prob/prob032

  This model (or rather my earlier MiniZinc and Comet models) was 
  inspired by the OPL model from
  Toni Mancini, Davide Micaletto, Fabio Patrizi, Marco Cadoli: 
  "Evaluating ASP and commercial solvers on the CSPLib"
  http://www.dis.uniroma1.it/~tmancini/index.php?problemid=032&solver=OPL&spec=BASE&currItem=research.publications.webappendices.csplib2x.problemDetails#listing

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   Size = 6,
   life(Size, Grid, Z),
   print_grid(Grid),
   writeln(z=Z),
   nl.

print_grid(Grid) =>
   foreach(G in Grid) 
      foreach(V in G) printf("%d", V) end, nl
   end.


life(Size, Grid, Z) =>

   GridSize = Size+4,

   Grid = new_array(GridSize,GridSize),
   Vars = vars(Grid),
   Vars :: 0..1,

   Z #= sum(Vars),
  
   % C1: Cells in the first/last two rows/columns are all 0 (dead)
   foreach(X in 1..GridSize)
          Grid[1,X] #= 0,
          Grid[2,X] #= 0,
          Grid[Size+3,X] #= 0,  
          Grid[Size+4,X] #= 0,
          Grid[X,1] #= 0,       
          Grid[X,2] #= 0,
          Grid[X,Size+3] #= 0,  
          Grid[X,Size+4] #= 0 
   end,
 
   foreach(R in 2..Size+3, C in 2..Size+3)
      % C2: Each cell of the board (except those of the first/last row/column) 
      %     that has exactly three live neighbors is alive. 
      %     Together with constraint C1, this implies that cells in the
      %     second/last-but-one row/column cannot have three live neighbors.
      ( ( Grid[R-1,C-1] + Grid[R-1,C] + Grid[R-1,C+1] + 
          Grid[R,C-1] + Grid[R,C+1] + 
          Grid[R+1,C-1] + Grid[R+1,C] + Grid[R+1,C+1]
        ) #= 3 
      ) #=> (Grid[R,C] #= 1)
      ,
           
      % C3: Each live cell must have 2 or 3 live neighbors (cells of the first/last 
      % row/column may be ignored by this constraint)
      (Grid[R,C] #= 1) #=> 
            2 #=< 
            ( Grid[R-1,C-1] + Grid[R-1,C] + Grid[R-1,C+1] +
              Grid[R,C-1] + Grid[R,C+1] +
              Grid[R+1,C-1] + Grid[R+1,C] + Grid[R+1,C+1] 
            )
            #/\
            ( Grid[R-1,C-1] + Grid[R-1,C] + Grid[R-1,C+1] +
              Grid[R,C-1] + Grid[R,C+1] +
              Grid[R+1,C-1] + Grid[R+1,C] + Grid[R+1,C+1] 
            ) #=< 3
   end,

   % SBSO: Symmetry-breaking by selective ordering
   % The assignment is forced to respect an ordering on the values that occur in corner entries
   % of the board. In particular:  
   % - if the NW-corner cell is dead, the SE-corner cell
   % must be dead too 
   % - if the NE-corner cell is dead, the SW-corner cell must be dead too
   % 
   Grid[2,2] #>= Grid[Size+1,Size+1],
   Grid[2,Size+1] #>= Grid[Size+1,2],

   solve([$max(Z),min,updown], Vars).

/* 

  MicroSam in Picat.

  Simplified version of SAM (Script Applier Mechanism).

  This Picat version is based on the Prolog code from
  Leon S. Sterling: "The Art of Prolog", 2nd edition,
  page 274ff.

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go ?=> 
   test_mcsam(Name,UnderstoodStory),
   writeln(name=Name),
   % writeln(understoodStory=UnderstoodStory),
   foreach(S in UnderstoodStory) writeln(S) end,
   nl,
   fail.

mcsam(Story,Script) =>  
   find(Story,Script,Defaults),
   match(Script,Story),
   name_defaults(Defaults).

find(Story,Script,Defaults) => 
   filler(Slot,Story),
   trigger(Slot,Name),
   script(Name,Script,Defaults).

/*
   match(Script,Story) =>
      Story is a subsequence of Script.
*/
match(_Script,Story) ?=> Story = [].
match(LineScript,LineStory) ?=> 
    LineScript = [Line|Script],
    LineStory = [Line|Story],
    match(Script,Story).
match(LineScript, LineStory) => 
    LineScript = [_Line|Script],
    LineStory = Story,
    match(Script,Story).

/*
   filler(Slot,Story) =>
      Slot is a word in Story.
*/

filler(Slot,Story) => 
   member([_Action|Args],Story),
   member(Slot,Args),
   nonvar(Slot).

/*
   name_defaults(Defaults) =>
      Unifies default pairs in Defaults.
*/

name_defaults(Defaults) ?=> 
   Defaults = [].
name_defaults(Defaults) ?=>  
   Defaults = [[N,N]|L],
   name_defaults(L).
name_defaults(Defaults) =>  
   Defaults = [[N1,N2]|L],
   N1 != N2, 
   name_defaults(L).


%
% Program 14.17 (page 277)
%
% The story is
%    "John went to Leones, ate a hamburger, and left."
% 
test_mcsam(Name,UnderstoodStory) =>
   story(Name,Story), 
   mcsam(Story,UnderstoodStory).

story(Name, Story) ?=> 
   Name=test,
   Story=[[ptrans, john, john, _X1, leones],
          [ingest, _X2, hamburger, _X3],
          [ptrans, Actor, Actor, _X4, _X5] ].

script(Name, Script, Defaults) => 
   Name = restaurant,
   Script = 
   [ [ptrans, Actor, Actor, Earlier_place, Restaurant],
     [ptrans, Actor, Actor, Door, Seat],
     [mtrans, Actor, Waiter, Food],
     [ingest, Actor, Food, [mouth, Actor] ],
     [atrans, Actor, Money, Actor, Waiter],
     [ptrans, Actor, Actor, Restaurant, Gone] ],
   Defaults = [ [Actor, customer], [Earlier_place, place1],
     [Restaurant, restaurant], [Door, door],
     [Seat, seat], [Food, meal], [Waiter, waiter],
     [Money, check], [Gone, place2] ].

trigger(Slot, Name) ?=> 
   Slot = leones, 
   Name=restaurant.  
trigger(Slot, Name) => 
   Slot = waiter, 
   Name = restaurant.
/*

  Minesweeper solver in Picat.

  From gecode/examples/minesweeper.cc:
  """
  A specification is a square matrix of characters. Alphanumeric
  characters represent the number of mines adjacent to that field. 
  Dots represent fields with an unknown number of mines adjacent to 
  it (or an actual mine).
  """
  
  E.g.
       "..2.3."
       "2....."
       "..24.3"
       "1.34.."
       ".....3"
       ".3.3.."
  """
  
  Also see:
  * http://www.janko.at/Raetsel/Minesweeper/index.htm

  * http://en.wikipedia.org/wiki/Minesweeper_(computer_game)
 
  * Ian Stewart on Minesweeper: 
    http://www.claymath.org/Popular_Lectures/Minesweeper/

  * Richard Kaye's Minesweeper Pages
    http://web.mat.bham.ac.uk/R.W.Kaye/minesw/minesw.htm

  * Some Minesweeper Configurations
    http://web.mat.bham.ac.uk/R.W.Kaye/minesw/minesw.pdf



  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% Problems 1..10, and 14: has unique solutions
%          11: 4 solutions
%          12: 2 solutions
%          13: many, many solutions (we just show the first here)
go =>   
   foreach(P in 1..14, P != 13)
      L = findall(_, $minesweeper(P)),
      writef("%d solution(s)\n", length(L))
   end,
   time2($minesweeper(13)).


% special for problem 13 (which has _many_ solutions)
go2 ?=>
  time2(minesweeper(13)), fail.

go2 => true.

% special for problem 15
% 19 solutions
go3 ?=>
  time2(minesweeper(15)), fail.
go3 => true.


%
% Main Minesweeper solver
%
minesweeper(Problem) =>

   problem(Problem, Game),
   writef("\nPROBLEM %d\n", Problem),
   
   % dimensions of the problem instance
   R = Game.length,
   C = Game[1].length,

   % decision variable: where is the mines?
   Mines = new_array(R,C),
   Mines :: 0..1, 

   %
   % Game[I,J] = _ means that it is unknown from start, may be a mine.
   % Games[I,J] >= 0 means that the value is known and that it is not a mine.
   %
   foreach(I in 1..R, J in 1..C)

         % some reasoning about this cell: not a mine
         if ground(Game[I,J]) then Mines[I,J] #= 0 end,

         % we check only those cells that we are unsure of, i.e.
         % when GameIJ >= 0
         if ground(Game[I,J]) then 
            % Sum the number of neighboring mines of this cell.
            % The number of neighboring mines must sum up to Game[I,J].
            Game[I,J] #= sum([Mines[I+A,J+B] :  A in -1..1, B in -1..1,
                              I+A >  0, J+B >  0,
                              I+A =< R, J+B =< C])
         end
   end,

   % search
   solve(Mines),

   % print
   pretty_print(Mines),
   nl.


pretty_print(X) =>
  foreach(I in 1..X.length)
    foreach(J in 1..X[1].length)
      if X[I,J] == 1 then writef("X") else writef("_") end
    end,
    nl
  end.

%
% data
%
%  _ is coded as unknown
%  0..8: known number of neighbours
%

% The first 10 examples (0..9) are from Gecode/examples/minesweeper.cc
% http://www.gecode.org/gecode-doc-latest/minesweeper_8cc-source.html
% """
% The instances are taken from
%   http://www.janko.at/Raetsel/Minesweeper/index.htm
% """


% Problem from Gecode/examples/minesweeper.cc  problem 0
% 
% Solution:
%  1 0 0 0 0 1
%  0 1 0 1 1 0
%  0 0 0 0 1 0
%  0 0 0 0 1 0
%  0 1 1 1 0 0
%  1 0 0 0 1 1
problem(0, P) => 
        P = {{_,_,2,_,3,_},
             {2,_,_,_,_,_},
             {_,_,2,4,_,3},
             {1,_,3,4,_,_},
             {_,_,_,_,_,3},
             {_,3,_,3,_,_}}.


% Problem from Gecode/examples/minesweeper.cc  problem 1
problem(1, P) => 
        P = {{_,2,_,2,1,1,_,_},
             {_,_,4,_,2,_,_,2},
             {2,_,_,2,_,_,3,_},
             {2,_,2,2,_,3,_,3},
             {_,_,1,_,_,_,4,_},
             {1,_,_,_,2,_,_,3},
             {_,2,_,2,2,_,3,_},
             {1,_,1,_,_,1,_,1}}.



% Problem from Gecode/examples/minesweeper.cc  problem 2
problem(2,P) => 
        P = {{1,_,_,2,_,2,_,2,_,_},
             {_,3,2,_,_,_,4,_,_,1},
             {_,_,_,1,3,_,_,_,4,_},
             {3,_,1,_,_,_,3,_,_,_},
             {_,2,1,_,1,_,_,3,_,2},
             {_,3,_,2,_,_,2,_,1,_},
             {2,_,_,3,2,_,_,2,_,_},
             {_,3,_,_,_,3,2,_,_,3},
             {_,_,3,_,3,3,_,_,_,_},
             {_,2,_,2,_,_,_,2,2,_}}.


% Problem from Gecode/examples/minesweeper.cc  problem 3
problem(3, P) => 
        P = {{2,_,_,_,3,_,1,_},
             {_,5,_,4,_,_,_,1},
             {_,_,5,_,_,4,_,_},
             {2,_,_,_,4,_,5,_},
             {_,2,_,4,_,_,_,2},
             {_,_,5,_,_,4,_,_},
             {2,_,_,_,5,_,4,_},
             {_,3,_,3,_,_,_,2}}.


% Problem from Gecode/examples/minesweeper.cc  problem 4
problem(4,P) => 
        P = {{0,_,0,_,1,_,_,1,1,_},
             {1,_,2,_,2,_,2,2,_,_},
             {_,_,_,_,_,_,2,_,_,2},
             {_,2,3,_,1,1,_,_,_,_},
             {0,_,_,_,_,_,_,2,_,1},
             {_,_,_,2,2,_,1,_,_,_},
             {_,_,_,_,_,3,_,3,2,_},
             {_,5,_,2,_,_,_,3,_,1},
             {_,3,_,1,_,_,3,_,_,_},
             {_,2,_,_,_,1,2,_,_,0}}.


% Problem from Gecode/examples/minesweeper.cc  problem 5
problem(5,P) => 
        P = {{_,2,1,_,2,_,2,_,_,_},
             {_,4,_,_,3,_,_,_,5,3},
             {_,_,_,4,_,4,4,_,_,3},
             {4,_,4,_,_,5,_,6,_,_},
             {_,_,4,5,_,_,_,_,5,4},
             {3,4,_,_,_,_,5,5,_,_},
             {_,_,4,_,4,_,_,5,_,5},
             {2,_,_,3,3,_,6,_,_,_},
             {3,6,_,_,_,3,_,_,4,_},
             {_,_,_,4,_,2,_,2,1,_}}.



% Problem from Gecode/examples/minesweeper.cc  problem 6
problem(6, P) => 
        P = {{_,3,2,_,_,1,_,_},
             {_,_,_,_,1,_,_,3},
             {3,_,_,2,_,_,_,4},
             {_,5,_,_,_,5,_,_},
             {_,_,6,_,_,_,5,_},
             {3,_,_,_,5,_,_,4},
             {2,_,_,5,_,_,_,_},
             {_,_,2,_,_,3,4,_}}.


% Problem from Gecode/examples/minesweeper.cc  problem 7
problem(7, P) => 
        P = {{_,1,_,_,_,_,_,3,_},
             {_,_,_,3,4,3,_,_,_},
             {2,4,4,_,_,_,4,4,3},
             {_,_,_,4,_,4,_,_,_},
             {_,4,_,4,_,3,_,6,_},
             {_,_,_,4,_,3,_,_,_},
             {1,2,3,_,_,_,1,3,3},
             {_,_,_,3,2,2,_,_,_},
             {_,2,_,_,_,_,_,3,_}}.



% Problem from Gecode/examples/minesweeper.cc  problem 8
problem(8, P) => 
        P = {{_,_,_,_,_,_,_},
             {_,2,3,4,3,5,_},
             {_,1,_,_,_,3,_},
             {_,_,_,5,_,_,_},
             {_,1,_,_,_,3,_},
             {_,1,2,2,3,4,_},
             {_,_,_,_,_,_,_}}.


% Problem from Gecode/examples/minesweeper.cc  problem 9
problem(9, P) => 
        P = {{2,_,_,_,2,_,_,_,2},
             {_,4,_,4,_,3,_,4,_},
             {_,_,4,_,_,_,1,_,_},
             {_,4,_,3,_,3,_,4,_},
             {2,_,_,_,_,_,_,_,2},
             {_,5,_,4,_,5,_,4,_},
             {_,_,3,_,_,_,3,_,_},
             {_,4,_,3,_,5,_,6,_},
             {2,_,_,_,1,_,_,_,2}}.



% From "Some Minesweeper Configurations",page 2
problem(10, P) => 
         P = {{_,_,_,_,_,_},
              {_,2,2,2,2,_},
              {_,2,0,0,2,_},
              {_,2,0,0,2,_},
              {_,2,2,2,2,_},
              {_,_,_,_,_,_}}.



% From "Some Minesweeper Configurations",page 3
% 4 solutions
problem(11, P) => 
         P = {{2,3,_,2,2,_,2,1},
              {_,_,4,_,_,4,_,2},
              {_,_,_,_,_,_,4,_},
              {_,5,_,6,_,_,_,2},
              {2,_,_,_,5,5,_,2},
              {1,3,4,_,_,_,4,_},
              {0,1,_,4,_,_,_,3},
              {0,1,2,_,2,3,_,2}}.


% Richard Kaye: How Complicated is Minesweeper?
% http://web.mat.bham.ac.uk/R.W.Kaye/minesw/ASE2003.pdf
% 
% A Wire,page 33
% 2 solutions
%
problem(12, P) => 
         P = {{_,0,0,0,0,0,0,0,0,0,0,0,0,_},
              {_,1,1,1,1,1,1,1,1,1,1,1,1,_},
              {_,_,1,_,_,1,_,_,1,_,_,1,_,_},
              {_,1,1,1,1,1,1,1,1,1,1,1,1,_},
              {_,0,0,0,0,0,0,0,0,0,0,0,0,_}}.


% Richard Kaye: How Complicated is Minesweeper?
% http://web.mat.bham.ac.uk/R.W.Kaye/minesw/ASE2003.pdf
% A splitter,page 35
% Many solutions...
%
problem(13, P) => 
          P= {{_,_,_,0,_,_,_,0,_,_,_},
              {_,_,_,0,1,_,1,0,_,_,_},
              {_,_,_,0,1,_,1,0,_,_,_},
              {0,0,0,0,1,1,1,0,0,0,0},
              {_,1,1,1,1,_,1,1,1,1,_},
              {_,_,_,1,_,2,_,1,_,_,_},
              {_,1,1,1,1,_,1,1,1,1,_},
              {0,0,0,0,1,1,1,0,0,0,0},
              {_,_,_,0,1,_,1,0,_,_,_},
              {_,_,_,0,1,_,1,0,_,_,_},
              {_,_,_,0,_,_,_,0,_,_,_}}.
        


% Oleg German,Evgeny Lakshtanov: "Minesweeper" without a computer
% http://arxiv.org/abs/0806.3480, page 4
problem(14, P) => 
         P = {{_,1,_,1,_,1},
              {2,_,2,_,1,_},
              {_,3,_,2,_,1},
              {1,_,3,_,2,_},
              {_,1,_,2,_,1}}.


%
% From http://stephenlombardi.com/minesweeper/minesweeper.lisp
%
problem(15,P) =>
  P = 
{{0,0,0,0,1,_,_,_,_},
 {0,0,0,0,1,_,_,3,_},
 {0,0,1,1,2,_,_,_,_},
 {0,0,1,_,_,_,_,1,_},
 {0,0,1,2,_,3,_,_,_},
 {0,0,0,1,_,_,_,_,_},
 {0,0,1,2,2,1,1,1,1},
 {0,0,1,_,1,0,0,0,0},
 {0,0,1,_,1,0,0,0,0}}./* 

  Missionaries and cannibals problem in Picat.

  See
  http://en.wikipedia.org/wiki/Missionaries_and_cannibals_problem

  Inspired by this Prolog code
  http://www-users.cs.york.ac.uk/~suresh/LAI/exercise1-sol/node3.html
  http://www-users.cs.york.ac.uk/~suresh/LAI/exercise1-sol/node6.html

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
   initial_state(Init),
   time(plan2(Init,L,Cost)),
   foreach(Move in L) writeln(Move) end,
   nl,
   writeln(len=L.length),
   writeln(cost=Cost),
   nl.

initial_state(Init) => Init=[3,3,left].

goal_state(Goal) => Goal=[0,0,_].


legal([LM,LC,_]) ?=>
    %% left-hand side either missionaries greater-equals cannibals
    %%                 or    no missionaries and some cannibals
    ( LM >= LC ; (LM == 0, not(LC==0)) ),
    %% right-hand side either missionaries greater-equals cannibals
    %%                 or    no missionaries and some cannibals
    ( (3 - LM) >= (3 - LC) ; (LM == 3, not(LC==3)) ).


table
%% Move 1 missionary across to right
legal_move(From,Move,To,Cost) ?=> 
    From=[LM,LC,left],
    To=[NLM,LC,right],
    Move=[m1_to_right,To],
    LM >= 1,
    NLM = LM - 1,
    legal([NLM,LC,right]),Cost=1.

%% Move 1 missionary across to left
legal_move(From,Move,To,Cost) ?=> 
    From=[LM,LC,left],
    To=[NLM,LC,right],
    Move=[m1_to_left,To],
    (3 - LM) >= 1,
    NLM = LM + 1,
    legal([NLM,LC,right]),Cost=1.


%% Move 1 cannibal across to right
legal_move(From,Move,To,Cost) ?=> 
    From=[LM,LC,left],
    To=[LM,NLC,right],
    Move=[c1_to_right,To],
    LC >= 1,
    NLC = LC - 1,
    legal([LM,NLC,right]),Cost=1.

%% Move 1 cannibal across to left
legal_move(From,Move,To,Cost) ?=> 
    From=[LM,LC,right],
    To=[LM,NLC,left],
    Move=[c1_to_left,To],
    (3 - LC) >= 1,
    NLC = LC + 1,
    legal([LM,NLC,left]),Cost=1.

%% Move 2 missionaries across to right
legal_move(From,Move,To,Cost) ?=> 
    From=[LM,LC,left],
    To=[NLM,LC,right],
    Move=[m2_to_right,To],
    LM >= 2,
    NLM = LM - 2,
    legal([NLM,LC,right]),Cost=1.

%% Move 2 missionaries across to left
legal_move(From,Move,To,Cost) ?=> 
    From=[LM,LC,right],
    To=[NLM,LC,left],
    Move=[m2_to_left,To],
    (3 - LM) >= 2,
    NLM = LM + 2,
    legal([NLM,LC,right]),Cost=1.

%% Move 2 cannibals across to right
legal_move(From,Move,To,Cost) ?=> 
    From=[LM,LC,left],
    To=[LM,NLC,right],
    Move=[c2_to_right,To],
    LC >= 2,
    NLC = LC - 2,
    legal([LM,NLC,right]),Cost=1.

%% Move 2 cannibals across to left
legal_move(From,Move,To,Cost) ?=> 
    From=[LM,LC,right],
    To=[LM,NLC,left],
    Move=[c2_to_left,To],
    (3 - LC) >= 2,
    NLC = LC + 2,
    legal([LM,NLC,left]),Cost=1.


%% Move 1 missionary + 1 cannibal across to right
legal_move(From,Move,To,Cost) ?=> 
    From=[LM,LC,left],
    To=[NLM,NLC,right],
    Move=[m1c1_to_right,To],
    LM >= 1,
    LC >= 1,
    NLM = LM - 1,
    NLC = LC - 1,
    legal([NLM,NLC,right]),Cost=1.


%% Move 1 missionary + 1 cannibal across to left
legal_move(From,Move,To,Cost) => 
    From=[LM,LC,right],
    To=[NLM,NLC,left],
    Move=[m1c1_to_left,To],
    (3 - LM) >= 1,
    (3 - LC) >= 1,
    NLM = LM + 1,
    NLC = LC + 1,
    legal([NLM,NLC,left]),Cost=1.
/*

  Simple money change problem in Picat.

 

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   problem(1,Value, Coins),
   solveit(Value,Coins).

go2 =>
   problem(2,Value, Coins),
   solveit(Value,Coins).

solveit(Value,Coins) =>
   L = findall(X, $money(Value, Coins, X)),
   writeln(L),
   writeln(len=L.length),
   nl.

scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).


money(Value, Coins, X) =>
   
   N = length(Coins),
   X = new_list(N),
   X :: 0..Value,
   scalar_product(Coins, X, Value),
   solve(X).


% problem(Problem, Value, Coins).
problem(1, Value, Coins) => Value = 100, Coins = [100,50,25,10,5,1].
problem(2, Value, Coins) => Value = 100, Coins = [100,50,25,10,5,2,1].
/* 

  Monkey and bananas problem in Picat.

  Inspired by the Prolog code in Thinking as Computation. 

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
   initial_state(Init),
   % time(bplan(Init,L)),
   time(plan2(Init,L,Cost)),
   write(L), nl,
   writeln(len=L.length),
   writeln(cost=Cost),
   nl.


%  This is the monkey and bananas as a planning problem.

% The bananas, monkey, and box are at different locations.
% The monkey is not on the box and has no bananas.
initial_state(Init) => Init=[loc1,loc2,loc3,n,n].


% The goal is any state where the monkey has the bananas.
goal_state(Goal) => Goal=[_,_,_,_,y].

table
% Climbing on the box causes the monkey to be on the box.
legal_move(From,Move,To,Cost) ?=> 
   From=[B,M,M,n,H],Move=climb_on,To=[B,M,M,y,H],Cost=1.

% Climbing off the box causes the monkey to be off the box.
legal_move(From,Move,To,Cost) ?=> 
   From=[B,M,M,y,H],Move=climb_off,To=[B,M,M,n,H],Cost=1.

% Grabbing the bananas causes the monkey to have the bananas.
legal_move(From,Move,To,Cost) ?=> 
   From=[B,B,B,y,n],Move=grab,To=[B,B,B,y,y],Cost=1.

% Pushing the box changes where the monkey and the box are.
legal_move(From,Move,To,Cost) ?=> 
   From=[B,M,M,n,H],Move=$push(X),To=[B,X,X,n,H],Cost=1.

% Going to a location changes where the monkey is.
legal_move(From,Move,To,Cost) =>   
   From=[B,_,L,n,H],Move=$go(X),To=[B,X,L,n,H],Cost=1.
/*

  Monks and doors problem in Picat.

  From http://user.it.uu.se/~rolandb/LP/gammal/960615_facit.ps
  """
  There is a room with four doors and eight monks. One or more of
  the doors may be exit. Each monk is either telling a lie or the truth.
 
  The monks make the following statements:
  Monk 1: Door A is the exit.
  Monk 2: At least one of the doors B and C is the exit.
  Monk 3: Monk 1 and Monk 2 are telling the truth.
  Monk 4: Doors A and B are both exits.
  Monk 5: Doors A and B are both exits.
  Monk 6: Either Monk 4 or Monk 5 is telling the truth.
  Monk 7: If Monk 3 is telling the truth, so is Monk 6.
  Monk 8: If Monk 7 and Monk 8 are telling the truth, so is Monk 1.
 
  Which door is an exit no matter who is a liar and who is telling the
  truth.
  """
 
  Answer: Door A is an exit.
          And monks 1, 7, and 8 are telling the truth.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   Doors = [A,B,C,D],
   Doors :: 0..1,
   Monks = [M1,M2,M3,M4,M5,M6,M7,M8],
   Monks :: 0..1,

   % Monk 1: Door A is the exit.
   M1 #= A, 
   
   %  Monk 2: At least one of the doors B and C is the exit.
   M2 #= 1 #<=> (B + C #>= 1),
   
   %  Monk 3: Monk 1 and Monk 2 are telling the truth.
   M3 #= 1 #<=> (M1 #/\ M2),
   
   %  Monk 4: Doors A and B are both exits.
   M4 #= 1 #<=> (A #/\ B) ,
   
   %  Monk 5: Doors A and C are both exits.
   M5 #= 1 #<=> (A #/\ C),
   
   %  Monk 6: Either Monk 4 or Monk 5 is telling the truth.
   M6 #= 1 #<=> (M4 #\/ M5),
   
   %  Monk 7: If Monk 3 is telling the truth, so is Monk 6.
   M7 #= 1 #<=> (M3 #=> M6),
   
   %  Monk 8: If Monk 7 and Monk 8 are telling the truth, so is Monk 1.
   M8 #= 1 #<=> ((M7 #/\ M8) #=> (M1)),
   
   % Exactly one door is an exit.
   (A + B + C + D) #= 1,
   
   FD = Doors ++ Monks,
   solve([], FD),

   writeln(exit_doors=Doors),
   DoorsS = ["A","B","C","D"],
   println(exit_doors=[DoorsS[I] : I in 1..4, Doors[I] = 1]),
   println(truth_telling_monks=Monks),
   println(truth_telling_monks=[I : I in 1..8, Monks[I] = 1]),
   nl.
/*

  Monte Carlo methods in Picat.

  From Rosetta code: 
  http://rosettacode.org/wiki/Monte_Carlo_methods
  """
  A Monte Carlo Simulation is a way of approximating the value of a 
  function where calculating the actual value is difficult or impossible. 
  It uses random sampling to define constraints on the value and then makes 
  a sort of "best guess."

  A simple Monte Carlo Simulation can be used to calculate the value for . 
  If you had a circle and a square where the length of a side of the square 
  was the same as the diameter of the circle, the ratio of the area of the 
  circle to the area of the square would be /4. So, if you put this circle 
  inside the square and select many random points inside the square, the number 
  of points inside the circle divided by the number of points inside the square 
  and the circle would be approximately /4.

  Write a function to run a simulation like this with a variable number of 
  random points to select. Also, show the results of a few different sample 
  sizes. For software where the number  is not built-in, we give  to a 
  couple of digits: 3.141592653589793238462643383280 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
   foreach(N in 0..6)
      time(sim_pi(10**N))
   end,
   nl.

go2 => 
   foreach(N in 0..6)
      time(sim_pi2(10**N))
   end,
   nl.


sim_pi(N) =>
  println($sim_pi(N)),
  Inside = sim(N, pi_f),
  println(inside=Inside),
  MyPi = 4.0*Inside/N,
  println(myPi=MyPi),
  Pi = 4*atan2(1,1),
  println(pi=Pi),
  println([n=N, myPi=MyPi, diff=Pi-MyPi]).


sim_pi2(N) =>
  Inside = sim2(N, pi_f),
  MyPi = 4.0*Inside/N,
  Pi = 4*atan2(1,1),
  println([n=N, myPi=MyPi, diff=Pi-MyPi]).



% the simulation function: 
%    returns 1 if success, 0 otherwise
% pi_f() = cond(randf()**2 + randf()**2 <= 1, 1, 0).
pi_f() = cond(frand()**2 + frand()**2 <= 1, 1, 0).

% simple (but general) Monte Carlo simulator
% f() is the simulation function
sim(N, F) = C =>
  println($sim(N, F)),
  C = 0,
  foreach (_I in 1..N) 
    % println(c=C),
    C := C + apply($F)
  end.

sim2(N, F) = sum([apply(F) : _I in 1..N]). 


% random value between 0.0..1.0
randf() = V => (_I,V) = modf(random()/1000000.0).
/*

  Mr Smith problem in Picat.

  From an IF Prolog example (http://www.ifcomputer.de/)
  """
  The Smith family and their three children want to pay a visit but they
  do not all have the time to do so. Following are few hints who will go
  and who will not:
      o If Mr Smith comes, his wife will come too.
      o At least one of their two sons Matt and John will come.
      o Either Mrs Smith or Tim will come, but not both.
      o Either Tim and John will come, or neither will come.
      o If Matt comes, then John and his father will
        also come.
  """

  The answer should be:
    Mr_Smith_comes      =  0
    Mrs_Smith_comes     =  0
    Matt_comes          =  0
    John_comes          =  1
    Tim_comes           =  1

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   write(findall(L,$mr_smith(L))),nl.

mr_smith(L) =>

   L = [Mr_Smith,Mrs_Smith,Matt, John,Tim],
   L :: 0..1,

   % If Mr Smith comes, his wife will come too.
   Mr_Smith #=> Mrs_Smith,

   % At least one of their two sons Matt and John will come.
   Matt #\/ John,

   % Either Mrs Smith or Tim will come, but not both.
   % Mrs_Smith + Tim #= 1,
   Mrs_Smith #^ Tim,

   % Either Tim and John will come, or neither will come.
   Tim #= John,

   % If Matt comes, then John and his father will also come.
   Matt #=> (John #/\ Mr_Smith),

   solve([],L).
/* 

  Mtak benchmark in Picat.

  From 
  http://www.jekejeke.ch/idatab/doclet/prod/en/docs/05_run/15_stdy/06_bench/09_programs/09_mtak/01_mtak.p.html

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


/**
 * Prolog code for the tak function benchmark.
 *
 * McCarthys tak function.
 * Modification of the tarai function from Takeuchi.
 *
 * Copyright 2010-2012, XLOG Technologies GmbH, Switzerland
 * Jekejeke Prolog 0.8.3 (a fast and small prolog interpreter)
 */

fun(X,Y,Z,A), X =< Y =>
    Z = A.

fun(X,Y,Z,A) =>
    X1 = X - 1,
    fun(X1,Y,Z,A1),
    Y1 = Y - 1,
    fun(Y1,Z,X,A2),
    Z1 = Z - 1,
    fun(Z1,X,Y,A3),
    fun(A1,A2,A3,A).

mtak =>
    fun(18, 12, 6, M),  
    writeln(M).

mtak2 =>
    fun(18, 12, 6, _M).


go2 => mtak2./* 

  Multiplicative sequence in Picat.

  From "Mind Your Decision"
  "Monday puzzle: can you guess the 1000th number in my list?"
  http://mindyourdecisions.com/blog/2013/08/12/monday-puzzle-can-you-guess-the-1000-number-in-my-list/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+mindyourdecisions+%28Mind+Your+Decisions%29
  """
  I have written a long, long sequence of positive whole numbers. 
  Can you guess the 1,000 item on my list?
  
  I will give you 3 clues about my sequence of numbers {a[n]}:
    1. The list of numbers is strictly increasing (a[k] + 1 > a[k])
    2. The second number in my list is 2 (a[2] = 2)
    3. My list always has a(m*n) = a[m]*a[n] when the two numbers m and n are 
       relatively prime. (Call this the multiplicative property). For 
       example, a[60] = a[4]*a[15] because 4 and 15 are relatively prime.
  
  What possible number(s) could I have written for a1000?
  
  I admit I did not solve this puzzle on my own. Can you?
  
  ...
  
  Source of puzzle: this is puzzle 42 from the website qbyte.org 
  [
      http://www.qbyte.org/puzzles/puzzle05.html
      "Multiplicative sequence"
  ]

  """

  Note: Here are the number of solutions for some N << 1000
        (for the somewhat arbitrary domain of X in 1..2*N):

     N: #num solutions
   ------------------------------
     2: 1 (prime: 1) N*N:3
     3: 4 (prime: 1) N*N:4
     4: 15 (prime: 0) N*N:5
     5: 56 (prime: 1) N*N:6
     6: 20 (prime: 0) N*N:7
     7: 70 (prime: 1) N*N:8
     8: 38 (prime: 0) N*N:9
     9: 140 (prime: 0) N*N:10
    10: 68 (prime: 0) N*N:11
    11: 276 (prime: 1) N*N:12


  For 12..100: when N is a prime then there is > 1 solutions.
  Then the number of solutions is 1+N, i.e. the last
  element (X[N]) will be all the values in the range N..2*N.

  I don't understand the number of solutions for N < 12, though.

     2: 1 (prime: 1) N*N:3
     3: 4 (prime: 1) N*N:4
     4: 15 (prime: 0) N*N:5
     5: 56 (prime: 1) N*N:6
     6: 20 (prime: 0) N*N:7
     7: 70 (prime: 1) N*N:8
     8: 38 (prime: 0) N*N:9
     9: 140 (prime: 0) N*N:10
    10: 68 (prime: 0) N*N:11
    11: 276 (prime: 1) N*N:12
    12: 1 (prime: 0) N*N:13
    13: 14 (prime: 1) N*N:14
    14: 1 (prime: 0) N*N:15
    15: 1 (prime: 0) N*N:16
    16: 1 (prime: 0) N*N:17
    17: 18 (prime: 1) N*N:18
    18: 1 (prime: 0) N*N:19
    19: 20 (prime: 1) N*N:20
    20: 1 (prime: 0) N*N:21
    21: 1 (prime: 0) N*N:22
    22: 1 (prime: 0) N*N:23
    23: 24 (prime: 1) N*N:24
    24: 1 (prime: 0) N*N:25
    25: 26 (prime: 0) N*N:26
    26: 1 (prime: 0) N*N:27
    27: 1 (prime: 0) N*N:28
    28: 1 (prime: 0) N*N:29
    29: 30 (prime: 1) N*N:30
    30: 1 (prime: 0) N*N:31
    31: 32 (prime: 1) N*N:32
    32: 1 (prime: 0) N*N:33
    33: 1 (prime: 0) N*N:34
    34: 1 (prime: 0) N*N:35
    35: 1 (prime: 0) N*N:36
    36: 1 (prime: 0) N*N:37
    37: 38 (prime: 1) N*N:38
    38: 1 (prime: 0) N*N:39
    39: 1 (prime: 0) N*N:40
    40: 1 (prime: 0) N*N:41
    41: 42 (prime: 1) N*N:42
    42: 1 (prime: 0) N*N:43
    43: 44 (prime: 1) N*N:44
    44: 1 (prime: 0) N*N:45
    45: 1 (prime: 0) N*N:46
    46: 1 (prime: 0) N*N:47
    47: 48 (prime: 1) N*N:48
    48: 1 (prime: 0) N*N:49
    49: 50 (prime: 0) N*N:50
    50: 1 (prime: 0) N*N:51
    51: 1 (prime: 0) N*N:52
    52: 1 (prime: 0) N*N:53
    53: 54 (prime: 1) N*N:54
    54: 1 (prime: 0) N*N:55
    55: 1 (prime: 0) N*N:56
    56: 1 (prime: 0) N*N:57
    57: 1 (prime: 0) N*N:58
    58: 1 (prime: 0) N*N:59
    59: 60 (prime: 1) N*N:60
    60: 1 (prime: 0) N*N:61
    61: 62 (prime: 1) N*N:62
    62: 1 (prime: 0) N*N:63
    63: 1 (prime: 0) N*N:64
    64: 1 (prime: 0) N*N:65
    65: 1 (prime: 0) N*N:66
    66: 1 (prime: 0) N*N:67
    67: 68 (prime: 1) N*N:68
    68: 1 (prime: 0) N*N:69
    69: 1 (prime: 0) N*N:70
    70: 1 (prime: 0) N*N:71
    71: 72 (prime: 1) N*N:72
    72: 1 (prime: 0) N*N:73
    73: 74 (prime: 1) N*N:74
    74: 1 (prime: 0) N*N:75
    75: 1 (prime: 0) N*N:76
    76: 1 (prime: 0) N*N:77
    77: 1 (prime: 0) N*N:78
    78: 1 (prime: 0) N*N:79
    79: 80 (prime: 1) N*N:80
    80: 1 (prime: 0) N*N:81
    81: 1 (prime: 0) N*N:82
    82: 1 (prime: 0) N*N:83
    83: 84 (prime: 1) N*N:84
    84: 1 (prime: 0) N*N:85
    85: 1 (prime: 0) N*N:86
    86: 1 (prime: 0) N*N:87
    87: 1 (prime: 0) N*N:88
    88: 1 (prime: 0) N*N:89
    89: 90 (prime: 1) N*N:90
    90: 1 (prime: 0) N*N:91
    91: 1 (prime: 0) N*N:92
    92: 1 (prime: 0) N*N:93
    93: 1 (prime: 0) N*N:94
    94: 1 (prime: 0) N*N:95
    95: 1 (prime: 0) N*N:96
    96: 1 (prime: 0) N*N:97
    97: 98 (prime: 1) N*N:98
    98: 1 (prime: 0) N*N:99
    99: 1 (prime: 0) N*N:100
    100: 1 (prime: 0) N*N:101

    sols=[1,4,15,56,20,70,38,140,68,276,1,14,1,1,1,18,1,20,1,1,1,24,1,26,1,1,1,30,1,32,1,1,1,1,1,38,1,1,1,42,1,44,1,1,1,48,1,50,1,1,1,54,1,1,1,1,1,60,1,62,1,1,1,1,1,68,1,1,1,72,1,74,1,1,1,1,1,80,1,1,1,84,1,1,1,1,1,90,1,1,1,1,1,1,1,98,1,1,1]

  (OEIS don't recognize the sequence 1,4,15,56,20,70,38,140,68,276)

  And some larger values
    991: 992 (prime: 1) 2*N:992
    992: 1 (prime: 0) 2*N:993
    993: 1 (prime: 0) 2*N:994
    994: 1 (prime: 0) 2*N:995
    995: 1 (prime: 0) 2*N:996
    996: 1 (prime: 0) 2*N:997
    997: 998 (prime: 1) 2*N:998
    998: 1 (prime: 0) 2*N:999
    999: 1 (prime: 0) 2*N:1000
    1000: 1 (prime: 0) 2*N:1001
    1001: 1 (prime: 0) 2*N:1002
    1002: 1 (prime: 0) 2*N:1003
    1003: 1 (prime: 0) 2*N:1004
    1004: 1 (prime: 0) 2*N:1005
    1005: 1 (prime: 0) 2*N:1006
    1006: 1 (prime: 0) 2*N:1007
    1007: 1 (prime: 0) 2*N:1008
    1008: 1 (prime: 0) 2*N:1009
    1009: 1010 (prime: 1) 2*N:1010
    1010: 1 (prime: 0) 2*N:1011
    1011: 1 (prime: 0) 2*N:1012
    1012: 1 (prime: 0) 2*N:1013
    1013: 1014 (prime: 1) 2*N:1014


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go ?=> 
  N = 1000,
  seq(N, X),
  writeln(x=X),
  nl,
  fail.

go2 => 
  Sols = [],
  foreach(N in 2..100) 
    All = findall(X, seq(N,X)),
    Len = All.length,
    Prime = cond(prime(N), 1, 0),
    NN = 1+N, 
    printf("    %2d: %d (prime: %d) 2*N:%d\n", N,Len, Prime, NN),
    Sols := Sols ++ [Len]
  end,
  writeln(sols=Sols),
  nl.

go3 ?=> 
  N = 13,
  seq(N, X),
  writeln(x=X),
  nl,
  fail.

go3 => true.

go4 => 
  Sols = [],
  % Got some larger primes
  foreach(N in 991..1013) 
    All = findall(X, seq(N,X)),
    Len = All.length,
    Prime = cond(prime(N), 1, 0),
    NN = 1+N, 
    printf("    %2d: %d (prime: %d) 2*N:%d\n", N,Len, Prime, NN),
    Sols := Sols ++ [Len]
  end,
  writeln(sols=Sols),
  nl.


seq(N,X) =>

  X = new_array(N),
  X :: 1..N*2, % note: arbitrary domain 1..N*N
  
  foreach(I in 1..N, J in 1..N, I <= J, I*J <= N, I mod J != 0)
     % X[I*J] #= X[I]*X[J]
     X[I]*X[J] #= X[I*J]
  end,
  
  foreach(I in 2..N) 
    X[I-1] #< X[I]
  end,

  X[2] #= 2,

  solve([ff], X).

/* 

  Mu problem in Picat.

  Ported from Prolog program mu.pl
  http://sicstus.sics.se/sicstus/bench.zip
  """
  generated: 9 November 1989
  option(s): 

  mu

  derived from Douglas R. Hofstadter, "Godel, Escher, Bach," pages 33-35.

  prove "mu-math" theorem muiiu
  """

  Also, see http://en.wikipedia.org/wiki/MU_puzzle

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
   data(Data),
   % writeln(data=Data),
   All=findall(Out, $benchmark(Data, Out)),
   foreach(Sol in All) writeln(Sol) end,
   nl.

% From fast_mu.pl (from SICStus' bench.zip)
%
%     string          steps
%	miui		8
%	muii		8
%	muui		11
%	muiiu		6
%	miuuu		9
%	muiuu		9
%	muuiu		9
%	muuui		9

go2 => 
    Test = ["miiiii","miui","muii","muui","muiiu","miuuu","muiuu","muuiu","muuui"],
    foreach(T in Test)
       writeln(t=T),
       All=findall(Out, benchmark(T, Out)),
       foreach(Sol in All) writeln(Sol) end
    end,
    nl.

% random input
go3 => 
    UI = "ui",
    foreach(_T in 1..20)
      Len = 2+random2() mod 8,
      String := "m" ++ [UI[1+random2() mod 2] : _I in 2..Len],
     writeln(string=String),
      All=findall(Out, $benchmark(String, Out)),
      foreach(Sol in All) writeln(Sol) end,
      % benchmark(String, Out),
      % writeln(out=Out),
      nl
    end,
    nl.

% Get the shortest length
go4 => 
    String = "miiiii",
    Len :: 2..20,
    indomain(Len),
    writeln(len=Len),
    All=findall(Out, $theorem(String, Len, Out)),
    foreach(Sol in All) writeln(Sol) end,
    nl,
    (All.length == 0 -> fail ; true).




benchmark(Data, Out) =>
   Len = length(Data),
   theorem(Data, Len, Out).

data(Data) => Data = [m,u,i,i,u].

%% -> mi
theorem(MI, _, AMI) ?=> 
   MI = [m,i],
   AMI = [[a|[m,i]]].

%% -> mu
% theorem(MI, _, MU) ?=> 
%   MI = [m,i],
%   MU = [[a|[m,u]]].

theorem(R, Depth, NRP) =>
   NRP = [[N|R]|P],
   Depth > 0,
   D = Depth-1,
   theorem(S, D, P),
   rule(N, S, R).


rule(N, S, R), N= 1 ?=> rule1(S, R).
rule(N, S, R), N= 2 ?=> rule2(S, R).
rule(N, S, R), N= 3 ?=> rule3(S, R).
rule(N, S, R), N= 4  => rule4(S, R).


% Xi -> Xiu
rule1([i], R) ?=> R=[i,u].
rule1([H|X], R) =>
   R = [H|Y],
   rule1(X, Y).

% mX -> mXX
rule2([m|X], MY) => 
   MY = [m|Y],
   concatenate(X, X, Y).

% XiiiY -> XuY
rule3([i,i,i|X], R) ?=> 
   R = [u|X].
rule3([H|X], HY) =>
   HY = [H|Y],
   rule3(X, Y).

% XuuY -> XY
rule4(UUX, X) ?=>
   UUX = [u,u|X].
rule4([H|X], HY) =>
   HY = [H|Y],
   rule4(X, Y).

concatenate([], X, X2) => 
   X2 = X.
concatenate(AB, X, AB1) =>
   AB = [A|B],
   AB1 = [A|B1],
   concatenate(B, X, B1).
/*

  Music men puzzle in Picat.

  """
  Three friends like different kinds of music.  From the clues given
  below, can you identify them, say how old each is, and work out
  his musical preference?

  Clues: 
  1.      Rob is older than Queen, who likes classical music.
  2.      The pop-music fan, who is not Prince, is not 24.
  3.      Leon, who is not King, is 25.
  4.      Mark's musical preference is not jazz.
  """

  Knowledge: "this is what we know of the world."
  Names           : Leon, Mark, Rob.
  Surnames        : King, Prince, Queen.
  Ages            : 24, 25, 26.
  Music           : Classical, Jazz, Pop.


  Solution:
    Leon Prince, 25, jazz.
    Mark Queen, 24, classical.
    Rob King, 26, pop.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   music_men([Age,Names,Surnames,Music]),
   NamesS = ["King","Prince","Queen"],
   SurnamesS = ["Leon","Mark","Rob"],
   MusicS = ["classical","jazz","pop"],
   get_sol(Names,NamesS,NamesSol),
   get_sol(Surnames,SurnamesS,SurnamesSol),
   get_sol(Music,MusicS,MusicSol),
   foreach(I in 1..NamesS.length)
      printf("%s %s, %d, %s\n", SurnamesSol[I],NamesSol[I],Age[I],MusicSol[I])
   end,
   nl.


go2 =>
   L = findall([age=Age,names=Names,surnames=Surnames,music=Music],
                $music_men([Age,Names,Surnames,Music])),
   writeln(L),nl.


go3 =>
   music_men([[Age24, Age25, Age26],
             [King, Prince, Queen],
             [Leon, Mark, Rob],
             [Classical, Jazz, Pop]]),
   writeln([age24=Age24, age25=Age25, age26=Age26]),
   writeln([king=King, prince=Prince, queen=Queen]),
   writeln([leon=Leon, mark=Mark, rob=Rob]),
   writeln([classical=Classical, jazz=Jazz, pop=Pop]),nl.


% lookup the solution given the age list
get_sol(List,Lookup,Sol) =>
   Sol = [Val : L in List, Ix = L - 23, Val=Lookup[Ix]].
      

music_men([Age,Names,Surnames,Music]) =>

   Age      = [Age24, Age25, Age26],
   Names    = [King, Prince, Queen],
   Surnames = [Leon, Mark, Rob],
   Music    = [Classical, Jazz, Pop],

   Age      = [24,25,26],
   Names    :: 24..26,
   Surnames :: 24..26,
   Music    :: 24..26,

   all_different(Age),
   all_different(Names),
   all_different(Surnames),
   all_different(Music),

   % Age
   Age24 #= 24,
   Age25 #= 25,
   Age26 #= 26,

   % Rob is older than Queen, who likes classical music.
   Rob #> Queen,
   Queen #= Classical,

   % The pop-music fan, who is not Prince, is not 24.
   Pop #!= Prince,
   Pop #!= Age24,

   % Leon, who is not King, is 25.
   Leon #!= King,
   Leon #= Age25,

   %  Mark's musical preference is not jazz.
   Mark #!= Jazz,

   Vars = Names ++ Surnames ++ Music,

   solve([], Vars).

/*

  Nadel's construction problem in Picat.

  From Rina Dechter "Constraint Processing", page 5.
  Attributes the problem to
  B.A. Nadel "Constraint satisfaction algorithms" (1989).
  """
  * The recreation area should be near the lake.
  
  * Steep slopes are to be avoided for all but the recreation area.
  * Poor soil should be avoided for those developments that 
    involve construction, namely the apartments and the family houses.
  
  * The highway, being noisy, should not be near the apartments, 
    the housing, or the recreation area.
  
  * The dumpsite should not be visible from the apartments, 
    the houses, or the lake.
  
  * Lots 3 and 4 have bad soil.
  * Lots 3, 4, 7, and 8 are on steep slopes .
  * Lots 2, 3, and 4 are near the lake.
  * Lots 1 and 2 are near the highway.
  """

  Comment: 
  I have not found any model that satisfies all the constraints.
  However this "soft" version counts the broken constraints
  and minimizes to 1 broken constraint.
  
  The model (which - of course - could be erroneous) generates 28 different 
  models. The broken constraints are either
    - steep_slopes constraints or
    - near_dump constraints.


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   List = findall([Developments,Broken,TotalCount],
                   $nadel(Developments,Broken,TotalCount)),
   AllBroken = [],
   foreach([Developments2,Broken2,TotalCount2] in List)
      writeln(developements=Developments2),
      AllBroken := AllBroken ++ [Broken2],
      printf("Constraints broken: %w (%w)\n",Broken2,
                         [ C : {B,C} in zip(Broken2, 1..Broken2.length), B == 1]),
      printf("Total broken constraints: %d\n", TotalCount2),
      nl
   end,

   println("\nWhich constraints was broken in the above list?\n"),
   AllBrokenTransposed = transpose(AllBroken), 
   foreach({B,C} in zip(AllBrokenTransposed,1..AllBrokenTransposed.length))
      printf("Contraint %d has %d occurences\n", C,sum(B))
   end,
   nl.


nadel(Developments, Broken, TotalCount) =>

   % Near lots
   % * Lots 3 and 4 have bad soil.
   % * Lots 3, 4, 7, and 8 are on steep slopes .
   % * Lots 2, 3, and 4 are near the lake.
   % * Lots 1 and 2 are near the highway.
   
         % 1, 2, 3, 4, 5, 6, 7, 8
   BadSoil     =  [0, 0, 1, 1, 0, 0, 0, 0],
   SteepSlopes =  [0, 0, 1, 1, 0, 0, 1, 1],
   NearLake    =  [0, 1, 1, 1, 0, 0, 0, 0],
   NearHighway =  [1, 1, 0, 0, 0, 0, 0, 0],
   
   % neighborhood matrix (for the dump placement)
   NearLots =  % 1  2  3  4  5  6  7  8  
          [[0, 1, 0, 0, 1, 0, 0, 0], % 1
           [1, 0, 1, 0, 0, 1, 0, 0], % 2 
           [0, 1, 0, 1, 0, 0, 1, 0], % 3 
           [0, 0, 1, 0, 0, 0, 0, 1], % 4
           [1, 0, 0, 0, 0, 1, 0, 0], % 5
           [0, 1, 0, 0, 1, 0, 1, 0], % 6
           [0, 0, 1, 0, 0, 1, 0, 1], % 7
           [0, 0, 0, 1, 0, 0, 1, 0]], % 8

   N = length(NearLots), % number of lots   
   
   % the development to place in one of the lots
   Developments = [Recreation, Apartments, Houses, Cemetery, Dump],
   Developments :: 1..N,

   C = 13, % number of constraints
   Broken = new_list(C),
   Broken :: 0..1, % indicator of broken constraint
   Broken = [Broken1,Broken2,Broken3,Broken4,Broken5,Broken6,
             Broken7,Broken8,Broken9,Broken10,Broken11,Broken12,
             Broken13],

   TotalCount #= sum(Broken),
   TotalCount #=< 1, % for findall

   all_different(Developments),

   % * The recreation area should be near the lake.
   element(Recreation,NearLake,NearLakeRecreation),
   (NearLakeRecreation #= 1 #<=> Broken1 #= 0),
   
   % * Steep slopes are to be avoided for all but the recreation
   %   area.
   element(Apartments,SteepSlopes,SteepSlopesApartments),
   element(Houses,SteepSlopes,SteepSlopesHouses),
   element(Cemetery,SteepSlopes,SteepSlopesCemetry),
   element(Dump,SteepSlopes,SteepSlopesDump),
   (SteepSlopesApartments #= 0 #<=> Broken2 #= 0),
   (SteepSlopesHouses     #= 0 #<=> Broken3 #= 0),
   (SteepSlopesCemetry    #= 0 #<=> Broken4 #= 0),
   (SteepSlopesDump       #= 0 #<=> Broken5 #= 0),

   % * Poor soil should be avoided for those developments that 
   %   involve construction, namely the apartments and the family
   %   houses.
   element(Apartments,BadSoil,BadSoilApartments),
   element(Houses,BadSoil,BadSoilHouses),
   (BadSoilApartments #= 0 #<=> Broken6 #= 0 ),
   (BadSoilHouses     #= 0 #<=> Broken7 #= 0 ),
   
   % * The highway, being noisy, should not be near the apartments, 
   %   the housing, or the recreation area.
   element(Apartments,NearHighway,NearHighwayApartments),
   element(Houses,NearHighway,NearHighwayHouses),
   element(Recreation,NearHighway,NearHighwayRecreation),
   (NearHighwayApartments #= 0 #<=> Broken8 #= 0),
   (NearHighwayHouses     #= 0 #<=> Broken9 #= 0),
   (NearHighwayRecreation #= 0 #<=> Broken10 #= 0),
   
   % * The dumpsite should not be visible from the apartments, 
   %   the houses, or the lake.

   % not near the lake
   element(Dump,NearLake, NearLakeDump),
   (NearLakeDump #= 0 #<=> Broken11 #= 0),

   % not near the house 

   matrix_element(NearLots,Dump,Houses,NearLotsDumpHouses),
   matrix_element(NearLots,Houses,Dump,NearLotsHousesDump),
   (
       (NearLotsDumpHouses #= 0 #/\ NearLotsHousesDump #= 0)
        #<=> 
       Broken12 #= 0
   ), 

   % not near the apartments  
   matrix_element(NearLots,Dump,Apartments,NearLotsDumpApartments),
   matrix_element(NearLots,Apartments,Dump,NearLotsApartmentsDump),
   (
       (NearLotsDumpApartments #= 0 #/\ NearLotsApartmentsDump #= 0)
        #<=> Broken13 #= 0
   ),

   % search
   Vars = Developments ++ Broken,
   solve([], Vars).

"MARY","PATRICIA","LINDA","BARBARA","ELIZABETH","JENNIFER","MARIA","SUSAN","MARGARET","DOROTHY","LISA","NANCY","KAREN","BETTY","HELEN","SANDRA","DONNA","CAROL","RUTH","SHARON","MICHELLE","LAURA","SARAH","KIMBERLY","DEBORAH","JESSICA","SHIRLEY","CYNTHIA","ANGELA","MELISSA","BRENDA","AMY","ANNA","REBECCA","VIRGINIA","KATHLEEN","PAMELA","MARTHA","DEBRA","AMANDA","STEPHANIE","CAROLYN","CHRISTINE","MARIE","JANET","CATHERINE","FRANCES","ANN","JOYCE","DIANE","ALICE","JULIE","HEATHER","TERESA","DORIS","GLORIA","EVELYN","JEAN","CHERYL","MILDRED","KATHERINE","JOAN","ASHLEY","JUDITH","ROSE","JANICE","KELLY","NICOLE","JUDY","CHRISTINA","KATHY","THERESA","BEVERLY","DENISE","TAMMY","IRENE","JANE","LORI","RACHEL","MARILYN","ANDREA","KATHRYN","LOUISE","SARA","ANNE","JACQUELINE","WANDA","BONNIE","JULIA","RUBY","LOIS","TINA","PHYLLIS","NORMA","PAULA","DIANA","ANNIE","LILLIAN","EMILY","ROBIN","PEGGY","CRYSTAL","GLADYS","RITA","DAWN","CONNIE","FLORENCE","TRACY","EDNA","TIFFANY","CARMEN","ROSA","CINDY","GRACE","WENDY","VICTORIA","EDITH","KIM","SHERRY","SYLVIA","JOSEPHINE","THELMA","SHANNON","SHEILA","ETHEL","ELLEN","ELAINE","MARJORIE","CARRIE","CHARLOTTE","MONICA","ESTHER","PAULINE","EMMA","JUANITA","ANITA","RHONDA","HAZEL","AMBER","EVA","DEBBIE","APRIL","LESLIE","CLARA","LUCILLE","JAMIE","JOANNE","ELEANOR","VALERIE","DANIELLE","MEGAN","ALICIA","SUZANNE","MICHELE","GAIL","BERTHA","DARLENE","VERONICA","JILL","ERIN","GERALDINE","LAUREN","CATHY","JOANN","LORRAINE","LYNN","SALLY","REGINA","ERICA","BEATRICE","DOLORES","BERNICE","AUDREY","YVONNE","ANNETTE","JUNE","SAMANTHA","MARION","DANA","STACY","ANA","RENEE","IDA","VIVIAN","ROBERTA","HOLLY","BRITTANY","MELANIE","LORETTA","YOLANDA","JEANETTE","LAURIE","KATIE","KRISTEN","VANESSA","ALMA","SUE","ELSIE","BETH","JEANNE","VICKI","CARLA","TARA","ROSEMARY","EILEEN","TERRI","GERTRUDE","LUCY","TONYA","ELLA","STACEY","WILMA","GINA","KRISTIN","JESSIE","NATALIE","AGNES","VERA","WILLIE","CHARLENE","BESSIE","DELORES","MELINDA","PEARL","ARLENE","MAUREEN","COLLEEN","ALLISON","TAMARA","JOY","GEORGIA","CONSTANCE","LILLIE","CLAUDIA","JACKIE","MARCIA","TANYA","NELLIE","MINNIE","MARLENE","HEIDI","GLENDA","LYDIA","VIOLA","COURTNEY","MARIAN","STELLA","CAROLINE","DORA","JO","VICKIE","MATTIE","TERRY","MAXINE","IRMA","MABEL","MARSHA","MYRTLE","LENA","CHRISTY","DEANNA","PATSY","HILDA","GWENDOLYN","JENNIE","NORA","MARGIE","NINA","CASSANDRA","LEAH","PENNY","KAY","PRISCILLA","NAOMI","CAROLE","BRANDY","OLGA","BILLIE","DIANNE","TRACEY","LEONA","JENNY","FELICIA","SONIA","MIRIAM","VELMA","BECKY","BOBBIE","VIOLET","KRISTINA","TONI","MISTY","MAE","SHELLY","DAISY","RAMONA","SHERRI","ERIKA","KATRINA","CLAIRE","LINDSEY","LINDSAY","GENEVA","GUADALUPE","BELINDA","MARGARITA","SHERYL","CORA","FAYE","ADA","NATASHA","SABRINA","ISABEL","MARGUERITE","HATTIE","HARRIET","MOLLY","CECILIA","KRISTI","BRANDI","BLANCHE","SANDY","ROSIE","JOANNA","IRIS","EUNICE","ANGIE","INEZ","LYNDA","MADELINE","AMELIA","ALBERTA","GENEVIEVE","MONIQUE","JODI","JANIE","MAGGIE","KAYLA","SONYA","JAN","LEE","KRISTINE","CANDACE","FANNIE","MARYANN","OPAL","ALISON","YVETTE","MELODY","LUZ","SUSIE","OLIVIA","FLORA","SHELLEY","KRISTY","MAMIE","LULA","LOLA","VERNA","BEULAH","ANTOINETTE","CANDICE","JUANA","JEANNETTE","PAM","KELLI","HANNAH","WHITNEY","BRIDGET","KARLA","CELIA","LATOYA","PATTY","SHELIA","GAYLE","DELLA","VICKY","LYNNE","SHERI","MARIANNE","KARA","JACQUELYN","ERMA","BLANCA","MYRA","LETICIA","PAT","KRISTA","ROXANNE","ANGELICA","JOHNNIE","ROBYN","FRANCIS","ADRIENNE","ROSALIE","ALEXANDRA","BROOKE","BETHANY","SADIE","BERNADETTE","TRACI","JODY","KENDRA","JASMINE","NICHOLE","RACHAEL","CHELSEA","MABLE","ERNESTINE","MURIEL","MARCELLA","ELENA","KRYSTAL","ANGELINA","NADINE","KARI","ESTELLE","DIANNA","PAULETTE","LORA","MONA","DOREEN","ROSEMARIE","ANGEL","DESIREE","ANTONIA","HOPE","GINGER","JANIS","BETSY","CHRISTIE","FREDA","MERCEDES","MEREDITH","LYNETTE","TERI","CRISTINA","EULA","LEIGH","MEGHAN","SOPHIA","ELOISE","ROCHELLE","GRETCHEN","CECELIA","RAQUEL","HENRIETTA","ALYSSA","JANA","KELLEY","GWEN","KERRY","JENNA","TRICIA","LAVERNE","OLIVE","ALEXIS","TASHA","SILVIA","ELVIRA","CASEY","DELIA","SOPHIE","KATE","PATTI","LORENA","KELLIE","SONJA","LILA","LANA","DARLA","MAY","MINDY","ESSIE","MANDY","LORENE","ELSA","JOSEFINA","JEANNIE","MIRANDA","DIXIE","LUCIA","MARTA","FAITH","LELA","JOHANNA","SHARI","CAMILLE","TAMI","SHAWNA","ELISA","EBONY","MELBA","ORA","NETTIE","TABITHA","OLLIE","JAIME","WINIFRED","KRISTIE","MARINA","ALISHA","AIMEE","RENA","MYRNA","MARLA","TAMMIE","LATASHA","BONITA","PATRICE","RONDA","SHERRIE","ADDIE","FRANCINE","DELORIS","STACIE","ADRIANA","CHERI","SHELBY","ABIGAIL","CELESTE","JEWEL","CARA","ADELE","REBEKAH","LUCINDA","DORTHY","CHRIS","EFFIE","TRINA","REBA","SHAWN","SALLIE","AURORA","LENORA","ETTA","LOTTIE","KERRI","TRISHA","NIKKI","ESTELLA","FRANCISCA","JOSIE","TRACIE","MARISSA","KARIN","BRITTNEY","JANELLE","LOURDES","LAUREL","HELENE","FERN","ELVA","CORINNE","KELSEY","INA","BETTIE","ELISABETH","AIDA","CAITLIN","INGRID","IVA","EUGENIA","CHRISTA","GOLDIE","CASSIE","MAUDE","JENIFER","THERESE","FRANKIE","DENA","LORNA","JANETTE","LATONYA","CANDY","MORGAN","CONSUELO","TAMIKA","ROSETTA","DEBORA","CHERIE","POLLY","DINA","JEWELL","FAY","JILLIAN","DOROTHEA","NELL","TRUDY","ESPERANZA","PATRICA","KIMBERLEY","SHANNA","HELENA","CAROLINA","CLEO","STEFANIE","ROSARIO","OLA","JANINE","MOLLIE","LUPE","ALISA","LOU","MARIBEL","SUSANNE","BETTE","SUSANA","ELISE","CECILE","ISABELLE","LESLEY","JOCELYN","PAIGE","JONI","RACHELLE","LEOLA","DAPHNE","ALTA","ESTER","PETRA","GRACIELA","IMOGENE","JOLENE","KEISHA","LACEY","GLENNA","GABRIELA","KERI","URSULA","LIZZIE","KIRSTEN","SHANA","ADELINE","MAYRA","JAYNE","JACLYN","GRACIE","SONDRA","CARMELA","MARISA","ROSALIND","CHARITY","TONIA","BEATRIZ","MARISOL","CLARICE","JEANINE","SHEENA","ANGELINE","FRIEDA","LILY","ROBBIE","SHAUNA","MILLIE","CLAUDETTE","CATHLEEN","ANGELIA","GABRIELLE","AUTUMN","KATHARINE","SUMMER","JODIE","STACI","LEA","CHRISTI","JIMMIE","JUSTINE","ELMA","LUELLA","MARGRET","DOMINIQUE","SOCORRO","RENE","MARTINA","MARGO","MAVIS","CALLIE","BOBBI","MARITZA","LUCILE","LEANNE","JEANNINE","DEANA","AILEEN","LORIE","LADONNA","WILLA","MANUELA","GALE","SELMA","DOLLY","SYBIL","ABBY","LARA","DALE","IVY","DEE","WINNIE","MARCY","LUISA","JERI","MAGDALENA","OFELIA","MEAGAN","AUDRA","MATILDA","LEILA","CORNELIA","BIANCA","SIMONE","BETTYE","RANDI","VIRGIE","LATISHA","BARBRA","GEORGINA","ELIZA","LEANN","BRIDGETTE","RHODA","HALEY","ADELA","NOLA","BERNADINE","FLOSSIE","ILA","GRETA","RUTHIE","NELDA","MINERVA","LILLY","TERRIE","LETHA","HILARY","ESTELA","VALARIE","BRIANNA","ROSALYN","EARLINE","CATALINA","AVA","MIA","CLARISSA","LIDIA","CORRINE","ALEXANDRIA","CONCEPCION","TIA","SHARRON","RAE","DONA","ERICKA","JAMI","ELNORA","CHANDRA","LENORE","NEVA","MARYLOU","MELISA","TABATHA","SERENA","AVIS","ALLIE","SOFIA","JEANIE","ODESSA","NANNIE","HARRIETT","LORAINE","PENELOPE","MILAGROS","EMILIA","BENITA","ALLYSON","ASHLEE","TANIA","TOMMIE","ESMERALDA","KARINA","EVE","PEARLIE","ZELMA","MALINDA","NOREEN","TAMEKA","SAUNDRA","HILLARY","AMIE","ALTHEA","ROSALINDA","JORDAN","LILIA","ALANA","GAY","CLARE","ALEJANDRA","ELINOR","MICHAEL","LORRIE","JERRI","DARCY","EARNESTINE","CARMELLA","TAYLOR","NOEMI","MARCIE","LIZA","ANNABELLE","LOUISA","EARLENE","MALLORY","CARLENE","NITA","SELENA","TANISHA","KATY","JULIANNE","JOHN","LAKISHA","EDWINA","MARICELA","MARGERY","KENYA","DOLLIE","ROXIE","ROSLYN","KATHRINE","NANETTE","CHARMAINE","LAVONNE","ILENE","KRIS","TAMMI","SUZETTE","CORINE","KAYE","JERRY","MERLE","CHRYSTAL","LINA","DEANNE","LILIAN","JULIANA","ALINE","LUANN","KASEY","MARYANNE","EVANGELINE","COLETTE","MELVA","LAWANDA","YESENIA","NADIA","MADGE","KATHIE","EDDIE","OPHELIA","VALERIA","NONA","MITZI","MARI","GEORGETTE","CLAUDINE","FRAN","ALISSA","ROSEANN","LAKEISHA","SUSANNA","REVA","DEIDRE","CHASITY","SHEREE","CARLY","JAMES","ELVIA","ALYCE","DEIRDRE","GENA","BRIANA","ARACELI","KATELYN","ROSANNE","WENDI","TESSA","BERTA","MARVA","IMELDA","MARIETTA","MARCI","LEONOR","ARLINE","SASHA","MADELYN","JANNA","JULIETTE","DEENA","AURELIA","JOSEFA","AUGUSTA","LILIANA","YOUNG","CHRISTIAN","LESSIE","AMALIA","SAVANNAH","ANASTASIA","VILMA","NATALIA","ROSELLA","LYNNETTE","CORINA","ALFREDA","LEANNA","CAREY","AMPARO","COLEEN","TAMRA","AISHA","WILDA","KARYN","CHERRY","QUEEN","MAURA","MAI","EVANGELINA","ROSANNA","HALLIE","ERNA","ENID","MARIANA","LACY","JULIET","JACKLYN","FREIDA","MADELEINE","MARA","HESTER","CATHRYN","LELIA","CASANDRA","BRIDGETT","ANGELITA","JANNIE","DIONNE","ANNMARIE","KATINA","BERYL","PHOEBE","MILLICENT","KATHERYN","DIANN","CARISSA","MARYELLEN","LIZ","LAURI","HELGA","GILDA","ADRIAN","RHEA","MARQUITA","HOLLIE","TISHA","TAMERA","ANGELIQUE","FRANCESCA","BRITNEY","KAITLIN","LOLITA","FLORINE","ROWENA","REYNA","TWILA","FANNY","JANELL","INES","CONCETTA","BERTIE","ALBA","BRIGITTE","ALYSON","VONDA","PANSY","ELBA","NOELLE","LETITIA","KITTY","DEANN","BRANDIE","LOUELLA","LETA","FELECIA","SHARLENE","LESA","BEVERLEY","ROBERT","ISABELLA","HERMINIA","TERRA","CELINA","TORI","OCTAVIA","JADE","DENICE","GERMAINE","SIERRA","MICHELL","CORTNEY","NELLY","DORETHA","SYDNEY","DEIDRA","MONIKA","LASHONDA","JUDI","CHELSEY","ANTIONETTE","MARGOT","BOBBY","ADELAIDE","NAN","LEEANN","ELISHA","DESSIE","LIBBY","KATHI","GAYLA","LATANYA","MINA","MELLISA","KIMBERLEE","JASMIN","RENAE","ZELDA","ELDA","MA","JUSTINA","GUSSIE","EMILIE","CAMILLA","ABBIE","ROCIO","KAITLYN","JESSE","EDYTHE","ASHLEIGH","SELINA","LAKESHA","GERI","ALLENE","PAMALA","MICHAELA","DAYNA","CARYN","ROSALIA","SUN","JACQULINE","REBECA","MARYBETH","KRYSTLE","IOLA","DOTTIE","BENNIE","BELLE","AUBREY","GRISELDA","ERNESTINA","ELIDA","ADRIANNE","DEMETRIA","DELMA","CHONG","JAQUELINE","DESTINY","ARLEEN","VIRGINA","RETHA","FATIMA","TILLIE","ELEANORE","CARI","TREVA","BIRDIE","WILHELMINA","ROSALEE","MAURINE","LATRICE","YONG","JENA","TARYN","ELIA","DEBBY","MAUDIE","JEANNA","DELILAH","CATRINA","SHONDA","HORTENCIA","THEODORA","TERESITA","ROBBIN","DANETTE","MARYJANE","FREDDIE","DELPHINE","BRIANNE","NILDA","DANNA","CINDI","BESS","IONA","HANNA","ARIEL","WINONA","VIDA","ROSITA","MARIANNA","WILLIAM","RACHEAL","GUILLERMINA","ELOISA","CELESTINE","CAREN","MALISSA","LONA","CHANTEL","SHELLIE","MARISELA","LEORA","AGATHA","SOLEDAD","MIGDALIA","IVETTE","CHRISTEN","ATHENA","JANEL","CHLOE","VEDA","PATTIE","TESSIE","TERA","MARILYNN","LUCRETIA","KARRIE","DINAH","DANIELA","ALECIA","ADELINA","VERNICE","SHIELA","PORTIA","MERRY","LASHAWN","DEVON","DARA","TAWANA","OMA","VERDA","CHRISTIN","ALENE","ZELLA","SANDI","RAFAELA","MAYA","KIRA","CANDIDA","ALVINA","SUZAN","SHAYLA","LYN","LETTIE","ALVA","SAMATHA","ORALIA","MATILDE","MADONNA","LARISSA","VESTA","RENITA","INDIA","DELOIS","SHANDA","PHILLIS","LORRI","ERLINDA","CRUZ","CATHRINE","BARB","ZOE","ISABELL","IONE","GISELA","CHARLIE","VALENCIA","ROXANNA","MAYME","KISHA","ELLIE","MELLISSA","DORRIS","DALIA","BELLA","ANNETTA","ZOILA","RETA","REINA","LAURETTA","KYLIE","CHRISTAL","PILAR","CHARLA","ELISSA","TIFFANI","TANA","PAULINA","LEOTA","BREANNA","JAYME","CARMEL","VERNELL","TOMASA","MANDI","DOMINGA","SANTA","MELODIE","LURA","ALEXA","TAMELA","RYAN","MIRNA","KERRIE","VENUS","NOEL","FELICITA","CRISTY","CARMELITA","BERNIECE","ANNEMARIE","TIARA","ROSEANNE","MISSY","CORI","ROXANA","PRICILLA","KRISTAL","JUNG","ELYSE","HAYDEE","ALETHA","BETTINA","MARGE","GILLIAN","FILOMENA","CHARLES","ZENAIDA","HARRIETTE","CARIDAD","VADA","UNA","ARETHA","PEARLINE","MARJORY","MARCELA","FLOR","EVETTE","ELOUISE","ALINA","TRINIDAD","DAVID","DAMARIS","CATHARINE","CARROLL","BELVA","NAKIA","MARLENA","LUANNE","LORINE","KARON","DORENE","DANITA","BRENNA","TATIANA","SAMMIE","LOUANN","LOREN","JULIANNA","ANDRIA","PHILOMENA","LUCILA","LEONORA","DOVIE","ROMONA","MIMI","JACQUELIN","GAYE","TONJA","MISTI","JOE","GENE","CHASTITY","STACIA","ROXANN","MICAELA","NIKITA","MEI","VELDA","MARLYS","JOHNNA","AURA","LAVERN","IVONNE","HAYLEY","NICKI","MAJORIE","HERLINDA","GEORGE","ALPHA","YADIRA","PERLA","GREGORIA","DANIEL","ANTONETTE","SHELLI","MOZELLE","MARIAH","JOELLE","CORDELIA","JOSETTE","CHIQUITA","TRISTA","LOUIS","LAQUITA","GEORGIANA","CANDI","SHANON","LONNIE","HILDEGARD","CECIL","VALENTINA","STEPHANY","MAGDA","KAROL","GERRY","GABRIELLA","TIANA","ROMA","RICHELLE","RAY","PRINCESS","OLETA","JACQUE","IDELLA","ALAINA","SUZANNA","JOVITA","BLAIR","TOSHA","RAVEN","NEREIDA","MARLYN","KYLA","JOSEPH","DELFINA","TENA","STEPHENIE","SABINA","NATHALIE","MARCELLE","GERTIE","DARLEEN","THEA","SHARONDA","SHANTEL","BELEN","VENESSA","ROSALINA","ONA","GENOVEVA","COREY","CLEMENTINE","ROSALBA","RENATE","RENATA","MI","IVORY","GEORGIANNA","FLOY","DORCAS","ARIANA","TYRA","THEDA","MARIAM","JULI","JESICA","DONNIE","VIKKI","VERLA","ROSELYN","MELVINA","JANNETTE","GINNY","DEBRAH","CORRIE","ASIA","VIOLETA","MYRTIS","LATRICIA","COLLETTE","CHARLEEN","ANISSA","VIVIANA","TWYLA","PRECIOUS","NEDRA","LATONIA","LAN","HELLEN","FABIOLA","ANNAMARIE","ADELL","SHARYN","CHANTAL","NIKI","MAUD","LIZETTE","LINDY","KIA","KESHA","JEANA","DANELLE","CHARLINE","CHANEL","CARROL","VALORIE","LIA","DORTHA","CRISTAL","SUNNY","LEONE","LEILANI","GERRI","DEBI","ANDRA","KESHIA","IMA","EULALIA","EASTER","DULCE","NATIVIDAD","LINNIE","KAMI","GEORGIE","CATINA","BROOK","ALDA","WINNIFRED","SHARLA","RUTHANN","MEAGHAN","MAGDALENE","LISSETTE","ADELAIDA","VENITA","TRENA","SHIRLENE","SHAMEKA","ELIZEBETH","DIAN","SHANTA","MICKEY","LATOSHA","CARLOTTA","WINDY","SOON","ROSINA","MARIANN","LEISA","JONNIE","DAWNA","CATHIE","BILLY","ASTRID","SIDNEY","LAUREEN","JANEEN","HOLLI","FAWN","VICKEY","TERESSA","SHANTE","RUBYE","MARCELINA","CHANDA","CARY","TERESE","SCARLETT","MARTY","MARNIE","LULU","LISETTE","JENIFFER","ELENOR","DORINDA","DONITA","CARMAN","BERNITA","ALTAGRACIA","ALETA","ADRIANNA","ZORAIDA","RONNIE","NICOLA","LYNDSEY","KENDALL","JANINA","CHRISSY","AMI","STARLA","PHYLIS","PHUONG","KYRA","CHARISSE","BLANCH","SANJUANITA","RONA","NANCI","MARILEE","MARANDA","CORY","BRIGETTE","SANJUANA","MARITA","KASSANDRA","JOYCELYN","IRA","FELIPA","CHELSIE","BONNY","MIREYA","LORENZA","KYONG","ILEANA","CANDELARIA","TONY","TOBY","SHERIE","OK","MARK","LUCIE","LEATRICE","LAKESHIA","GERDA","EDIE","BAMBI","MARYLIN","LAVON","HORTENSE","GARNET","EVIE","TRESSA","SHAYNA","LAVINA","KYUNG","JEANETTA","SHERRILL","SHARA","PHYLISS","MITTIE","ANABEL","ALESIA","THUY","TAWANDA","RICHARD","JOANIE","TIFFANIE","LASHANDA","KARISSA","ENRIQUETA","DARIA","DANIELLA","CORINNA","ALANNA","ABBEY","ROXANE","ROSEANNA","MAGNOLIA","LIDA","KYLE","JOELLEN","ERA","CORAL","CARLEEN","TRESA","PEGGIE","NOVELLA","NILA","MAYBELLE","JENELLE","CARINA","NOVA","MELINA","MARQUERITE","MARGARETTE","JOSEPHINA","EVONNE","DEVIN","CINTHIA","ALBINA","TOYA","TAWNYA","SHERITA","SANTOS","MYRIAM","LIZABETH","LISE","KEELY","JENNI","GISELLE","CHERYLE","ARDITH","ARDIS","ALESHA","ADRIANE","SHAINA","LINNEA","KAROLYN","HONG","FLORIDA","FELISHA","DORI","DARCI","ARTIE","ARMIDA","ZOLA","XIOMARA","VERGIE","SHAMIKA","NENA","NANNETTE","MAXIE","LOVIE","JEANE","JAIMIE","INGE","FARRAH","ELAINA","CAITLYN","STARR","FELICITAS","CHERLY","CARYL","YOLONDA","YASMIN","TEENA","PRUDENCE","PENNIE","NYDIA","MACKENZIE","ORPHA","MARVEL","LIZBETH","LAURETTE","JERRIE","HERMELINDA","CAROLEE","TIERRA","MIRIAN","META","MELONY","KORI","JENNETTE","JAMILA","ENA","ANH","YOSHIKO","SUSANNAH","SALINA","RHIANNON","JOLEEN","CRISTINE","ASHTON","ARACELY","TOMEKA","SHALONDA","MARTI","LACIE","KALA","JADA","ILSE","HAILEY","BRITTANI","ZONA","SYBLE","SHERRYL","RANDY","NIDIA","MARLO","KANDICE","KANDI","DEB","DEAN","AMERICA","ALYCIA","TOMMY","RONNA","NORENE","MERCY","JOSE","INGEBORG","GIOVANNA","GEMMA","CHRISTEL","AUDRY","ZORA","VITA","VAN","TRISH","STEPHAINE","SHIRLEE","SHANIKA","MELONIE","MAZIE","JAZMIN","INGA","HOA","HETTIE","GERALYN","FONDA","ESTRELLA","ADELLA","SU","SARITA","RINA","MILISSA","MARIBETH","GOLDA","EVON","ETHELYN","ENEDINA","CHERISE","CHANA","VELVA","TAWANNA","SADE","MIRTA","LI","KARIE","JACINTA","ELNA","DAVINA","CIERRA","ASHLIE","ALBERTHA","TANESHA","STEPHANI","NELLE","MINDI","LU","LORINDA","LARUE","FLORENE","DEMETRA","DEDRA","CIARA","CHANTELLE","ASHLY","SUZY","ROSALVA","NOELIA","LYDA","LEATHA","KRYSTYNA","KRISTAN","KARRI","DARLINE","DARCIE","CINDA","CHEYENNE","CHERRIE","AWILDA","ALMEDA","ROLANDA","LANETTE","JERILYN","GISELE","EVALYN","CYNDI","CLETA","CARIN","ZINA","ZENA","VELIA","TANIKA","PAUL","CHARISSA","THOMAS","TALIA","MARGARETE","LAVONDA","KAYLEE","KATHLENE","JONNA","IRENA","ILONA","IDALIA","CANDIS","CANDANCE","BRANDEE","ANITRA","ALIDA","SIGRID","NICOLETTE","MARYJO","LINETTE","HEDWIG","CHRISTIANA","CASSIDY","ALEXIA","TRESSIE","MODESTA","LUPITA","LITA","GLADIS","EVELIA","DAVIDA","CHERRI","CECILY","ASHELY","ANNABEL","AGUSTINA","WANITA","SHIRLY","ROSAURA","HULDA","EUN","BAILEY","YETTA","VERONA","THOMASINA","SIBYL","SHANNAN","MECHELLE","LUE","LEANDRA","LANI","KYLEE","KANDY","JOLYNN","FERNE","EBONI","CORENE","ALYSIA","ZULA","NADA","MOIRA","LYNDSAY","LORRETTA","JUAN","JAMMIE","HORTENSIA","GAYNELL","CAMERON","ADRIA","VINA","VICENTA","TANGELA","STEPHINE","NORINE","NELLA","LIANA","LESLEE","KIMBERELY","ILIANA","GLORY","FELICA","EMOGENE","ELFRIEDE","EDEN","EARTHA","CARMA","BEA","OCIE","MARRY","LENNIE","KIARA","JACALYN","CARLOTA","ARIELLE","YU","STAR","OTILIA","KIRSTIN","KACEY","JOHNETTA","JOEY","JOETTA","JERALDINE","JAUNITA","ELANA","DORTHEA","CAMI","AMADA","ADELIA","VERNITA","TAMAR","SIOBHAN","RENEA","RASHIDA","OUIDA","ODELL","NILSA","MERYL","KRISTYN","JULIETA","DANICA","BREANNE","AUREA","ANGLEA","SHERRON","ODETTE","MALIA","LORELEI","LIN","LEESA","KENNA","KATHLYN","FIONA","CHARLETTE","SUZIE","SHANTELL","SABRA","RACQUEL","MYONG","MIRA","MARTINE","LUCIENNE","LAVADA","JULIANN","JOHNIE","ELVERA","DELPHIA","CLAIR","CHRISTIANE","CHAROLETTE","CARRI","AUGUSTINE","ASHA","ANGELLA","PAOLA","NINFA","LEDA","LAI","EDA","SUNSHINE","STEFANI","SHANELL","PALMA","MACHELLE","LISSA","KECIA","KATHRYNE","KARLENE","JULISSA","JETTIE","JENNIFFER","HUI","CORRINA","CHRISTOPHER","CAROLANN","ALENA","TESS","ROSARIA","MYRTICE","MARYLEE","LIANE","KENYATTA","JUDIE","JANEY","IN","ELMIRA","ELDORA","DENNA","CRISTI","CATHI","ZAIDA","VONNIE","VIVA","VERNIE","ROSALINE","MARIELA","LUCIANA","LESLI","KARAN","FELICE","DENEEN","ADINA","WYNONA","TARSHA","SHERON","SHASTA","SHANITA","SHANI","SHANDRA","RANDA","PINKIE","PARIS","NELIDA","MARILOU","LYLA","LAURENE","LACI","JOI","JANENE","DOROTHA","DANIELE","DANI","CAROLYNN","CARLYN","BERENICE","AYESHA","ANNELIESE","ALETHEA","THERSA","TAMIKO","RUFINA","OLIVA","MOZELL","MARYLYN","MADISON","KRISTIAN","KATHYRN","KASANDRA","KANDACE","JANAE","GABRIEL","DOMENICA","DEBBRA","DANNIELLE","CHUN","BUFFY","BARBIE","ARCELIA","AJA","ZENOBIA","SHAREN","SHAREE","PATRICK","PAGE","MY","LAVINIA","KUM","KACIE","JACKELINE","HUONG","FELISA","EMELIA","ELEANORA","CYTHIA","CRISTIN","CLYDE","CLARIBEL","CARON","ANASTACIA","ZULMA","ZANDRA","YOKO","TENISHA","SUSANN","SHERILYN","SHAY","SHAWANDA","SABINE","ROMANA","MATHILDA","LINSEY","KEIKO","JOANA","ISELA","GRETTA","GEORGETTA","EUGENIE","DUSTY","DESIRAE","DELORA","CORAZON","ANTONINA","ANIKA","WILLENE","TRACEE","TAMATHA","REGAN","NICHELLE","MICKIE","MAEGAN","LUANA","LANITA","KELSIE","EDELMIRA","BREE","AFTON","TEODORA","TAMIE","SHENA","MEG","LINH","KELI","KACI","DANYELLE","BRITT","ARLETTE","ALBERTINE","ADELLE","TIFFINY","STORMY","SIMONA","NUMBERS","NICOLASA","NICHOL","NIA","NAKISHA","MEE","MAIRA","LOREEN","KIZZY","JOHNNY","JAY","FALLON","CHRISTENE","BOBBYE","ANTHONY","YING","VINCENZA","TANJA","RUBIE","RONI","QUEENIE","MARGARETT","KIMBERLI","IRMGARD","IDELL","HILMA","EVELINA","ESTA","EMILEE","DENNISE","DANIA","CARL","CARIE","ANTONIO","WAI","SANG","RISA","RIKKI","PARTICIA","MUI","MASAKO","MARIO","LUVENIA","LOREE","LONI","LIEN","KEVIN","GIGI","FLORENCIA","DORIAN","DENITA","DALLAS","CHI","BILLYE","ALEXANDER","TOMIKA","SHARITA","RANA","NIKOLE","NEOMA","MARGARITE","MADALYN","LUCINA","LAILA","KALI","JENETTE","GABRIELE","EVELYNE","ELENORA","CLEMENTINA","ALEJANDRINA","ZULEMA","VIOLETTE","VANNESSA","THRESA","RETTA","PIA","PATIENCE","NOELLA","NICKIE","JONELL","DELTA","CHUNG","CHAYA","CAMELIA","BETHEL","ANYA","ANDREW","THANH","SUZANN","SPRING","SHU","MILA","LILLA","LAVERNA","KEESHA","KATTIE","GIA","GEORGENE","EVELINE","ESTELL","ELIZBETH","VIVIENNE","VALLIE","TRUDIE","STEPHANE","MICHEL","MAGALY","MADIE","KENYETTA","KARREN","JANETTA","HERMINE","HARMONY","DRUCILLA","DEBBI","CELESTINA","CANDIE","BRITNI","BECKIE","AMINA","ZITA","YUN","YOLANDE","VIVIEN","VERNETTA","TRUDI","SOMMER","PEARLE","PATRINA","OSSIE","NICOLLE","LOYCE","LETTY","LARISA","KATHARINA","JOSELYN","JONELLE","JENELL","IESHA","HEIDE","FLORINDA","FLORENTINA","FLO","ELODIA","DORINE","BRUNILDA","BRIGID","ASHLI","ARDELLA","TWANA","THU","TARAH","SUNG","SHEA","SHAVON","SHANE","SERINA","RAYNA","RAMONITA","NGA","MARGURITE","LUCRECIA","KOURTNEY","KATI","JESUS","JESENIA","DIAMOND","CRISTA","AYANA","ALICA","ALIA","VINNIE","SUELLEN","ROMELIA","RACHELL","PIPER","OLYMPIA","MICHIKO","KATHALEEN","JOLIE","JESSI","JANESSA","HANA","HA","ELEASE","CARLETTA","BRITANY","SHONA","SALOME","ROSAMOND","REGENA","RAINA","NGOC","NELIA","LOUVENIA","LESIA","LATRINA","LATICIA","LARHONDA","JINA","JACKI","HOLLIS","HOLLEY","EMMY","DEEANN","CORETTA","ARNETTA","VELVET","THALIA","SHANICE","NETA","MIKKI","MICKI","LONNA","LEANA","LASHUNDA","KILEY","JOYE","JACQULYN","IGNACIA","HYUN","HIROKO","HENRY","HENRIETTE","ELAYNE","DELINDA","DARNELL","DAHLIA","COREEN","CONSUELA","CONCHITA","CELINE","BABETTE","AYANNA","ANETTE","ALBERTINA","SKYE","SHAWNEE","SHANEKA","QUIANA","PAMELIA","MIN","MERRI","MERLENE","MARGIT","KIESHA","KIERA","KAYLENE","JODEE","JENISE","ERLENE","EMMIE","ELSE","DARYL","DALILA","DAISEY","CODY","CASIE","BELIA","BABARA","VERSIE","VANESA","SHELBA","SHAWNDA","SAM","NORMAN","NIKIA","NAOMA","MARNA","MARGERET","MADALINE","LAWANA","KINDRA","JUTTA","JAZMINE","JANETT","HANNELORE","GLENDORA","GERTRUD","GARNETT","FREEDA","FREDERICA","FLORANCE","FLAVIA","DENNIS","CARLINE","BEVERLEE","ANJANETTE","VALDA","TRINITY","TAMALA","STEVIE","SHONNA","SHA","SARINA","ONEIDA","MICAH","MERILYN","MARLEEN","LURLINE","LENNA","KATHERIN","JIN","JENI","HAE","GRACIA","GLADY","FARAH","ERIC","ENOLA","EMA","DOMINQUE","DEVONA","DELANA","CECILA","CAPRICE","ALYSHA","ALI","ALETHIA","VENA","THERESIA","TAWNY","SONG","SHAKIRA","SAMARA","SACHIKO","RACHELE","PAMELLA","NICKY","MARNI","MARIEL","MAREN","MALISA","LIGIA","LERA","LATORIA","LARAE","KIMBER","KATHERN","KAREY","JENNEFER","JANETH","HALINA","FREDIA","DELISA","DEBROAH","CIERA","CHIN","ANGELIKA","ANDREE","ALTHA","YEN","VIVAN","TERRESA","TANNA","SUK","SUDIE","SOO","SIGNE","SALENA","RONNI","REBBECCA","MYRTIE","MCKENZIE","MALIKA","MAIDA","LOAN","LEONARDA","KAYLEIGH","FRANCE","ETHYL","ELLYN","DAYLE","CAMMIE","BRITTNI","BIRGIT","AVELINA","ASUNCION","ARIANNA","AKIKO","VENICE","TYESHA","TONIE","TIESHA","TAKISHA","STEFFANIE","SINDY","SANTANA","MEGHANN","MANDA","MACIE","LADY","KELLYE","KELLEE","JOSLYN","JASON","INGER","INDIRA","GLINDA","GLENNIS","FERNANDA","FAUSTINA","ENEIDA","ELICIA","DOT","DIGNA","DELL","ARLETTA","ANDRE","WILLIA","TAMMARA","TABETHA","SHERRELL","SARI","REFUGIO","REBBECA","PAULETTA","NIEVES","NATOSHA","NAKITA","MAMMIE","KENISHA","KAZUKO","KASSIE","GARY","EARLEAN","DAPHINE","CORLISS","CLOTILDE","CAROLYNE","BERNETTA","AUGUSTINA","AUDREA","ANNIS","ANNABELL","YAN","TENNILLE","TAMICA","SELENE","SEAN","ROSANA","REGENIA","QIANA","MARKITA","MACY","LEEANNE","LAURINE","KYM","JESSENIA","JANITA","GEORGINE","GENIE","EMIKO","ELVIE","DEANDRA","DAGMAR","CORIE","COLLEN","CHERISH","ROMAINE","PORSHA","PEARLENE","MICHELINE","MERNA","MARGORIE","MARGARETTA","LORE","KENNETH","JENINE","HERMINA","FREDERICKA","ELKE","DRUSILLA","DORATHY","DIONE","DESIRE","CELENA","BRIGIDA","ANGELES","ALLEGRA","THEO","TAMEKIA","SYNTHIA","STEPHEN","SOOK","SLYVIA","ROSANN","REATHA","RAYE","MARQUETTA","MARGART","LING","LAYLA","KYMBERLY","KIANA","KAYLEEN","KATLYN","KARMEN","JOELLA","IRINA","EMELDA","ELENI","DETRA","CLEMMIE","CHERYLL","CHANTELL","CATHEY","ARNITA","ARLA","ANGLE","ANGELIC","ALYSE","ZOFIA","THOMASINE","TENNIE","SON","SHERLY","SHERLEY","SHARYL","REMEDIOS","PETRINA","NICKOLE","MYUNG","MYRLE","MOZELLA","LOUANNE","LISHA","LATIA","LANE","KRYSTA","JULIENNE","JOEL","JEANENE","JACQUALINE","ISAURA","GWENDA","EARLEEN","DONALD","CLEOPATRA","CARLIE","AUDIE","ANTONIETTA","ALISE","ALEX","VERDELL","VAL","TYLER","TOMOKO","THAO","TALISHA","STEVEN","SO","SHEMIKA","SHAUN","SCARLET","SAVANNA","SANTINA","ROSIA","RAEANN","ODILIA","NANA","MINNA","MAGAN","LYNELLE","LE","KARMA","JOEANN","IVANA","INELL","ILANA","HYE","HONEY","HEE","GUDRUN","FRANK","DREAMA","CRISSY","CHANTE","CARMELINA","ARVILLA","ARTHUR","ANNAMAE","ALVERA","ALEIDA","AARON","YEE","YANIRA","VANDA","TIANNA","TAM","STEFANIA","SHIRA","PERRY","NICOL","NANCIE","MONSERRATE","MINH","MELYNDA","MELANY","MATTHEW","LOVELLA","LAURE","KIRBY","KACY","JACQUELYNN","HYON","GERTHA","FRANCISCO","ELIANA","CHRISTENA","CHRISTEEN","CHARISE","CATERINA","CARLEY","CANDYCE","ARLENA","AMMIE","YANG","WILLETTE","VANITA","TUYET","TINY","SYREETA","SILVA","SCOTT","RONALD","PENNEY","NYLA","MICHAL","MAURICE","MARYAM","MARYA","MAGEN","LUDIE","LOMA","LIVIA","LANELL","KIMBERLIE","JULEE","DONETTA","DIEDRA","DENISHA","DEANE","DAWNE","CLARINE","CHERRYL","BRONWYN","BRANDON","ALLA","VALERY","TONDA","SUEANN","SORAYA","SHOSHANA","SHELA","SHARLEEN","SHANELLE","NERISSA","MICHEAL","MERIDITH","MELLIE","MAYE","MAPLE","MAGARET","LUIS","LILI","LEONILA","LEONIE","LEEANNA","LAVONIA","LAVERA","KRISTEL","KATHEY","KATHE","JUSTIN","JULIAN","JIMMY","JANN","ILDA","HILDRED","HILDEGARDE","GENIA","FUMIKO","EVELIN","ERMELINDA","ELLY","DUNG","DOLORIS","DIONNA","DANAE","BERNEICE","ANNICE","ALIX","VERENA","VERDIE","TRISTAN","SHAWNNA","SHAWANA","SHAUNNA","ROZELLA","RANDEE","RANAE","MILAGRO","LYNELL","LUISE","LOUIE","LOIDA","LISBETH","KARLEEN","JUNITA","JONA","ISIS","HYACINTH","HEDY","GWENN","ETHELENE","ERLINE","EDWARD","DONYA","DOMONIQUE","DELICIA","DANNETTE","CICELY","BRANDA","BLYTHE","BETHANN","ASHLYN","ANNALEE","ALLINE","YUKO","VELLA","TRANG","TOWANDA","TESHA","SHERLYN","NARCISA","MIGUELINA","MERI","MAYBELL","MARLANA","MARGUERITA","MADLYN","LUNA","LORY","LORIANN","LIBERTY","LEONORE","LEIGHANN","LAURICE","LATESHA","LARONDA","KATRICE","KASIE","KARL","KALEY","JADWIGA","GLENNIE","GEARLDINE","FRANCINA","EPIFANIA","DYAN","DORIE","DIEDRE","DENESE","DEMETRICE","DELENA","DARBY","CRISTIE","CLEORA","CATARINA","CARISA","BERNIE","BARBERA","ALMETA","TRULA","TEREASA","SOLANGE","SHEILAH","SHAVONNE","SANORA","ROCHELL","MATHILDE","MARGARETA","MAIA","LYNSEY","LAWANNA","LAUNA","KENA","KEENA","KATIA","JAMEY","GLYNDA","GAYLENE","ELVINA","ELANOR","DANUTA","DANIKA","CRISTEN","CORDIE","COLETTA","CLARITA","CARMON","BRYNN","AZUCENA","AUNDREA","ANGELE","YI","WALTER","VERLIE","VERLENE","TAMESHA","SILVANA","SEBRINA","SAMIRA","REDA","RAYLENE","PENNI","PANDORA","NORAH","NOMA","MIREILLE","MELISSIA","MARYALICE","LARAINE","KIMBERY","KARYL","KARINE","KAM","JOLANDA","JOHANA","JESUSA","JALEESA","JAE","JACQUELYNE","IRISH","ILUMINADA","HILARIA","HANH","GENNIE","FRANCIE","FLORETTA","EXIE","EDDA","DREMA","DELPHA","BEV","BARBAR","ASSUNTA","ARDELL","ANNALISA","ALISIA","YUKIKO","YOLANDO","WONDA","WEI","WALTRAUD","VETA","TEQUILA","TEMEKA","TAMEIKA","SHIRLEEN","SHENITA","PIEDAD","OZELLA","MIRTHA","MARILU","KIMIKO","JULIANE","JENICE","JEN","JANAY","JACQUILINE","HILDE","FE","FAE","EVAN","EUGENE","ELOIS","ECHO","DEVORAH","CHAU","BRINDA","BETSEY","ARMINDA","ARACELIS","APRYL","ANNETT","ALISHIA","VEOLA","USHA","TOSHIKO","THEOLA","TASHIA","TALITHA","SHERY","RUDY","RENETTA","REIKO","RASHEEDA","OMEGA","OBDULIA","MIKA","MELAINE","MEGGAN","MARTIN","MARLEN","MARGET","MARCELINE","MANA","MAGDALEN","LIBRADA","LEZLIE","LEXIE","LATASHIA","LASANDRA","KELLE","ISIDRA","ISA","INOCENCIA","GWYN","FRANCOISE","ERMINIA","ERINN","DIMPLE","DEVORA","CRISELDA","ARMANDA","ARIE","ARIANE","ANGELO","ANGELENA","ALLEN","ALIZA","ADRIENE","ADALINE","XOCHITL","TWANNA","TRAN","TOMIKO","TAMISHA","TAISHA","SUSY","SIU","RUTHA","ROXY","RHONA","RAYMOND","OTHA","NORIKO","NATASHIA","MERRIE","MELVIN","MARINDA","MARIKO","MARGERT","LORIS","LIZZETTE","LEISHA","KAILA","KA","JOANNIE","JERRICA","JENE","JANNET","JANEE","JACINDA","HERTA","ELENORE","DORETTA","DELAINE","DANIELL","CLAUDIE","CHINA","BRITTA","APOLONIA","AMBERLY","ALEASE","YURI","YUK","WEN","WANETA","UTE","TOMI","SHARRI","SANDIE","ROSELLE","REYNALDA","RAGUEL","PHYLICIA","PATRIA","OLIMPIA","ODELIA","MITZIE","MITCHELL","MISS","MINDA","MIGNON","MICA","MENDY","MARIVEL","MAILE","LYNETTA","LAVETTE","LAURYN","LATRISHA","LAKIESHA","KIERSTEN","KARY","JOSPHINE","JOLYN","JETTA","JANISE","JACQUIE","IVELISSE","GLYNIS","GIANNA","GAYNELLE","EMERALD","DEMETRIUS","DANYELL","DANILLE","DACIA","CORALEE","CHER","CEOLA","BRETT","BELL","ARIANNE","ALESHIA","YUNG","WILLIEMAE","TROY","TRINH","THORA","TAI","SVETLANA","SHERIKA","SHEMEKA","SHAUNDA","ROSELINE","RICKI","MELDA","MALLIE","LAVONNA","LATINA","LARRY","LAQUANDA","LALA","LACHELLE","KLARA","KANDIS","JOHNA","JEANMARIE","JAYE","HANG","GRAYCE","GERTUDE","EMERITA","EBONIE","CLORINDA","CHING","CHERY","CAROLA","BREANN","BLOSSOM","BERNARDINE","BECKI","ARLETHA","ARGELIA","ARA","ALITA","YULANDA","YON","YESSENIA","TOBI","TASIA","SYLVIE","SHIRL","SHIRELY","SHERIDAN","SHELLA","SHANTELLE","SACHA","ROYCE","REBECKA","REAGAN","PROVIDENCIA","PAULENE","MISHA","MIKI","MARLINE","MARICA","LORITA","LATOYIA","LASONYA","KERSTIN","KENDA","KEITHA","KATHRIN","JAYMIE","JACK","GRICELDA","GINETTE","ERYN","ELINA","ELFRIEDA","DANYEL","CHEREE","CHANELLE","BARRIE","AVERY","AURORE","ANNAMARIA","ALLEEN","AILENE","AIDE","YASMINE","VASHTI","VALENTINE","TREASA","TORY","TIFFANEY","SHERYLL","SHARIE","SHANAE","SAU","RAISA","PA","NEDA","MITSUKO","MIRELLA","MILDA","MARYANNA","MARAGRET","MABELLE","LUETTA","LORINA","LETISHA","LATARSHA","LANELLE","LAJUANA","KRISSY","KARLY","KARENA","JON","JESSIKA","JERICA","JEANELLE","JANUARY","JALISA","JACELYN","IZOLA","IVEY","GREGORY","EUNA","ETHA","DREW","DOMITILA","DOMINICA","DAINA","CREOLA","CARLI","CAMIE","BUNNY","BRITTNY","ASHANTI","ANISHA","ALEEN","ADAH","YASUKO","WINTER","VIKI","VALRIE","TONA","TINISHA","THI","TERISA","TATUM","TANEKA","SIMONNE","SHALANDA","SERITA","RESSIE","REFUGIA","PAZ","OLENE","NA","MERRILL","MARGHERITA","MANDIE","MAN","MAIRE","LYNDIA","LUCI","LORRIANE","LORETA","LEONIA","LAVONA","LASHAWNDA","LAKIA","KYOKO","KRYSTINA","KRYSTEN","KENIA","KELSI","JUDE","JEANICE","ISOBEL","GEORGIANN","GENNY","FELICIDAD","EILENE","DEON","DELOISE","DEEDEE","DANNIE","CONCEPTION","CLORA","CHERILYN","CHANG","CALANDRA","BERRY","ARMANDINA","ANISA","ULA","TIMOTHY","TIERA","THERESSA","STEPHANIA","SIMA","SHYLA","SHONTA","SHERA","SHAQUITA","SHALA","SAMMY","ROSSANA","NOHEMI","NERY","MORIAH","MELITA","MELIDA","MELANI","MARYLYNN","MARISHA","MARIETTE","MALORIE","MADELENE","LUDIVINA","LORIA","LORETTE","LORALEE","LIANNE","LEON","LAVENIA","LAURINDA","LASHON","KIT","KIMI","KEILA","KATELYNN","KAI","JONE","JOANE","JI","JAYNA","JANELLA","JA","HUE","HERTHA","FRANCENE","ELINORE","DESPINA","DELSIE","DEEDRA","CLEMENCIA","CARRY","CAROLIN","CARLOS","BULAH","BRITTANIE","BOK","BLONDELL","BIBI","BEAULAH","BEATA","ANNITA","AGRIPINA","VIRGEN","VALENE","UN","TWANDA","TOMMYE","TOI","TARRA","TARI","TAMMERA","SHAKIA","SADYE","RUTHANNE","ROCHEL","RIVKA","PURA","NENITA","NATISHA","MING","MERRILEE","MELODEE","MARVIS","LUCILLA","LEENA","LAVETA","LARITA","LANIE","KEREN","ILEEN","GEORGEANN","GENNA","GENESIS","FRIDA","EWA","EUFEMIA","EMELY","ELA","EDYTH","DEONNA","DEADRA","DARLENA","CHANELL","CHAN","CATHERN","CASSONDRA","CASSAUNDRA","BERNARDA","BERNA","ARLINDA","ANAMARIA","ALBERT","WESLEY","VERTIE","VALERI","TORRI","TATYANA","STASIA","SHERISE","SHERILL","SEASON","SCOTTIE","SANDA","RUTHE","ROSY","ROBERTO","ROBBI","RANEE","QUYEN","PEARLY","PALMIRA","ONITA","NISHA","NIESHA","NIDA","NEVADA","NAM","MERLYN","MAYOLA","MARYLOUISE","MARYLAND","MARX","MARTH","MARGENE","MADELAINE","LONDA","LEONTINE","LEOMA","LEIA","LAWRENCE","LAURALEE","LANORA","LAKITA","KIYOKO","KETURAH","KATELIN","KAREEN","JONIE","JOHNETTE","JENEE","JEANETT","IZETTA","HIEDI","HEIKE","HASSIE","HAROLD","GIUSEPPINA","GEORGANN","FIDELA","FERNANDE","ELWANDA","ELLAMAE","ELIZ","DUSTI","DOTTY","CYNDY","CORALIE","CELESTA","ARGENTINA","ALVERTA","XENIA","WAVA","VANETTA","TORRIE","TASHINA","TANDY","TAMBRA","TAMA","STEPANIE","SHILA","SHAUNTA","SHARAN","SHANIQUA","SHAE","SETSUKO","SERAFINA","SANDEE","ROSAMARIA","PRISCILA","OLINDA","NADENE","MUOI","MICHELINA","MERCEDEZ","MARYROSE","MARIN","MARCENE","MAO","MAGALI","MAFALDA","LOGAN","LINN","LANNIE","KAYCE","KAROLINE","KAMILAH","KAMALA","JUSTA","JOLINE","JENNINE","JACQUETTA","IRAIDA","GERALD","GEORGEANNA","FRANCHESCA","FAIRY","EMELINE","ELANE","EHTEL","EARLIE","DULCIE","DALENE","CRIS","CLASSIE","CHERE","CHARIS","CAROYLN","CARMINA","CARITA","BRIAN","BETHANIE","AYAKO","ARICA","AN","ALYSA","ALESSANDRA","AKILAH","ADRIEN","ZETTA","YOULANDA","YELENA","YAHAIRA","XUAN","WENDOLYN","VICTOR","TIJUANA","TERRELL","TERINA","TERESIA","SUZI","SUNDAY","SHERELL","SHAVONDA","SHAUNTE","SHARDA","SHAKITA","SENA","RYANN","RUBI","RIVA","REGINIA","REA","RACHAL","PARTHENIA","PAMULA","MONNIE","MONET","MICHAELE","MELIA","MARINE","MALKA","MAISHA","LISANDRA","LEO","LEKISHA","LEAN","LAURENCE","LAKENDRA","KRYSTIN","KORTNEY","KIZZIE","KITTIE","KERA","KENDAL","KEMBERLY","KANISHA","JULENE","JULE","JOSHUA","JOHANNE","JEFFREY","JAMEE","HAN","HALLEY","GIDGET","GALINA","FREDRICKA","FLETA","FATIMAH","EUSEBIA","ELZA","ELEONORE","DORTHEY","DORIA","DONELLA","DINORAH","DELORSE","CLARETHA","CHRISTINIA","CHARLYN","BONG","BELKIS","AZZIE","ANDERA","AIKO","ADENA","YER","YAJAIRA","WAN","VANIA","ULRIKE","TOSHIA","TIFANY","STEFANY","SHIZUE","SHENIKA","SHAWANNA","SHAROLYN","SHARILYN","SHAQUANA","SHANTAY","SEE","ROZANNE","ROSELEE","RICKIE","REMONA","REANNA","RAELENE","QUINN","PHUNG","PETRONILA","NATACHA","NANCEY","MYRL","MIYOKO","MIESHA","MERIDETH","MARVELLA","MARQUITTA","MARHTA","MARCHELLE","LIZETH","LIBBIE","LAHOMA","LADAWN","KINA","KATHELEEN","KATHARYN","KARISA","KALEIGH","JUNIE","JULIEANN","JOHNSIE","JANEAN","JAIMEE","JACKQUELINE","HISAKO","HERMA","HELAINE","GWYNETH","GLENN","GITA","EUSTOLIA","EMELINA","ELIN","EDRIS","DONNETTE","DONNETTA","DIERDRE","DENAE","DARCEL","CLAUDE","CLARISA","CINDERELLA","CHIA","CHARLESETTA","CHARITA","CELSA","CASSY","CASSI","CARLEE","BRUNA","BRITTANEY","BRANDE","BILLI","BAO","ANTONETTA","ANGLA","ANGELYN","ANALISA","ALANE","WENONA","WENDIE","VERONIQUE","VANNESA","TOBIE","TEMPIE","SUMIKO","SULEMA","SPARKLE","SOMER","SHEBA","SHAYNE","SHARICE","SHANEL","SHALON","SAGE","ROY","ROSIO","ROSELIA","RENAY","REMA","REENA","PORSCHE","PING","PEG","OZIE","ORETHA","ORALEE","ODA","NU","NGAN","NAKESHA","MILLY","MARYBELLE","MARLIN","MARIS","MARGRETT","MARAGARET","MANIE","LURLENE","LILLIA","LIESELOTTE","LAVELLE","LASHAUNDA","LAKEESHA","KEITH","KAYCEE","KALYN","JOYA","JOETTE","JENAE","JANIECE","ILLA","GRISEL","GLAYDS","GENEVIE","GALA","FREDDA","FRED","ELMER","ELEONOR","DEBERA","DEANDREA","DAN","CORRINNE","CORDIA","CONTESSA","COLENE","CLEOTILDE","CHARLOTT","CHANTAY","CECILLE","BEATRIS","AZALEE","ARLEAN","ARDATH","ANJELICA","ANJA","ALFREDIA","ALEISHA","ADAM","ZADA","YUONNE","XIAO","WILLODEAN","WHITLEY","VENNIE","VANNA","TYISHA","TOVA","TORIE","TONISHA","TILDA","TIEN","TEMPLE","SIRENA","SHERRIL","SHANTI","SHAN","SENAIDA","SAMELLA","ROBBYN","RENDA","REITA","PHEBE","PAULITA","NOBUKO","NGUYET","NEOMI","MOON","MIKAELA","MELANIA","MAXIMINA","MARG","MAISIE","LYNNA","LILLI","LAYNE","LASHAUN","LAKENYA","LAEL","KIRSTIE","KATHLINE","KASHA","KARLYN","KARIMA","JOVAN","JOSEFINE","JENNELL","JACQUI","JACKELYN","HYO","HIEN","GRAZYNA","FLORRIE","FLORIA","ELEONORA","DWANA","DORLA","DONG","DELMY","DEJA","DEDE","DANN","CRYSTA","CLELIA","CLARIS","CLARENCE","CHIEKO","CHERLYN","CHERELLE","CHARMAIN","CHARA","CAMMY","BEE","ARNETTE","ARDELLE","ANNIKA","AMIEE","AMEE","ALLENA","YVONE","YUKI","YOSHIE","YEVETTE","YAEL","WILLETTA","VONCILE","VENETTA","TULA","TONETTE","TIMIKA","TEMIKA","TELMA","TEISHA","TAREN","TA","STACEE","SHIN","SHAWNTA","SATURNINA","RICARDA","POK","PASTY","ONIE","NUBIA","MORA","MIKE","MARIELLE","MARIELLA","MARIANELA","MARDELL","MANY","LUANNA","LOISE","LISABETH","LINDSY","LILLIANA","LILLIAM","LELAH","LEIGHA","LEANORA","LANG","KRISTEEN","KHALILAH","KEELEY","KANDRA","JUNKO","JOAQUINA","JERLENE","JANI","JAMIKA","JAME","HSIU","HERMILA","GOLDEN","GENEVIVE","EVIA","EUGENA","EMMALINE","ELFREDA","ELENE","DONETTE","DELCIE","DEEANNA","DARCEY","CUC","CLARINDA","CIRA","CHAE","CELINDA","CATHERYN","CATHERIN","CASIMIRA","CARMELIA","CAMELLIA","BREANA","BOBETTE","BERNARDINA","BEBE","BASILIA","ARLYNE","AMAL","ALAYNA","ZONIA","ZENIA","YURIKO","YAEKO","WYNELL","WILLOW","WILLENA","VERNIA","TU","TRAVIS","TORA","TERRILYN","TERICA","TENESHA","TAWNA","TAJUANA","TAINA","STEPHNIE","SONA","SOL","SINA","SHONDRA","SHIZUKO","SHERLENE","SHERICE","SHARIKA","ROSSIE","ROSENA","RORY","RIMA","RIA","RHEBA","RENNA","PETER","NATALYA","NANCEE","MELODI","MEDA","MAXIMA","MATHA","MARKETTA","MARICRUZ","MARCELENE","MALVINA","LUBA","LOUETTA","LEIDA","LECIA","LAURAN","LASHAWNA","LAINE","KHADIJAH","KATERINE","KASI","KALLIE","JULIETTA","JESUSITA","JESTINE","JESSIA","JEREMY","JEFFIE","JANYCE","ISADORA","GEORGIANNE","FIDELIA","EVITA","EURA","EULAH","ESTEFANA","ELSY","ELIZABET","ELADIA","DODIE","DION","DIA","DENISSE","DELORAS","DELILA","DAYSI","DAKOTA","CURTIS","CRYSTLE","CONCHA","COLBY","CLARETTA","CHU","CHRISTIA","CHARLSIE","CHARLENA","CARYLON","BETTYANN","ASLEY","ASHLEA","AMIRA","AI","AGUEDA","AGNUS","YUETTE","VINITA","VICTORINA","TYNISHA","TREENA","TOCCARA","TISH","THOMASENA","TEGAN","SOILA","SHILOH","SHENNA","SHARMAINE","SHANTAE","SHANDI","SEPTEMBER","SARAN","SARAI","SANA","SAMUEL","SALLEY","ROSETTE","ROLANDE","REGINE","OTELIA","OSCAR","OLEVIA","NICHOLLE","NECOLE","NAIDA","MYRTA","MYESHA","MITSUE","MINTA","MERTIE","MARGY","MAHALIA","MADALENE","LOVE","LOURA","LOREAN","LEWIS","LESHA","LEONIDA","LENITA","LAVONE","LASHELL","LASHANDRA","LAMONICA","KIMBRA","KATHERINA","KARRY","KANESHA","JULIO","JONG","JENEVA","JAQUELYN","HWA","GILMA","GHISLAINE","GERTRUDIS","FRANSISCA","FERMINA","ETTIE","ETSUKO","ELLIS","ELLAN","ELIDIA","EDRA","DORETHEA","DOREATHA","DENYSE","DENNY","DEETTA","DAINE","CYRSTAL","CORRIN","CAYLA","CARLITA","CAMILA","BURMA","BULA","BUENA","BLAKE","BARABARA","AVRIL","AUSTIN","ALAINE","ZANA","WILHEMINA","WANETTA","VIRGIL","VI","VERONIKA","VERNON","VERLINE","VASILIKI","TONITA","TISA","TEOFILA","TAYNA","TAUNYA","TANDRA","TAKAKO","SUNNI","SUANNE","SIXTA","SHARELL","SEEMA","RUSSELL","ROSENDA","ROBENA","RAYMONDE","PEI","PAMILA","OZELL","NEIDA","NEELY","MISTIE","MICHA","MERISSA","MAURITA","MARYLN","MARYETTA","MARSHALL","MARCELL","MALENA","MAKEDA","MADDIE","LOVETTA","LOURIE","LORRINE","LORILEE","LESTER","LAURENA","LASHAY","LARRAINE","LAREE","LACRESHA","KRISTLE","KRISHNA","KEVA","KEIRA","KAROLE","JOIE","JINNY","JEANNETTA","JAMA","HEIDY","GILBERTE","GEMA","FAVIOLA","EVELYNN","ENDA","ELLI","ELLENA","DIVINA","DAGNY","COLLENE","CODI","CINDIE","CHASSIDY","CHASIDY","CATRICE","CATHERINA","CASSEY","CAROLL","CARLENA","CANDRA","CALISTA","BRYANNA","BRITTENY","BEULA","BARI","AUDRIE","AUDRIA","ARDELIA","ANNELLE","ANGILA","ALONA","ALLYN","DOUGLAS","ROGER","JONATHAN","RALPH","NICHOLAS","BENJAMIN","BRUCE","HARRY","WAYNE","STEVE","HOWARD","ERNEST","PHILLIP","TODD","CRAIG","ALAN","PHILIP","EARL","DANNY","BRYAN","STANLEY","LEONARD","NATHAN","MANUEL","RODNEY","MARVIN","VINCENT","JEFFERY","JEFF","CHAD","JACOB","ALFRED","BRADLEY","HERBERT","FREDERICK","EDWIN","DON","RICKY","RANDALL","BARRY","BERNARD","LEROY","MARCUS","THEODORE","CLIFFORD","MIGUEL","JIM","TOM","CALVIN","BILL","LLOYD","DEREK","WARREN","DARRELL","JEROME","FLOYD","ALVIN","TIM","GORDON","GREG","JORGE","DUSTIN","PEDRO","DERRICK","ZACHARY","HERMAN","GLEN","HECTOR","RICARDO","RICK","BRENT","RAMON","GILBERT","MARC","REGINALD","RUBEN","NATHANIEL","RAFAEL","EDGAR","MILTON","RAUL","BEN","CHESTER","DUANE","FRANKLIN","BRAD","RON","ROLAND","ARNOLD","HARVEY","JARED","ERIK","DARRYL","NEIL","JAVIER","FERNANDO","CLINTON","TED","MATHEW","TYRONE","DARREN","LANCE","KURT","ALLAN","NELSON","GUY","CLAYTON","HUGH","MAX","DWAYNE","DWIGHT","ARMANDO","FELIX","EVERETT","IAN","WALLACE","KEN","BOB","ALFREDO","ALBERTO","DAVE","IVAN","BYRON","ISAAC","MORRIS","CLIFTON","WILLARD","ROSS","ANDY","SALVADOR","KIRK","SERGIO","SETH","KENT","TERRANCE","EDUARDO","TERRENCE","ENRIQUE","WADE","STUART","FREDRICK","ARTURO","ALEJANDRO","NICK","LUTHER","WENDELL","JEREMIAH","JULIUS","OTIS","TREVOR","OLIVER","LUKE","HOMER","GERARD","DOUG","KENNY","HUBERT","LYLE","MATT","ALFONSO","ORLANDO","REX","CARLTON","ERNESTO","NEAL","PABLO","LORENZO","OMAR","WILBUR","GRANT","HORACE","RODERICK","ABRAHAM","WILLIS","RICKEY","ANDRES","CESAR","JOHNATHAN","MALCOLM","RUDOLPH","DAMON","KELVIN","PRESTON","ALTON","ARCHIE","MARCO","WM","PETE","RANDOLPH","GARRY","GEOFFREY","JONATHON","FELIPE","GERARDO","ED","DOMINIC","DELBERT","COLIN","GUILLERMO","EARNEST","LUCAS","BENNY","SPENCER","RODOLFO","MYRON","EDMUND","GARRETT","SALVATORE","CEDRIC","LOWELL","GREGG","SHERMAN","WILSON","SYLVESTER","ROOSEVELT","ISRAEL","JERMAINE","FORREST","WILBERT","LELAND","SIMON","CLARK","IRVING","BRYANT","OWEN","RUFUS","WOODROW","KRISTOPHER","MACK","LEVI","MARCOS","GUSTAVO","JAKE","LIONEL","GILBERTO","CLINT","NICOLAS","ISMAEL","ORVILLE","ERVIN","DEWEY","AL","WILFRED","JOSH","HUGO","IGNACIO","CALEB","TOMAS","SHELDON","ERICK","STEWART","DOYLE","DARREL","ROGELIO","TERENCE","SANTIAGO","ALONZO","ELIAS","BERT","ELBERT","RAMIRO","CONRAD","NOAH","GRADY","PHIL","CORNELIUS","LAMAR","ROLANDO","CLAY","PERCY","DEXTER","BRADFORD","DARIN","AMOS","MOSES","IRVIN","SAUL","ROMAN","RANDAL","TIMMY","DARRIN","WINSTON","BRENDAN","ABEL","DOMINICK","BOYD","EMILIO","ELIJAH","DOMINGO","EMMETT","MARLON","EMANUEL","JERALD","EDMOND","EMIL","DEWAYNE","WILL","OTTO","TEDDY","REYNALDO","BRET","JESS","TRENT","HUMBERTO","EMMANUEL","STEPHAN","VICENTE","LAMONT","GARLAND","MILES","EFRAIN","HEATH","RODGER","HARLEY","ETHAN","ELDON","ROCKY","PIERRE","JUNIOR","FREDDY","ELI","BRYCE","ANTOINE","STERLING","CHASE","GROVER","ELTON","CLEVELAND","DYLAN","CHUCK","DAMIAN","REUBEN","STAN","AUGUST","LEONARDO","JASPER","RUSSEL","ERWIN","BENITO","HANS","MONTE","BLAINE","ERNIE","CURT","QUENTIN","AGUSTIN","MURRAY","JAMAL","ADOLFO","HARRISON","TYSON","BURTON","BRADY","ELLIOTT","WILFREDO","BART","JARROD","VANCE","DENIS","DAMIEN","JOAQUIN","HARLAN","DESMOND","ELLIOT","DARWIN","GREGORIO","BUDDY","XAVIER","KERMIT","ROSCOE","ESTEBAN","ANTON","SOLOMON","SCOTTY","NORBERT","ELVIN","WILLIAMS","NOLAN","ROD","QUINTON","HAL","BRAIN","ROB","ELWOOD","KENDRICK","DARIUS","MOISES","FIDEL","THADDEUS","CLIFF","MARCEL","JACKSON","RAPHAEL","BRYON","ARMAND","ALVARO","JEFFRY","DANE","JOESPH","THURMAN","NED","RUSTY","MONTY","FABIAN","REGGIE","MASON","GRAHAM","ISAIAH","VAUGHN","GUS","LOYD","DIEGO","ADOLPH","NORRIS","MILLARD","ROCCO","GONZALO","DERICK","RODRIGO","WILEY","RIGOBERTO","ALPHONSO","TY","NOE","VERN","REED","JEFFERSON","ELVIS","BERNARDO","MAURICIO","HIRAM","DONOVAN","BASIL","RILEY","NICKOLAS","MAYNARD","SCOT","VINCE","QUINCY","EDDY","SEBASTIAN","FEDERICO","ULYSSES","HERIBERTO","DONNELL","COLE","DAVIS","GAVIN","EMERY","WARD","ROMEO","JAYSON","DANTE","CLEMENT","COY","MAXWELL","JARVIS","BRUNO","ISSAC","DUDLEY","BROCK","SANFORD","CARMELO","BARNEY","NESTOR","STEFAN","DONNY","ART","LINWOOD","BEAU","WELDON","GALEN","ISIDRO","TRUMAN","DELMAR","JOHNATHON","SILAS","FREDERIC","DICK","IRWIN","MERLIN","CHARLEY","MARCELINO","HARRIS","CARLO","TRENTON","KURTIS","HUNTER","AURELIO","WINFRED","VITO","COLLIN","DENVER","CARTER","LEONEL","EMORY","PASQUALE","MOHAMMAD","MARIANO","DANIAL","LANDON","DIRK","BRANDEN","ADAN","BUFORD","GERMAN","WILMER","EMERSON","ZACHERY","FLETCHER","JACQUES","ERROL","DALTON","MONROE","JOSUE","EDWARDO","BOOKER","WILFORD","SONNY","SHELTON","CARSON","THERON","RAYMUNDO","DAREN","HOUSTON","ROBBY","LINCOLN","GENARO","BENNETT","OCTAVIO","CORNELL","HUNG","ARRON","ANTONY","HERSCHEL","GIOVANNI","GARTH","CYRUS","CYRIL","RONNY","LON","FREEMAN","DUNCAN","KENNITH","CARMINE","ERICH","CHADWICK","WILBURN","RUSS","REID","MYLES","ANDERSON","MORTON","JONAS","FOREST","MITCHEL","MERVIN","ZANE","RICH","JAMEL","LAZARO","ALPHONSE","RANDELL","MAJOR","JARRETT","BROOKS","ABDUL","LUCIANO","SEYMOUR","EUGENIO","MOHAMMED","VALENTIN","CHANCE","ARNULFO","LUCIEN","FERDINAND","THAD","EZRA","ALDO","RUBIN","ROYAL","MITCH","EARLE","ABE","WYATT","MARQUIS","LANNY","KAREEM","JAMAR","BORIS","ISIAH","EMILE","ELMO","ARON","LEOPOLDO","EVERETTE","JOSEF","ELOY","RODRICK","REINALDO","LUCIO","JERROD","WESTON","HERSHEL","BARTON","PARKER","LEMUEL","BURT","JULES","GIL","ELISEO","AHMAD","NIGEL","EFREN","ANTWAN","ALDEN","MARGARITO","COLEMAN","DINO","OSVALDO","LES","DEANDRE","NORMAND","KIETH","TREY","NORBERTO","NAPOLEON","JEROLD","FRITZ","ROSENDO","MILFORD","CHRISTOPER","ALFONZO","LYMAN","JOSIAH","BRANT","WILTON","RICO","JAMAAL","DEWITT","BRENTON","OLIN","FOSTER","FAUSTINO","CLAUDIO","JUDSON","GINO","EDGARDO","ALEC","TANNER","JARRED","DONN","TAD","PRINCE","PORFIRIO","ODIS","LENARD","CHAUNCEY","TOD","MEL","MARCELO","KORY","AUGUSTUS","KEVEN","HILARIO","BUD","SAL","ORVAL","MAURO","ZACHARIAH","OLEN","ANIBAL","MILO","JED","DILLON","AMADO","NEWTON","LENNY","RICHIE","HORACIO","BRICE","MOHAMED","DELMER","DARIO","REYES","MAC","JONAH","JERROLD","ROBT","HANK","RUPERT","ROLLAND","KENTON","DAMION","ANTONE","WALDO","FREDRIC","BRADLY","KIP","BURL","WALKER","TYREE","JEFFEREY","AHMED","WILLY","STANFORD","OREN","NOBLE","MOSHE","MIKEL","ENOCH","BRENDON","QUINTIN","JAMISON","FLORENCIO","DARRICK","TOBIAS","HASSAN","GIUSEPPE","DEMARCUS","CLETUS","TYRELL","LYNDON","KEENAN","WERNER","GERALDO","COLUMBUS","CHET","BERTRAM","MARKUS","HUEY","HILTON","DWAIN","DONTE","TYRON","OMER","ISAIAS","HIPOLITO","FERMIN","ADALBERTO","BO","BARRETT","TEODORO","MCKINLEY","MAXIMO","GARFIELD","RALEIGH","LAWERENCE","ABRAM","RASHAD","KING","EMMITT","DARON","SAMUAL","MIQUEL","EUSEBIO","DOMENIC","DARRON","BUSTER","WILBER","RENATO","JC","HOYT","HAYWOOD","EZEKIEL","CHAS","FLORENTINO","ELROY","CLEMENTE","ARDEN","NEVILLE","EDISON","DESHAWN","NATHANIAL","JORDON","DANILO","CLAUD","SHERWOOD","RAYMON","RAYFORD","CRISTOBAL","AMBROSE","TITUS","HYMAN","FELTON","EZEQUIEL","ERASMO","STANTON","LONNY","LEN","IKE","MILAN","LINO","JAROD","HERB","ANDREAS","WALTON","RHETT","PALMER","DOUGLASS","CORDELL","OSWALDO","ELLSWORTH","VIRGILIO","TONEY","NATHANAEL","DEL","BENEDICT","MOSE","JOHNSON","ISREAL","GARRET","FAUSTO","ASA","ARLEN","ZACK","WARNER","MODESTO","FRANCESCO","MANUAL","GAYLORD","GASTON","FILIBERTO","DEANGELO","MICHALE","GRANVILLE","WES","MALIK","ZACKARY","TUAN","ELDRIDGE","CRISTOPHER","CORTEZ","ANTIONE","MALCOM","LONG","KOREY","JOSPEH","COLTON","WAYLON","VON","HOSEA","SHAD","SANTO","RUDOLF","ROLF","REY","RENALDO","MARCELLUS","LUCIUS","KRISTOFER","BOYCE","BENTON","HAYDEN","HARLAND","ARNOLDO","RUEBEN","LEANDRO","KRAIG","JERRELL","JEROMY","HOBERT","CEDRICK","ARLIE","WINFORD","WALLY","LUIGI","KENETH","JACINTO","GRAIG","FRANKLYN","EDMUNDO","SID","PORTER","LEIF","JERAMY","BUCK","WILLIAN","VINCENZO","SHON","LYNWOOD","JERE","HAI","ELDEN","DORSEY","DARELL","BRODERICK","ALONSO"/*

  Nontransitive dice in Picat.

  From 
  http://en.wikipedia.org/wiki/Nontransitive_dice
  """
  A set of nontransitive dice is a set of dice for which the relation 
  "is more likely to roll a higher number" is not transitive. See also 
  intransitivity.
  
  This situation is similar to that in the game Rock, Paper, Scissors, 
  in which each element has an advantage over one choice and a 
  disadvantage to the other.
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   
   M = 3, % number of dice
   N = 6, % number of sides of each die

   % the data (if any)

   % from the Wikipedia page
   %  A > B = 5/9   B > C = 5/9  C > A = 5/9
   D = 
     [[2,2,4,4,9,9], % die A
      [1,1,6,6,8,8], % die B
      [3,3,5,5,7,7]  % die C
      ],

   UseData = 0,

   % decision variables

   % the dice
   Dice = new_array(M,N),
   Dice :: 1..N*2,

   % the competitions: 
   % (die 1 vs die 2, die 2 vs die 1), ... (die m vs die 1, die 1 vs die m)
   % And the first die must beat the second in each round.
   % Note the last wrap around which breaks the transitivity.
   Comp = new_array(M, 2), % [0..M-1, 1..2] in 0..n*n,
   Comp :: 0..N*N,

   % max value of the dice
   MaxVal :: 0..N*2,
   % max win
   MaxWin :: 0..N*N,

   % gap, gap_sum
   Gap = new_array(M), % gap[0..m-1] in 0..n*n,
   Gap :: 0..N*N,
   GapSum :: 0..N*N*M,


   % constraints 

   if (UseData == 1) then
      foreach(I in 1..M, J in 1..N) 
         Dice[I,J] #= D[I,J]
      end
   end,

   GapSum #= sum([Gap[I] : I in 1..M-1]),
   MaxVal #= max([Dice[I,J] : I in 1..M, J in 1..N]),
   MaxWin #= max([Comp[I,1] : I in 1..M]),

   % order the number of each die (increasing)
   foreach(DD in 1..M) 
      foreach(I in 2..N) 
         Dice[DD,I-1] #<= Dice[DD,I]
      end
   end,

   % and now we roll...
   % Number of wins for [A vs B, B vs A]
   foreach(DD in 1..M) 
      Comp[DD,1] #= sum([(Dice[1+(DD mod M), R1] #> Dice[1+((DD + 1) mod M), R2])
                       : R1 in 1..N, R2 in 1..N]),
      Comp[DD,2] #= sum([(Dice[1+((DD+1) mod M), R1] #> Dice[1+((DD) mod M), R2]) 
                                       : R1 in 1..N, R2 in 1..N]),

      Gap[DD] #= Comp[DD,1] - Comp[DD,2]
   end,


   % non-transitivity
   % All dice 1..m-1 must beat the follower, and die m must beat die 1
   foreach(DD in 1..M) 
       Comp[DD,1] #> Comp[DD,2]
   end,
   Comp[M,1] #> Comp[1,2],

   % symmetry breaking (be careful if you use one of the examples above)
   /*
   foreach(DD in 2..M) {
      lex(all(j in 1..n) dice[d-1,j],all(j in 1..n) dice[d,j]),
   } 
   */

   Vars = Dice.to_list() ++ Comp.to_list(), %  ++ Gap, %  ++ [MaxVal,MaxWin,GapSum],


   % maximize sum(i in 0..m-1, j in 1..2) comp[i,j],
   % maximize min(i in 0..m-1) comp[i,1], % maximize the smallest winning
   % maximize min(i in 0..m-1) gap[i], % maximize the smallest winning

   % solve([constr,split, $report(printf("Found %d\n", MaxVal)), $min(MaxVal)], Vars), 
   solve([constr,split], Vars), 
   % solve([constr, $max(MaxWin)], Vars), 
   % solve([$report(printf("Found %d\n", GapSum)),$max(GapSum)], Vars), 
   % solve([$max(sum([Comp[I,1] : I in 1..M]))], Vars), % maximize the sum of the winnings


   writeln(maxVal=MaxVal),
   writeln(maxWin=MaxWin),
   writeln(gapSum=GapSum),
   println("Dice:"),
   foreach(DD in Dice)
     println(DD)
   end,
   println("Comp:"),
   foreach(C in Comp)
     println(C)
   end,
   nl.
/*

  N-Queens problem in Picat.


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

%
% Note that $Q[I] is needed here.
%
queens3(N, Q) =>
    Q=new_list(N),
    Q :: 1..N,
    all_different(Q),
    all_different([$Q[I]-I : I in 1..N]),
    all_different([$Q[I]+I : I in 1..N]),
    solve([ff],Q).

queens3(N) =>
    queens3_all(N, Solutions),
    % writeln(Solutions),
    writeln(len=Solutions.length).

% generate all solutions via solve_all (don't work right now)
queens3_all(N, Solutions) =>
    Q=new_list(N),
    Q :: 1..N,
    all_different(Q),
    all_different([$Q[I]-I : I in 1..N]),
    all_different([$Q[I]+I : I in 1..N]),
    Solutions = solve_all([ff],Q).
    % This works:
    % Solutions = findall(Q, $solve($Q)).


% Using all_distinct instead
queens3b(N, Q) =>
    Q=new_list(N),
    Q :: 1..N,
    all_distinct(Q),
    all_distinct([$Q[I]-I : I in 1..N]),
    all_distinct([$Q[I]+I : I in 1..N]),
    solve([ff],Q).

    
% alternative approaches
queens4(N, Q) =>
   Q = new_list(N),
   Q :: 1..N,
   foreach(A in [-1,0,1])
      all_different([$Q[I]+I*A : I in 1..N])
   end,
   solve([ff],Q).

% Decomposition of alldifferent
all_different_me(L) =>
   Len = length(L),
   foreach(I in 1..Len, J in I+1..Len) L[I] #!= L[J] end.

% Using all_different_me (my decomposition)
queens5(N, Q) =>
    Q=new_list(N),
    Q :: 1..N,
    all_different_me(Q),
    all_different_me([$Q[I]-I : I in 1..N]),
    all_different_me([$Q[I]+I : I in 1..N]),
    solve([ff],Q).

go => 
   queens3(8,Q),
   writeln(Q),
   N2 = 12, 
   queens3_all(8, Solutions),
   % writeln(Solutions),
   Len=Solutions.length,
   writef("N:%w %w solutions.\n%w\n", N2, Len, Solutions).
  

go2 => 
    garbage_collect(20000000),
    foreach(N in 2..14) 
       statistics(backtracks, Backtracks),
       statistics(runtime, [_, _Runtime1]),
       queens3_all(N, Solutions),
       Len=Solutions.length,
       statistics(backtracks, Backtracks2),
       B = Backtracks2 - Backtracks,
       Backtracks := Backtracks2,
       statistics(runtime, [_, Runtime2]),
       writef("N:%3d %10d solutions (%d backtracks, %d millis)\n", N, Len, B, Runtime2)
    end.

%
% Times per Picat v 0.1-beta 10:
%   queens3 :  6.7s (2 backtracks)
%   queens3b: 10.83s (0 backtracks)
%   queens4 : 4.25s (2 backtracks)
%   queens5 : 6.86s (2 backtracks)
%
go3 => 
    Ps = [queens3=1000, queens3b=1000, queens4=1000,queens5=1000],
    foreach(P=N in Ps) 
       printf("%w(%d)\n", P, N),
       time2(once(call(P,N,Q))),
       writeln(Q),
       nl
    end.

% Using permutations/1. Very slow.
go4 => 
    N = 8,
    C = 0,
    foreach(P in permutations(1..N))
       if check4(P) then 
           % writeln(P), 
           C := C +1 
       end
    end,
    writeln(sols=C),
    nl.

go5 =>
    N=100,
    queens3(N,Q),
    writeln(Q),
    nl.

% N=10000 probably exhaust the RAM...
% go6 =>
%     N = 10000,
%     println("timing queens4(10000,Q)"),
%     time2(queens4(N,_Q)),
%     nl.

go7 =>
    Ns = [8,10,50,100,400,500,700,1000,1500],
    foreach(N in Ns)
       println(n=N),
       time2(queens3(N,_)),
       nl
    end,
    nl.

check4(P) =>
   N = length(P),
   foreach(I in 1..N, J in I+1..N) 
      P[I]-I != P[J]-J,
      P[I]+I != P[J]+J
   end.
/* 

  Nrev benchmark in Picat.

  http://www.jekejeke.ch/idatab/doclet/prod/en/docs/05_run/15_stdy/06_bench/09_programs/01_nrev/01_nrev.p.html

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


/**
 * Prolog code for the nave reverse benchmark.
 *
 * This is the benchmark of page 219 of:
 * Warren, D.H.D. (1983): Applied Logic  Its Use and
 * Implementation as a Programming Tool,
 * Technical Note 290, SRI International, 1983
 *
 */

% Prolog code
/*
rev([],[]).
rev([X|Rest],Ans) :- rev(Rest,L), concatenate(L,[X],Ans).

concatenate([],L,L).
concatenate([X|L1],L2,[X|L3]) :- concatenate(L1,L2,L3).

datanrev([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
                     21,22,23,24,25,26,27,28,29,30]).

nrev :- datanrev(X), rev(X,_).
*/


rev([],Y) => Y = [].
rev([X|Rest],Ans) => rev(Rest,L), concatenate(L,[X],Ans).

concatenate([],L,L2) => L2 = L.
concatenate([X|L1],L2,LL) => LL = [X|L3], concatenate(L1,L2,L3).

datanrev(D) => D = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
                     21,22,23,24,25,26,27,28,29,30].

% go => datanrev(X), rev(X,_).

go2 => datanrev(X), rev(X,_Y).
/*

  Number of days problem (knapsack) Picat.

  From Nathan Brixius
  "Solving a Knapsack problem with Solver Foundation and LINQ"
  http://blogs.msdn.com/natbr/archive/2010/05/06/solving-a-knapsack-problem-with-solver-foundation-and-linq.aspx
 """
  Let's say I have this list of days and prices:

    List<ReservationPrice> prices = new List<ReservationPrice>(); 
    prices.Add(new ReservationPrice { NumberOfDays = 1, Price = 1000 }); 
    prices.Add(new ReservationPrice { NumberOfDays = 2, Price = 1200 }); 
    prices.Add(new ReservationPrice { NumberOfDays = 3, Price = 2500 }); 
    prices.Add(new ReservationPrice { NumberOfDays = 4, Price = 3100 }); 
    prices.Add(new ReservationPrice { NumberOfDays = 7, Price = 4000 }); 

  What I would like to able to do now is: give me the best price 
  from the list based on a number of days.

  So if ask for 3 days the best price from the list is from child one 
  (1000) and two (1200), but there are of course different combinations. 
  How would an algorithm that found the best price from this list 
  look like ?
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   % days(Days),
   % cost(Costs),
   data(Data),
   Days1 = [],
   Costs1 = [],
   foreach([Day,Cost] in Data) 
      Days1 := Days1 ++ [Day],
      Costs1 := Costs1 ++ [Cost]
   end, 
   Days = Days1,
   Costs = Costs1,

   writeln(days=Days),
   writeln(costs=Costs),
  
   MaxDays = sum(Days),
   writeln(maxDays=MaxDays),

   % Calculate the best deal for all days from 1..17
   foreach(D in 1..MaxDays)
      number_of_days(Days,Costs,D,X,TotalCost),
      writeln(num_days=D),
      writeln(x=X),
      writeln(total_cost=TotalCost),
      nl
   end.
        
scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).


number_of_days(Days,Costs,NumDays,X,TotalCost) =>

   MaxDays #= sum(Days),
   MaxCost #= sum(Costs),
   Days :: 1..MaxDays,
   TotalCost :: 1..MaxCost,
   Len = length(Days),

   X = new_list(Len),
   X :: 0..1,
   scalar_product(Days,X,NumDays),
   scalar_product(Costs,X,TotalCost),

   solve([$min(TotalCost)], X).
         

data(Data) => 
  Data = [[1,1000],
          [2,1200],
          [3,2500],
          [4,3100],
          [7,4000]].

% Number of days, Cost
days(Days) => Days = [1,2,3,4,7].
cost(Cost) => Cost = [1000,1200,2500,3100,4000].
/*

  (Decomposition of) global constraint nvalue  Picat.

  From MiniZinc:
  """
  Requires that the number of distinct values in 'x' is 'n'.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go ?=>

   Len = 5,
   X = new_list(Len),
   X :: 1..Len,
   N :: 1..Len,      

   nvalue(N,X),

   Vars = X ++ [N],

   solve(Vars),

   writeln([n=N, x=X]),
   fail.

% nvalue(?N,?X)
%
% Requires that the number of distinct values in X is N.
%
nvalue(N, X) =>
   Len = length(X),
   LB = min([fd_min(X[I]) : I in 1..Len]),
   UB = max([fd_max(X[I]) : I in 1..Len]),
   N #= sum([ (sum([ (X[J] #= I) : J in 1..Len]) #> 0) : I in LB..UB]).

/*

  (Decomposition of) global constraint nvalues  Picat.

  Reference: 
  Clobal Constraint Catalog
  http://www.emn.fr/x-info/sdemasse/gccat/Cnvalues.html
  """
  Purpose
 
      Let N be the number of distinct values assigned to the variables of the 
      VARIABLES collection. Enforce condition N <RELOP> LIMIT to hold.
 
  Example
      (<4,5,5,4,1,5>,=,3)
 
      The nvalues constraint holds since the number of distinct values occurring within 
      the collection 4,5,5,4,1,5 is equal (i.e., RELOP is set to =) to its 
      third argument LIMIT=3.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go ?=>

   Len = 5,
   X = new_list(Len),
   X :: 1..Len,
   N :: 1..Len,      

   % It's better to fix N,
   % otherwise the same X may yield many
   % solutions (when op is not #=).
   N #= 3,

   nvalues(X,#=<,N),

   nvalue(N2,X), % So, how many different values was it?

   Vars = X ++ [N],

   solve(Vars),

   writeln([n=N, n2=N2, x=X]),
   fail.

% nvalues(X,Op,N)
%
% Requires that the number of distinct values in the array X is 
%    Op N 
% where
% Op is either one of 
%   #=, #<m, #=<, #>=, #>
% (this is not checked though)    
%
nvalues(X, Op, N) =>
   nvalue(M,X),
   call(Op, M, N).

%
% nvalue(?N,?X)
%
% Requires that the number of distinct values in X is N.
% (See http://www.hakank.org/bprolog/nvalue.pl)
%
nvalue(N, X) =>
   Len = length(X),
   N #= sum([ (sum([ (X[J] #= I) : J in 1..Len]) #> 0) : I in 1..Len]).
/* 

  Optimal Binary Search Tree in Picat.

  From the B-Prolog program:
  http://www.probp.com/examples/tabling/obst.pl
  """
  Taken from "Simplifying Dynamic Programming via Mode-directed Tabling"
  Software Practice and Experience, 38(1): 75-94, 2008, by Hai-Feng Guo, Gopal Gupta 
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
   statistics(_, _),
   obst([(a, 22), (am, 18), (and, 20), (egg, 5), (if, 25), 
   (a, 2), (am, 7), (and, 20), (egg, 5), (if, 25),   
   (a, 12), (am, 8), (and, 4), (egg, 5), (if, 5),   
   (a, 22), (am, 10), (and, 20), (egg, 15), (if, 25),   
   (a, 32), (am, 20), (and, 23), (egg, 5), (if, 25),   
   (a, 42), (am, 4), (and, 20), (egg, 5), (if, 5),   
   (a, 32), (am, 18), (and, 3), (egg, 15), (if, 25),   
   (a, 23), (am, 19), (and, 20), (egg, 5), (if, 5),   
   (a, 24), (am, 9), (and, 20), (egg, 15), (if, 25),   
   (a, 21), (am, 38), (and, 20), (egg, 5), (if, 5),   
   (a, 2), (am, 8), (and, 21), (egg, 5), (if, 25),   
   (a, 16), (am, 18), (and, 20), (egg, 5), (if, 25),   
   (the, 2), (two, 8)], N, _T),
   statistics(_, [_, B]),
   printf("Optimal value is %d\n", N),
   printf("execution time = %dms.\n", B), 
   nl.


% Optimal Binary Search Tree

table(+,min,-)
obst(A, B1, B2) ?=> B1=B2, base(A, B1).
obst(FF, N, T) =>
    FF = [F1, F2 |L],
    break([F1, F2 | L], L1, L2, (_W, P)),
    obst(L1, N1, T1),
    obst(L2, N2, T2),
    T = T1 + T2 + P,
    N = T + N1 + N2.

table
base(WP,P) ?=> WP=[], P=0.
base(WP,P)  => WP=[(_W, P)].

table
break(FF, A, B, F) ?=> 
   A = [],
   B = [],
   FF = [F].
break(FF, A, FF2, F1) ?=> 
   A = [],
   FF = [F1, F2 | L],
   FF2 = [F2 | L].
break(FF, FF2, L2, F) =>
    FF = [F1, F2 | L],
    FF2 = [F1 | L1],
    break([F2 | L], L1, L2, F).


/*

  Olympic puzzle in Picat.

  Benchmark for Prolog (BProlog)
  """
    File   : olympic.pl
    Author : Neng-Fa ZHOU
    Date   : 1993
 
    Purpose: solve a puzzle taken from Olympic Arithmetic Contest
 
     Given ten variables with the following configuration:
 
                 X7   X8   X9   X10
 
                    X4   X5   X6
 
                       X2   X3             
 
                          X1
 
    We already know that X1 is equal to 3 and want to assign each variable
    with a different integer from {1,2,...,10} such that for any three
    variables 
                        Xi   Xj
 
                           Xk
    the following constraint is satisfied:
 
                      |Xi-Xj| = Xk
  """

 

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

olympic(Vars) =>

   Vars=[X1,X2,X3,X4,X5,X6,X7,X8,X9,X10],
   Vars :: 1..10,

   all_different(Vars),

   X1 #= 3,
   minus(X2,X3,X1),
   minus(X4,X5,X2),
   minus(X5,X6,X3),
   minus(X7,X8,X4),
   minus(X8,X9,X5),
   minus(X9,X10,X6),

   solve([ff], Vars).


print_olympic([X1,X2,X3,X4,X5,X6,X7,X8,X9,X10]) =>
   printf("%d  %d  %d %d\n",X7,X8,X9,X10),
   printf("  %d  %d  %d\n",X4,X5,X6),
   printf("    %d  %d\n",X2,X3),
   printf("      %d\n",X1),
   nl.


minus(X, Y, Z) =>
   Z #= abs(X-Y).
/* 

  Omelet problem in Picat.

  From 
  http://www.sci.brooklyn.cuny.edu/~zhou/prolog_contest/pc2012.txt
  """
  Solutions in B-Prolog for the 2012 Prolog Programming Contest 
  Team members: Christian Theil Have, Nuno Lopes, and Neng-Fa Zhou 
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
   omelet(1,1,D11),
   writeln(d11=D11),
   omelet(2,1,D21),
   writeln(d21=D21),
   omelet(2,7,D27),
   writeln(d27=D27),
   omelet(3,7,D37),
   writeln(d37=D37),

   nl.

%% 4. omelet.pl
% Example queries:
% ?- omelet(1,1,D)
%    D = 1
% ?- omelet(2,1,D)
%    D=1
% ?- omelet(2,7,D)
%    D=4
% ?- omelet(3,7,D)
%    D=3

table (+,+,min)
omelet(_,1,X) => X=1.
omelet(1,H,H2) => H2=H.
omelet(N,H,D) =>
    N>1,
    H>1,
    between(1,H,L),
    N1 = N-1,
    L1 = L-1,
    omelet(N1,L1,D1),
    L2 = H-L,
    omelet(N1,L2,D2),
    D = max(D1,D2)+1.
/* 

  One-dimensional cellular automata in Picat.

  From Rosetta Code:
  http://rosettacode.org/wiki/One-dimensional_cellular_automata
  """
  Assume an array of cells with an initial distribution of live and dead cells, and 
  imaginary cells off the end of the array having fixed values.

  Cells in the next generation of the array are calculated based on the value of the 
  cell and its left and right nearest neighbours in the current generation. If, in the 
  following table, a live cell is represented by 1 and a dead cell by 0 then to generate 
  the value of the cell at a particular index in the array of cellular values you use 
  the following table:

  000 -> 0  # 
  001 -> 0  #
  010 -> 0  # Dies without enough neighbours
  011 -> 1  # Needs one neighbour to survive
  100 -> 0  #
  101 -> 1  # Two neighbours giving birth
  110 -> 1  # Needs one neighbour to survive
  111 -> 0  # Starved to death.
  """

  Compare with my K solution
  http://rosettacode.org/wiki/One-dimensional_cellular_automata#K


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


% The test instance
go =>
     %    _ # # # _ # # _ # _ # _ # _ # _ _ # _ _
     S = [0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,0,0],
     All = ca(S),
     foreach(A in All) println(A.convert()) end,
     writeln(len=All.length),
     nl.

% some random instances
go2 => 
     foreach(N in [5,10,20,50,75,100])
        ca_rand(N),
        nl
     end.

go3 =>
   N = 40,
   Ns = [0 : _ in 1..N],
   S = Ns ++ [1] ++ Ns,
   All = ca_30(S),
   foreach(A in All) println(A.convert()) end,
   writeln(len=All.length),
   nl.

go4 =>
   foreach(N in [5,10,20,50,75,100])
      ca30_rand(N),
      nl
   end.

   

%
% create the 1-D CA
%
ca(S) = All => 
     Len = S.length,
     All := [S],
     Seen = new_map(), % detect fixpoint and cycle
     while (not Seen.has_key(S))
        Seen.put(S,1),
        T = [S[1]] ++ [rule(slice(S,I-1,I+1)) : I in 2..Len-1] ++ [S[Len]],
        All := All ++ [T],
        S := T
     end.

ca_rand(N) =>
     S = [random2() mod 2 : _I in 1..N],
     All = ca(S),
     foreach(A in All) println(A.convert()) end,
     writeln(len=All.length),
     nl.

%
% Rule 30:
% http://en.wikipedia.org/wiki/Rule_30
%
ca_30(S) = All => 
     Len = S.length,
     All := [S],
     Seen = new_map(), % detect fixpoint and cycle
     while (not Seen.has_key(S))
        Seen.put(S,1),
        T = [S[1]] ++ [rule30(slice(S,I-1,I+1)) : I in 2..Len-1] ++ [S[Len]],
        All := All ++ [T],
        S := T
     end.

ca30_rand(N) =>
     S = [random2() mod 2 : _I in 1..N],
     All = ca_30(S),
     foreach(A in All) println(A.convert()) end,
     writeln(len=All.length),
     nl.


% for presentation
convert(L) = Res =>
    B = "_#",
    Res = [B[L[I]+1] : I in 1..L.length].


% the rules
index(+)
rule([0,0,0]) = 0. % 
rule([0,0,1]) = 0. %
rule([0,1,0]) = 0. % Dies without enough neighbours
rule([0,1,1]) = 1. % Needs one neighbour to survive
rule([1,0,0]) = 0. %
rule([1,0,1]) = 1. % Two neighbours giving birth
rule([1,1,0]) = 1. % Needs one neighbour to survive
rule([1,1,1]) = 0. % Starved to death.



% the rules
index(+)
rule30([0,0,0]) = 0.
rule30([0,0,1]) = 1.
rule30([0,1,0]) = 1.
rule30([0,1,1]) = 1.
rule30([1,0,0]) = 1.
rule30([1,0,1]) = 0.
rule30([1,1,0]) = 0.
rule30([1,1,1]) = 0.
/*

  Ordered words in Picat.

  http://rosettacode.org/wiki/Ordered_words
  """
  Define an ordered word as a word in which the letters of the word appear in 
  alphabetic order. Examples include 'abbey' and 'dirt'.

  The task is to find and display all the ordered words in this dictionary that have the 
  longest word length. (Examples that access the dictionary file locally assume that you 
  have downloaded this [unixdict.txt] file yourself.) The display needs to be shown 
  on this page. 

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
   FD = open("unixdict.txt"),
   % FD = open("words_lower.txt"),
   Dict = new_map(),
   while (not at_end_of_stream(FD))
      Line = read_line(FD),
      if Line == Line.sort() then
          Len = Line.length,
          Dict.put(Len, cond(Dict.has_key(Len), Dict.get(Len), "") ++ [Line])
      end
   end,
   close(FD),

   println(Dict.get(max(Dict.keys()))),

   nl.


go2 =>
   % Dict = "unixdict.txt",
   Dict = "words_lower.txt",
   Words = new_map([Word=Word.length : Word in read_file_lines(Dict), Word == Word.sort()]),
   MaxLen = max([Len : _Word=Len in Words]),
   println(maxLen=MaxLen),
   println([Word : Word=Len in Words, Len=MaxLen].sort()),

   nl.

/*

  Organize a day in Picat.

  Problem formulation:
  Slides on (finite domain) Constraint Logic Programming, page 38f

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   N = 4,
   TasksStr = ["Work","Mail","Shop","Bank"],

   Begins = new_list(N),
   Begins :: 9..17,
   Ends = new_list(N),
   Ends :: 9..17,

   durations(Durations),
   before_tasks(BeforeTasks),

   L = findall([Begins,Ends], $organize(Durations,BeforeTasks,Begins, Ends)),
   foreach([BB,EE] in L)
      foreach(Task in 1..N)
          S = TasksStr[Task],
          B = BB[Task],
          E = EE[Task],
          printf("%w: %2d .. %2d\n",S,B,E)
      end,
      nl
   end,
   nl.


organize(Durations,BeforeTasks,Begins,Ends) =>

   N = 4, % number of tasks

   foreach(I in 1..N)  Ends[I] #= Begins[I] + Durations[I] end,

   % foreach(I in 1..N, J in I+1..N)
   %    no_overlap(Begins,Durations,I,J)
   % end,

   % no_overlaps is better written during the built-in constraint
   % serialized:
   serialized(Begins,Durations),


   % and serialized is in turn a special case of cumulative:
   % Ones = [1 : I in 1..N],
   % cumulative(Begins,Durations,Ones, 1),

   % handle precendeces
   foreach([A,B] in BeforeTasks) Ends[A] #=< Begins[B] end,

   % Work >= 11 a clock
   Begins[1] #>= 11,

   Vars = Begins ++ Ends,

   solve(Vars).


no_overlap(Begins,Durations,I,J) =>
   (Begins[I] + Durations[I] #=< Begins[J])
   #\/
   (Begins[J] + Durations[J] #=< Begins[I]).
   
   
   
% duration of the four tasks
durations(Durations) => Durations = [4,1,2,1].

% precedences
% [A,B] : task A must be completed before task B
before_tasks(Before) => Before = [[4,3],[2,1]].
/*

  Ormat game in Picat.

  From bit-player "The Ormat Game"
  http://bit-player.org/2010/the-ormat-game
  """
  I'm going to give you a square grid, with some of the cells colored 
  and others possibly left blank. We'll call this a template. Perhaps 
  the grid will be one of these 3x3 templates:
  
  [see pictures at the web page]
  
  You have a supply of transparent plastic overlays that match the 
  grid in size and shape and that also bear patterns of black dots:
  
  [ibid.]

  Your task is to assemble a subset of the overlays and lay them on 
  the template in such a way that dots cover all the colored squares 
  but none of the blank squares. You are welcome to superimpose multiple 
  dots on any colored square, but overall you want to use as few overlays 
  as possible. To make things interesting, I'll suggest a wager. I'll pay 
  you $3 for a correct covering of a 3x3 template, but you have to pay me 
  $1 for each overlay you use. Is this a good bet?
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   nolog,
   % Problem 6 is the hardest problem of 1..7
   foreach(P in 1..7) time2(ormat_game(P)) end.


% Problem 8 is the hardest of them all
go2 =>
   nolog,
   time2(ormat_game(8)).


% generate the 4! overlays
go3 =>
   nolog,
   generate(4, Overlays),
   foreach(O in Overlays) print_grid(O,_I),nl end,
   writeln(len=Overlays.length),
   nl.

% generate the (adjusted) overlays for Problem 4
go4 =>
   nolog,
   problem(6,N, Problem),
   generate(N, Problem, Overlays),
   foreach(O in Overlays) print_grid(O,_I),nl end,
   writeln(len=Overlays.length),
   nl.

% How much is reduced for the problems using generate/3?
go5 =>
   nolog,
   foreach(P in 1..8)
      problem(P,N,Problem),
      factorial(N,Fact),
      writeln([$problem(P),n=N,fact=Fact]),
      generate(N,Problem,Overlays),
      Len = Overlays.length,
      writeln(num_overlays=Len),
      Reduction = 1-(Len / Fact),
      writeln(reduction_factor=Reduction),
      nl
   end.

factorial(N,F) =>
   F1 = 1,
   foreach(I in 1..N) F1 := I*F1 end,
   F = F1.

ormat_game(P) =>

   problem(P, N, Problem),

   printf("Problem: %d\n", P),
   print_grid(Problem,_),
   nl,

   % There are N! possible overlays
   % generate(N,Overlays),

   % This version of generate reduces the tentative overlays.
   generate(N,Problem,Overlays),
   OSize = Overlays.length,
   writeln(after_generating=P),

   % decision variables
   X = new_list(OSize),
   X :: 0..1,
   NumOverlays #= sum(X),

   % constraints
   foreach(I in 1..N, J in 1..N)
      if Problem[I,J] == 1 then
          sum([X[O]*Overlays[O,I,J] : O in 1..OSize]) #>=  1
      else
          sum([X[O]*Overlays[O,I,J] : O in 1..OSize]) #= 0
      end
   end,
   % minimize the number of overlays needed

   writeln(search),
   % solve($[min,$min(NumOverlays)], X),
   % solve($[min,split,min(NumOverlays)], X),
   solve($[ff,min(NumOverlays)], X),


   % output
   writeln(x=X),
   writeln(numOverlays=NumOverlays),
   println('\nThe overlays:'),
   foreach(I in 1..OSize)
      if X[I] == 1 then
         print_grid(Overlays[I],I),
        nl
      end
   end,
   writeln(numOverlays=NumOverlays),
   nl.


print_grid(Grid,I) =>
   if nonvar(I) then
     printf("#%d\n",I)
   end,
   foreach(G in Grid) writeln(G) end.



%
% generate the N! overlays
%
generate(N,Overlays) =>
   Overlays = findall(Overlay,generate1(N,Overlay)).

generate1(N,Overlay) =>
   OverlayA = new_array(N,N),
   Vars = vars(OverlayA),
   Vars :: 0..1,
   foreach(I in 1..N)
      sum([OverlayA[I,J] : J in 1..N]) #= 1,
      sum([OverlayA[J,I] : J in 1..N]) #= 1 
   end,
   solve([ff,split],Vars),
   % convert to list
   Overlay = OverlayA.


% This version checks that it is a possible overlay,
% i.e. that is: when then problem has and 0 then the
% overlay also must have an 0 in the same position.
% This reduces the number of overlays and the complexity 
% of the problem
generate(N,Problem,Overlays) =>
   Overlays = findall(Overlay,generate1(N,Problem,Overlay)).

generate1(N,Problem,Overlay) =>
   OverlayA = new_array(N,N),
   Vars = vars(OverlayA),
   Vars :: 0..1,
   foreach(I in 1..N)
      foreach(J in 1..N)
         Problem[I,J] #= 0 #=> OverlayA[I,J] #= 0
      end,
      sum([OverlayA[I,J] : J in 1..N]) #= 1,
      sum([OverlayA[J,I] : J in 1..N]) #= 1
   end,
   solve([ff,split],Vars),
   % convert to list
   Overlay = OverlayA.




% The following problems are from 
% http://bit-player.org/2010/the-ormat-game
%
% Problem grid 1 (n=3)
problem(1, N, Grid) => N = 3,
Grid =
   [[1,0,0],
    [0,1,1],
    [0,1,1]].

% Problem grid 2 (n=3)
problem(2,N, Grid) => N = 3,
Grid =
   [[1,1,1],
    [1,1,1],
    [1,1,1]
   ].

% Problem grid 3 (n=3)
problem(3,N, Grid) => N = 3,
Grid = 
   [[1,1,1],
    [1,1,1],
    [1,1,0]].


%
% Problem 4 (n=4)
%
problem(4,N, Grid) => N=4,
Grid = 
   [[1,1,1,1],
    [1,1,1,1],
    [1,1,1,1],
    [1,1,0,0]].


%
% Problem 5 (n=5)
%
problem(5,N,Grid) => N = 5,
Grid =
   [[1,1,1,1,1],
    [1,1,1,1,1],
    [1,1,1,1,1],
    [1,1,1,1,1],
    [1,1,0,0,0]].
   

%
% Problem 6 (n=6)
%
% hard
%
problem(6,N, Grid) => N=6,
Grid =
   [[1,1,1,1,1,1],
    [1,1,1,1,1,1],
    [1,1,1,1,1,1],
    [1,1,1,1,1,1],
    [1,1,1,1,1,1],
    [1,1,0,0,0,0]].


%
% Problem 7 (n=7)
%
problem(7,N, Grid) => N=7,
Grid =
   [[1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1],
    [0,1,1,1,1,1,1],
    [0,0,1,1,1,1,1],
    [0,0,0,1,1,1,1],
    [0,0,0,0,1,1,1],
    [0,0,0,0,0,1,1]].

%
% Problem 8 (n=7), "flags"
%
% quite hard
%
problem(8,N, Grid) => N=7,
Grid =
   [[0,0,0,1,1,1,1],
    [0,0,0,1,1,1,1],
    [0,0,0,1,1,1,1],
    [1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1]].
/*

  Pair divides the sum in Picat
.
  From comp.lang.prolog
  """
  Date: Sat, Feb 28 2009 3:55 am
  From: Nick Wedd

  Here is a puzzle which I found surprisingly easy to program Prolog to
  generate solutions to.  If any of you teach Prolog to students, you
  might use it as an example (like the goat-wolf-cabbage thing).

  Find a set of four distinct positive integers such that, for every pair
  of them, their difference divides their sum.

  Find lots of such sets.

  As above, but sets of five distinct positive integers.
  
  As above, but sets of six ...
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% There are no solutions for 8 or 9 (for MaxVal=100)
problem =>
   N :: 5..7,

   indomain(N),
   writeln(n=N),

   MaxVal = 100,
   X = new_list(N),
   X :: 1..MaxVal,
   Z :: N..MaxVal*N,

   all_different(X),
   increasing(X),

   Z #= sum(X),
   Z mod N #= 0,
   foreach(I in 1..N, J in I+1..N) Z mod abs(X[I]-X[J]) #= 0 end,

   solve([constr,reverse_split], X),

   writeln(n=N),
   writeln(x=X),
   writeln(z=Z),
   nl.
      
   
increasing(List) =>
   foreach(I in 2..List.length) List[I-1] #=< List[I] end.
/*

  Palindrome detection in Picat.

  http://rosettacode.org/wiki/Palindrome_detection
  """
  Write at least one function/method (or whatever it is called in 
  your preferred language) to check if a sequence of characters (or bytes) 
  is a palindrome or not. The function must return a boolean value 
  (or something that can be used as boolean value, like an integer). 
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
   Strings = ["In girum imus nocte et consumimur igni", 
              "this is a non palindrome string",
              "anna ABcdcBA anna",
              "anna ABcdcBA annax",
              "A man, a plan, a canoe, pasta, heros, rajahs" ++
              "a coloratura, maps, snipe, percale, macaroni, " ++
              "a gag, a banana bag, a tan, a tag, " ++
              "a banana bag again (or a camel), a crepe, pins, " ++
              "Spam, a rut, a Rolo, cash, a jar, sore hats, " ++
              "a peon, a canal - Panama!"
           ],

   foreach(S in Strings) 
     if is_palindrome(S) then
        println([S, "yes"])
     else
        println([S, "no"])
     end
   end,
   nl.



is_palindrome(S) => 
    S2 = strip2(S),
    S2 = S2.reverse().

% lowercase and strip everythin except a..z
strip(S) = V =>
   V = [],
   Alpha = "abcdefghijklmnopqrstuvwxyz",
   foreach(C in S.to_lowercase()) 
      if member(C,Alpha) then
         V := V ++ [C]
      end
   end.

% Using list comprehension instead.
% Must use the helper predicate in2/2 since it don't work to have
%   Val in List as a condition.
strip2(S) = [C : C in S.to_lowercase(), C.in2("abcdefghijklmnopqrstuvwxyz")].

in2(Val, List) => member(Val, List).
/*

  Pancake sort in Picat.

  See 
   * http://en.wikipedia.org/wiki/Pancake_sorting
   * http://rosettacode.org/wiki/Sorting_algorithms/Pancake_sort


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   
   Nums = [7,6,5,9,8,4,3,1,2,0],
   println([Nums,pancake_sort(Nums)]),
   nl.

go2 => 

   foreach(N in 1..3) 
      M = 10**N, 
      printf("M: %d\n", M),
      R1 = [random() mod M  : _I in 1..M],
      time(_S = pancake_sort(R1))
   end,   
   nl.

% comparison, using built-in sort
go3 => 
   foreach(N in 1..5) 
      M = 10**N, 
      println(M),
      R1 = [random() mod M  : _I in 1..M],
      time(_S = sort(R1))
   end,   
   nl.


pancake_sort(Nums) = Nums2 =>
    Nums2 = Nums,

    foreach(I in Nums.length..-1..1) 
       % find the index of the largest element not yet sorted
     
       [_ThisMax, MaxIdx] = find_max([Nums[J] : J in 1..I]),
    
       if MaxIdx != I then
          % flip this max element to index 1
          if (MaxIdx > 1) then
            Tmp := [Nums2[J] : J in 1..MaxIdx].reverse(),
            foreach(K in 1..MaxIdx)
               Nums2[K] := Tmp[K]
            end
          end,
    
          % then flip the max element to its place
          Tmp := [Nums2[J] : J in 1..I].reverse(),
          foreach(K in 1..I) 
             Nums2[K] := Tmp[K]
          end
       end
    end.


%
% find the (first) index of the max value 
% in a tuple.
find_max(A) = [ThisMax,MaxIdx] =>
  MaxIdx = 1,
  ThisMax = A[1],
  foreach(J in 2..A.length)
    if A[J] > ThisMax then
      ThisMax := A[J],
      MaxIdx := J
    end
  end.
/*

  Pandigital numbers in Picat.

  From
  Albert H. Beiler "Recreations in the Theory of Numbers", quoted from
  http://www.worldofnumbers.com/ninedig1.htm
  """
  [ Chapter VIII : Digits - and the magic of 9 ]
  [ I found the same expos in Shakuntala Devi's book
    "Figuring : The Joy of Numbers" ]

  The following curious table shows how to arrange the 9 digits so that
  the product of 2 groups is equal to a number represented by the
  remaining digits."

    12 x 483 = 5796
    42 x 138 = 5796
    18 x 297 = 5346
    27 x 198 = 5346
    39 x 186 = 7254
    48 x 159 = 7632
    28 x 157 = 4396
    4 x 1738 = 6952
    4 x 1963 = 7852
  """

  See also

  * MathWorld http://mathworld.wolfram.com/PandigitalNumber.html
  """
  A number is said to be pandigital if it contains each of the digits
  from 0 to 9 (and whose leading digit must be nonzero). However,
  "zeroless" pandigital quantities contain the digits 1 through 9.
  Sometimes exclusivity is also required so that each digit is
  restricted to appear exactly once.
  """

  * Wikipedia http://en.wikipedia.org/wiki/Pandigital_number


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
        L = findall([X1,X2,X3], pandigital([X1,X2,X3])),
        Len = length(L),
        writeln(len=Len).

scalar_product(A, X, Product) => 
   Product #= sum([A[I]*X[I] : I in 1..A.length]).


%
% converts a number Num to/from a list of integer List given a base Base
%
to_num(List, Base, Num) =>
        Len = length(List),
        Num #= sum([List[I]*Base**(Len-I) : I in 1..Len]).


pandigital([X1,X2,X3]) =>
        
        %
        % length of numbers
        %
        % Len1 #>= 1,
        % Len1 #=< 4,
        % Len2 #>= 1,
        % Len2 #=< 4,
        % Len3 #= 4,
        Len1 :: 1..2,
        Len2 :: 3..4,
        Len3 #= 4,

        % Len1 #=< Len2, % symmetry breaking
        Len1 + Len2 + Len3 #= 9,
        
        indomain(Len1),

        % set length of lists
        X1 = new_list(Len1),
        X1 :: 1..9,

        X2 = new_list(Len2),
        X2 :: 1..9,

        X3 = new_list(Len3), % the result
        X3 :: 1..9,

        % convert to number
        Base = 10,
        to_num(X1, Base, Num1),
        to_num(X2, Base, Num2),
        to_num(X3, Base, Res),

        % calculate result
        Num1 * Num2 #= Res,

        Vars = X1 ++ X2 ++ X3,
        all_different(Vars),

        % search
        solve(Vars),

        writef("%2d * %4d = %4d\n",Num1,Num2,Res).
        % writeln([X1,X2,X3]).

/*

  Pangram checker in Picat.

  http://rosettacode.org/wiki/Pangram_checker
  """
  Write a function or method to check a sentence to see if it is a 
  pangram or not and show its use.
  
  A pangram is a sentence that contains all the letters of the 
  English alphabet at least once, for example: The quick brown fox jumps 
  over the lazy dog. 
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   S1 = "The quick brown fox jumps over the lazy dog",
   println([S1, is_pangram(S1)]),
   S2 = "The fox jumps over the lazy dog",
   println([S2, is_pangram(S2)]),

   nl.

is_pangram(S) = C => 
   Alpha = [chr(I+96) : I in 1..26],
   foreach(A in Alpha) member(A,S) end -> C = 1 ; C = 0.

/* 

  Panoz problem in Picat.

  From
  "How to Solve it With B-Prolog?"
  http://www.cs.nmsu.edu/ALP/2010/08/how-to-solve-it-with-b-prolog/
  (Prolog Programming Contest 2010)
  """
  Manhattan has several outlets of the famous Belgian bakery Panoz. During an 
  experiment with a new kind of chocolate pastry, the old bakery has exploded. 
  A new bakery will be built, somewhere in Manhattan, and this occasion is used to 
  optimize the distribution of all the goodies. Clearly Panoz wants the location 
  in Manhattan which minimizes the maximal (Manhattan) distance from the bakery to 
  any outlet.

  Write a predicate panoz/2 whose queries look like ?- panoz(Outlets,Sol). where Sol 
  is the location of the new bakery. The outlet coordinates Outlets are given as 
  a list of tuples, e.g. [(0,1),(0,2),(4,0),(4,3)].

  Here is a typical query and its answer:
  ?- panoz([(0,1),(0,2),(4,0),(4,3)],Sol).
  Sol = (2,2)

  Of course, Sol = (2,1) would also have been a good solution.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
  panoz([[0,1],[0,2],[4,0],[4,3]],Sol, Ds),
  writeln([sol=Sol,ds=Ds]),

  % find all optimal solutions
  panoz2([[0,1],[0,2],[4,0],[4,3]],Sols2,Ds),
  writeln(all_solutions=Sols2),
  nl.


panoz(Ps, Sol, Ds) =>
   Xs = [X : [X,_] in Ps],
   Ys = [Y : [_,Y] in Ps],
   X :: min(Xs)..max(Xs),
   Y :: min(Ys)..max(Ys),
   Ds #= max([max(X1-X,X-X1)+max(Y1-Y,Y-Y1) : [X1,Y1] in Ps]),
   solve([$min(Ds)],[X,Y]),
   Sol = [X,Y]. 


panoz2(Ps, Sols,Ds) =>
   Xs = [X : [X,_] in Ps],
   Ys = [Y : [_,Y] in Ps],
   X :: min(Xs)..max(Xs),
   Y :: min(Ys)..max(Ys),
   Ds #= max([max(X1-X,X-X1)+max(Y1-Y,Y-Y1) : [X1,Y1] in Ps]),
   Sols = solve_all([X,Y]).
/*

  Partition into subset of equal sums in Picat.

  From Programmers Stack Exchange (C#)
  http://programmers.stackexchange.com/questions/153184/partitioning-set-into-subsets-with-respect-to-equality-of-sum-among-subsets
  Partitioning set into subsets with respect to equality of sum among subsets
  """
  let say i have {3, 1, 1, 2, 2, 1,5,2,7} set of numbers, I need to split the 
  numbers such that sum of subset1 should be equal to sum of subset2 
  {3,2,7} {1,1,2,1,5,2}. First we should identify whether we can split number(one 
  way might be dividable by 2 without any remainder) and if we can, we should 
  write our algorithm two create s1 and s2 out of s.
  
  How to proceed with this approach? I read partition problem in wiki and even in some 
  articles but i am not able to get anything. Can someone help me to find the 
  right algorithm and its explanation in simple English?
  """

  In my comment I show some possible solutions in MiniZinc and Google or-tools/C#:
  http://programmers.stackexchange.com/a/153215/13955

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   
   S = [3, 1, 1, 2, 2, 1, 5, 2, 7],

   NumSubsets = 2,
   % NumSubsets = 3,
   
   partition(S, NumSubsets, X, Sum),
   print_result(S,NumSubsets, X, Sum).


% All 19 solutions of the original problem.
go1 => 

   S = [3, 1, 1, 2, 2, 1, 5, 2, 7],

   NumSubsets = 2,
   % NumSubsets = 3,
   
   All = findall(_, $(
                partition(S, NumSubsets, X, Sum),
                print_result(S,NumSubsets, X, Sum)
              )),
   writeln(len=All.length).

% random test
go2 =>

   NumSubsets = 2,
   % NumSubsets = 3,
   
   R = 20,
   N = 100,   
   test_random(NumSubsets, R, N).


% another random test
go3 =>

   NumSubsets = 3,
   % NumSubsets = 3,
   
   R = 100,
   N = 1000,
   test_random(NumSubsets, R, N).


test_random(NumSubsets, R,N) =>

   S = [1+(random() mod R) : _I in 1..N],

   while (sum(S) mod NumSubsets != 0)
       printf("fixing S\n"),
       S[R] := 1+(random() mod R)
   end,

   partition(S, NumSubsets, X, Sum),
   print_result(S,NumSubsets, X, Sum).


print_result(S,NumSubsets, X, Sum) =>

   writeln(s=S),
   writeln(sum=Sum),
   writeln(x=X),

   N = length(S),
   foreach(P in 1..NumSubsets)
      Indices = [I : I in 1..N, X[I] == P],
      Values = [S[I] : I in 1..N, X[I] == P],
      printf("Partition %d: Indices: %w  Values: %w.\n", P,Indices, Values)
   end,
   nl.


partition(S, NumSubsets, X, Sum) =>

   printf("sum(S): %d\n", sum(S)),
   N = length(S),

   % decision variables
   X = new_list(N),
   X :: 1..NumSubsets,

   Sum #= sum(S) // NumSubsets,
   foreach(P in 1..NumSubsets)
      sum([ (S[I]*(X[I] #= P)) : I in 1..N]) #= Sum
   end,


   % Symmetry breaking
   X[1] #= 1,

   solve([ff,updown], X).
/* 

  Pattern matching in Picat.

  This started to be an etude in pattern matching, and then
  evolved into porting some Haskell stuff.

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>

   writeln(my_factorial=my_factorial(10)),
   writeln(my_first=my_first([3,1,4,1,5])),
   writeln(my_second=my_second([3,1,4,1,5])),

   writeln(cumsum=cumsum(1..10)),

   greatestCommonPrefixTest(),
   rletest(),
   qsorttest(),

   casetest(),
   swaptest(),

   concordancetest(),
   difftest(),
   permutationstest(),

   partition_bytest(),

   haskelltest(),

   nl.

my_sum([]) = 0.
my_sum([H|T]) = H + my_sum(T).

my_factorial(0) = 1.
my_factorial(N) = N*my_factorial(N-1).

my_first([X|_]) = X.
my_second([_,X|_]) = X.

% See below
% scanl(_F, E, []) = [E].
% scanl(F, E, [X|Xs]) = [E] ++ scanl(F, apply(F,E,X), Xs).

% scanl2(F, L) = scanl(F,L.first(),L.rest()).

% scanr(_F, A, []) = [A].
% scanr(F, A, [X|Xs]) = [apply(F, X, first(Ys))] ++ Ys => Ys = scanr(F,A,Xs).

% cumsum(L) = scanl(+,L.first(), L.rest()).
cumsum(L) = scanl1(+,L).

rest(L) = [E : E in 2..L.length].


% Greatest common prefix
% Inspired by
% http://www.shlomifish.org/lecture/Perl/Haskell/slides/list_manip/examples.html
prefix2(_, []) = [].
prefix2([], _) = [].
prefix2([A|As],[B|Bs]) = cond(A == B, [A] ++ prefix2(As,Bs), []).

gc_prefix([]) = [].
gc_prefix([A|As]) = fold(prefix2,A,As).

greatestCommonPrefixTest =>
     writeln(gc_prefix=gc_prefix(["anna", "anders","alfred"])),
     writeln(gc_prefix=gc_prefix(["anna", "anders","andorra"])).


% Run Length Encoding
% http://www.shlomifish.org/lecture/Perl/Haskell/slides/basic/lists.html
rle([]) = [].
rle([A|[]]) = [(A=1)].
rle([X|Xs]) = cond(X == A, 
                   [(A=Count+1)|As],
                   [(X=1),(A=Count)|As]) => [(A=Count)|As] = rle(Xs).

rletest => 
   writeln(rle=rle([1,1,12,12,3,3,3,4,4,4,4,5,6,1,1,1])).
           

% quicksort
% http://www.shlomifish.org/lecture/Perl/Haskell/slides/basic/lists.html
qsort([]) = [].
qsort([X|Xs]) = qsort(EltsLtX) ++ [X] ++ qsort(EltsGrEqX)
                =>
                EltsLtX   = [Y : Y in Xs, Y < X],
                EltsGrEqX = [Y : Y in Xs, Y >= X].

qsort2([]) = [].
qsort2([X|Xs]) = qsort2([Y : Y in Xs, Y < X]) ++ 
                 [X] ++ 
                 qsort2([Y : Y in Xs, Y >= X]).

qsorttest => 
    writeln(qsort=qsort([4,6,32,8,6,4,2,1,1,3,45,6,8,65,4])),
    writeln(qsort2=qsort2([4,6,32,8,6,4,2,1,1,3,45,6,8,65,4])).


% case(Element, CheckList, ResponseList)
%    returns element R in ResponseList for which C in CheckList == Element
% returns _ if no matching element found.
case(E, Check, Response) = Case => 
    Case = _,
    foreach({C,R} in zip(Check,Response), var(Case))
       if E == C then Case := R end
    end.

casetest =>
   writeln(case=case(10, [3,2,1,5,4,10,3,2],[a,b,c,d,e,f,g,h])),
   writeln(case=case(10, [3,2,1,5,4,9,3,2],[a,b,c,d,e,f,g,h])).

swap([]) = [].
swap([X]) = [X].
swap([X,Y]) = [Y,X].
swap(List) = List.
swap(X,Y) = (Y,X).
swaptest => 
   writeln(swap=swap([])),
   writeln(swap=swap([1])),
   writeln(swap=swap([1,2])),
   writeln(swap=swap([1,2,3])),
   writeln(swap=swap(1,2)),
   A=1, B=2,
   (B,A) = swap(A,B),
   writeln(afterswap=[A,B]).


%
% Haskell's group/1: 
% Groups together consecutive elements of L into sublists.
%    Picat> G = grouph([1,2,3,2,1,2,2,2,3,3,21])               
%    G = [[1],[2],[3],[2],[1],[2,2,2],[3,3],[21]]
%
grouph(L) = Group =>
    Group = [],
    Tmp = [L[1]],
    foreach(I in 2..L.length) 
       if L[I] == L[I-1] then
          Tmp := [L[I]|Tmp]
       else
          Group := Group ++ [Tmp],
          Tmp := [L[I]]
       end
    end,
    Group := Group ++ [Tmp].   

% Haskell's nub/1
nub(List) = List.remove_dups().

% 
% This is inspired by an old Haskell function of mine which returns
% the concordance of the elements in List, as
%   [{element1,count1},{element2,count2},...]
%
% Here's the Haskell function:
% concordance lst =  zip (nub sortlst) (map length $ group sortlst) 
%     where sortlst = sort lst
% 
concordance(List) = zip(Sorted.nub(),map(length, Sorted.grouph()))
                     => 
                     Sorted = List.sort().

% Another version:
concordance2(List) = [{head(X), length(X)} : X in List.sort().grouph()].

concordancetest => 
   writeln(concordance=concordance([1,2,3,2,1,2,2,2,3,3,21,2,3,2,1,32,3,1])),
   println(concordance=concordance(["kalle","pelle","nisse","kalle","pelle","pelle","nisse","nisse","nisse","hakank"])),
   writeln(concordance2=concordance2([1,2,3,2,1,2,2,2,3,3,21,2,3,2,1,32,3,1])),
   println(concordance2=concordance2(["kalle","pelle","nisse","kalle","pelle","pelle","nisse","nisse","nisse","hakank"])),
   % println(concordance2=concordance2(read_file_chars("pattern_matching.pi").split())),
   nl.


% diff
% butlast(List) = [List[I] : I in 1..List.length-1].
butlast([])  = [].
butlast([_])  = [].
butlast([X|Xs]) = [X] ++ butlast(Xs).

diff(List) = [Y-X : {X,Y} in zip(tail(List), butlast(List))].

difftest =>
   writeln(diff=diff([2,3,1,8,6,6,5,3,33])),
   nl.


% Permutation inspired by this Haskell code
% permutation xs = case xs of {[] -> [[]]; _ -> [x:ys | x <- xs, ys <- permutation (delete x xs)]}

% Note: This is much slower than the built-in permutations/1.
permutations2(Xs) = cond(Xs == [],
                    [[]],
                    [[X] ++ Ys : X in Xs, Ys in permutations2(delete_all(Xs,X))]).

permutationstest =>
    writeln(permutation2=permutations2([1,2,3,4])),
    % time(_L=permutations2(1..9)), % 0.524s
    % time(_L=permutations(1..9)), % built-in: 0.08s
    nl.


% Partitions a list in sublists according to function F
partition_by(F,List) = partition_by(List,F), list(List) => true.
partition_by(List,F) = [ (K=[X : (V=X) in P, V=K ]): K in map(first,P).nub()] =>
       P=[(apply(F,X)=X) : X in List].


mod3(X) = X mod 3.
partition_bytest => 
   writeln(partition_by=partition_by(1..10, mod3)),
   writeln(partition_by=partition_by(1..20, mod2)), % lambda is undocumented for now
   writeln(partition_by=partition_by(mod2, 1..20)),
   % writeln(partition_by=partition_by(1..20, map(apply(mod,2)))),
   nl.


% Hutton: "Programming in Haskell", page 73, ex. 6
% unfold p h t x | p x = []
%                | otherwise = h x : unfold p h t (t x)   
unfold(P,H,T,X) = cond(call(P,X),
                       [],
                       [apply(H, X)] ++ unfold(P,H,T,apply(T,X))).

% convert int -> binary
%  int2bin = unfold (==0) (`mod` 2) (`div` 2)
eq0(X) => X == 0.
eq1(X) => X == 0.
mod2(X) = X mod 2.
div2(X) = X div 2.
int2bin(N) = unfold(eq0,mod2,div2, N).reverse().

% a little more "anonymous" version (using lambda)
% int2bin2(N) = unfold(eq0,lambda([X], X mod 2),lambda([X], X div 2), N).reverse().
int2bin2(N) = unfold(eq0,mod2,div2, N).reverse().

% int -> radix
% modRadix(X,Radix) = X mod Radix.
% divRadix(X,Radix) = X div Radix.
% int2radix(N,Radix) = unfold(eq0,modRadix(X,Radix),divRadix(X,Radix), N).reverse().

% list to radix
% radixMult(Radix,I,J) = Radix*J+I.
% list2int(L,Radix) = fold(radixMult(Radix),0,L).
% list2int(L) = list2int(L,10).

radixtest => 
    writeln(int2bin=int2bin(14)),
    writeln(int2bin=int2bin2(14)),
    % writeln(int2radix=int2radix(150000000,36)),
    % writeln(list2int=list2int([1,2,3,4,5])),
    % writeln(list2int=list2int([1,2,3,4,5],13)),
    % writeln(list2int=[1,2,3,4,5,6].list2int(13)),

    writeln(int2bin=map(int2bin,2..10)),
%    writeln(int2radix=map(lambda([X],int2radix(X,4)),2..10)),
    nl.

%
% Here are Picat version of the functions in
% 
% From "Appendix: Some standard function" 
% in Richard Bird
% "Introduction to Functional Programming using Haskell
% second edition
%
% Note: Picat don't support lazy lists and some other Haskell
%       constructs.
% Also, some functions are yet to be written:
%   - cross
%   - iterate
%   - unzipx

% 1. Functional composition
o(F,G,X) = apply(G,apply(F,X)).

% 2. Concatenates to lists:
conc([], Ys) = Ys.
conc([X|Xs],Ys) = [X] ++ conc(Xs,Ys).

% 3. Conjunction
conj(1, X) = X.
conj(0, _) = 0.

% 4. Disjunction
disj(1, _) = 1.
disj(0, X) = X.

% 5. List indexing
% 0-based
ix0([], N) = _ => throw $error(index_to_large,ix,[], N).
ix0([X|_Xs], 0) = X.
ix0([_X|Xs], N) = ix0(Xs,N-1).

% 1-based
ix1([], N) = _ => throw $error(index_to_large,ix,[], N).
ix1([X|_Xs], 1) = X.
ix1([_X|Xs], N) = ix1(Xs,N-1).

% 6. and
and(1,1) = 1.
and(1,0) = 0.
and(0,_) = 0.
and(List) = foldr(and, 1, List), list(List) => true.

% 7. concat (i.e. flatten one level)
concat(List) = foldl(++,[], List).

% 8. const
const(X,_Y) = X.

% 9 cross
% cross(F,G,[X1,X2]) = (apply(F, X1),apply(G,X2)).  % TBW

% 10 curry
curry(F,X,Y) = apply(F,X,Y). % ?

% 11 drop
drop(0, Xs) = Xs.
drop(_N,[]) = [].
drop(N,[_X|Xs]) = drop(N-1, Xs).

% 12 dropWhile
drop_while2(_P,[]) = [].
drop_while2(P,[X|Xs]) = cond(call(P,X), drop_while2(P,Xs), [X] ++ Xs).

% 13 filter
filter(_P,[]) = [].
filter(P,[X|Xs]) = cond(call(P,X), [X] ++ filter(P,Xs), filter(P,Xs)).

% 14 flip
% L=flip(++,[4],[1]) -> [1,4] 
% L=flip(lambda([X,Y], X-Y), 10,3) -> 3 - 10 = -7
flip(F,X,Y) = apply(F,Y,X).

% 15 foldl
foldl(_F,E,[]) = E.
foldl(F,E,[X|Xs]) = foldl(F, apply(F,E,X), Xs).

% 16 fold1
foldl1(F,[]) = _ => throw $error(empty_list,foldl1,F, []).
foldl1(F,[X|Xs]) = foldl(F,X,Xs).

% 17 foldr
foldr(_F,E,[]) = E.
foldr(F,E,[X|Xs]) = apply(F,X,foldr(F,E,Xs)).

% 18 foldr1f
foldr1(F,[]) = _ => throw $error(empty_list,fold1,F, []).
foldr1(F,[X|Xs]) = apply(F, X, foldr1(F,Xs)).

% 19 fst
fst(X,_Y) = X.
fst([X,_Y]) = X.

% 20 head
head([]) = _ => throw $error(empty_list,head,[]).
head([X|_Xs]) = X. % note: It says Xs in the book

% 21 id
id(X) = X.

% 22 init
init([]) = _ => throw $error(empty_list,head,[]).
init([_X]) = [].
init([X,Y|Xs]) = [X] ++ init([Y|Xs]).

% 23 iterate
% iterate(F,X) = [X] ++ iterate(F, apply(F, X)). % TBW

% 24 lastx (slower than built-in last)
lastx([]) = _ => throw $error(empty_list,lastx,[]).
lastx([X]) = X.
lastx([_X,Y|Xs]) = lastx([Y|Xs]).

% 25 length
lengthx([]) = 0.
lengthx([_X|Xs]) = 1 + lengthx(Xs).

% 26 map
mapx(_F,[]) = [].
mapx(F,[X|Xs]) = [apply(F,X)] ++ mapx(F,Xs).

% 27 not
notx(1) = 0.
notx(0) = 1.

% 28 null
null([]) => true.
null([_]) => not(true).
null([_X|_Xs]) => not(true).

% 29 or
or(1,_) = 1.
or(0,1) = 1.
or(0,0) = 0.
or(List) = foldr(or,0,List).

% 30 pair (NB: I'm not sure about this...)
pair(F,G,X) = (apply(F,X), apply(G,X)). % ?

% 31 partition
partition(_P,[]) = [[],[]].
partition(P,[X|Xs]) = cond(call(P,X),
                            [[X|Ys],Zs],
                            [Ys,[X|Zs]]) =>
                       [Ys,Zs] = partition(P, Xs).


% 32 reverse (much slower than built-in reverse/1)
% reversex(List) = foldl(flip(++,[],List),[],List). % ?
app2(X,Y) = [Y] ++ X.
reversex(List) = foldl(app2,[],List).

% 33 scanl
scanl(_F, E, []) = [E].
% scanl(F, E, [X|Xs]) = [E] ++ scanl(F, apply(F,E,X), Xs).
scanl(F,E,Xs) = [E] ++ scanlT(F,E,Xs).
scanlT(_F,_A,[]) = [].
scanlT(F,A,[Y|Ys]) = scanl(F, apply(F,A,Y), Ys).

% 34 scanl1
scanl1(_F,[]) = _ => throw $error(empty_list,scanl1,[]).
scanl1(F, [X|Xs]) = scanl(F,X,Xs).

% 35 scanr
scanr(_F,E,[]) = [E].
scanr(F,E,[X|Xs]) = [apply(F,X,head(Ys))] ++ Ys =>
                    Ys = scanr(F,E,Xs).

% 36 scanr1
scanr1(_F, []) = _ => throw $error(empty_list,scanr1,[]).
scanr1(_F,[X]) = [X].
scanr1(F,[X,Y|Xs]) = [apply(F,X,head(Zs))] ++ Zs =>
                   Zs = scanr1(F,[Y|Xs]).

% 37 singleton
singleton(Xs) => not(null(Xs)), null(tail(Xs)).

% 38 span
% L=span(prime,[2,3,5,6,7,8,9]) -> [[2,3,5],[6,7,8,9]]
span(_P,[]) = [[],[]].
span(P,[X|Xs]) = cond(call(P,X),
                      [[X|Ys],Zs],
                      [[],[X|Xs]]) =>
                 [Ys,Zs] = span(P,Xs).

% 39 splitAt
% L=splitAt(3,1..10) -> [[1,2],[3,4,5,6,7,8,9,10]]
% Note: 1-based
split_at(1,Xs) = [[],Xs].
split_at(_N,[]) = [[],[]].
split_at(N,[X|Xs]) = [[X|Ys],Zs] => [Ys,Zs] = split_at(N-1,Xs).

% 40 snd
snd(_X,Y) = Y.
snd([_X,Y]) = Y.

% 41 tail
tailx([]) = _ => throw $error(empty_list,tail,[]).
tailx([_X|Xs]) = Xs.

% 42 take
takex(0,_Xs) = [].
takex(_N,[]) = [].
takex(N,[X|Xs]) = [X] ++ takex(N-1,Xs).

% 43 takeWhile
% L=take_while(even,[2,4,6,7,8,9,16]) -> [2,4,6]
take_while2(_P,[]) = [].
take_while2(P,[X|Xs]) = cond(call(P,X),
                           [X] ++ take_while2(P,Xs), 
                           []).

% 44 uncurry
uncurry(F,Xy) = apply(F,first(Xy), snd(Xy)).

% 45 until
% L=until(mod3_1,dec,9) -> 7
mod3_1(N) => N mod 3 == 1.
inc(N) = N+1.
dec(N) = N-1. 
until(P,F,X) = cond(call(P,X),
                    X,
                    until(P,F,apply(F,X))).


% 46 unzip
% unzipx(List) = foldr(unzipxF,[], List). % ?
% unzipxF(X,Y) = cross(++,++,[X,Y]). % TBW


% 47 wrap
wrap(X) = [X].

% 48 zip
zipx([], _Ys) = [].
zipx(_Xs, []) = [].
zipx([X|Xs], [Y|Ys]) = [[X,Y]] ++ zipx(Xs,Ys).


             
% 49 zipp
% L=zipp([1..4,5..8]) -> [[1,5],[2,6],[3,7],[4,8]]
zipp(List) = uncurry(zipx,List).


haskelltest=> 
        println("\nhaskell test:"),
        % writeln(o=o(lambda([X],X+1),lambda([X],X*2),10)),
        writeln(conc=conc(1..3,4..8)),
        writeln(conj=conj(1,0)),
        writeln(conj=disj(0,1)),
        writeln(ix0=ix0([1,2,3,4,5,6,7],0)),
        writeln(ix1=ix1([1,2,3,4,5,6,7],3)),
        writeln(and=and([1,1,1])),
        writeln(and=and([1,1,1,0,1,1])),
        writeln(concat=concat([[1],[2,3],[3,4,5]])),
        writeln(concat=concat([[1],[2,[3,4,[5,6],7]],[3,4,5]])),
        writeln(const=const(a,b)),
        % writeln(cross=cross(...)), % TBW
        writeln(curry=curry(+,1,2)),
        writeln(drop=drop(3,1..10)),
        writeln(drop_while2=drop_while2(even,[2,4,6,1,2,3,4,5,6])),
        writeln(flip=flip(++,[4],[1])),
        % writeln(flip=flip(lambda([X,Y], X-Y), 10,3)),
        writeln(foldl=foldl(+,0,1..10)),
        writeln(foldl1=foldl1(+,1..10)),
        writeln(fst=fst(a,b)),
        writeln(fst=fst([a,b])),
        writeln(head=head(1..10)),
        writeln(id=id(3)),
        writeln(id=id([a,b,c])),
        writeln(init=init([1,2,3,4,5])),
        % writeln(iterate=iterate(....)), % TBW
        writeln(lastx=lastx(1..1000)),
        writeln(lengthx=lengthx(1..1000)),
        writeln(mapx=mapx(sin,0..0.1..1)),
        writeln(notx=notx(1)),
        writeln(notx=notx(0)),
        writeln(null=cond(null([]),isnull, isnotnull)),
        writeln(null=cond(null([a]),isnull, isnotnull)),
        writeln(null=cond(null([a,b,c]),isnull, isnotnull)),
        writeln(or=or(0,1)),
        writeln(or=or(1,0)),
        writeln(or=or([0,0,0,0,1])),
        writeln(or=or([0,0,0,0,0])),
        writeln(pair=pair(sin,cos,0.5)),
        writeln(partition=partition(prime,1..20)),
        % writeln(reversex=reversex(1..10)),
        writeln(scanl=scanl(+,0,1..10)),
        writeln(scanl=scanl(*,1,1..10)),
        writeln(scanl=scanl(/,1,1..10)),
        writeln(scanl=scanl(++,[],[[1],[2],[3]])),
        writeln(scanl=scanl1(+,1..10)),
        writeln(scanl=scanl1(*,1..10)),
        writeln(scanl=scanl1(**,2..5)),
        writeln(scanr=scanr(+,0,1..10)),
        writeln(scanr=scanr(*,1,1..10)),
        writeln(scanr=scanr(++,[],[[1],[2],[3]])),
        writeln(scanr1=scanr1(+,1..10)),
        writeln(scanr1=scanr1(*,1..10)),
        writeln(singleton=cond(singleton([a]),is_singleton, is_not_singleton)),
        writeln(span=span(prime,[2,3,5,6,7,8,9])),
        writeln(split_at=split_at(3,1..10)),
        writeln(snd=snd(a,b)),
        writeln(snd=snd([a,b])),
        writeln(tailx=tailx(1..10)),
        writeln(takex=takex(5,1..10)),
        writeln(take_while2=take_while2(even, [2,4,6,7,8,9,16])),
        writeln(uncurry=uncurry(**,[2,10])),
        writeln(until=until(mod3_1,dec,9)),
        % writeln(unzipx=unzipx(...)), % TBW
        writeln(wrap=wrap(a)),
        writeln(zipx=zipx(1..5,6..10)),
        writeln(zipp=zipp([1..5,6..10])),

        nl.

/* 

  Perfect number benchmark in Picat.

  From 
  http://www.jekejeke.ch/idatab/doclet/prod/en/docs/05_run/15_stdy/06_bench/09_programs/10_perfect/01_perfect.p.html

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


/**
 * Prolog code for finding a perfect number.
 *
 * A solution that did not make use of findall/3 and rem/2 
 * was posted Dec 16, 1988 on comp.lang.prolog by Thomas 
 * Sj|land. It was titled Christmas pleasure and contained
 * an invitation to further dig into Euclids theorem.

 */


between1(Lo,Hi,_), Lo>Hi => fail.
between1(Lo,_Hi,X) ?=> X = Lo.
between1(Lo,Hi,X) => Lo2 = Lo+1, between1(Lo2,Hi,X).

sumlist1([],S) => S = 0.
sumlist1([X|Y],R) => sumlist1(Y,H), R = X+H.

perfect(Hi,X) =>
    between1(1,Hi,X),
    % between(1,Hi,X),
    Y = X // 2,
    % L = findall(Z,$(between1(1,Y,Z), (X rem Z == 0))),
    L = [Z : Z in 1..Y, X rem Z == 0],
    %writeln(l=L),
    sumlist1(L,X).

perfect =>
    perfect(500,P),
    writeln(P).

perfect2 =>
    perfect(500,_P).



/*

  Perfect numbers in Picat.

  See http://rosettacode.org/wiki/Perfect_numbers
  """
  A number is perfect if the sum of its factors is equal to 
  twice the number. An equivalent condition is that n is perfect 
  if the sum of n's factors that are less than n is equal to n. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 

   % print the first 50 perfect numbers
   println(perfect_n(50)),

   % perfect numbers generated by the primes below < 100
   PP=[[P,perfectf(P)] : P in primes(100)],
   println(PP),
   println(len=PP.length),

   nl.


go2 => 
  %
  % It takes about 0.07s to generate the first 1000 
  % perfect numbers.
  % 
  time(P=perfect_n(1000)),
  println(len=P.length),
  time(Last=P.last()),
  println(last=Last),
  nl.

%
% using the traditional definition
%
go3 =>
    
   println([I : I in 1..10000, perfect(I)]),
   nl.

go4 =>
   
   foreach(I in 1..524288) 
     if perfect(I) then
       println(I)
     end,
     if I mod 1000 == 0 then
       print("."),
       flush(stdout)
     end,
     if I mod 10000 == 0 then
       print("\n"),
       flush(stdout)
     end
   end,
   nl.


% 
% using formula for perfect numbers: 2^(p-1)*(2^p-1) where p is a prime
%
perfect_n(N) = Perfect =>
  Perfect1 = [],
  C = 0, P = 2,
  while(C < N)
    if prime(P) then
      Perfect1 := Perfect1 ++ [perfectf(P)],
      C := C + 1 
    end,
    P := P + 1
  end,
  Perfect = Perfect1.

% the formula
perfectf(P) = (2**(P-1))*((2**P)-1).


perfect(N) => sum(divisors(N)) == N.


divisors(N) = [J: J in 1..1+N div 2, N mod J == 0].


/*

  Perfect square sequence in Picat.

  From "Fun with num3ers"
  "Sequence"
  http://benvitale-funwithnum3ers.blogspot.com/2010/11/sequence.html
  """
  If we take the numbers from 1 to 15 
      (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) 
  and rearrange them in such an order that any two consecutive 
  numbers in the sequence add up to a perfect square, we get,
  
  8     1     15     10     6     3     13     12      4      5     11     14        2      7      9
      9    16    25     16     9     16     25     16     9     16     25     16       9     16
1  
  
  I ask the readers the following:
  
  Can you take the numbers from 1 to 25 to produce such an arrangement?
  How about the numbers from 1 to 100?
  """
  
  Via http://wildaboutmath.com/2010/11/26/wild-about-math-bloggers-111910


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   foreach(N in 2..50)
       writeln(n=N),
       time2(perfect_square_sequence(N))
   end,
   nl.

perfect_square_sequence(N) =>    

   Squares = [(I*I) : I in 1..ceiling(sqrt(N*N))],

   % decision variables
   X = new_list(N),
   X :: 1..N,

   Tmp = new_list(N-1),
   Tmp :: Squares,

   % constraints
   all_different(X),
   
   foreach(I in 2..N) 
     Tmp[I-1] #= (X[I-1]+X[I])
     % Tmp #= (X[I-1]+X[I]),
     % Tmp :: Squares
   end,

   % symmetry breaking
   X[1] #< X[N],
   
   Vars = X ++ Tmp,
   solve([constr,updown], Vars),

   writeln(x=X),
   writeln(tmp=Tmp),
   nl./*

  Simple PERT model in Picat.

  From Pascal van Hentenryck 
  "Scheduling and Packing In the Constraint Language cc(FD)", page 7f
  http://citeseer.ist.psu.edu/300151.html
 

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   MaxTime = 30,
   times(Times),
   N = length(Times),
   dependencies(Dependencies),

   % decision variable
   Start = new_list(N),
   Start :: 0..MaxTime,
   
   % constraints
   foreach([D1,D2] in Dependencies)
       Start[D1] #>= Start[D2] + Times[D2]
   end,

   SEnd = Start[N], % to minimize
   SumTimes #= sum(Start),

   % search
   solve([$min(SEnd)], Start),

   % output
   writeln(sEnd=SEnd),
   writeln(start_times=Start),
   writeln(sum_times=SumTimes),
   nl.


% Times for each action
%                        a  b  c  d  e  f  g  h  j  k  Send 
times(Times) => Times = [7, 3, 1, 8, 1, 1, 1, 3, 2, 1, 1].

% Dependencies
% Note: There is no Si
dependencies(Dependencies) => 
  Dependencies =
        [[2,1],  % Sb >= Sa + 7
         [4,1],  % Sd >= Sa + 7
         [3,2],  % Sc >= Sb + 3
         [5,3],  % Se >= Sc + 1
         [5,4],  % Se >= Sd + 8
         [7,3],  % Sg >= Sc + 1
         [7,4],  % Sg >= Sd + 8
         [6,4],  % Sf >= Sd + 8
         [6,3],  % Sf >= Sc + 1
         [8,6],  % Sh >= Sf + 1
         [9,8],  % Sj >= Sh + 3
         [10,7], % Sk >= Sg + 1
         [10,5], % Sk >= Se + 1
         [10,9], % Sk >= Sj + 2
         [11,10] % Send >= Sk + 1
        ].
        /*

  Photo problem in Picat.

  Problem statement from Mozart/Oz tutorial:
  http://www.mozart-oz.org/home/doc/fdt/node37.html#section.reified.photo
  """
  Betty, Chris, Donald, Fred, Gary, Mary, and Paul want to align in one row for 
  taking a photo. Some of them have preferences next to whom they want to stand:
 
     1. Betty wants to stand next to Gary and Mary.
     2. Chris wants to stand next to Betty and Gary.
     3. Fred wants to stand next to Mary and Donald.
     4. Paul wants to stand next to Fred and Donald.
 
  Obviously, it is impossible to satisfy all preferences. Can you find an alignment that maximizes the number of satisfied preferences?
  """

  Oz solution: 
    6 # alignment(betty:5  chris:6  donald:1  fred:3  gary:7   mary:4   paul:2)
  [5, 6, 1, 3, 7, 4, 2]
  
   
  There are 8 solutions:
 
  positions = [3, 1, 6, 5, 2, 4, 7]
  positions = [3, 1, 7, 5, 2, 4, 6]
  positions = [3, 2, 6, 5, 1, 4, 7]
  positions = [3, 2, 7, 5, 1, 4, 6]
  positions = [5, 6, 1, 3, 7, 4, 2]  (the Oz solution.)
  positions = [5, 6, 2, 3, 7, 4, 1]
  positions = [5, 7, 1, 3, 6, 4, 2]
  positions = [5, 7, 2, 3, 6, 4, 1]

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   foreach(P in 1..3)
      time2($photo(P)),
      nl
   end,
   nl.

photo(Problem) =>

   printf("Problem %d\n",Problem),

   preferences(Problem, N, Preferences), % get the problem
   % write(n:N),nl,

   % positions, decision variables
   Positions = new_list(N),
   Positions :: 1..N,

   % constraints
   all_different(Positions),
   Diffs = [],
   foreach([Pref1,Pref2] in Preferences)
       % element(Pref1,Positions,P1),
       P1 = Positions[Pref1],
       % element(Pref2,Positions,P2),
       P2 = Positions[Pref2],
       Diff #= (abs(P1-P2) #= 1),
       Diffs := Diffs ++ [Diff]
   end,
       
   % number of fullfilled preferences
   Z #= sum(Diffs), 

   % Z #>= 6, % for Problem 1
   % Z #>= 12, % for Problem 2

   Vars = Positions ++ Diffs,
   solve([$max(Z)],Vars),

   writeln(z=Z),
   writeln(positions=Positions),
   nl.


%
% Problem 1 (see above):
% 1. Betty wants to stand next to Gary and Mary.
%     1 : 5, 6
% 2. Chris wants to stand next to Betty and Gary.
%     2 : 1, 5
% 3. Fred wants to stand next to Mary and Donald.
%     4 : 6, 3
% 4. Paul wants to stand next to Fred and Donald.
%     7 : 4, 3
%
% preferences(ProblemNumber, NumberOfPersons, Preferences)
preferences(1, N, Preferences) => 
  N = 7,
  Preferences = 
        [[1,5],
         [1,6],
         [2,1],
         [2,5],
         [4,6],
         [4,3],
         [7,4],
         [7,3]].


% From http://www.g12.cs.mu.oz.au/minizinc/photo.data2
preferences(2, N, Preferences) => 
  N = 11, 
  Preferences = 
         [[1,3], 
          [1,5], 
          [1,8], 
          [2,5], 
          [2,9], 
          [3,4], 
          [3,5], 
          [4,1], 
          [4,5], 
          [4,10],
          [5,6], 
          [5,1], 
          [6,1], 
          [6,9], 
          [7,3],
          [7,8], 
          [8,9],
          [8,7], 
          [9,10], 
          [10,11]].


% From http://www.ampl.com/NEW/LOGIC/EXAMPLES/photo9.dat
% (This seems to be a simplified of #2
preferences(3, N, Preferences) => 
  N = 9, 
  Preferences = 
         [[1,3], 
          [1,5], 
          [1,8], 
          [2,5], 
          [2,9], 
          [3,4], 
          [3,5], 
          [4,1], 
          [4,5], 
          [5,1], 
          [5,6], 
          [6,1], 
          [6,9], 
          [7,3],
          [7,8], 
          [8,7],
          [8,9]].
#!/bin/sh
#
# This is just a wrapper for running the 
#    picat run_program.pi picat_program arg1 [arg2]
#
PICAT_ME=/home/hakank/picat/me
RUN_PROGRAM=${PICAT_ME}/run_program.pi
if [ "$#" -eq 1 ]; then
   picat -log $RUN_PROGRAM $@ go
else
   picat -log $RUN_PROGRAM $@
fi
/* 

  Picking teams in Picat.

  This model was inspired by David Curran's
  blog post "The Fairest Way to Pick a Team "
  http://liveatthewitchtrials.blogspot.se/2012/06/fairest-way-to-pick-team.html
  """
  What is the best way to pick a team? As kids we would always strictly alternate 
  between teams so team 1 had first team 2 the second pick and then team 1 again etc.
  
  Most things you can measure about people are on a bell curve. A small number of 
  people are bad, most are in the middle and a few are good. There are a few good 
  known metrics of ability. None are perfect, there is no one number that can sum up 
  ability. The simpler the sport the more one metric can tell you, in cycling VO2 max is 
  a very good indicator. Whereas in soccer VO2 max, kicking speed, vertical leap, number 
  of keep me ups you can do etc could all measure some part of football ability.
  
  So say there was one good metric for a task and teams were picked based on this. 
  Is the standard strict alteration, where Team 1 picks then Team 2 alternating, fair? 
  Fair here meaning both teams end up with a similar quality. 
  """
  
  For n = 10, where s = 1..n there are 20 optimal solutions with a diff of 1
  (with the symmetry breaking that x[1] is in team 1).
  
  Example:
   
  x: [1, 2, 2, 2, 1, 1, 1, 1, 2, 2]
  diff: 1
  team1: [1, 5, 6, 7, 8]  sum: 27
  team2: [2, 3, 4, 9, 10]  sum: 28
  ----------
  x: [1, 2, 2, 2, 1, 1, 1, 2, 1, 2]
  diff: 1
  team1: [1, 5, 6, 7, 9]  sum: 28
  team2: [2, 3, 4, 8, 10]  sum: 27


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   S =  [35, 52, 17, 26, 90, 55, 57, 54, 41, 9, 75, 24, 17, 23, 62, 74, 100, 67, 40, 48, 7, 6, 44, 19, 16, 14, 2, 66, 70, 2, 43, 45, 76, 53, 90, 12, 88, 96, 30, 30, 36, 93, 74, 1, 52, 45, 38, 7, 24, 96, 17, 21, 12, 12, 23, 90, 77, 64, 37, 79, 67, 62, 24, 11, 74, 82, 51, 17, 72, 18, 37, 94, 43, 44, 32, 86, 94, 33, 97, 27, 38, 38, 29, 92, 35, 82, 22, 66, 80, 8, 62, 72, 25, 13, 94, 42, 51, 31, 69, 66],
  picking_teams(S).

go2 => 
   S = [1+(random2() mod 10) : _I in 1..300],
   writeln(S),
   time2($picking_teams(S)).
   

go3 => 
   S = [1+(random2() mod 10000) : _J in 1..100],
   writeln(s=S),
   time(picking_teams(S)).


go4 => 
   S = [41,85,90,47,15,37,90,77,4,95,6,13,77,15,17,91,12,22,15,68,11,23,41,77,71,42,23,30,77,30,74,90,97,28,89,18,3,74,86,99,25,20,58,13,59,52,81,5,49,50,56,91,85,67,47,51,70,76,59,88,51,79,79,23,18,21,43,74,85,69,11,28,55,94,3,58,83,74,87,84,98,83,59,9,88,56,33,36,21,59,4,42,68,94,11,88,25,38,89,38],
   writeln(s=S),
   time(picking_teams(S)).


picking_teams(S) => 
   N = S.length,
   NumTeams = 2,

   Diff :: 0..sum(S) div 2,

   X = new_list(N),
   X :: 1..NumTeams,

   % the difference in strength between the teams
   Diff #= abs(sum([S[I]*(X[I] #= 1) : I in 1..N]) - 
               sum([S[I]*(X[I] #= 2) : I in 1..N])),

  % same size of team
  count(1, X, #=, N div NumTeams),

  % divisibility of the sum
  Diff mod 2 #= sum(S) mod 2,

  % symmetry breaking: assign first person to team 1
  % X[1] #= 1,

  solve([$min(Diff),split], X),

  writeln(diff=Diff),
  writeln(x=X).
  
   
   

/*

  Pigeon hole problem in Picat.

  From
  ftp://ftp.inria.fr/INRIA/Projects/contraintes/publications/CLP-FD/plilp94.html
  """
  pigeon: the pigeon-hole problem consists in putting n pigeons in m pigeon-holes 
  (at most 1 pigeon per hole). The boolean formulation uses n - m variables to 
  indicate, for each pigeon, its hole number. Obviously, there is a 
  solution iff n <= m.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
   N = 3,  % N pigeons
   M = 10, % M pigeon holes     
   wrapper(N,M).

% This is an impossible problem (M < N)
go2 =>
   N = 5,  % N pigeons
   M = 4, % M pigeon holes
   wrapper(N,M).


wrapper(N,M) =>
   L = findall(P, $pigeon_hole(N,M, P)),
   foreach(Sol in L) pretty_print(Sol) end,
   printf("It was %d solutions.\n", L.length).

pigeon_hole(N,M, PigeonHoles) =>

   % N pigeons at M pigeon holes
   PigeonHoles = new_array(N,M),
   PigeonHoles :: 0..1,
   
   writeln(here1),
   writeln(row_len=PigeonHoles.length),
   writeln(col_len=PigeonHoles[1].length),

   % all pigeon must be placed and only at one hole (rows)
   % foreach(Row in PigeonHoles) sum(Row) #=1 end, % this don't work

   foreach(Row in PigeonHoles) sum(Row.to_list()) #=1 end, % must explicitly convert Row to list
   % foreach(I in 1..N) sum([$PigeonHoles[I,J] : J in 1..M]) #=1 end,

   % max 1 pigeon per pigeon hole (columns)
   foreach(Column in transpose(PigeonHoles).array_matrix_to_list_matrix()) sum(Column) #=< 1 end,

   solve([ff],PigeonHoles).


pretty_print(X) =>
   foreach(Row in X) writeln(Row) end, 
   nl.

/* 

  Pi (Rosetta Code) in Picat.

  From http://rosettacode.org/wiki/Pi
  """
  Create a program to continually calculate and output the next digit of  (pi). 
  The program should continue forever (until it is aborted by the user) calculating 
  and outputting each digit in succession. The output should be a decimal 
  sequence beginning 3.14159265 ... 
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
  pi1,
  nl.

go2 => 
  pi2,
  nl.


go3 => 
  writeln(pi(1000)),
  nl.

% Some small Pi calculations, inspired by
% http://stackoverflow.com/questions/407518/code-golf-leibniz-formula-for-pi
go4 =>
  % MathPi = math.pi,
  println(4*sum([((-1)**(I+1))/(2*I-1):I in 1..10**6])),
  println(4*sum([((-1)**I)/(2*I+1):I in 0..10**6])),
  println(sum([8/I/(I+2):I in 1..4..10**6])),
  nl.


% Inspired by the D solution
pi1 => 
   Ndigits = 0,
   Q = 1,
   R = 0,
   T = Q,
   K = Q,
   N = 3,
   L = N,

   First = 1,
   C = 1, % counter for presentation
   while (1=1)
       if 4 * Q + R - T < N * T then
           print(N), 
           C := C + 1,
           if C mod 30 == 0 then printf("  %% (%d)\n", C) end,
           Ndigits := Ndigits + 1,
           if First == 1 then First := 0, print('.') end,
           NR := 10 * (R - N * T),
           N := ((10 * (3 * Q + R)) // T) - 10 * N,
           Q := Q* 10,
           R := NR
       else
           NR := (2    * Q + R) * L,
           NN := (Q * (7 * K + 2) + R * L) // (T * L),
           Q := Q * K,
           T := T* L,
           L := L + 2,
           K := K+1,
           N := NN,
           R := NR
       end
   end,
   nl.


% Inspired by the Erlang version
pi2 => 
   pi2b(1,0,1,1,3,3,0).

pi2b(Q,R,T,K,N,L,C) =>
   if C == 50 then
      nl,
      pi2b(Q,R,T,K,N,L,0)
   else
     if (4*Q + R-T) < (N*T) then
       print(N),
       P := 10*(R-N*T),
       pi2b(Q*10, P, T, K, ((10*(3*Q+R)) div T)-10*N, L,C+1)
     else 
       P := (2*Q+R)*L,
       M := (Q*(7*K)+2+(R*L)) div (T*L),
       H := L+2,
       J := K+ 1,
       pi2b(Q*K, P, T*L, J, M, H, C)
     end
   end,
   nl.


% Get first Len digits of Pi
pi(Len) = Res => 
   Ndigits = 0,
   Q = 1,
   R = 0,
   T = Q,
   K = Q,
   N = 3,
   L = N,

   Res = [],
   C = 1, % counter for presentation
   while (C <= Len)
       if 4 * Q + R - T < N * T then
           Res := Res ++ [N],
           C := C + 1,
           Ndigits := Ndigits + 1,
           NR := 10 * (R - N * T),
           N := ((10 * (3 * Q + R)) // T) - 10 * N,
           Q := Q* 10,
           R := NR
       else
           NR := (2    * Q + R) * L,
           NN := (Q * (7 * K + 2) + R * L) // (T * L),
           Q := Q * K,
           T := T* L,
           L := L + 2,
           K := K+1,
           N := NN,
           R := NR
       end
   end,
   nl.



/*

  Place number puzzle in Picat.

  http://ai.uwaterloo.ca/~vanbeek/Courses/Slides/introduction.pdf
  """
  Place numbers 1 through 8 on nodes
  - each number appears exactly once
  - no connected nodes have consecutive numbers
       2 - 5 
     / | X | \
   1 - 3 - 6 - 8
     \ | X | /
       4 - 7
  """

  Compare with another approach:
  http://hakank.org/picat/place_number_puzzle2.pi

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
    L = findall(X,place_number_puzzle(X)),
    writeln(L).

place_number_puzzle(X) =>

        N = 8,
        X = new_list(N),
        X :: 1..N,

        Graph = 
          {{1,2}, {1,3}, {1,4},
           {2,1}, {2,3}, {2,5}, {2,6},
           {3,2}, {3,4}, {3,6}, {3,7},
           {4,1}, {4,3}, {4,6}, {4,7},
           {5,2}, {5,3}, {5,6}, {5,8},
           {6,2}, {6,3}, {6,4}, {6,5}, {6,7}, {6,8},
           {7,3}, {7,4}, {7,6}, {7,8},
           {8,5}, {8,6}, {8,7}},


        all_distinct(X),
        foreach(I in 1..Graph.length) 
           abs(X[Graph[I,1]]-X[Graph[I,2]]) #> 1 
        end,

        % symmetry breaking
        X[1] #< X[N],

        solve(X).
/*

  P-median problem in Picat.

  Model and data from the OPL Manual, which describes the problem:
  """
  The P-Median problem is a well known problem in Operations Research. 
  The problem can be stated very simply, like this: given a set of customers 
  with known amounts of demand, a set of candidate locations for warehouses, 
  and the distance between each pair of customer-warehouse, choose P 
  warehouses to open that minimize the demand-weighted distance of serving 
  all customers from those P warehouses.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   P = 2,
   Customers = ["Albert","Bob","Chris","Daniel"],
   NumCustomers = length(Customers),
   Warehouses = ["Santa Clara", "San Jose", "Berkeley"],
   NumWarehouses = length(Warehouses),
   writeln([numCustomers=NumCustomers,numWarehouses=NumWarehouses]),
   Demand = [100,80,80,70],
   Distance = 
   [[2, 10, 50],
    [2, 10, 52],
    [50, 60,  3],
    [40, 60,  1]],

   
   % decision variables
   OpenWarehouse = new_list(NumWarehouses),
   OpenWarehouse :: 0..1,
   
   ShipToCustomer = new_array(NumCustomers,NumWarehouses),
   ShipToCustomer :: 0..1,

   Z #= sum([Demand[C]*Distance[C,W]*ShipToCustomer[C,W]  :
                  C in 1..NumCustomers, W in 1..NumWarehouses]),

   foreach(C in 1..NumCustomers)
      sum([ ShipToCustomer[C,W] : W in 1..NumWarehouses]) #= 1
   end,

   sum(OpenWarehouse) #= P,

   foreach(C in 1..NumCustomers, W in 1..NumWarehouses)
      ShipToCustomer[C,W] #=< OpenWarehouse[W]
   end,

   Vars = OpenWarehouse ++ ShipToCustomer,
   solve([$min(Z)],Vars),

   writeln(z=Z),
   writeln(openWarehouse=OpenWarehouse),
   foreach(W in 1..NumWarehouses)
      if OpenWarehouse[W] == 1 then
         println(open=Warehouses[W])
      end
   end,
   
   foreach(C in 1..NumCustomers)
      S = [ShipToCustomer[C,W] : W in 1..NumWarehouses],
      Cust = Customers[C],
      WW = [Warehouses[W]: W in 1..NumWarehouses, S[W] == 1],
      printf("Customer %w: %w %w\n",Cust,S,WW)
   end,

   nl.

   
   
/*

  Post office problem in Picat.

  Problem statement:
  http://www-128.ibm.com/developerworks/linux/library/l-glpk2/
 
  From Winston "Operations Research: Applications and Algorithms":
  """
  A post office requires a different number of full-time employees working 
  on different days of the week [summarized below]. Union rules state that 
  each full-time employee must work for 5 consecutive days and then receive 
  two days off. For example, an employee who works on Monday to Friday 
  must be off on Saturday and Sunday. The post office wants to meet its 
  daily requirements using only full-time employees. Minimize the number 
  of employees that must be hired.
 
  To summarize the important information about the problem:
 
    * Every full-time worker works for 5 consecutive days and takes 2 days off
    * Day 1 (Monday): 17 workers needed
    * Day 2 : 13 workers needed
    * Day 3 : 15 workers needed
    * Day 4 : 19 workers needed
    * Day 5 : 14 workers needed
    * Day 6 : 16 workers needed
    * Day 7 (Sunday) : 11 workers needed
 
  The post office needs to minimize the number of employees it needs
  to hire to meet its demand. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   Days = 7,
   % requirements number workers per day
   Need = [17, 13, 15, 19, 14, 16, 11],

   % Total cost for the 5 day schedule.
   % Base cost per day is 100.
   % Working saturday is 100 extra
   % Working sunday is 200 extra.
   Cost = [500, 600, 800, 800, 800, 800, 700],

   % Decision variables. X[I]: Number of workers starting at day I
   X = new_list(Days),
   X :: 0..10,

   % TotalCost: sum of total workers (started on a day)
   % Week start at monday (day 0)
   % Note: We use 0..6 as days since it's easier with the 
   % modulo operations.
   foreach({Nd,I} in zip(Need,0..6))
       % Satisfy the need of the day
       sum([X[J+1] : J in 0..6, J != (I + 5) mod 7, J != (I + 6) mod 7]) #>= Nd 
   end,

   scalar_product(Cost,X,TotalCost),
   NumWorkers #= sum(X),

   solve([ffc,split,$min(TotalCost)],X),

   writeln(x=X),
   writeln(total_cost=TotalCost),
   writeln(num_workers=NumWorkers),nl.


scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).
/*

  Primes in a circle in Picat.


  From 
  http://wordplay.blogs.nytimes.com/2013/06/17/primes-circle/?_r=0
  """
  This weeks puzzle was suggested by University of the 
  Andes Professor Bernardo Recamn.

  Place the numbers 1 to 14 around a circle so that both the sum and 
  the (positive difference) of any two neighboring numbers is a prime.
  ""

  For N = 14, there are 28 solutions (14 solutions and there reverses).
  With symmetry breaking there is 2 solutions (1+its reverse):

     [1,4,7,10,13,6,11,8,3,14,9,2,5,12]
     [1,12,5,2,9,14,3,8,11,6,13,10,7,4]

  For N = 12 there are 48 solutions, and 4 with symmetry breaking:
     [1,4,9,2,5,12,7,10,3,8,11,6]
     [1,6,11,8,3,10,7,4,9,2,5,12]
     [1,6,11,8,3,10,7,12,5,2,9,4]
     [1,12,5,2,9,4,7,10,3,8,11,6]

  Here are the results for N=14..26 (even numbers)
  using symmetry breaking (X[1] #= 1):
     N   #solutions
    12      4        
    14      2
    16      8
    18    176
    20      0
    22   1952
    24  44554
    26  44730


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go ?=>

    N :: 12..18,
    indomain(N),

    N mod 2 #= 0, % just even

    primes_in_a_circle(N, All),
    writeln([n=N,num_solutions=All.length]),
    foreach(A in All)
      writeln(A)
    end,
    nl,
    fail.

% Just the number of solutions
go2 ?=>

    N :: 12..28,
    indomain(N),

    N mod 2 #= 0, % just even

    time($primes_in_a_circle(N,All)),
    writeln([n=N,num_solutions=All.length]),
    % foreach(A in All)
    %   writeln(A)
    % end,
    nl,
    fail.

go2 => true.

% Just check one solution
go3 => 
    foreach(N in 12..128, N mod 2 #= 0)
       (
         time2($once(primes_in_a_circle2(N, X))),
         writeln([n=N,X])
       ; 
         true
       )
    end,
    nl.


% All solutions (with symmetry breaking)
primes_in_a_circle(N,All) =>
    Primes = sieve(N*2),
    writeln([n=N,primes=Primes]),

    X = new_list(N),
    X :: 1..N,

    % constraints
    all_different(X),
    
    foreach(I in 1..N-1) 
        p(X[I],X[I+1],Primes)
    end,
    p(X[1],X[N],Primes),

    % symmetry breaking
    X[1] #= 1,

    All = solve_all([ffd,reverse_split], X).


% Just one solution
primes_in_a_circle2(N,X) =>
    Primes = sieve(N*2),
    % writeln([n=N,primes=Primes]),

    X = new_list(N),
    X :: 1..N,

    % constraints
    all_different(X),
    
    foreach(I in 1..N-1) 
        p(X[I],X[I+1],Primes)
    end,
    p(X[1],X[N],Primes),

    % symmetry breaking
    X[1] #= 1,

    solve([ffd,reverse_split], X).



        
%% don't work
% p(A,B,Primes) => 
%    Plus #= A+B,
%    Abs #= abs(A-B),
%    Primes.has_key(Plus),
%    Primes.has_key(Abs).


p(A,B,Primes) =>
   sum([A+B#=P : P in Primes]) #= 1,
   sum([abs(A-B)#=P : P in Primes]) #= 1.

sieve(N) = Res => 
   Sieve = [0 : I in 1..N].to_array(),
   foreach(I in 2..round(sqrt(N)), J in I*I..I..N)
      Sieve[J] := 1
   end,
   Res := [I : I in 2..N, Sieve[I] == 0].
/* 

  2x3-puzzle in Picat.

  This is a stripped down 8-puzzle,
  inspired by the Prolog code in Thinking as Computation. 

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
   initial_state(Init),
   time(bplan(Init,L)),
   % time(plan2(Init,L,Cost)),
   write(L), nl,
   writeln(len=L.length),
   % writeln(cost=Cost),
   nl.


% This is a 2x3 version of the 15 puzzle.
% Initial state:
%%%%%%%%%
%   1 5 %
% 4 3 2 %
%%%%%%%%%
initial_state(Init) => Init=[0,1,5,4,3,2].
goal_state(Goal) => Goal=[1,2,3,4,5,0].

% Up <-> Down
legal_move(From,Move,To) ?=> 
   From=[0,B,C, X,E,F],Move=$up(X),To=[X,B,C, 0,E,F].
legal_move(From,Move,To) ?=> 
   From=[A,0,C, D,X,F],Move=$up(X),To=[A,X,C, D,0,F].
legal_move(From, Move, To) ?=> 
   From=[A,B,0, D,E,X],Move=$up(X),To=[A,B,X, D,E,0].
legal_move(From,Move,To) ?=> 
   % From=S1,Move=$down(X),To=S2,
   % legal_move(S2,$up(X),S1).
   Move=$down(X),
   legal_move(To, $up(X), From).

% Left <-> Right
legal_move(From,Move,To) ?=> 
   From=[0,X,C, D,E,F],Move=$left(X),To=[X,0,C, D,E,F].
legal_move(From,Move,To) ?=> 
   From=[A,0,X, D,E,F],Move=$left(X),To=[A,X,0, D,E,F].
legal_move(From,Move,To) ?=>
   From=[A,B,C, 0,X,F],Move=$left(X),To=[A,B,C, X,0,F].
legal_move(From,Move,To) ?=> 
   From=[A,B,C, D,0,X],Move=$left(X),To=[A,B,C, D,X,0].
legal_move(From,Move,To) => 
   % From=S1,Move=$right(X),To=S2,
   % legal_move(S2,$left(X),S1).
   Move=$right(X),
   legal_move(To,$left(X),From).
/*

  Pythagoras problem in Picat.


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

write_list(L) =>
   foreach([A,B,C] in L) printf("%d^2 + %d^2 = %d^2\n", A,B,C) end.


pythagoras(LD, Max) => 
   LD = [A,B,C],
   LD :: 1..Max,

   A**2#=A2,
   B**2#=B2,
   C**2#=C2,
   A2+B2 #= C2,
   A #=< B,
   B #=< C,

   solve([],LD).

/* 

  qsort benchmark in Picat.

  Prolog code from 
  http://www.jekejeke.ch/idatab/doclet/prod/en/docs/05_run/15_stdy/06_bench/09_programs/05_qsort/01_qsort.p.html

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


/**
 * Prolog code for the quick sort benchmark.
 *
 * This is the benchmark of page 220 of:
 * Warren, D.H.D. (1983): Applied Logic  Its Use and
 * Implementation as a Programming Tool,
 * Technical Note 290, SRI International, 1983
 *
 * Copyright 2010, XLOG Technologies GmbH, Switzerland
 * Jekejeke Prolog 0.8.3 (a fast and small prolog interpreter)
 */

partition([],_,L1,L2) => L1 = [], L2=[].
partition([X|L],Y,LL,L2), X =< Y =>
      LL=[X|L1],
      partition(L,Y,L1,L2).
partition([X|L],Y,L1,LL) =>
      LL = [X|L2],
      partition(L,Y,L1,L2).

qsort([], R1, R2) => R1 = R2 .
qsort([X|L], R0, R) =>
      partition(L, X, L1, L2),
      qsort(L2, R0, R1),
      qsort(L1, [X|R1], R).

index(-)
dataqsort([27,74,17,33,94,18,46,83,65,2,32,53,28,85,99,
           47,28,82,6,11,55,29,39,81,90,37,10,0,66,51,
           7,21,85,27,31,63,75,4,95,99,11,28,61,74,18,
           92,40,53,59,8]).

go =>
    dataqsort(X),
    qsort(X,[],Y),
    writeln(Y).


go2 =>
    dataqsort(X),
    qsort(X,[],_Y).
/*

  Quasigroup completion problem  in Picat.

  See 
  Carla P. Gomes and David Shmoys:
 "Completing Quasigroups or Latin Squares: Structured Graph Coloring Problem"

  
  See also
  Ivars Peterson "Completing Latin Squares"
  http://www.maa.org/mathland/mathtrek_5_8_00.html
  """
  Using only the numbers 1, 2, 3, and 4, arrange four sets of these 
  numbers into a four-by-four array so that no column or row contains 
  the same two numbers. The result is known as a Latin square.
  ...
  The so-called quasigroup completion problem concerns a table that is 
  correctly but only partially filled in. The question is whether the 
  remaining blanks in the table can be filled in to obtain a complete 
  Latin square (or a proper quasigroup multiplication table).
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

%
% Test the first two problems.
%
go =>
    quasigroup(1,Problem1),
    pretty_print(Problem1),

    quasigroup(2,Problem2),
    pretty_print(Problem2).

%
% Test all problems.
%
go2 =>
    foreach(I in 1..9) 
       if quasigroup(I,B) then pretty_print(B) end
    end.

pretty_print(X) =>
    N = X.length,
    foreach(I in 1..N)
       foreach(J in 1..N)
          writef("%2d ", X[I,J])
       end,
       writef("\n")
    end,
    writef("\n").

%
% Ensure a Latin square, 
% i.e. all rows and all columns are different
%
latin_square(Board) =>
   foreach(Row in Board) all_different(Row) end,
   foreach(Column in transpose(Board)) all_different(Column) end.


quasigroup(ProblemNum,Problem) =>

   problem(ProblemNum, Problem),
   writeln(problem=ProblemNum),

   N = Problem.length,
   ProblemVar = [P : I in 1..N, J in 1..N, P = Problem[I,J]],
   ProblemVar :: 1..N,

   latin_square(Problem),

   solve([ff,down],ProblemVar).



%
% Example from Ruben Martins and Ins Lynce
% Breaking Local Symmetries in Quasigroup Completion Problems, page 3
% The solution is unique:
% 1 3 2 5 4
% 2 5 4 1 3
% 4 1 3 2 5
% 5 4 1 3 2
% 3 2 5 4 1
%
% Note: this is an array of arrays
%
problem(1, A) => 
        A= {{1, _, _, _, 4},  
            {_, 5, _, _, _},
            {4, _, _, 2, _},
            {_, 4, _, _, _},
            {_, _, 5, _, 1}}.


%
% Example from Gomes & Shmoys, page 3.
% Solution:
% 4 1 2 3
% 2 3 4 1
% 1 4 3 2
% 3 2 1 4
%
problem(2, A) => 
        A = {{_, 1, 2, 3},
            {2, _, 4, 1}, 
            {1, 4, _, 2},
            {3, _, 1, _}}.

% Example from Gomes & Shmoys, page 7
% Two solutions.
%
problem(3, A) => 
       A = {{_, 1, _, _},
            {_, _, 2, _},
            {_, 3, _, _},
            {_, _, _, 4}}.


%
% Example from Global Constraint Catalogue
% http://www.emn.fr/x-info/sdemasse/gccat/sec2.7.108.html
%
% 12 solutions.
%
problem(4, A) => 
        A= {{1, _, _, _},
            {_, _, _, 3},
            {3, _, _, _},
            {_, _, _, 1}}.


%
% Problem from http://www.cs.cornell.edu/gomes/QUASIdemo.html
% (n = 10}
% Pattern #1. 
% There are _many_ solutions to this problem.
%
problem(5, A) => 
      A = {{_,_,_,1,_,_,_,_,_,_},
            {_,_,1,_,_,_,_,_,_,_},
            {_,1,_,_,_,2,_,_,_,_},
            {1,_,_,_,2,_,_,_,_,_},
            {_,_,_,2,1,_,_,_,_,_},
            {_,_,2,_,_,1,_,_,_,_},
            {_,_,_,_,_,_,1,_,_,_},
            {_,_,_,_,_,_,_,1,_,2},
            {_,_,_,_,_,_,_,_,2,_},
            {_,_,_,_,_,_,_,2,_,_}}.


%
% Problem from http://www.cs.cornell.edu/gomes/QUASIdemo.html
% (n = 10}
% Pattern #2. 
% There are _many_ solutions to this problem.
%
problem(6, A) => 
       A = {{_,_,1,2,3,4,_,_,_,_},
            {_,1,2,3,_,_,4,_,_,_},
            {1,2,3,_,_,_,_,4,_,_},
            {2,3,_,_,_,_,_,_,4,_},
            {3,_,_,_,_,_,_,_,_,4},
            {5,6,_,_,_,_,_,_,_,_},
            {_,5,6,_,_,_,_,_,_,_},
            {_,_,5,6,_,_,_,_,_,_},
            {_,_,_,5,6,_,_,_,_,_},
            {_,_,_,_,5,6,_,_,_,_}}.


%
% Problem from http://www.cs.cornell.edu/gomes/QUASIdemo.html
% (n = 10}
% Pattern #3. 
% Coding:
%    dark red   = 1
%    light blue = 2 
%    dark blue  = 3 
%    light red  = 4
%    brown      = 5
%    green      = 6
%    pink       = 7
%    grey       = 8
%    black      = 9
%    yellow     = 10    
% There are 40944 solutions for this pattern.
%
problem(7, A) => 
       A = {{_, _, 1, 5, 2, 6, 7, 8, _, _},
            {_, 1, 5, 2, _, _, 6, 7, 8, _},
            {1, 5, 2, _, _, _, _, 6, 7, 8},
            {5, 2, _, _, _, _, _, _, 6, 7},
            {2, _, _, _, _, _, _, _, _, 6},
            {4,10, _, _, _, _, _, _, 3, 9},
            {_, 4,10, _, _, _, _, 3, 9, _},
            {_, _, 4,10, _, _, 3, 9, _, _},
            {_, _, _, 4,10, 3, 9, _, _, _}, 
            { _, _, _, _, 4,9, _, _, _, _}}.


%
% Problem from http://www.cs.cornell.edu/gomes/QUASIdemo.html
% (n = 10}
% Pattern #4. 
%  dark red   = 1
%  light blue = 2
%  dark blue  = 3
%  light red  = 4
% Note: There are no solutions to this problem.
%
problem(8, A) => 
       A = {{1,_,_,_,_,_,_,_,_,_},
            {2,1,_,_,_,_,_,_,_,4},
            {3,2,1,_,_,_,_,_,4,_},
            {_,3,2,1,_,_,_,4,_,_},
            {_,_,3,2,1,_,4,_,_,_},
            {_,_,_,3,2,1,_,_,_,_},
            {_,_,_,_,3,2,1,_,_,_},
            {_,_,_,4,_,3,2,1,_,_},
            {_,_,4,_,_,_,3,2,1,_},
            {_,4,_,_,_,_,_,3,2,1}}.


%
% Problem from http://www.cs.cornell.edu/gomes/QUASIdemo.html
% (n = 10}
% Pattern #5
% Note: There are no solutions to this problem.
%
problem(9, A) => 
       A = {{_,_,_,_,_,_,_,_,_,1},
            {_,_,_,_,_,_,_,_,1,_},
            {_,_,_,_,_,_,_,1,_,_},
            {_,_,_,_,_,_,2,_,_,_},
            {_,_,_,_,_,1,_,_,_,_},
            {_,_,_,_,1,_,_,_,_,_},
            {_,_,_,1,_,_,_,_,_,_},
            {_,_,1,_,_,_,_,_,_,_},
            {_,1,_,_,_,_,_,_,_,_},
            {1,_,_,_,_,_,_,_,_,_}}.
/* 

  queens benchmark in Picat.

  From 
  http://www.jekejeke.ch/idatab/doclet/prod/en/docs/05_run/15_stdy/06_bench/09_programs/07_queens/01_queens.p.html

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


/**
 * Prolog code for the 9x9-queens benchmark.
 *
 * Originally conceived in by Max Bezzel for the 8x8 checker board.
 * Used by Edsger Dijkstra to illustrate the
 * depth-first backtracking search algorithm.
 *
 * Copyright 2010, XLOG Technologies GmbH, Switzerland
 * Jekejeke Prolog 0.8.3 (a fast and small prolog interpreter)
 */

nodiag([], _, _) => true.
nodiag([N|L], B, D) =>
      D != N - B,
      D != B - N,
      D1 = D + 1,
      nodiag(L, B, D1).

qdelete(L, A1, A2, L2) ?=> A1=A2,L2=L.
qdelete([H|T], X, A, AR) =>
      AR = [A|R],
      qdelete(T, X, H, R).

search([], _, Q) => Q=[].
search([H|T], History, QM) =>
      QM=[Q|M],
      qdelete(T, Q, H, L1),
      nodiag(History, Q, 1),
      search(L1, [Q|History], M).

index(-)
dataqueens([1,2,3,4,5,6,7,8,9]).

queens =>
   dataqueens(X),
   search(X,[],Y),
   writeln(Y).

queens2 =>
   dataqueens(X),
   search(X,[],_Y).


go3 =>
   All=findall(Y, $search(1..8,[],Y)),
   writeln(All.length),
   nl.


go4 => 
   dataqueens(X),
   All=findall(Y, $search(X,[],Y)),
   writeln(All),
   nl.

go5 => 
   foreach(N in 6..30)
      time(search(1..N,[],Y)),
      writeln([N,Y])
   end,
   nl.

go6 => 
   foreach(_I in 1..10006)
      call(go)
   end. /*

  N-Queens problem in Picat.


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

queens1(N, Q) => 
  Q = new_list(N),
  Q :: 1..N,
  foreach(I in 1..N, J in 1..N, I < J) 
    Q[I] #!= Q[J],
    Q[I] + I #!= Q[J] + J,
    Q[I] - I #!= Q[J] - J
  end,

  solve(Q).


%
% Note that $Q[I] is needed here.
%
queens3(N, Q) =>
    Q=new_list(N),
    Q :: 1..N,
    all_different(Q),
    all_different([$Q[I]-I : I in 1..N]),
    all_different([$Q[I]+I : I in 1..N]),

    solve([ff],Q).

queens3(N) =>
    garbage_collect(200_000_000),
    queens3_all(N, Solutions),
    % writeln(Solutions),
    writeln(len=Solutions.length).

% generate all solutions via solve_all (don't work right now)
queens3_all(N, Solutions) =>
    Q=new_list(N),
    Q :: 1..N,
    all_different(Q),
    all_different([$Q[I]-I : I in 1..N]),
    all_different([$Q[I]+I : I in 1..N]),
    Solutions = solve_all([ff],Q).
    % This works:
    % Solutions = findall(Q, $solve($Q)).


% Using all_distinct instead
queens3b(N, Q) =>
    Q=new_list(N),
    Q :: 1..N,
    all_distinct(Q),
    all_distinct([$Q[I]-I : I in 1..N]),
    all_distinct([$Q[I]+I : I in 1..N]),
    solve([ff],Q).

    
% alternative approaches
queens4(N, Q) =>
   Q = new_list(N),
   Q :: 1..N,
   foreach(A in [-1,0,1])
      all_different([$Q[I]+I*A : I in 1..N])
   end,
   solve([ff],Q).

% Decomposition of alldifferent
all_different_me(L) =>
   Len = length(L),
   foreach(I in 1..Len, J in I+1..Len) L[I] #!= L[J] end.

% Using all_different_me (my decomposition)
queens5(N, Q) =>
    Q=new_list(N),
    Q :: 1..N,
    all_different_me(Q),
    all_different_me([$Q[I]-I : I in 1..N]),
    all_different_me([$Q[I]+I : I in 1..N]),
    solve([ff],Q).

queens3_count(N) = length(findall(_, queens3(N, _))).


queens3_count2_temp(N) =>
    Q=new_list(N),
    Q :: 1..N,
    all_different(Q),
    all_different([$Q[I]-I : I in 1..N]),
    all_different([$Q[I]+I : I in 1..N]),
    solve([ff],Q),
    M = get_global_map(),
    M.put(count,M.get(count)+1).

queens3_count2(N, _Count) ?=> 
   get_global_map().put(count,0),
   queens3_count2_temp(N),
   fail.
queens3_count2(_N, Count) => 
   Count = get_global_map().get(count).

% From Albert Dinero / albertmcchan@yahoo.com
count(Goal) = Count =>
  M = get_global_map(),
  M.put(count, 0),
  (call(Goal),
   M.put(count, M.get(count) + 1),
   fail;
   Count = M.get(count)).

queens3_count3(N) = count($queens3(N, _)).

go => 
   queens3(8,Q),
   writeln(Q),
   N = 8, 
   queens3_all(N, Solutions),
   % writeln(Solutions),
   Len=Solutions.length,
   writef("N:%w %w solutions.\n%w\n", N, Len, Solutions).


go1 => 
   All=findall(Q,queens1(8,Q)),
   println(All),
   println(len=All.length),
   nl.


go2 => 
    garbage_collect(200_000_000),
    foreach(N in 2..15) 
       statistics(backtracks, Backtracks),
       statistics(runtime, [_, _Runtime1]),
       % queens3_all(N, Solutions),
       % Len=Solutions.length,
       Len = count_all(queens3(N,_)),
       statistics(backtracks, Backtracks2),
       B = Backtracks2 - Backtracks,
       Backtracks := Backtracks2,
       statistics(runtime, [_, Runtime2]),
       writef("N:%3d %10d solutions (%d backtracks, %d millis)\n", N, Len, B, Runtime2)
    end.

%
% Times per Picat v 0.1-beta 10:
%   queens3 :  6.7s (2 backtracks)
%   queens3b: 10.83s (0 backtracks)
%   queens4 : 4.25s (2 backtracks)
%   queens5 : 6.86s (2 backtracks)
% 
% Times per Picat v 1.6
%   queens3 :  1.86s (2 backtracks) % standard version
%   queens3b: 14.55s (0 backtracks) % all_distinct
%   queens4 : 3.07s (2 backtracks)  % alternative
%   queens5 : 5.53s (2 backtracks)  % using a decomposition of all_different/1.
%
% Times per Picat v 1.7
%   queens3 :  1.78s (2 backtracks) % standard version
%   queens3b: 13.5s (0 backtracks) % all_distinct
%   queens4 : 2.71s (2 backtracks)  % alternative
%   queens5 : 5.2s (2 backtracks)  % using a decomposition of all_different/1.
%
go3 => 
    Ps = [queens3=1000, queens3b=1000, queens4=1000,queens5=1000],
    foreach(P=N in Ps) 
       garbage_collect(200_000_000),
       printf("%w(%d)\n", P, N),
       time2(once(call(P,N,Q))),
       writeln(Q),
       nl
    end.

% Using permutations/1. Very slow.
go4 => 
    N = 8,
    C = 0,
    foreach(P in permutations(1..N))
       if check4(P) then 
           % writeln(P), 
           C := C +1 
       end
    end,
    writeln(sols=C),
    nl.

go5 =>
    N=100,
    queens3(N,Q),
    writeln(Q),
    nl.

% N=10000 probably exhaust the RAM...
go6 =>
    N = 10000,
    println("timing queens4(10000,Q)"),
    time2(queens3(N,_Q)),
    nl.

go7 =>
    Ns = [8,10,50,100,400,500,700,1000,1500],
    foreach(N in Ns)
       garbage_collect(200_000_000),
       println(n=N),
       time2(queens3(N,_)),
       nl
    end,
    nl.

go8 =>
   foreach(N in 8..15) 
      garbage_collect(200_000_000),
      time2(Count=queens3_count(N)),
      println(N=Count),
      nl
   end,
   nl.

go9 =>
   foreach(N in 8..15) 
      time2(queens3_count2(N,Count)),
      println(N=Count),
      nl
   end,
   nl.


go10 =>
   foreach(N in 8..15) 
      time2(Count=queens3_count3(N)),
      println(N=Count),
      nl
   end,
   nl.



check4(P) =>
   N = length(P),
   foreach(I in 1..N, J in I+1..N) 
      P[I]-I != P[J]-J,
      P[I]+I != P[J]+J
   end.


/* 

  Query benchmark in Picat.

  From
  http://www.jekejeke.ch/idatab/doclet/prod/en/docs/05_run/15_stdy/06_bench/09_programs/08_query/01_query.p.html

  Query population and area database to find countries
  of approximately equal population density.


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


/**
 * Prolog code for the database query benchmark.
 *
 * This is the benchmark of page 226 of:
 * Warren, D.H.D. (1983): Applied Logic  Its Use and
 * Implementation as a Programming Tool,
 * Technical Note 290, SRI International, 1983
 *
 * We use integer division instead of float division,
 * Further complication by two temporary variables T1 and T2.
 *
 * Copyright 2010, XLOG Technologies GmbH, Switzerland
 * Jekejeke Prolog 0.8.3 (a fast and small prolog interpreter)
 */

index(-,-)
pop(china,        8250).
pop(india,        5863).
pop(ussr,         2521).
pop(usa,          2119).
pop(indonesia,    1276).
pop(japan,        1097).
pop(brazil,       1042).
pop(bangladesh,    750).
pop(pakistan,      682).
pop(w_germany,     620).
pop(nigeria,       613).
pop(mexico,        581).
pop(uk,            559).
pop(italy,         554).
pop(france,        525).
pop(philippines,   415).
pop(thailand,      410).
pop(turkey,        383).
pop(egypt,         364).
pop(spain,         352).
pop(poland,        337).
pop(s_korea,       335).
pop(iran,          320).
pop(ethiopia,      272).
pop(argentina,     251).

index(+,-)
area(china,       3380).
area(india,       1139).
area(ussr,        8708).
area(usa,         3609).
area(indonesia,    570).
area(japan,        148).
area(brazil,      3288).
area(bangladesh,    55).
area(pakistan,     311).
area(w_germany,     96).
area(nigeria,      373).
area(mexico,       764).
area(uk,            86).
area(italy,        116).
area(france,       213).
area(philippines,   90).
area(thailand,     200).
area(turkey,       296).
area(egypt,        386).
area(spain,        190).
area(poland,       121).
area(s_korea,       37).
area(iran,         628).
area(ethiopia,     350).
area(argentina,   1080).

density(C, D) =>
  pop(C, P),
  area(C, A),
  D = P*100 // A.

query =>
  density(C1, D1),
  density(C2, D2),
  D1 > D2,
  T1 = 20 * D1,
  T2 = 21 * D2,
  T1 < T2,
  writeln([T1,T2]),
  writeln([D1,D2]),
  writeln([C1,C2]).

/*

  Rabbits problem in Picat.

  From Pascal Van Hentenryck "The OPL Optimization Programming Language",
  page 9.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   writeln(clp),
   N = 20,
   NbRabbits :: 0..N,
   NbPheasants :: 0..N,
   
   20 #= NbRabbits + NbPheasants,
   56 #= 4*NbRabbits + 2*NbPheasants,

   solve([],[NbRabbits,NbPheasants]),

   writeln(nbRabbits=NbRabbits),
   writeln(nbPheasants=NbPheasants),
   nl.

/*

  Railroad switching problem in Picat.

  Problem fromStefan Edelkamp, Stefan Schrdl:
  "Heuristic Search: Theory and Applications, page ff"

  Note: This use a graph representation.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% See http://www.hakank.org/picat/bplan.pi

go =>
   initial_state(Init),
   time(plan2(Init, Plan,_Cost)),
   print_plan(Plan),
   write(len=Plan.length),nl.

go2 =>
   % first find the optimal plan
   initial_state(Init),
   time(plan2(Init,Plan1,_Cost)),

   % then find all optimal plans
   P = new_list(Plan1.length),
   All=findall(P,bplan.plan(P)),
   foreach(Plan in All) print_plan(Plan) end,
   writeln(len=All.length),
   nl.

print_plan(Plan) => 
   foreach([From,To] in Plan) printf("%w -> %w\n", From,To) end, 
   nl.


index(-)
initial_state([e,a,b]).

index(-)
goal_state([e,b,a]).

legal_move(From,Move,To) ?=>
   graph2(From,To,_),
   Move = [From,To].


legal_move(From,Move,To,Cost) ?=>
   graph2(From,To,_),
   Move = [From,To],
   Cost = 1.


%
% This is the graph from figure 1.4 (page 13) in "Heuristic Search..."
% (This is a directed graph.)
%
index(-,-,-)
graph([e,a,b],[b,a,e],eab_bae).
graph([b,a,e],[b,e,a],bae_bea).
graph([b,a,e],[a,e,b],bae_aeb).
graph([b,e,a],[a,b,e],bea_abe).
graph([a,b,e],[a,e,b],abe_aeb).
graph([a,b,e],[e,b,a],abe_eba).

% Make the graph undirected
graph2(From,To,Move) ?=> 
  graph(From,To,Move).

graph2(From,To,Move) ?=> 
  graph(To,From, Move)./* 

  Read test in Picat.

  This is one of my standard test when learning a new programming
  language: read a word file and filters the words that match 
  the regular expression
      a.*b.*c..., b.*c.*d.., c.*d.*e..., etc

  Since Picat currently don't support regular expressions I've
  done some replacements...

  The pattern with most words found is this pattern of length 5:
      .*a.*b.*c.*d.*e.* 
  matching these 26 words:

    abecedaire,
    abecedaries,
    abjectedness,
    aborticide,
    absconded,
    abscondedly,
    abscondence,
    absconder,
    absconders,
    abstractedness,
    amblycephalidae,
    ambuscade,
    ambuscaded, 
    ambuscader,
    ambuscades,
    ambuscadoed,
    amebicide,
    amoebicide,
    bambocciade,
    bambochade,
    carbacidometer,
    cerambycidae,
    nonabstractedness,
    oxylabracidae,
    scabicide,
    unabstractedness


  Statistics on testing words_lower.txt (415834 words) on 5 length patterns.
  check3/2 (using "plain" recursion) is by far the fastest:

   * check/2 (tested in go/0): 17.5s
   * check2/2 (tested in go2/0): 17.5s
   * check3/2 (tested in go3/0): 3.8s
   * check3/2 (using list comprehension in go3b/0): 3.6s

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


%
% using check/2: 17.5s
% [[26,abcde],[23,rstuv],[23,lmnop],[6,efghi],[3,klmno],[1,defgh]]
% CPU time 17.5s seconds.
%
go =>
   Words = read_file_lines("words_lower.txt"),
   % Words = read_file_lines("/usr/share/dict/words"),
   % Words = read_file_lines("/home/hakank/public_html/combograms/sv_spelling_org_utf8.txt"),
   Alpha = lower(),
   Len = 5,
   AllMatch = [],
   Patterns = [ [Alpha[J] : J in I..I+Len-1] : I in 1..Alpha.length-Len+1],
   foreach(Pattern in Patterns) 
      println(pattern=Pattern),
      Match = [],
      foreach(Word in Words,check(Word,Pattern))
        Match := Match ++ [Word]
      end,
      println(Match),
      println(len=Match.length),
      if Match.length > 0 then
         AllMatch := AllMatch ++ [[Match.length,Pattern]]
      end,
      nl        
   end,

   println(AllMatch.sort_down()),

   nl.

%
% using check2: 17.5s
% [26,abcde],[23,rstuv],[23,lmnop],[6,efghi],[3,klmno],[1,defgh]]
% CPU time 17.5 seconds.
%
go2 =>
   Words = read_file_lines("words_lower.txt"),
   % Words = read_file_lines("/usr/share/dict/words"),
   Alpha = lower(),
   Len = 5,
   AllMatch = [],
   Patterns = [ [Alpha[J] : J in I..I+Len-1] : I in 1..Alpha.length-Len+1],
   foreach(Pattern in Patterns) 
      println(pattern=Pattern),
      Match = [],
      foreach(Word in Words, check2(Word,Pattern))
        Match := Match ++ [Word]
      end,
      println(Match),
      println(len=Match.length),
      if Match.length > 0 then
         AllMatch := AllMatch ++ [[Match.length,Pattern]]
      end,
      nl        
   end,

   println(AllMatch.sort_down()),
   nl.


go2b =>
   Pattern = "abcde",
   Words = check_word_list("words_lower.txt",Pattern),
   println(Words),
   println(len=Words.length),
   nl.


%
% using check3: 3.7s
% [[26,abcde],[23,rstuv],[23,lmnop],[6,efghi],[3,klmno],[1,defgh]]
% CPU time 3.7s seconds.
%
go3 =>
   Words = read_file_lines("words_lower.txt"),
   % Words = read_file_lines("/usr/share/dict/words"),
   Alpha = lower(),
   Len = 5,
   AllMatch = [],
   Patterns = [ [Alpha[J] : J in I..I+Len-1] : I in 1..Alpha.length-Len+1],
   foreach(Pattern in Patterns) 
      println(pattern=Pattern),
      Match = [],
      foreach(Word in Words, check3(Word,Pattern))
         Match := Match ++ [Word]
      end,
      println(Match),
      println(len=Match.length),
      if Match.length > 0 then
         AllMatch := AllMatch ++ [[Match.length,Pattern]]
      end,
      nl        
   end,

   println(AllMatch.sort_down()),

   nl.

%
% Variant using list comprehension (and a slightly different presentation): 3.6s
%
go3b =>
   Words = read_file_lines("words_lower.txt"),
   % Words = read_file_lines("/usr/share/dict/words"),
   Alpha = lower(),
   Len = 5,
   Patterns = [ [Alpha[J] : J in I..I+Len-1] : I in 1..Alpha.length-Len+1],
   AllMatch = [[Matches.len,Pattern,Matches] :  Pattern in Patterns, Matches=[Word : Word in Words, check3(Word,Pattern)], Matches.len > 0].sort_down(),
   println(AllMatch.join("\n")),

   nl.


% much slower due to the overhead of call/n
go4 =>
  test_all("words_lower.txt",5,check3).


lower() = [chr(I+96) : I in 1..26].
upper() = [chr(I+64) : I in 1..26].

lower_swe() = [chr(I+96) : I in 1..26] ++ "".


%
% Check if the pattern P match the string String. 
% Pattern P corresponds to the regular expression
%    /.*P[1].*P[2].*P[3].*...P[P.length].*/
%
check(String,Pattern) =>
   S = String,
   PLen = Pattern.length,
   Ix = 1,
   Found = 0,
   % while (Ix <= PLen, once(find(S,Pattern[Ix],From,_To)))
   while (Ix <= PLen, find2(S,Pattern[Ix],From,_To))
      SS = substr(S,From),
      S := SS,
      Found := Found + 1,
      Ix := Ix + 1
   end,
   Found == Pattern.length.


%
% Another approach: about the same time as check/2.
%
check2(String,Pattern) =>
   PLen = Pattern.length,
   SIx = 1,
   PIx = 1,
   Found = 0,
   while (SIx <= String.length, PIx <= PLen, Found < PLen)
      if String[SIx] == Pattern[PIx] then 
         Found := Found + 1,
         PIx := PIx + 1
      end,
      SIx := SIx + 1
   end,
   Found == PLen.


%
% Plain recursive version.
% Much faster - and smaller - than check/2 and check2/2.
%

% check each character in the string against the pattern
check3([SH|ST],P@[PH|PT]) => 
  (SH == PH -> 
    check3(ST,PT)
   ; 
    check3(ST,P)
  ).

% empty pattern (this is the goal)
check3(_S,[]) => 
  true.


% General testing of the predicates. 
% However the use of call/n slows it down considerably.
% E.g. test_all("words_lower.txt",5,check3) takes 68s, compared to go3's 3.7s
%
test_all(Dict,Len,CheckPred) =>
   Words = read_file_lines(Dict),
   Alpha = lower(),
   AllMatch = [],
   Patterns = [ [Alpha[J] : J in I..I+Len-1] : I in 1..Alpha.length-Len+1],
   foreach(Pattern in Patterns) 
      println(pattern=Pattern),
      Match = [],
      foreach(Word in Words)
         if call(CheckPred,Word,Pattern) then
            Match := Match ++ [Word]
         end
      end,
      println(Match),
      println(len=Match.length),
      if Match.length > 0 then
         AllMatch := AllMatch ++ [[Match.length,Pattern]]
      end,
      nl        
   end,

   println(AllMatch.sort_down()),

   nl.


substr(S, From) = [S[I] : I in From..S.length].
substr(S, From, To) = [S[I] : I in From..To].

check_word_list(File,Pattern) = Words =>
    FD = open(File),    
    Words = [],
    while (not at_end_of_stream(FD)) 
       Word := read_line(FD),
       if check(Word,Pattern) then
          % println(Word),
          Words := Words ++ [Word]
       end
    end,
    close(FD).


%
% find/4 requires that the Substring is a string.
%
find2(String, Substring, From, To), char(Substring) => 
  find(String, Substring.to_string(), From, To).

find2(String, Substring, From, To) => 
  find(String, Substring, From, To).
/*

  Remainder problem in Picat.

  """
  11.  Is there a number which when divided by 3 gives a remainder of 1;
  when divided by 4, gives a remainder of 2; when divided by 5, gives a
  remainder of 3; and when divided by 6, gives a remainder of 4?
  (Kordemsky)
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
  writeln(findall(X,$remainder(X,10000))),nl.

go2 =>
  writeln(findall(X,$remainder2(X,10000))),nl.

remainder(X,Max) =>

   [X,A,B,C,D] :: 1..Max,

   X #= A*3 + 1,
   X #= B*4 + 2,
   X #= C*5 + 3,
   X #= D*6 + 4,

   solve([X,A,B,C,D]).


remainder2(X,Max) =>

   [X,A,B,C,D] :: 1..Max,

   foreach({I,K} in zip(1..4,[A,B,C,D])) 
     X #= K*(I+2) + I
   end,
   solve([X,A,B,C,D]).

/*

  Remarkable sequence  in Picat.

  Problem statement in the Alma-0 example program remarkable.a0
  """
  This problem is taken from
  @book{CC88,
        author = "H. Coelho and J. C. Cotta",
        title = "Prolog by Example",
        publisher = "Springer-Verlag",
        address = "Berlin",
        year = 1988}
  (page 193)
 
  Call a sequence of 27 elements remarkable if it consists of three 1's,
  three 2's, ...  three 9's arranged in such a way that for all i in
  [1..9] there are exactly i numbers between successive occurrences of
  i.  For example, the sequence
 
  (1,9,1,2,1,8,2,4,6,2,7,9,4,5,8,6,3,4,7,5,3,9,6,8,3,5,7)
 
  is remarkable.  Write a program that generates all
  remarkable sequences.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   L = findall(A, remarkable_sequence(A)),
   foreach(X in L) writeln(X.to_list()) end,
   nl.

remarkable_sequence(A) =>

   N = 9, % the digits
   M = 3, % number of occurrences of each number
   NM = N*M,
   A = new_array(NM),
   A :: 1..N, 

   Js = [],
   foreach(I in 1..N)
      MaxVal = 25-(2*I),
      J :: 1..MaxVal,
      element(J,A,I),
      JI1 #= J+I+1,
      element(JI1,A,I),
      J2I2 #= J+2*I+2,
      element(J2I2,A,I),
      Js := Js ++ [J]
   end,

   % exact 3 occurrences of each digit
   Cards = [$(K-3): K in 1..9], % note: $(K-3) for the pairs (Key-Value)
   global_cardinality(A,Cards),

   % foreach(K in 1..9, count(K,A,#=,3)),
   % Symmetry breaking: First element is less than the last
   A[1] #=< A[NM],

   Vars = vars(A) ++ Js,
   solve([ff],Vars).

/* 

  Reverse multiples in Picat.

  Find reverse multiples.
  
  E.g.
   4*2178 = 8712


  Also see:
    - Richard Green: "Reverse multiple numbers"
      https://plus.google.com/u/0/101584889282878921052/posts/9HFfd99sFj2

    - N.J.A. Sloane: "2178 And All That"
      http://arxiv.org/abs/1307.0453
  via
  
  Jekejeke Logic Programming:
  https://plus.google.com/u/0/103259555581227445618/posts/9HE8iXQaXnM

  (Thanks to Neng-Fa for some improvements.)

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
   % Len = 4,
   Base = 10,
   foreach(Len in 2..9) 
       println(len=Len),
       time2(All = findall([Num1,Num2,M,A1,A2], reverse_multiples(Len, Base, Num1, Num2, M,A1,A2))),
       foreach([Num1,Num2,M,A1,A2] in All) 
          if Base == 10 then
              println([len=Len,num1=Num1,num2=Num2,m=M])
          else
              println([len=Len,num1=Num1,num2=Num2,m=M,a1=A1,a2=A2])
          end
       end,
       nl
   end,
   nl.


go2 =>
   Base = 10,
   Len=6,
   time2(All = findall([Num1,Num2,M,A1,A2], reverse_multiples(Len, Base, Num1, Num2, M,A1,A2))),
   foreach([Num1,Num2,M,A1,A2] in All) 
      writeln([len=Len,num1=Num1,num2=Num2,m=M,a1=A1,a2=A2])
   end,
   nl.

% Solve for just one solution.
go3 =>
   Base = 10,
   Len = 6,
   Variable = [backward,constr,degree,ff,ffc,forward,inout,leftmost,max,min],
   Value = [down,updown,split,reverse_split],
   Best = [],
   Timeout = 10000,
   foreach(Var in Variable) 
     foreach(Val in Value) 
       Labeling = [Var,Val],
       println(Labeling),
       time2(time_out(reverse_multiples(Len, Base, Num1, Num2, M,A1,A2, Labeling), Timeout, Status)),
       if Status == success then
          writeln([len=Len,num1=Num1,num2=Num2,m=M,a1=A1,a2=A2]),
          Best := Best ++ [Labeling]
       end
     end
   end,
   nl.
   

reverse_multiples(Len, Base,Num1,Num2,M,A1,A2) =>
   reverse_multiples(Len, Base,Num1,Num2,M,A1,A2,[ff,updown]).

reverse_multiples(Len, Base,Num1,Num2,M,A1,A2, Labeling) =>
     % writeln(labeling=Labeling),
     Lower = Base**(Len-1),
     Upper = Base**(Len)-1,

     Num1 :: Lower..Upper,
     Num2 :: Lower..Upper,

     M :: 2..Base-1, % the multiplier
     % M :: [4,9],

     A1 = new_list(Len),
     A1 :: 0..Base-1,
     A2 = new_list(Len),
     A2 :: 0..Base-1,

     %Num2 #< Num1,

     to_num(A1,Base,Num1),
     to_num(A2,Base,Num2),

     M * Num2 #= Num1,

     A2 = reverse(A1),
     % reverse2(A1,A2),

     % writeln([num1=Num1,num2=Num2,m=M, a1=A1,a2=A2]),

     Vars = A1 ++ [M] ++ A2 ++ [Num1,Num2],
     solve(Labeling,Vars).
 


% converts a number Num to/from a list of integer List given a base Base
to_num(List, Base, Num) =>
        Len = List.length,
        Num #= sum([List[I]*Base**(Len-I) : I in 1..Len]).

reverse2(L1,L2) =>
   Len = L1.length, 
   foreach(I in 1..Len) 
      L1[I] #= L2[Len-I+1]
   end.
/*

  Roman numerals/Decode in Picat.

  From Rosetta code:
  http://rosettacode.org/wiki/Roman_numerals/Decode
  """
  Create a function that takes a Roman numeral as its argument and returns 
  its value as a numeric decimal integer. You don't need to validate the form 
  of the Roman numeral.

  Modern Roman numerals are written by expressing each decimal digit of the 
  number to be encoded separately, starting with the leftmost digit and 
  skipping any 0s. So 1990 is rendered "MCMXC" (1000 = M, 900 = CM, 90 = XC) 
  and 2008 is rendered "MMVIII" (2000 = MM, 8 = VIII). The Roman numeral 
  for 1666, "MDCLXVI", uses each letter in descending order. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
   List = ["IV",
           "XLII",
           "M",
           "MCXI",
           "CMXI",
           "MCM",
           "MCMXC",
           "MMVIII",
           "MMIX",
           "MCDXLIV",
           "MDCLXVI",
           "MMXII"],
   foreach(R in List) 
      printf("%-8s: %w\n", R, roman_decode(R))
   end,
   nl.


roman_decode(Str) = Res =>
  if Str == "" then
    Res := ""
  else 
    % Roman = split("MDCLXVI",""),
    % Dec   = split("1000 500 100 50 10 5 1", " "),
    % D     = new_map([(Roman[I]=to_integer(Dec[I])) : I in 1..Roman.length]),
    D = new_map(findall((R=D), $roman(R,D))),
    % D = new_map[("M"=1000), ("D"=500), ("C"=100), ("L"=50), ("X"=10), ("V"=5), ("I"=1)]),
    Res = 0,
    Old = 0,
    foreach(S in Str)
      N = D.get(S),
      % Fix for the Roman convention that XC = 90, not 110.
      if Old > 0, N > Old then
        Res := Res - 2*Old
      end,
      Res := Res + N,
      Old := N 
    end
  end.


index (-,-)
roman('I', 1).
roman('V', 5).
roman('X', 10).
roman('L', 50).
roman('C', 100).
roman('D', 500).
roman('M', 1000)./*

  Roman numerals/Encode in Picat.

  From Rosetta code:
  http://rosettacode.org/wiki/Roman_numerals/Encode
  """
  Create a function taking a positive integer as its parameter and 
  returning a string containing the Roman Numeral representation of that integer.
  
  Modern Roman numerals are written by expressing each digit separately 
  starting with the left most digit and skipping any digit with a value of 
  zero. In Roman numerals 1990 is rendered: 1000=M, 900=CM, 90=XC; 
  resulting in MCMXC. 2008 is written as 2000=MM, 8=VIII; or MMVIII. 
  1666 uses each Roman symbol in descending order: MDCLXVI. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
   List = [455,999,1999,2000,2001,2009,2010,2011,2012,1666,3456,3888,4000],
   foreach(Val in List)
      printf("%4d: %w\n", Val, roman_encode(Val))
   end,
   nl.



roman_encode(Val) = Res => 
  if Val <= 0 then
     Res := -1
  else
     Arabic = [1000, 900, 500, 400,  100, 90,  50, 40,  10,  9,  5,  4,   1],
     Roman  = ["M", "CM", "D", "CD", "C", "XC","L","XL","X","IX","V","IV","I"],
     Res = "",
     foreach(I in 1..Arabic.length)
        while(Val >= Arabic[I]) 
           Res := Res ++ Roman[I],
           Val := Val - Arabic[I]
        end
     end
  end.
/*

  Rot 13 in Picat.

  See 
     http://en.wikipedia.org/wiki/ROT13
     http://rosettacode.org/wiki/Rot-13

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
  S = "Big fjords vex quick waltz nymph!",
  println(rot13(S)),
  println(rot13(rot13(S))),

  nl.
    
% Rot 13 using a map
rot13(S) = S2 =>
  Lower = "abcdefghijklmnopqrstuvwxyz",
  Upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  M = create_map(Lower, Upper),
  % If a char is not in a..zA..z then show it as it is.
  S2 := [M.get(C,C) : C in S].

create_map(Lower, Upper) = M =>
  M = new_map(),
  Len = Lower.length,
  LDiv := Lower.length div 2,
  foreach(I in 1..Len)
    II = (LDiv+I) mod Len,
    if II == 0 then II := Len end,
    M.put(Upper[I],Upper[II]),
    M.put(Lower[I],Lower[II])
  end.


/* 

  Rotation puzzle in Picat.

  From GAP mailing list
  http://www-groups.dcs.st-and.ac.uk/~gap/ForumArchive/Harris.1/Bob.1/Re__GAP_.59/1.html
  """
  Since you asked about what the puzzle actually is, the fellow who posted it
  at rec.puzzles (Kevin Buzzard <buzzard@ic.PUZZLE.ac.ELZZUP.uk>) had found it
  on his nokia cell phone. It is called "rotation" at Nokia's web site
  http://www.nokia.com/games
  I think this variant is level 5.

  The puzzle is a 4x4 square of numbers. There are four operations, each of
  which involves rotating the numbers in a 3x3 square clockwise. So, in the
  diagram below, one move is the cycle (1,2,3,7,11,10,9,5). The numbers
  maintain orientation-- they don't rotate; if they did, that would add
  another layer of complexity for the solver.

       1  2  3  4
       5  6  7  8
       9 10 11 12
      13 14 15 16

  Anyone who's interested in an archive of the discussion ofthis puzzle (it's
  about a 40K byte text file), let me know. The discussion focuses primarily
  on finding minimal move sequences to swap two given tiles.

  There's a very well done java applet for a similar puzzle at
  http://www.microprizes.com/mp52.htm 
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


% See http://www.hakank.org/picat/bplan.pi

go =>
   % One 1-rotation:
   % Init = [2,3,7,4,1,6,11,8,5,9,10,12,13,14,15,16],

   % 2,1
   % Init = [2,7,4,8,1,3,11,12,5,6,9,10,13,14,15,16],

   % 1,2,1
   % Init = [7,4,11,8,2,3,9,12,1,5,6,10,13,14,15,16],

   % 1,2,3
   % Init = [3,4,11,8,1,2,10,12,6,5,7,15,9,13,14,16],
   
   % 1,2,3,2,2,3
   % Init = [8,12,7,15,1,4,2,10,3,6,11,14,5,9,13,16 ],
   
   % 4,4,4,1,2,3,2,2,3
   Init = [8,12,7,15,1,14,16,13,3,10,11,9,5,2,4,6 ],

   % Random puzzle
   % Init = [2,4,16,11,15,7,12,1,8,9,14,3,10,5,13,6],

   % swap 15<->16 (GAP says 53 moves,but that's probably not optimal )
   % Init = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,16,15 ],

   time(once(bplan(Init, L))),
   % time(bplan(Init, L)),
   writeln(L),
   Len=length(L),
   writeln(len=Len),
   nl.

% Using bplan.plan2
go2 =>
   % One 1-rotation:
   % Init = [2,3,7,4,1,6,11,8,5,9,10,12,13,14,15,16],

   % 2,1
   % Init = [2,7,4,8,1,3,11,12,5,6,9,10,13,14,15,16],

   % 1,2,1
   % Init = [7,4,11,8,2,3,9,12,1,5,6,10,13,14,15,16],

   % 1,2,3
   % Init = [3,4,11,8,1,2,10,12,6,5,7,15,9,13,14,16],
   
   % 1,2,3,2,2,3
   % Init = [8,12,7,15,1,4,2,10,3,6,11,14,5,9,13,16 ],
   
   % 4,4,4,1,2,3,2,2,3
   Init = [8,12,7,15,1,14,16,13,3,10,11,9,5,2,4,6 ],

   % Random puzzle
   % Init = [2,4,16,11,15,7,12,1,8,9,14,3,10,5,13,6],

   % swap 15<->16 (GAP says 53 moves,but that's probably not optimal )
   % Init = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,16,15 ],

   time(plan2(Init, L,Cost)),
   writeln(L),
   writeln(len=L.length),
   writeln(cost=Cost),
   nl.


goal_state(Goal) => Goal=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16].


% table
% 1, 2, 3,  7, 11, 10,  9,  5, % move 1 (around 6)
legal_move([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16],M, To) ?=> 
           M=1, To=[M5,M1,M2,M4,M9,M6,M3,M8,M10,M11,M7,M12,M13,M14,M15,M16].

% 2, 3, 4,  8, 12, 11, 10,  6, % move 2 (around 7)
legal_move([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16],M, To) ?=> 
           M=2, To=[M1,M6,M2,M3,M5,M10,M7,M4,M9,M11,M12,M8,M13,M14,M15,M16].

% 5, 6, 7, 11, 15, 14, 13,  9, % move 3 (around 10)
legal_move([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16],M, To) ?=> 
           M=3, To=[M1,M2,M3,M4,M9,M5,M6,M8,M13,M10,M7,M12,M14,M15,M11,M16].

% 6, 7, 8, 12, 16, 15, 14, 10, % move 4 (around 11)
legal_move([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16],M, To) => 
           M=4, To=[M1,M2,M3,M4,M5,M10,M6,M7,M9,M14,M11,M8,M13,M15,M16,M12].


%
% For bplan.plan2/3
%
% table
% 1, 2, 3,  7, 11, 10,  9,  5, % move 1 (around 6)
legal_move([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16],M, To, Cost) ?=> 
           M=1, To=[M5,M1,M2,M4,M9,M6,M3,M8,M10,M11,M7,M12,M13,M14,M15,M16], Cost=1.

% 2, 3, 4,  8, 12, 11, 10,  6, % move 2 (around 7)
legal_move([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16],M, To,Cost) ?=> 
           M=2, To=[M1,M6,M2,M3,M5,M10,M7,M4,M9,M11,M12,M8,M13,M14,M15,M16],Cost=1.

% 5, 6, 7, 11, 15, 14, 13,  9, % move 3 (around 10)
legal_move([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16],M, To,Cost) ?=> 
           M=3, To=[M1,M2,M3,M4,M9,M5,M6,M8,M13,M10,M7,M12,M14,M15,M11,M16],Cost=1.

% 6, 7, 8, 12, 16, 15, 14, 10, % move 4 (around 11)
legal_move([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16],M, To,Cost) => 
           M=4, To=[M1,M2,M3,M4,M5,M10,M6,M7,M9,M14,M11,M8,M13,M15,M16,M12], Cost=1.



%
% CP approach
%
go_cp =>
   % One 1-rotation:
   % Init = [2,3,7,4,1,6,11,8,5,9,10,12,13,14,15,16],

   % 2,1
   % Init = [2,7,4,8,1,3,11,12,5,6,9,10,13,14,15,16],

   % 1,2,1
   % Init = [7,4,11,8,2,3,9,12,1,5,6,10,13,14,15,16],

   % 1,2,3
   % Init = [3,4,11,8,1,2,10,12,6,5,7,15,9,13,14,16],
   
   % 1,2,3,2,2,3
   % Init = [8,12,7,15,1,4,2,10,3,6,11,14,5,9,13,16 ],
   
   % 4,4,4,1,2,3,2,2,3
   Init = [8,12,7,15,1,14,16,13,3,10,11,9,5,2,4,6 ],

   % Random puzzle
   % Init = [2,4,16,11,15,7,12,1,8,9,14,3,10,5,13,6],

   % swap 15<->16 (GAP says 53 moves,but that's probably not optimal )
   % Init = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,16,15 ],

   rotation_cp(Init, Moves),
   writeln(Moves),
   nl.

% The permutation from A <-> B using the permutation P
permutation3(A,P,B) =>
   foreach(I in 1..A.length)
       %  B[I] #= A[P[I]]
       PI #= P[I], 
       BI #= B[I], 
       element(PI, A, BI)
   end.


% CP approach
%
% Using indomain(Len) find the shortest solution.
%
rotation_cp(Init, Moves) => 
    N = 16,

    Len :: 2..100,
    indomain(Len),
    writeln(len=Len),

    Moves = new_list(Len-1),
    Moves :: 1..4,
    X = new_array(Len, N),    
    X :: 1..N,

    % The valid moves
    Permutations = [
                      [5,1,2,4,9,6,3,8,10,11,7,12,13,14,15,16], % move 1
                      [1,6,2,3,5,10,7,4,9,11,12,8,13,14,15,16], % move 2
                      [1,2,3,4,9,5,6,8,13,10,7,12,14,15,11,16], % move 3
                      [1,2,3,4,5,10,6,7,9,14,11,8,13,15,16,12]  % move 4
                   ],

    % init
    foreach(J in 1..N) X[1,J] #= Init[J] end,
    % the moves
    foreach(Move in 2..Len)
       all_different([X[Move,J] : J in 1..N]),
       permutation3([X[Move-1,J] : J in 1..N], 
                    [P : J in 1..N, matrix_element(Permutations, Moves[Move-1],J,P)],
                    [X[Move,J] : J in 1..N])
    end,
    % the goal
    foreach(J in 1..N) X[Len,J] #= J end,

    Vars = Moves ++ X.to_list(),
    solve([split], Vars),

    foreach(Row in X) writeln(Row.to_list()) end,
    writeln(moves=Moves),
    nl.

% matrix_element(X, I, J, Val) =>
%  nth(I, X, Row),
%  element(J, Row, Val).

%matrix_element(X, I, J, Val) =>
%  element(I, X, Row),
%  nth(J, Row, Val).

%matrix_element(X, I, J, Val) =>
%  nth(I, X, Row),
%  nth(J, Row, Val).

%matrix_element(X, I, J, Val) =>
%   freeze(I, (nth(I, X, Row),freeze(J,nth(J,Row,Val)))).

matrix_element(X, I, J, Val) =>
   freeze(I, (element(I, X, Row),freeze(J,element(J,Row,Val)))).

% matrix_element(X, I, J, Val) =>
%   freeze(I, (element(I, X, Row),freeze(J,nth(J,Row,Val)))).
/*

  Runs a Picat program via the shell command line in Picat.

  This works for simple goals:

    $ picat run_program.pi queens go

    $ picat run_program.pi queens "time(go)"

  If time2 is defined in queens.pi, then this also works

    $ picat run_program.pi queens "time2(go)"

  And we can use the predicates defined in this program (here timeX/1)

    $ picat run_program.pi queens "timeX(go)"


  However, it don't work for more complex goals, e.g. calling a predicate 
  with a variable:

    $ picat run_program.pi queens 'queens3(100,Q),writeln(Q)'

***  Undefined procedure: throw/2


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

timeX(Goal) =>
    statistics(runtime,_),
    statistics(backtracks, Backtracks1),
    (call(Goal); true),
    statistics(backtracks, Backtracks2),
    statistics(runtime, [_,End]),
    T = End / 1000.0,
    Backtracks = Backtracks2 - Backtracks1,
    printf("CPU time %2.5f seconds. Backtracks: %d\n", T, Backtracks).



% timeout(Goal, Limit in s)
timeout(Goal, Limit) => 
    println($timeout(Goal, Limit)),
    if Limit == 0 then
       call(Goal)
    else 
       time_out(Goal, Limit*1000, Result)
    end,
    println(Result).

time_out(Goal,Limit) =>
   timeout(Goal, Limit).

% Run Goal N times,
% and report times and their average
bench(Goal,N) =>
   Times = [],
   statistics(runtime,_),
   foreach(_I in 1..N) 
     call(Goal),
     statistics(runtime, [_,End]),
     T = End / 1000.0,
     Times := Times ++ [T]
   end,
   println([times=Times, avg=avg(Times)]).

bench(Goal) =>
  bench(Goal,1).

eval(Expr) = parse_term(Expr.flatten()).apply().

main([Program|Goals]) =>

    println(program=Program),
    cl(Program), % compile and load the program
    foreach(Goal in Goals) 
       nl,
       G = parse_term(Goal), % convert the goal string to an atom
       println(goal=Goal),
       % G.call()
       time2(G.call())
       % time(G.call())
    end.

/*

  Safe cracking problem in Picat.

  From the Oz Primer:
  http://www.comp.nus.edu.sg/~henz/projects/puzzles/digits/index.html
  """
  The code of Professor Smart's safe is a sequence of 9 distinct 
  nonzero digits C1 .. C9 such that the following equations and
  inequations are satisfied:

        C4 - C6   =   C7
   C1 * C2 * C3   =   C8 + C9
   C2 + C3 + C6   <   C8
             C9   <   C8

   and

 
   C1 <> 1, C2 <> 2, ..., C9 <> 9

  can you find the correct combination?
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   safe(LD),
   writeln(LD),nl.

go2 =>
   write(findall(LD, $safe(LD))),nl.

safe(LD) =>
   N = 9,
   LD=[C1, C2, C3, C4, _C5, C6, C7, C8, C9],
   LD :: 1..9,

   all_different(LD),
    
   % C1 <> 1, C2 <> 2, ..., C9 <> 9
   foreach({I,L} in zip(1..N,LD)) L #!= I end,
   
   C4 - C6 #= C7,
   C1 * C2 * C3 #= C8 + C9,
   C2 + C3 + C6 #< C8,
   C9 #< C8,

   solve([forward,split], LD).
/*

  Scheduling in Picat.

  Example from SICStus Prolog:
  http://www.sics.se/sicstus/docs/latest/html/sicstus/Cumulative-Scheduling.html#Cumulative%20Scheduling

  """
  Cumulative Scheduling

  This example is a very small scheduling problem. We consider seven
  tasks where each task has a fixed duration and a fixed amount of used
  resource:

  Task Duration Resource
   t1    16       2
   t2     6       9
   t3    13       3
   t4     7       7
   t5     5      10
   t6    18       1
   t7     4      11

  The goal is to find a schedule that minimizes the completion time for
  the schedule while not exceeding the capacity 13 of the resource. The
  resource constraint is succinctly captured by a cumulative/4
  constraint. Branch-and-bound search is used to find the minimal
  completion time. 

  This example was adapted from [Beldiceanu & Contejean 94]. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   Capacity = 13,
   schedule1(Ss, End, Capacity),
   writeln(capacity= Capacity),
   writeln([Ss, End]).

schedule1(Ss, End,Capacity) =>

   Ds = [16, 6,13, 7, 5,18, 4],
   Ss = new_list(Ds.length),
   Ss :: 1..30,

   Rs = [ 2, 9, 3, 7,10, 1,11],
   End :: 1..50,

   after(Ss, Ds, End),
   cumulative(Ss, Ds, Rs, Capacity),

   Vars = Ss ++ [End],

   solve([$min(End)],Vars).


after([], [], _) => true.
after([S|Ss], [D|Ds], E) => E #>= S+D, after(Ss, Ds, E).

/*

  Scheduling example in Picat.

  Example from
  http://www.sciences.univ-nantes.fr/info/perso/permanents/monfroy/Teaching/Cours/ConstraintLecture-PS-PDF/P1-CP_Lecture/Part13_global_reified_constraints/global_reified_constraints.pdf
  page 32,


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   schedule(LO, End),
   writeln(LO),
   writeln(End).

schedule(LO,End) => 
   % starting time
   LO = [O1,O2,O3,O4,O5,O6,O7],
 
   %duration of tasks
   LD = [16,6,13,7,5,18,4],
   
   % resources needed by each task
   LR = [2,9,3,7,10,1,11],
   % ending times
   LE = [E1,E2,E3,E4,E5,E6,E7],
   
   % time allowed
   End :: 1..30,
   LO :: 1..30,
   LE :: 1..30,

   % ending time is starting time + duration
   O1 + 16 #= E1,
   O2 + 6 #= E2,
   O3 + 13 #= E3,
   O4 + 7 #= E4,
   O5 + 5 #= E5,
   O6 + 18 #= E6,
   O7 + 4 #= E7,
   
   % constraint End to be the maximum element in the li
   End #= max(LE),
   
   % start, duration, resource units, resource limits
   cumulative(LO,LD,LR,13),
   
   % find the values that minimize End
   solve([$min(End)], LO).
/*

  Scheduling speakers in Picat.

  From Rina Dechter, Constraint Processing, page 72
  Scheduling of 6 speakers in 6 slots.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   N = 6, % number of speakers

   % the available slots 
   Available = 
       [
                  % Reasoning:        
         [3,4,5,6],    % 2) the only one with 6 after speaker F -> 1
         [3,4],   % 5) 3 or 4
         [2,3,4,5],    % 3) only with 5 after F -> 1 and A -> 6
         [2,3,4],      % 4) only with 2 after C -> 5 and F -> 1 
         [3,4],   % 5) 3 or 4
         [1,2,3,4,5,6] % 1) the only with 1
       ],

   L = findall(X,$schedule_speakers(N,Available,X)),
   foreach(S in L) writeln(S) end,
   nl.


schedule_speakers(N,Available,Xs) =>

   % the alotted speaker slot
   Xs = new_list(N),
   Xs :: 1..N,

   all_different(Xs),

   foreach({X,A} in zip(Xs,Available))  member(X,A) end,

   solve([], Xs).
/* 

  Schur numbers Picat.

  http://dominia.org/~damancha/part.html
  """
  1. A set S is said to be "sum-free" if there exist no three (not necessarilly 
     distinct) elements a,b,c in S where a+b=c

  2. A set S is said to be "weakly sum-free" if there exist no three distinct 
     elements of S a,b,c such that a+b=c

  3. Schur number s(n) is the maximum m, such that [1,m] can be partitioned into 
     n sum-free subsets (The known schur numbers are s(1)=1, s(2)=4, s(3)=13, s(4)=44) 
     known bounds for the 5th schur are 160<=s(5)<=315.
  """

  Also, see http://mathworld.wolfram.com/SchurNumber.html

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


% Testing n=4. Schur number is 44
go =>
   test_schur(4,50,4),
   nl.

% Testing n=5. Schur number is >= 160, <= 315
go2 =>
   foreach(Timeout in 10..10..1000)
       test_schur(5,160,315,Timeout)
   end,
   nl.


test_schur(N, Upper, Timeout) =>
   test_schur(N, 2, Upper, Timeout).

test_schur(N, Lower, Upper, Timeout) =>

   NBoxes = N,
   NBalls :: Lower..Upper,
   indomain(NBalls),

   println([boxes=NBoxes,balls=NBalls,timeout=Timeout]),

   time_out(once(schur(NBalls,NBoxes, X)),Timeout*1000, Status),

   if Status == success then
        print_boxes(X),
        fail
   else
        println(timeout)
   end,
   nl.



schur(NBalls,NBoxes,X) =>

    X = new_list(NBalls),
    X :: 1..NBoxes,
    
    foreach(I in 1..NBalls, J in 1..NBalls, K in 1..NBalls)
        if I+J==K then
           X[I] #!= X[J] #\/ X[J] #!= X[K]        
        end
    end,

    % symmetry breaking
    foreach(I in 1..min(NBoxes,NBalls)) 
       X[I] #=< I
    end,
  
    solve([ff,split], X).


print_boxes(X) => 
   println(x=X),
   foreach(Box in 1..max(X)) 
      printf("Box %2d: ", Box),
      foreach(Ball in 1..X.length)
         if X[Ball] == Box then
           printf("%3d ", Ball)
         end
      end,
      nl
   end,
   nl.
/*

  Secret Santa problem II in Picat.

  From Maple Primes: "Secret Santa Graph Theory"
  http://www.mapleprimes.com/blog/jpmay/secretsantagraphtheory
  """
  Every year my extended family does a "secret santa" gift exchange. 
  Each person draws another person at random and then gets a gift for 
  them. At first, none of my siblings were married, and so the draw was 
  completely random. Then, as people got married, we added the restriction 
  that spouses should not draw each others names. This restriction meant 
  that we moved from using slips of paper on a hat to using a simple 
  computer program to choose names. Then people began to complain when 
  they would get the same person two years in a row, so the program was 
  modified to keep some history and avoid giving anyone a name in their 
  recent history. This year, not everyone was participating, and so after 
  removing names, and limiting the number of exclusions to four per person, 
  I had data something like this:
  
  Name: Spouse, Recent Picks
  
  Noah: Ava. Ella, Evan, Ryan, John
  Ava: Noah, Evan, Mia, John, Ryan
  Ryan: Mia, Ella, Ava, Lily, Evan
  Mia: Ryan, Ava, Ella, Lily, Evan
  Ella: John, Lily, Evan, Mia, Ava
  John: Ella, Noah, Lily, Ryan, Ava
  Lily: Evan, John, Mia, Ava, Ella
  Evan: Lily, Mia, John, Ryan, Noah
  """
  
  Note: I interpret this as the following three constraints:
    1) One cannot be a Secret Santa of one's spouse
    2) One cannot be a Secret Santa for somebody two years in a row
    3) Optimization: maximize the time since the last time 

  This model also handle single persons, something the original
  problem don't mention.
  

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   % N = 8, % Without Single person
   N = 9, % With a Single person
   Noah = 1,
   Ava  = 2,
   Ryan = 3,
   Mia  = 4,
   Ella = 5,
   John = 6,
   Lily = 7,
   Evan = 8,
   _Single = 9,

   Spouses = 
   [
         Ava,  % Noa
         Noah, % Ava
         Mia,  % Rya
         Ryan, % Mia
         John, % Ella
         Ella, % John
         Evan, % Lily
         Lily  % Evan
         , 0   % Single has no spouse
   ], 

   M = N+1, % "large M" to indicate no earlier history

   %
   % The matrix version of earlier rounds.
   % M means that no earlier Santa.
   % Note: Ryan and Mia has the same recipient for years 3 and 4,
   %       and Ella and John has for year 4. 
   %       This seems to be caused by modification of 
   %       original data.
   %
   %
   % rounds with a single person (fake data)
   %
   Rounds =
   [
   %N  A  R  M  El J  L  Ev S
    [0, M, 3, M, 1, 4, M, 2, 2], % Noah
    [M, 0, 4, 2, M, 3, M, 1, 1], % Ava 
    [M, 2, 0, M, 1, M, 3, 4, 4], % Ryan
    [M, 1, M, 0, 2, M, 3, 4, 3], % Mia 
    [M, 4, M, 3, 0, M, 1, 2, M], % Ella
    [1, 4, 3, M, M, 0, 2, M, M], % John
    [M, 3, M, 2, 4, 1, 0, M, M], % Lily
    [4, M, 3, 1, M, 2, M, 0, M], % Evan
    [1, 2, 3, 4, M, 2, M, M, 0]  % Single
   ],


   % decision variables
   Santas = new_list(N),
   Santas :: 1..N,
   Santas2 = new_list(N),
   Santas :: 1..N,
   SantaDistance = new_list(N),
   SantaDistance :: 1..N+1,
   Z :: 0..1000, % total distance (to minimize)

   % constraints

   % Everyone gives and receives a Secret Santa
   all_different(Santas),

   % no Santa for a spouses
   foreach(I in 1..N) 
      Santas[I] #!= I,
      if Spouses[I] > 0 then
         Santas[I] #!= Spouses[I]
      end
   end,

   % optimize "distance" to earlier rounds:
   foreach(I in 1..N) 
      % SantaDistance[I] #= Rounds[I,Santas[I]]
      matrix_element(Rounds,I,Santas[I],SantaDistance[I])
   end,

   % Cannot be a Secret Santa for the same person two years in a row.
   foreach(I in 1..N) 
       % Rounds[I,Santas2[I]] #= 1,
       matrix_element(Rounds,I,Santas2[I],1),
       Santas[I] #!= Santas2[I]
   end,

   Z #= sum([SantaDistance[I] : I in 1..N]),

   solve($[split,max(Z)], Santas ++ Santas2),

   writeln(z=Z),
   writeln(santas=Santas),
   writeln(santas2=Santas2),
   writeln(santaDistance=SantaDistance),
   nl.

% matrix_element(X, I, J, Val) =>
%    Row = X[I],
%    element(J,Row,Val).

% matrix_element(X, I, J, Val) =>
%    freeze(I, (element(I, X, Row),freeze(J,element(J,Row,Val)))).
/*

  Secret Santa problem in Picat.

  From Ruby Quiz Secret Santa
  http://www.rubyquiz.com/quiz2.html
  """
  Honoring a long standing tradition started by my wife's dad, my friends 
  all play a Secret Santa game around Christmas time. We draw names and 
  spend a week sneaking that person gifts and clues to our identity. On the 
  last night of the game, we get together, have dinner, share stories, and, 
  most importantly, try to guess who our Secret Santa was. It's a crazily 
  fun way to enjoy each other's company during the holidays.
  
  To choose Santas, we use to draw names out of a hat. This system was 
  tedious, prone to many "Wait, I got myself..." problems. This year, we 
  made a change to the rules that further complicated picking and we knew 
  the hat draw would not stand up to the challenge. Naturally, to solve 
  this problem, I scripted the process. Since that turned out to be more 
  interesting than I had expected, I decided to share.
  
  This weeks Ruby Quiz is to implement a Secret Santa selection script.
  
  Your script will be fed a list of names on STDIN. 
  ...
  Your script should then choose a Secret Santa for every name in the list. 
  Obviously, a person cannot be their own Secret Santa. In addition, my friends 
  no longer allow people in the same family to be Santas for each other and your 
  script should take this into account.
  """

  Comment: Well, this model skips the file input and mail parts. We 
           assume that the friends are identified with a number from 1..n,
           and the families is identified with a number 1..num_families. 


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   % Ruby Quiz example
   % Family = [1,1,2,2, 3, 4,4],
   Family = [1,1,1,1, 2, 3,3,3,3,3, 4,4],
   N = length(Family),

   X = new_list(N),
   X :: 1..N,

   % Everyone gives and receives a Secret Santa
   all_different(X),

   % Can't be one own's Secret Santa
   foreach(I in 1..N) X[I] #!= I end,
   
   % No Secret Santa to a person in the same family
   foreach(I in 1..N)
      element(I,X,XI),
      element(XI,Family,FXI),
      Family[I] #!= FXI
   end,

   solve(X),

   writeln(X),
   foreach(I in 1..N)
      printf("Person %2d (family %d) is a Secret Santa of %2d (family %d)\n", 
             I,Family[I],X[I], Family[X[I]])
   end,
   nl.
/*

  SEND+MORE=MONEY in Picat.

  Solve the alphametic problem 
    SEND+MORE=MONEY
  using distinct digits for the letters.

  sendmore and sendmore2 are using base 10, and sendmore_base
  use "any" base.

  Also some non-CP variants.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 0.02s
go =>
  time2(sendmore(Digits)),
  println(Digits).

% 0.02s 
go2 => 
  sendmore2(Digits),
  println(Digits).

% 0.02s
go3 =>
  Base = 10,
  sendmore_base(Digits, Base),
  println(Digits).

%
% Check the number of solutions for different bases.
% 0.024s
go4 =>
  Lens = [],
  foreach(Base in 2..30)
    printf("Base: %d\n", Base),
    All = findall(Digits, sendmore_base(Digits, Base)),
    Len = length(All),
    Lens := Lens ++ [Len]
  end,
  printf("All lengths: %w\n", Lens).

% 0.02s
go5 => 
  sendmore_carry(_Digits,_Carry),
  nl.

% 0.45s
go6 => 
  sendmore_no_cp1(Digits),
  println(Digits),
  nl.

% 0.7s
go6b => 
  sendmore_no_cp1b(Digits),
  println(Digits),
  nl.


% 1.2s
go7 => 
  sendmore_no_cp2(Digits),
  println(Digits),
  nl.

% 4.5s
go8 => 
  sendmore_no_cp3(Digits),
  println(Digits),
  nl.

% 1.1s
go9 => 
  sendmore_no_cp4(Digits),
  println(Digits),
  nl.


scalar_product(A, X,Product)  => 
  Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).


%
% Standard problem (in base 10)
%
sendmore(Digits) =>

  Digits = [S,E,N,D,M,O,R,Y],
  Digits :: 0..9,

  % all_different(Digits),
  all_distinct(Digits),
  S #> 0,
  M #> 0,
         1000*S + 100*E + 10*N + D
  +      1000*M + 100*O + 10*R + E
  #= 10000*M + 1000*O + 100*N + 10*E + Y,
  
  println([s=S,e=E,n=N,d=D,m=M,o=O,r=R,y=Y]),
  println([s=S.fd_dom(),e=E.fd_dom(),n=N.fd_dom(),d=D.fd_dom(),m=M.fd_dom(),o=O.fd_dom(),r=R.fd_dom(),y=Y.fd_dom()]),
  % println(1000*S + 100*E + 10*N + D
  %  +      1000*M + 100*O + 10*R + E
  % #= 10000*M + 1000*O + 100*N + 10*E + Y),

  solve([ffd],Digits).


%
% Using scalar_product
%
sendmore2(Digits) =>

  Digits = [S,E,N,D,M,O,R,Y],
  Digits :: 0..9,

  all_different(Digits),

  S #> 0,
  M #> 0,

  Base4 = [1000,100,10,1],
  Base5 = [10000,1000,100,10,1],
  scalar_product(Base4, [S,E,N,D], SEND),
  scalar_product(Base4, [M,O,R,E], MORE),
  scalar_product(Base5, [M,O,N,E,Y], MONEY),
  SEND + MORE #= MONEY,
  println([s=S,e=E,n=N,d=D,m=M,o=O,r=R,y=Y]),

  solve(Digits).


%
% Solve the SEND + MORE = MONEY problem in base Base
%
sendmore_base(Digits, Base) =>

  Digits = [S,E,N,D,M,O,R,Y],
  Base2 = Base - 1,
  Digits :: 0..Base2,

  all_different(Digits),
  S #> 0,
  M #> 0,
           Base**3*S + Base**2*E + Base*N + D
  +        Base**3*M + Base**2*O + Base*R + E
  #= Base**4*M + Base**3*O + Base**2*N + Base*E + Y,
  println([s=S,e=E,n=N,d=D,m=M,o=O,r=R,y=Y]),
  
  solve(Digits).


%
% With carry
%
%   C4 C3 C2 C1
%       S  E  N  D
%  +    M  O  R  E
%  ---------------
%  = M  O  N  E  Y
% 

sendmore_carry(Digits, Carry) =>
  Digits = [S,E,N,D,M,O,R,Y],
  Digits :: 0..9,

  Carry = [C1,C2,C3,C4],
  Carry :: 0..1,

  all_different(Digits),

  S #> 0,
  M #> 0,
  
  C4 #= M,
  C3 + S + M #= O + 10 * C4,
  C2 + E + O #= N + 10 * C3,
  C1 + N + R #= E + 10 * C2,
  D + E #= Y + 10 * C1,

  println(digits=Digits), % inferred domains before search
  println(carry=Carry),

  solve([], Digits ++ Carry),
  println(digits=Digits),
  println(carry=Carry),
  nl.


% without CP, using select: 0.44s
sendmore_no_cp1(Digits) =>
  Digits = [S,E,N,D,M,O,R,Y],
  SS = 0..9,
  % ensure that all numbers are different
  select(S,SS,Rest1),
  S != 0,
  select(E,Rest1,Rest2),
  select(N,Rest2,Rest3),
  select(D,Rest3,Rest4),
  select(M,Rest4,Rest5),
  M != 0,
  select(O,Rest5,Rest6),
  select(R,Rest6,Rest7),
  select(Y,Rest7,_Rest8),
  (S * 1000 + E * 100 + N * 10 + D) +
  (M * 1000 + O * 100 + R * 10 + E) == 
  (M * 10000 + O * 1000 + N * 100 + E * 10 + Y ).


% assign( Digits, Vars):  
% Assign chosen distinct digits from list Digits to variables in list Vars
assign(_,[])           => true.
assign(Digs,[D|Vars])  =>	
  select(D, Digs,Digs1),
  assign(Digs1,Vars).

% variant where the selects are moved to assign/2
sendmore_no_cp1b(Digits) =>
  Digits = [S,E,N,D,M,O,R,Y],
  assign([0,1,2,3,4,5,6,7,8,9],[S,E,N,D,M,O,R,Y]),
  S != 0,
  M != 0,
  (S * 1000 + E * 100 + N * 10 + D) +
  (M * 1000 + O * 100 + R * 10 + E) == 
  (M * 10000 + O * 1000 + N * 100 + E * 10 + Y ).
  
 
% without CP, permutation/2: 1.2s
sendmore_no_cp2(Digits2) =>
  Digits = [S,E,N,D,M,O,R,Y, A,B],
  permutation(0..9,Digits),
  A < B, % symmetry breaking of the two unused digits
  S > 0, M > 0,
  (S * 1000 + E * 100 + N * 10 + D) +
  (M * 1000 + O * 100 + R * 10 + E) == 
  (M * 10000 + O * 1000 + N * 100 + E * 10 + Y),
  Digits2 = [S,E,N,D,M,O,R,Y].
  
 
% without CP, permutations/1: 3.97s
sendmore_no_cp3(Digits) =>
  foreach([S,E,N,D,M,O,R,Y, A,B] in permutations(0..9))
    if S > 0, 
       M > 0, 
       A < B,
       (S * 1000 + E * 100 + N * 10 + D) +
       (M * 1000 + O * 100 + R * 10 + E) == 
       (M * 10000 + O * 1000 + N * 100 + E * 10 + Y) 
       then
       Digits = [S,E,N,D,M,O,R,Y]
    end
  end.


% without CP, ordset/1: 1.1s
sendmore_no_cp4(Digits) =>
  Digits = [S,E,N,D,M,O,R,Y],
  SS = new_ordset(0..9),
  member(S,subtract(SS,new_ordset([0]))), % > 0
  member(E,subtract(SS,new_ordset([S]))),
  member(N,subtract(SS,new_ordset([S,E]))),
  member(D,subtract(SS,new_ordset([S,E,N]))),
  member(M,subtract(SS,new_ordset([S,E,N,D, 0]))), % > 0
  member(O,subtract(SS,new_ordset([S,E,N,D,M]))),
  member(R,subtract(SS,new_ordset([S,E,N,D,M,O]))),
  member(Y,subtract(SS,new_ordset([S,E,N,D,M,O,R]))),
  (S * 1000 + E * 100 + N * 10 + D) +
  (M * 1000 + O * 100 + R * 10 + E) == 
  (M * 10000 + O * 1000 + N * 100 + E * 10 + Y ).

/*

  SEND+MOST=MONEY in Picat.

  Alphametic problem were we maximize MONEY.

  This version do two things:
    - find the maximum of MONEY
    - and then find all solutions for the maximum value of MONEY.

  Problem from the lecture notes:
  http://www.ict.kth.se/courses/ID2204/notes/L01.pdf

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
        %
        % first part: find the maximum value of MONEY
        %
        LD = new_list(8),
        LD :: 0..9,
        send_most_money(LD, MONEY),

        println("First, find maximum value of MONEY:"),
        solve([$max(MONEY)], LD),
        writeln([MONEY, LD]),

        %
        % second part: find all solutions for the maximum value of MONEY
        % 
        LD2 = new_list(8),
        LD2 :: 0..9,
        send_most_money(LD2, MONEY),
        AllSolutions = solve_all(LD2), 
 
        Len = length(AllSolutions),
        printf("\nHere are all (%d) solutions with MONEY = %d:\n", Len, MONEY),
        foreach(Solution in AllSolutions)  writeln(Solution) end.



send_most_money([S,E,N,D,M,O,T,Y], MONEY) =>

        all_different([S,E,N,D,M,O,T,Y]),
        S #> 0,
        M #> 0,
        MONEY #= 10000 * M + 1000 * O + 100 * N + 10 * E + Y,
        1000*S + 100*E + 10*N + D +
        1000*M + 100*O + 10*S + T #= MONEY.

/*

  Global constraint sequence in Picat.

  From the MiniZinc definition:
  """
  Requires that in each subsequence 'x[i], ..., x[i + l - 1]' the sum of the
  variables is between 'mn' and 'mx'.
      sequence(array[int] of var int: x, int: l, int: mn, int: mx)
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go ?=>

   N = 11,
   X = new_list(N),
   X :: 1..N,

   % Sum of X (just for show)
   Sum #= sum(X),

   % Length may be a decision varible,
   % but must be fixed
   Length :: 2..4,
   Length #= 3,

   N1 = N-1,
   LBound :: 1..N1, % lower bound
   UBound :: 1..N1, % upper bound    
   LBound #= UBound,
   % LBound #=< UBound,

   sequence(X,Length,LBound,UBound),

   Vars = X ++ [LBound, UBound, Length],

   solve([], Vars),
   
   writeln(x=X),
   writeln(sum=Sum),
   writeln(lower_bound=LBound),
   writeln(upper_bound=UBound),
   writeln(length=Length),
   nl,
   fail.

go => true.


%
% sequence(?X,+Length,?LBound,?UBound)
% 
% Ensures that all sums of every subsequence of length Length
% in array X is between LBound and UBound
% 
sequence(X,Length, LBound,UBound) =>
   foreach(I in 1..X.length-Length+1)
       Sum #= sum([X[J] : J in I..I+Length-1]),
       Sum #>= LBound,
       Sum #=< UBound
   end.


/*

  Seseman problem in Picat.

  Description of the problem:
  
  n is the length of a border
  There are (n-2)^2 "holes", i.e.
  there are n^2 - (n-2)^2 variables to find out.
 
  The simplest problem, n = 3 (n x n matrix)
  which is represented by the following matrix:
 
   a b c 
   d   e 
   f g h 
  
  Where the following constraints must hold:
 
    a + b + c = border_sum
    a + d + f = border_sum
    c + e + h = border_sum
    f + g + h = border_sum
    a + b + c + d + e + f = total_sum


  For a (Swedish) discussion of this problem, see
  "Sesemans matematiska klosterproblem samt lite Constraint Logic Programming"
  http://www.hakank.org/webblogg/archives/001084.html
  and
  Seseman's Convent Problem: http://www.hakank.org/seseman/seseman.cgi
  (using ECLiPSe CLP code)

  It was also is commented in the (Swedish) blog post
  "Constraint Programming: Minizinc, Gecode/flatzinc och ECLiPSe/minizinc"
  http://www.hakank.org/webblogg/archives/001209.html
  

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
        [Rowsum,Total,FirstNum] = [9,24,1],
        writeln([rowsum=Rowsum,total=total]),
        L = findall(S, seseman(Rowsum, Total, FirstNum, S)),
        foreach(X in L)  write_convent(X) end,
        Len = length(L),
        writeln(solutions=Len).

%
% Using symmetry breaking (seseman2).
%
go2 =>
        Rowsum = 9,
        Total = 24,
        FirstNum = 1,
        writeln([rowsum=Rowsum,total=Total]),
        L = findall(S, seseman2(Rowsum, Total, FirstNum, S)),
        foreach(X in L)  write_convent(X) end,
        Len = length(L),
        writeln(solutions=Len).


write_convent([A,B,C,D,E,F,G,H]) =>
        writef("%d %d %d\n", A,B,C),
        writef("%d _ %d\n", D,E),
        writef("%d %d %d\n", F,G,H),
        writef("\n").


% General constraints
constraints([A,B,C,D,E,F,G,H], Rowsum, Total) =>

        A+B+C #= Rowsum,
        A+D+F #= Rowsum,
        C+E+H #= Rowsum,
        F+G+H #= Rowsum,
        A+B+C+D+E+F+G+H #= Total.


%
% Plain problem (no symmetry breaking)
%
seseman(Rowsum, Total, FirstNum, LD) =>
        % LD = [A,B,C,D,E,F,G,H],
        LD = new_list(8),

        % FirstNum = 0: empty rooms allowed
        % FirstNum = 1: empty rooms not allowed
        LD :: FirstNum..9,

        constraints(LD, Rowsum, Total),

        solve(LD).



%
% With symmetry breaking
%
seseman2(Rowsum, Total, FirstNum, LD) =>

        LD = [A,B,_C,D,E,_F,G,H],

        % FirstNum = 0: empty rooms allowed
        % FirstNum = 1: empty rooms not allowed
        LD :: FirstNum..9,

        % Row sums/Column sums
        constraints(LD, Rowsum, Total),

        % additional constraints for uniqueness (rotation, mirror)
        A #=< H,
        B #=< D,
        D #=< E,
        E #=< G,

        solve(LD).


/*

  Set covering problem in Picat.

  Example 9.1-2, page 354ff, from Taha "Operations Research - An Introduction"
  Minimize the number of security telephones in street corners on a campus.

  AMPL model: http://taha.ineg.uark.edu/setcover.txt


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

%
% First find the optimal value (MinVal) i.e. the number of telephones
% placed. Then find all the solutions with that value.
%
go =>
        writef("Find the optimal solution:\n"),
        corners(N, Corners),
        set_covering2(N, Corners, MinVal, _X),

        writef("\nFinding all optimal solutions with MinVal %d:\n", MinVal),
        L = findall(X, $set_covering2(N, Corners, MinVal, X)),
        Len = length(L),
        writeln(L),
        writef("It was %d solutions\n", Len).


set_covering2(N, Corners, MinVal, X) =>
      
        % where to place the telephones
        X = new_list(N),
        X :: 0..1,
        
        % All streets must be covered
        foreach(I in 1..Corners.length) 
           X[Corners[I,1]] + X[Corners[I,2]] #>= 1
        end,


        % objective: minimize the number of telephones
        MinVal #= sum(X),

        % Either search for all solutions (with the minimum value) or
        % search for the optimal value.
        if ground(MinVal) then
            solve(X)
        else
            solve([$min(MinVal)], X)
        end,

        writeln(minVal=MinVal),
        writeln(x=X).


% corners of each street
%
% corners(NumberOfStreets, Corners)
%
corners(N, Corners) => 
        N = 8,
        Corners =
            {{1,2},
              {2,3},
              {4,5},
              {7,8},
              {6,7},
              {2,6},
              {1,6},
              {4,7},
              {2,4},
              {5,8},
              {3,5}}.

/*

  Set covering problem in Picat.

  Problem from 
  Katta G. Murty: "Optimization Models for Decision Making", page 302f
  http://ioe.engin.umich.edu/people/fac/books/murty/opti_model/junior-7.pdf
 
  10 senators making a committee, where there must at least be one 
  representative from each group:
  group:        senators:
  southern      1 2 3 4 5
  northern      6 7 8 9 10
  liberals      2 3 8 9 10
  conservative  1 5 6 7
  democrats     3 4 5 6 7 9
  republicans   1 2 8 10

  The objective is to minimize the number of senators.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

%
% First find the optimal value (MinVal), then find all the solutions with that value.
%
go =>

        writeln('Find the optimal solution'),
        belongs(Belongs),
        set_covering3(Belongs, MinVal,_),

        writef("\nFinding all optimal solutions with MinVal %d:\n", MinVal),
        L = findall(X, $set_covering3(Belongs,  MinVal,X)),
        Len = length(L),
        writef("It was %d solutions\n", Len).


set_covering3(Belongs, MinVal, X) =>

        % The dimensions of Belongs matrix
        NumGroups = Belongs.length,
        NumSenators = Belongs[1].length,

        % which senator to choose
        X = new_list(NumSenators),
        X :: 0..1,

        % cover all groups with the senators
        foreach(I in 1..NumGroups)
           sum([X[J]*Belongs[I,J]: J in 1..NumSenators]) #>= 1
        end,


        % objective: minimize the number of senators
        MinVal #= sum(X),

        % Either search for all solutions (for the minimum value) or
        % the optimal value.
        if ground(MinVal) then
          solve(X)
        else
          solve([$min(MinVal)], X)
        end,

        writeln(x=X),
        senators(SenatorNames),
        S = [],
        foreach(I in 1..NumSenators)
           if X[I] == 1 then
             S := S ++ [SenatorNames[I]] 
           end
        end,
        writef("These senators are selected: %w\n", S),
        writeln(minVal=MinVal).


%
% The Belong matrix:
%
% 1 if a senator belongs to the group, 
% 0 if senator don't belong to the group
%
belongs(Matrix) => 
  Matrix = {{1, 1, 1, 1, 1, 0, 0, 0, 0, 0},   % 1 southern
            {0, 0, 0, 0, 0, 1, 1, 1, 1, 1},   % 2 northern
            {0, 1, 1, 0, 0, 0, 0, 1, 1, 1},   % 3 liberals
            {1, 0, 0, 0, 1, 1, 1, 0, 0, 0},   % 4 conservative
            {0, 0, 1, 1, 1, 1, 1, 0, 1, 0},   % 5 democrats
            {1, 1, 0, 0, 0, 0, 0, 1, 0, 1}}.  % 6 republicans

senators(Senators) => 
    Senators = [a,b,c,d,e,f,g,h,i,j].

/*

  Set covering and set partition in Picat.

  Example from Lundgren, Ronnqvist, Varbrand "Optimeringslora", page 408.
  [This is a Swedish book about Operational Research.]
  
  We want to minimize the cost of the alternatives which covers all the 
  objects, i.e. all objects must be choosen. The requirement is than an object 
  may be selected _exactly_ once.
 
  Alternative        Cost        Object
  1                  19           1,6
  2                  16           2,6,8
  3                  18           1,4,7
  4                  13           2,3,5
  5                  15           2,5
  6                  19           2,3
  7                  15           2,3,4
  8                  17           4,5,8
  9                  16           3,6,8
  10                 15           1,6,7
 
  The problem has a unique solution of z = 49 where alternatives 
  3, 5, and 9 is selected. 
 
  If we, however, allow that an object is selected more than one time, 
  then the solution is z = 45 (i.e. less cost than the first problem),
  and the alternatives 4, 8, and 10 is selected, where object 5 is 
  selected twice (alt. 4 and 8). It's an unique solution as well.
 

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% plain scalar product
scalar_product(A, X, Product) => 
   Product #= sum([A[I]*X[I] : I in 1..A.length]).

% scalar product with relation
scalar_product(A, X, Rel, Product) => 
   scalar_product(A, X, P),
   call(Rel,P,Product).


%
% First find the optimal value (MinVal), then find all the solutions with that value.
% Note: This handles both set partition and set covering.
%
go =>

        %
        % set partition
        %
        writef("\nSET PARTITION\n"),
        writef("Find the optimal solution\n"),
        problem(Costs,Alternatives),

        set_covering4(Costs, Alternatives, set_partition, MinVal, _),

        writef("\nFinding all optimal solutions with MinVal %d:\n", MinVal),
        L = findall(Assignments, 
                $set_covering4(Costs, Alternatives, set_partition,MinVal,Assignments)),
        Len = length(L),
        writeln(all_solutions=L),
        writef("It was %d solution(s) (Set partition)\n\n", Len),


        %
        % Set covering
        %
        writef("\nSET COVERING\n"),
        writef("Find the optimal solution\n"),

        set_covering4(Costs, Alternatives, set_covering, MinVal2, _),

        writef("\nFinding all optimal solutions with MinVal %d:\n", MinVal2),
        L2 = findall(Assignments2, 
                $set_covering4(Costs, Alternatives, set_covering,MinVal2,Assignments2)),
        Len2 = length(L2),
        writeln(all_solutions=L2),
        writef("It was %d solution(s) (Set covering)\n\n", Len2).



set_covering4(Costs, Alternatives, Type, MinVal, Assignments) =>

        % get the dimensions
        NumAlternatives = Costs.length,
        NumObjects = Alternatives[1].length,

        % decision variable: which alternative to choose

        %
        % which alternative to choose
        %
        X = new_list(NumAlternatives),
        X :: 0..1,

        % 
        % cover all groups with the senators
        %
        foreach(J in 1..NumObjects)
             Sum #= sum([X[I]*Alternatives[I,J] : I in 1..NumAlternatives]),
             % which type? set partition or set covering?
             if Type = set_partition then
                % all objects must be covered _exactly_ once 
                % (set partition)
                Sum #= 1
             else 
                % variant: all objects must be covered _at least_ once
                % (set covering)
               Sum #>= 1
            end
        end,

        %
        % objective: minimize the number of senators
        %
        scalar_product(Costs,X,#=,MinVal),

        %
        % either search for all solutions (for the minimum value) or
        % the optimal value
        %
        if ground(MinVal) then
            solve(X)
        else
            solve([$min(MinVal)], X)
        end,

        Assignments1 = [],
        foreach(I in 1..NumAlternatives)
             if X[I] = 1 then
                Assignments1 := Assignments1 ++ [I]
             end
        end,
        Assignments = Assignments1,

        writeln(minVal=MinVal),
        writeln(x=X),
        writeln(assignements=Assignments),
        writef("\n").


%
% cost and alternatives
%
problem(Costs, Alternatives) => 
        Costs = {19, 16, 18, 13, 15, 19, 15, 17, 16, 15}, % costs
        Alternatives = 
          {{1,0,0,0,0,1,0,0},   % alternative 1    % alternatives 
           {0,1,0,0,0,1,0,1},   % alternative 2
           {1,0,0,1,0,0,1,0},   % alternative 3
           {0,1,1,0,1,0,0,0},   % alternative 4
           {0,1,0,0,1,0,0,0},   % alternative 5
           {0,1,1,0,0,0,0,0},   % alternative 6
           {0,1,1,1,0,0,0,0},   % alternative 7
           {0,0,0,1,1,0,0,1},   % alternative 8
           {0,0,1,0,0,1,0,1},   % alternative 9
           {1,0,0,0,0,1,1,0}}. % alternative 10
/*

  Set covering, scheduling in Picat.

  Example from the Swedish book 
  Lundgren, Ronnqvist, Varbrand "Optimeringslara", 
  ("Optimization theory"), page 410.
  
  Work schedule for a security company with three employees: Anders, Lotta, Per
  (common Swedish names).
 
  The tasks has different qualifications, and each person
  may give preferences to each task (each person has 10 points to spread).
 
  Task     Time (h)           Anders           Lotta            Per
                         Qualify, Points  Qualify, Points  Qualify, Points
   1             4         X        5      X         4       
   2             3         X        2                        X       2
   3             3         X        1      X         2       X       4
   4             3                         X         2       X       1
   5             3         X        1                        X       1
   6             2         X        1                        X       2
   7             2                         X         1
   8             2                         X         1
 
  Each person must work 7 or 8 hour per night.
 
  From the table above, 19 different combinations is construed, given at
  page 412. See the model below for the combinations.
 
  The problem is now to assign one combination to each person so
  that all tasks is covered exactly once, and maximizing the total
  preference points.
 
  The answer from the book, page 413: 
  The combination is 1 (Anders), 13 (Lotta), 18 (Per) with the following
  tasks:
    Anders: 1,2    Lotta: 4,7,8    Per: 3,5,6
 
  The total preference points is 18.

  
  Note: There is another solution with preference points 18:
  tasks 3, 13, 14
    Anders: 1,5  Lotta: 4,7,8   Per: 2,3,6


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   NumCombinations = 19,
   NumTasks = 8,
   NumPersons = 3,

   Persons = ["Anders","Lotta","Per"],

   % which combination belongs to which person
   % 1: Anders, 2: Lotta, 3: Per
   CombinationsPerson = [             
                % Anders, comb. 1..6
                1, 1, 1, 1, 1, 1,
             
                % Lotta, comb. 7..13
                2, 2, 2, 2, 2, 2, 2,
             
                % Per, comb., 14..19
                3, 3, 3, 3, 3, 3
              ],

   % preference point per tasks
   Preferences = [ % 1 2 3 4 5 6 7 8
           [5,2,1,0,1,1,0,0], % Anders
           [4,0,2,2,0,0,1,1], % Lotta
           [0,2,4,1,1,2,0,0] % Per
            ],

   % the combinations and the tasks they contain (set representation)
   Comb = [
      % Anders
      [1,2],   % 1
      [1,3],   % 2
      [1,5],   % 3
      [2,3,6], % 4
      [2,5,6], % 5
      [3,5,6], % 6 
      
      % Lotta
      [1,3],   % 7
      [1,4],   % 8
      [1,7,8], % 9
      [3,4,7], % 10
      [3,4,8], % 11
      [3,7,8], % 12
      [4,7,8], % 13
      
      % Per
      [2,3,6], % 14
      [2,4,6], % 15
      [2,5,6], % 16
      [3,4,6], % 17
      [3,5,6], % 18 
      [4,5,6]  % 19
       ],


   % decision variables
   X = new_list(NumCombinations),
   X :: 0..1,

   PreferencePoints = new_list(NumPersons),
   PreferencePoints :: 1..10,
   SumPrefPoints #= sum(PreferencePoints),

   % constraints

   % choose one combination for each person
   foreach(P in 1..NumPersons)
      sum([(X[J]) : J in 1..NumCombinations, CombinationsPerson[J] == P]) #= 1,

      % preference points for the person
      PreferencePoints[P] #=  
            sum([(X[I]*Preferences[P,J]) : 
                       I in 1..NumCombinations, 
                       J in 1..NumTasks,
                       CombinationsPerson[I] == P,
                       J.in2(Comb[I])])
   end,
   % all tasks must be covered exactly once
   foreach(J in 1..NumTasks)
      % sum([(X[I]) : I in 1..NumCombinations, J.in2(Comb[I])]) #= 1 % this work
      sum([(X[I]) : I in 1..NumCombinations, member(J,Comb[I])]) #= 1 % this work as well
   end,

   Vars = X ++ PreferencePoints,
   % satisfy the employee's preferences as much as possible
   solve([$max(SumPrefPoints)], Vars),

   % solve(Vars),

   writeln(x=X),
   writeln(preferencePoints=PreferencePoints),
   writeln(sumPreferencePoints=SumPrefPoints),
   println("Selected combinations"),
   foreach(I in 1..NumCombinations)
       if X[I] #= 1 then
         CPI = CombinationsPerson[I],
         P = Persons[CPI],
         C = Comb[I],
         printf("Combination %d: %w Tasks: %w\n", I,P,C)
       end
   end,

   nl.
   % nl, fail.

% To be able to use in/2 as conditional in a list comprehension. 
in2(E, List) => member(E,List)./*

  Set covering deployment in Picat.

  From http://mathworld.wolfram.com/SetCoveringDeployment.html
  """
  Set covering deployment (sometimes written "set-covering deployment"
  and abbreviated SCDP for "set covering deployment problem") seeks 
  an optimal stationing of troops in a set of regions so that a 
  relatively small number of troop units can control a large 
  geographic region. ReVelle and Rosing (2000) first described 
  this in a study of Emperor Constantine the Great's mobile field 
  army placements to secure the Roman Empire.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% First find the optimal value (MinVal), 
% then find all the solutions with that value.
go =>
   
   printf("\nFind the optimal solution\n"),
   problem(Matrix),
   armies(Armies),
   println(armies=Armies),
   set_covering_deployment(Matrix, Armies, MinVal,_),

   writef("\nNow find all optimal solutions with MinVal %d:\n", MinVal),
   L = findall(Assignments, $set_covering_deployment(Matrix, Armies, MinVal, Assignments)), 
   Len = length(L),
   nl,
   printf("All solutions:\n"),
   foreach(Sol in L) println(Sol) end,
   printf("\nIt was %d solution(s)\n", Len).



set_covering_deployment(Matrix, Armies, MinVal, Assignments) =>

   % adjacency matrix of the cities, order N
   N = Matrix.length,

   % first army
   Xs = new_list(N),
   Xs :: 0..1,

   % second army
   Ys = new_list(N),
   Ys :: 0..1,

   %
   % Constraint 1: There is always an army in a city (+ maybe a backup)
   %          Or rather: Is there a backup, there must be an
   %          an army
   % 
   foreach({X,Y} in zip(Xs,Ys)) X #>= Y end,


   %
   % Constraint 2: There should always be an backup army near
   % every city
   %
   foreach({X,MatRow} in zip(Xs,Matrix))
      X + sum([Y*M : {M,Y} in zip(MatRow,Ys)]) #>= 1
   end,
   
   % objective: minimize the number of armies
   MinVal #= sum([X+Y : {X,Y} in zip(Xs,Ys)]),

   % either search for all solutions (for the minimum value) or
   % the optimal value
   Vars = Xs ++ Ys ++ [MinVal],

   if ground(MinVal) then
       solve(Vars)
   else
       solve([$min(MinVal)], Vars)
   end,
   

   % convert X and Y to nicer representation
   assignments(Xs,Ys,Armies,Assignments),

   println(minVal=MinVal),
   println(x=Xs),
   println(y=Ys),nl,
   println(assigments=Assignments),
   nl,nl.


assignments(Xs,Ys,Armies,Assignments) =>
   Len = length(Ys),
   Assignments = [(A=Num) : {X,Y,I} in zip(Xs, Ys,1..Len), 
                  Num #= X +Y, Num > 0, A = Armies[I]].


problem(Problem) => 
 Problem = 
   [[0, 1, 0, 1, 0, 0, 1, 1],
    [1, 0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 1, 0, 0],
    [1, 1, 0, 0, 0, 0, 1, 0],
    [0, 0, 1, 0, 0, 1, 1, 0],
    [0, 0, 1, 0, 1, 0, 1, 1],
    [1, 0, 0, 1, 1, 1, 0, 1],
    [1, 0, 0, 0, 0, 1, 1, 0]].

armies(Armies) => 
 Armies = ["Alexandria", "Asia Minor", "Britain", "Byzantium", "Gaul", "Iberia", "Rome", "Tunis"].
/*

  Set covering in Picat.

  Placing of firestations, from Winston "Operations Research", page 486

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   problem(1, MinDistance, Distance),

   writeln(min_distance=MinDistance),

   % distance between the cities
   NumCities = Distance.length,
   writeln(num_cities=NumCities),

   % where to place the fire stations: 1 if placed in this city.
   X = new_list(NumCities),
   X :: 0..1,

   % calculate the number of covered fire stations
   foreach(J in 1..NumCities)
      sum([X[I] : I in 1..NumCities, Distance[I,J] =< MinDistance]) #>= 1
   end,

   % objective: minimize the number of fire stations
   Z #= sum(X),

   solve([$min(Z)], X),
   writeln(z=Z),
   writeln(x=X).


%
% data
%

%
% Placing of firestations, from Winston "Operations Research", page 486
%
problem(1, MinDistance, Distance) =>
        MinDistance = 15, % minimum distance 
        Distance    = {{0,10,20,30,30,20},  % distances between the cities
                       {10,0,25,35,20,10},
                       {20,25,0,15,30,20},
                       {30,35,15,0,15,25},
                       {30,20,30,15,0,14},
                       {20,10,20,25,14,0}}.
/*

  Set covering in Picat.

  Example from Steven Skiena, The Stony Brook Algorithm Repository
  http://www.cs.sunysb.edu/~algorith/files/set-cover.shtml
  """
  Input Description: A set of subsets S_1, ..., S_m of the 
  universal set U = {1,...,n}.
  
  Problem: What is the smallest subset of subsets T subset S such 
  that \cup_{t_i in T} t_i = U?
  """
  Data is from the pictures INPUT/OUTPUT.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

%
% First find the optimal value (MinVal), then find all the solutions with that value.
%
go =>

   printf("Find the optimal solution"),
   belongs(Belongs),
   set_covering_skiena(Belongs, MinVal,_),

   printf("\nFinding all optimal solutions with MinVal %d:\n", MinVal),
   L = findall(X, $set_covering_skiena(Belongs,  MinVal,X)),
   Len = length(L),
   foreach(S in L) writeln(S) end,
   printf("It was %d solutions\n", Len),nl.

set_covering_skiena(Belongs, MinVal, X) =>

   NumSets = Belongs.length,

   X = new_list(NumSets),
   X :: 0..1,

   BelongsTransposed = transpose(Belongs),
   foreach(Belong in BelongsTransposed)
      sum([XX*(B#>0) : {B,XX} in zip(Belong,X)]) #>= 1 
   end,
   MinVal #= sum(X),

   % either search for all solutions (for the minimum value) or
   % the optimal value
   if ground(MinVal) then
       solve([],X)
   else
       solve([$min(MinVal)], X)
   end.


%
% The belong matrix:
%
belongs(Belongs) => 
  Belongs = 
   [[1,1,0,0,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,1,0,0,0,0],
    [0,0,0,0,1,1,0,0,0,0,0,0],
    [0,0,0,0,0,1,1,0,0,1,1,0],
    [0,0,0,0,0,0,0,0,1,1,0,0],
    [1,1,1,0,1,0,0,0,1,1,1,0],
    [0,0,1,1,0,0,1,1,0,0,1,1]].
/* 

  Some set predicates in Picat.

  Port of the B-Prolog code
  http://www.sci.brooklyn.cuny.edu/~zhou/teaching/cis2210/set.pl
  """
  by Neng-Fa Zhou, January 2012
  These predicates in B-Prolog (www.probp.com) implement the set operations 
  covered in my Discrete Structures class. As the students are not yet familiar 
  with recursion, no recursion is used except for power/2. 
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

test =>
    A = [X : X in 0..11],
    B = [X : X in 0..18, X mod 2 == 0],
    write('A='),writeln(A),
    write('B='),writeln(B),
    AuB=union(A,B), writeln($union(AuB)),
    AiB=intersection(A,B), writeln($intersection(AiB)),
    AmB=difference(A,B),writeln($difference(AmB)),
    AxB=xorx(A,B),writeln($xorx(AxB)),

    C = [1,2,3,4],
    D = [4,5,6],
    Power=power(C),writeln($power(Power)),
    Product=product(C,D),writeln($product(Product)),

    E = [2,3],
    if subset(E,C) then printf("%w is a subset of %w\n", E,C) end,

    nl.

% test if A is a subset of B
subset(A,B)=>
    foreach(X in A) member(X,B) end.

% test if A is a proper subset of B
proper_subset(A,B)=>
    subset(A,B),
    member(X,B), 
    not member(X,A).

% test if sets A and B are equal
equal(A,B)=>
    subset(A,B),
    subset(B,A).

% C is the union of A and B
union(A,B) = C =>
    append(A,B,AB),
    C=sort(AB).remove_dups().   % eliminate duplicates

% C is the intersection of A and B
intersection(A,B) = C =>
    C = [X : X in A, member(X,B)].

% C is the relative complement of A w.r.t. B (A-B)
difference(A,B) = C =>
    C = [X : X in A, not member(X,B)].

% C is the exclusive or of A and B.
xorx(A,B) = C =>
    C = [X : X in A, not member(X,B)] ++ [X : X in B, not member(X,A)].

% P is the product of A and B
product(A,B) = P =>
    P = [(X,Y) : X in A, Y in B].

% P is the power set of A
power([]) = P => P = [[]].
power([H|T]) = P =>
    P1 = power(T),
    P2 = [[H|S] : S in P1],
    append(P1,P2,P).
/*

  Sicherman Dice in Picat.

  From http://en.wikipedia.org/wiki/Sicherman_dice
  """ 
  Sicherman dice are the only pair of 6-sided dice which are not normal dice, 
  bear only positive integers, and have the same probability distribution for 
  the sum as normal dice.
  
  The faces on the dice are numbered 1, 2, 2, 3, 3, 4 and 1, 3, 4, 5, 6, 8.
  """

  I read about this problem in a book/column by Martin Gardner long
  time ago, and got inspired to model it now by the WolframBlog post
  "Sicherman Dice": http://blog.wolfram.com/2010/07/13/sicherman-dice/

  This model gets the two different ways, first the standard way and
  then the Sicherman dice:
  
  x1 = array1d(1..6, [1, 2, 3, 4, 5, 6]);
  x2 = array1d(1..6, [1, 2, 3, 4, 5, 6]);
  ----------
  x1 = array1d(1..6, [1, 2, 2, 3, 3, 4]);
  x2 = array1d(1..6, [1, 3, 4, 5, 6, 8]);


  Extra: If we also allow 0 (zero) as a valid value then the 
  following two solutions are also valid:
  
  x1 = array1d(1..6, [0, 1, 1, 2, 2, 3]);
  x2 = array1d(1..6, [2, 4, 5, 6, 7, 9]);
  ----------
  x1 = array1d(1..6, [0, 1, 2, 3, 4, 5]);
  x2 = array1d(1..6, [2, 3, 4, 5, 6, 7]);
  
  These two extra cases are mentioned here:
  http://mathworld.wolfram.com/SichermanDice.html


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   _ = findall(_, $sicherman_dice(_X1a,_X2a,1)),
   _ = findall(_, $sicherman_dice(_X1b,_X2b,0)).
      

sicherman_dice(X1,X2, Min) =>
   printf("\nMin: %d\n", Min),

   N = 6,  % number of dice
   M = 10, % max value of each side
   % standard distribution of 2 pair of dice
   StandardDist = [1,2,3,4,5,6,5,4,3,2,1],


   X1 = new_list(N),
   X2 = new_list(N),
   X1 :: Min..M,
   X2 :: Min..M,

   % ensure standard distributions of the sums
   foreach(K in 1..10)
      StandardDist[K] #= sum([(X1[I]+X2[J] #= K+1) : I in 1..N, J in 1..N]) 
   end,

   % Symmetry breaking
   increasing(X1),
   increasing(X2),

   % x1 is less <= to x2
   foreach(I in 1..N) X1[I] #=< X2[I] end,


   Vars = X1 ++ X2,
   solve([ffd,split], Vars),

   writeln(X1),
   writeln(X2),
   nl.
   

increasing(List) =>
   foreach(I in 2..List.length) List[I-1] #=< List[I] end.

/*

  Sierpinski triangle in Picat.

  From
  http://rosettacode.org/wiki/Sierpinski_triangle
  """
  Produce an ASCII representation of a Sierpinski triangle of order N. 
  For example, the Sierpinski triangle of order 4 should look like this:

                       *
                      * *
                     *   *
                    * * * *
                   *       *
                  * *     * *
                 *   *   *   *
                * * * * * * * *
               *               *
              * *             * *
             *   *           *   *
            * * * *         * * * *
           *       *       *       *
          * *     * *     * *     * *
         *   *   *   *   *   *   *   *
        * * * * * * * * * * * * * * * *
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
   foreach(N in 1..5)
      sierpinski(N)
   end,

   nl.


% Inspired the E solution
sierpinski(N)  =>
    Size = 2**N,
    foreach(Y in Size-1..-1..0)
       printf("%s", [' ' : _I in 1..Y]),
       foreach(X in 0..Size-Y-1)
          printf("%s ", cond(X /\ Y == 0, "*", " ")) 
       end,
       nl
    end.

/*

  Ski assignment in Picat.

  From  
  Jeffrey Lee Hellrung, Jr.: PIC 60, Fall 2008, Final Review, December 12, 2008
  http://www.math.ucla.edu/~jhellrun/course_files/Fall%25202008/PIC%252060%2520-%2520Data%2520Structures%2520and%2520Algorithms/final_review.pdf
  """
  5. Ski Optimization! Your job at Snapple is pleasant but in the winter you've 
  decided to become a ski bum. You've hooked up with the Mount Baldy Ski Resort. 
  They'll let you ski all winter for free in exchange for helping their ski rental 
  shop with an algorithm to assign skis to skiers. Ideally, each skier should 
  obtain a pair of skis whose height matches his or her own height exactly. 
  Unfortunately, this is generally not possible. We define the disparity between 
  a skier and his or her skis to be the absolute value of the difference between 
  the height of the skier and the pair of skis. Our objective is to find an 
  assignment of skis to skiers that minimizes the sum of the disparities. 
  ...
  Illustrate your algorithm by explicitly filling out the A[i, j] table for the 
  following sample data:
    * Ski heights: 1, 2, 5, 7, 13, 21.
    * Skier heights: 3, 4, 7, 11, 18.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   SkiHeights   = [1, 2, 5, 7, 13, 21],
   SkierHeights = [3, 4, 7, 11, 18],
   
   NumSkis = length(SkiHeights),
   NumSkiers = length(SkierHeights),

   % descision variables
   X = new_list(NumSkiers), 
   X :: 1..NumSkis,
   all_different(X),

   % minimize the differences of ski height and skier's height (Z)
   % Z :: 0..10,
   % We must use element here...
   Z #= sum([abs(SXI - SkierHeights[I]) : I in 1..NumSkiers, 
               XI = X[I], element(XI,SkiHeights,SXI)]),

   solve([$min(Z)],X),

   writeln(x=X),
   writeln(z=Z).
/*

  Global constraint sliding sum in Picat.

  From Global Constraint Catalog
  http://www.emn.fr/x-info/sdemasse/gccat/Csliding_sum.html
  """
  sliding_sum(LOW, UP, SEQ, VARIABLES)
  
  Purpose
 
  Constrains all sequences of SEQ consecutive variables of the collection 
  VARIABLES so that the sum of the variables belongs to interval [LOW, UP].
 
  Example
      (
      3, 7, 4,<1, 4, 2, 0, 0, 3, 4>
      )
 
  The example considers all sliding sequences of SEQ=4 consecutive values of 
  <1, 4, 2, 0,0,3, 4> collection and constraints the sum to be in 
  [LOW,UP] = [3, 7]. The sliding_sum constraint holds since the sum associated 
  with the corresponding subsequences 1 4 2 0, 4 2 0 0, 2 0 0 3, and 
  0 0 3 4 are respectively 7, 6, 5 and 7.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go ?=>

   N = 7,
   Variables = new_list(N),
   Variables :: 0..4,

   Low :: 0..10,
   Up :: 0..10,

   Seq :: 1..N,
   Seq #= 4,

   % test data:
   % Variables = [1,4,2,0,0,3,3],
   Low #= 3,
   Up #= 7,

   sliding_sum(Low, Up, Seq, Variables),

   Vars = Variables ++ [Low,Up,Seq],
   solve([],Vars),

   writeln(variables=Variables),
   fail.

go => true.

%
% Note: Seq must be instantiated, but neither Low or Up has
% to be (the result may be weird unless they are, though).
%
sliding_sum(Low, Up, Seq, Variables) =>
   foreach(I in 1..Variables.length-Seq+1)
      Sum #= sum([Variables[J] : J in I..I+Seq-1]),
      Sum #>= Low,
      Sum #=< Up
   end.


/*

  Social golfer problem in Picat.

  CSPLib problem 10:
  http://www.csplib.org/prob/prob010/index.html
  """
  The coordinator of a local golf club has come to you with the following 
  problem. In her club, there are 32 social golfers, each of whom play golf 
  once a week, and always in groups of 4. She would like you to come up 
  with a schedule of play for these golfers, to last as many weeks as 
  possible, such that no golfer plays in the same group as any other golfer 
  on more than one occasion.

  Possible variants of the above problem include: finding a 10-week schedule 
  with ``maximum socialisation''; that is, as few repeated pairs as possible 
  (this has the same solutions as the original problem if it is possible 
  to have no repeated pairs), and finding a schedule of minimum length 
  such that each golfer plays with every other golfer at least once 
  (``full socialisation'').

  The problem can easily be generalized to that of scheduling m groups of 
  n golfers over p weeks, such that no golfer plays in the same group as any 
  other golfer twice (i.e. maximum socialisation is achieved). 
  """

  This model is a translation of the OPL code from 
  http://www.dis.uniroma1.it/~tmancini/index.php?currItem=research.publications.webappendices.csplib2x.problemDetails&problemid=010


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   Weeks = 5,
   Groups = 7,
   GroupSize = 3,
   Golfers = Groups * GroupSize,

   Golfer = 1..Golfers,
   Week = 1..Weeks,
   Group = 1..Groups,
       

   % decision variables
   Assign = new_array(Golfers,Weeks),
   Assign :: 1..Groups,
      
   % C1: Each group has exactly groupSize players
   foreach(Gr in Group, W in Week)
       sum([(Assign[G,W] #= Gr) : G in Golfer]) #= GroupSize
   end,

   % C2: Each pair of players only meets at most once
   foreach(G1 in Golfer,G2 in Golfer, W1 in Week, W2 in Week)
      if G1 != G2, W1 != W2 then
           (Assign[G1,W1] #= Assign[G2,W1]) + 
           (Assign[G1,W2] #= Assign[G2,W2]) #=< 1
      end
   end,

   % SBSA: Symmetry-breaking by selective assignment
   % On the first week, the first groupSize golfers play in group 1, the 
   % second groupSize golfers play in group 2, etc. On the second week, 
   % golfer 1 plays in group 1, golfer 2 plays in group 2, etc.
   foreach(G in Golfer) Assign[G,1] #= ((G-1) // GroupSize) + 1 end,

   foreach(G in Golfer)
      if G =< GroupSize then Assign[G,2] #= G end
   end,

   solve([ff], Assign),

   foreach(Row in Assign) writeln(Row) end,
   nl.
/*

  Social golfer problem in Picat.

  CSPLib problem 10:
  http://www.csplib.org/prob/prob010/index.html
  """
  The coordinator of a local golf club has come to you with the following 
  problem. In her club, there are 32 social golfers, each of whom play golf 
  once a week, and always in groups of 4. She would like you to come up 
  with a schedule of play for these golfers, to last as many weeks as 
  possible, such that no golfer plays in the same group as any other golfer 
  on more than one occasion.

  Possible variants of the above problem include: finding a 10-week schedule 
  with ``maximum socialisation''; that is, as few repeated pairs as possible 
  (this has the same solutions as the original problem if it is possible 
  to have no repeated pairs), and finding a schedule of minimum length 
  such that each golfer plays with every other golfer at least once 
  (``full socialisation'').

  The problem can easily be generalized to that of scheduling m groups of 
  n golfers over p weeks, such that no golfer plays in the same group as any 
  other golfer twice (i.e. maximum socialisation is achieved). 
  """


  This model is a translation of the OPL code from 
  http://www.dis.uniroma1.it/~tmancini/index.php?currItem=research.publications.webappendices.csplib2x.problemDetails&problemid=010


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   Weeks = 5,
   Groups = 7,
   GroupSize = 3,
   Golfers = Groups * GroupSize,

   Golfer = 1..Golfers,
   Week = 1..Weeks,
   Group = 1..Groups,
       

   % decision variables
   Assign = new_array(Golfers,Weeks),
   Assign :: 1..Groups,
      
   % C1: Each group has exactly groupSize players
   foreach(Gr in Group, W in Week)
       sum([(Assign[G,W] #= Gr) : G in Golfer]) #= GroupSize
   end,

   % C2: Each pair of players only meets at most once
   foreach(G1 in Golfer,G2 in Golfer, W1 in Week, W2 in Week)
      if G1 != G2, W1 != W2 then
         (Assign[G1,W1] #= Assign[G2,W1]) + 
         (Assign[G1,W2] #= Assign[G2,W2]) #=< 1
      end
   end,


   solve([ff], Assign),

   foreach(Row in Assign) writeln(Row) end,
   nl.
/*

  SONET problem in Picat.

  From the ESSENCE' model in the Minion Translator examples:
  http://www.cs.st-andrews.ac.uk/~andrea/examples/sonet/sonet_problem.eprime
  """
  The SONET problem is a network design problem: set up a network between
  n nodes, where only certain nodes require a connection.
  Nodes are connected by putting them on a ring, where all nodes
  on a ring can communicate. Putting a node on a ring requires a so-called
  ADM, and each ring has a capacity of nodes, i.e. ADMs. There is a certain 
  amount of rings, r, that is available. The objective is to set up a network
  by using a minimal amount of ADMs.

  About the problem model

  The problem model has the amount of rings ('r'), amount of nodes('n'),
  the 'demand' (which nodes require communication) and node-capacity of each 
  ring ('capacity_nodes') as parameters.
  The assignement of nodes to rings is modelled by a 2-dimensional matrix 'rings',
  indexed by the amnount of rings and nodes. The matrix-domain is boolean:
  If the node in column j is assigned to the ring in row i, then rings[i,j] = 1 
  and 0 otherwise. So all the '1's in the matrix 'rings' stand for an ADM.
  Hence the objective is to minimise the sum over all columns and rows of matrix
  'rings'.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   R = 4,
   N = 5,
   Demand = [[0,1,0,1,0],
             [1,0,1,0,0],
             [0,1,0,0,1],
             [1,0,0,0,0],
             [0,0,1,0,0]],

   CapacityNodes = [3,2,2,1],

   % decision variables
   Rings = new_array(R,N).array_matrix_to_list_matrix(),
   Vars = vars(Rings),
   Vars :: 0..1,

   % to optimize

   Z #= sum([(Rings[Ring,Client]) : Ring in 1..R, Client in 1..N]),

   % if there is a demand between 2 nodes, then there has to exist 
   % a ring, on which they are both installed
   foreach(Client1 in 1..N, Client2 in Client1+1..N)
      if Demand[Client1,Client2] == 1 then
          matrix_element(Rings,Ring,Client1,R1),
          matrix_element(Rings,Ring,Client2,R2),
          R1 + R2 #>= 2
      end
   end,

   % capacity of each ring must not be exceeded     
   foreach(Ring in 1..R)
      sum([Rings[Ring,Client] : Client in 1..N]) #=< CapacityNodes[Ring] 
   end,

   % Z #= 7, % for showing all 6 optimal solutions

   solve([$min(Z)], Rings),
   % solve(Vars),

   writeln(z=Z),
   foreach(RR in Rings) writeln(RR) end,
   nl.
   
matrix_element(X, I, J, Val) =>
   nth(I, X, Row),
   element(J, Row, Val).


% matrix_element(X, I, J, Val) =>
%    freeze(I, (element(I, X, Row),freeze(J,element(J,Row,Val)))).

/*

  Soundex in Picat.

  See for example:
  * http://en.wikipedia.org/wiki/soundex
  * http://rosettacode.org/wiki/Soundex


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   % From J's test at http://rosettacode.org/wiki/Soundex#J
   % And O'Hara from the Forth test

   Names = split("Lloyd Woolcock Donnell Baragwanath Williams Ashcroft Euler Ellery Gauss Ghosh Hilbert Heilbronn Knuth Kant Ladd Lukasiewicz Lissajous O'Hara", " "),
  SoundexNames = split("L300 W422 D540 B625 W452 A226 E460 E460 G200 G200 H416 H416 K530 K530 L300 L222 L222 O600", " "),

   foreach({N,Correct} in zip(Names, SoundexNames)) 
    S = soundex(N, 4),
    println([N,soundex=S,correct=Correct]),
    if S != Correct then
      println("\tThat was wrong!\n")
    end
  end,
  nl.


% This was inspired by the Python code from  
%   http://code.activestate.com/recipes/52213/
% with the following comment:
% """
% soundex module conforming to Knuth's algorithm
% implementation 2000-12-24 by Gregory Jorgensen
% public domain
% """

soundex("", _) = "" => true.
soundex(Name, Len) = Soundex =>

  % digits holds the soundex values for the alphabet
  Digits = "01230120022455012623010202",
  Sndx = "",
  Fc   = "",

  % translate alpha chars in name to soundex digits
  foreach(C in Name.to_uppercase()) 
    if is_alpha(C) then
      if Fc == "" then
        Fc := C   % remember first letter
      end,
      D = Digits[ord(C)-64], 

      % duplicate consecutive soundex digits are skipped
      if Sndx.length == 0; D != Sndx[Sndx.length] then
        Sndx := Sndx ++ [D]
      end
    end
  end,

  % replace first digit with first alpha character
  if Sndx.length >= 2 then
    Sndx := [Fc] ++ [Sndx[J] : J in 2..Sndx.length]
  else 
    Sndx := Fc
  end,

  % remove all 0s from the soundex code
  Sndx := [S : S in Sndx, S != '0'],

  % return soundex code padded to len characters
  if Len > Sndx.length then
    Sndx := Sndx ++ rep('0', (Len - Sndx.length))
  end,
  Soundex := [Sndx[J] : J in 1..Len].

% for a single character
is_alpha(C), char(C) => member(C,"ABCDEFGHIJKLMNOPQRSTUVWXYZ").
% check the whole string
is_alpha(String), string(String) => 
   Alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
   foreach(C in String) member(C,Alpha) end.

% Repeat a string/character S N times.
rep(S, N) = [S : _I in 1..N].
/*

  Stable marriage problem in Picat.

  Problem and OPL model from Pascal Van Hentenryck
  "The OPL Optimization Programming Language", page 43ff.

  Also, see 
  http://www.comp.rgu.ac.uk/staff/ha/ZCSP/additional_problems/stable_marriage/stable_marriage.pdf

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   all_solutions(1),
   all_solutions(2),
   all_solutions(3),
   all_solutions(4),
   all_solutions(5),
   % one_solution(6),
   all_solutions(6).
   % one_solution(7).
   % one_solution(8).


go2 =>
   garbage_collect(200_000_000),
   % one_solution(7).
   all_solutions(7).

go3 =>
   garbage_collect(300_000_000),
   one_solution(8).



all_solutions(Problem) =>
   printf("\nProblem %d:\n", Problem),
   L = findall([Husband,Wife], 
      stable_marriage(Problem,Husband,Wife)),
   println(L),
   foreach([H,W] in L)
      printf("Husband: %w\n",H),
      printf("Wife   : %w\n",W),
      nl
   end.


one_solution(Problem) =>
   printf("\nProblem %d:\n", Problem),
   time2(stable_marriage(Problem,Husband,Wife)),
   printf("Husband: %w\n",Husband),
   printf("Wife   : %w\n",Wife),
   nl.



stable_marriage(Problem,Husband,Wife) =>

   problem(Problem, RankWomen,RankMen),

   NumMen = length(RankWomen),
   NumWomen = length(RankMen),

   Wife = new_list(NumMen),
   Wife :: 1..NumWomen,

   Husband = new_list(NumWomen),
   Husband :: 1..NumMen,

   assignment(Wife,Husband),
   
   all_distinct(Wife),
   all_distinct(Husband),
   % all_different(Wife),
   % all_different(Husband),

   foreach(M in 1..NumMen)
       %% Husband[Wife[M]] #= M
       % element(M,Wife,WifeM),
       % element(WifeM,Husband,HusbandWifeM),
       % HusbandWifeM #= M
       % This is faster
       element2(M,Wife,Husband)
   end,

   foreach(W in 1..NumWomen)
       %% Wife[Husband[W]] #= W
       % element(W,Husband,HusbandW),
       % element(HusbandW,Wife,WifeHusbandW),
       % WifeHusbandW #= W
       element2(W,Husband,Wife)
   end,

   foreach(M in 1..NumMen,O in 1..NumWomen)
       % (RankMen[M,O] #< RankMen[M, Wife[M]]) =>
       % (RankWomen[O,Husband[O]] #< RankWomen[O,M])
       matrix_element(RankMen,M,O,RankMenMO),
       element(M,Wife,WifeM),
       matrix_element(RankMen,M,WifeM,RankMenMWifeM),
       element(O,Husband,HusbandO),
       matrix_element(RankWomen,O,HusbandO,RankWomenOHusbandO),
       matrix_element(RankWomen,O,M,RankWomenOM),
       (RankMenMO #< RankMenMWifeM) #=> (RankWomenOHusbandO #< RankWomenOM)
    end,

   foreach(W in 1..NumWomen, O in 1..NumMen)
      % (RankWomen[W,O] #< RankWomen[W,Husband[W]]) =>
      % (RankMen[O,Wife[O]] #< RankMen[O,W])
      matrix_element(RankWomen,W,O,RankWomenWO),
      element(W,Husband,HusbandW),
      matrix_element(RankWomen,W,HusbandW,RankWomenWHusbandW),
      element(O,Wife,WifeO),
      matrix_element(RankMen,O,WifeO,RankMenOWifeO),
      matrix_element(RankMen,O,W,RankMenOW),
      (RankWomenWO #< RankWomenWHusbandW) #=> (RankMenOWifeO #< RankMenOW)
   end,


   Vars = Wife ++ Husband,
   println(searching),
   % solve([ffc,down],Vars).
   solve([ffd,split],Vars).


%
% handling
%   Husband[Wife[M]] #= M,
% i.e.
%   Y[X[I]] #= I
element2(I,X,Y) =>
   element(I,X,XI),
   element(XI,Y,XIY),
   XIY #= I.


%
% Original problem from Van Hentenryck
%
problem(1, W, M) =>
W = 
   [[1, 2, 4, 3, 5],  % rankWomen
    [3, 5, 1, 2, 4],
    [5, 4, 2, 1, 3],
    [1, 3, 5, 4, 2],
    [4, 2, 3, 5, 1]],
M =
   [[5, 1, 2, 4, 3],  % rankMen
    [4, 1, 3, 2, 5],
    [5, 3, 2, 4, 1],
    [1, 5, 4, 3, 2],
    [4, 3, 2, 1, 5]].




% Data from
% http://mathworld.wolfram.com/StableMarriageProblem.html
% """
% In the rankings illustrated above, the male-optimal stable 
% marriage is 
%     4, 2, 6, 5, 3, 1, 7, 9, 8, 
% and the female-optimal stable marriage is 
%     1, 2, 8, 9, 3, 4, 7, 6, 5. 
% A stable marriage can be found using StableMarriage[m, w] in the 
% Mathematica package Combinatorica` (which can be loaded with the 
% command <<Combinatorica`)
%
% 
% Note that the matrices given at the MathWorld page are transposed.
% 
% There are 6 solutions, though none is the solution given above:
%
% wife   : [6, 1, 4, 8, 5, 7, 3, 2, 9]
% husband: [2, 8, 7, 3, 5, 1, 6, 4, 9]
%
% wife   : [6, 1, 4, 8, 5, 9, 3, 2, 7]
% husband: [2, 8, 7, 3, 5, 1, 9, 4, 6]
%
% wife   : [6, 4, 1, 8, 5, 7, 3, 2, 9]
% husband: [3, 8, 7, 2, 5, 1, 6, 4, 9]
%
% wife   : [6, 4, 9, 8, 3, 7, 1, 5, 2]
% husband: [7, 9, 5, 2, 8, 1, 6, 4, 3]
%
% wife   : [6, 5, 9, 8, 3, 7, 1, 4, 2]
% husband: [7, 9, 5, 8, 2, 1, 6, 4, 3]
%
% wife   : [7, 5, 9, 8, 3, 6, 1, 4, 2]
% husband: [7, 9, 5, 8, 2, 6, 1, 4, 3]
%
%
% This is the transposed version from the MathWorld page
% 
problem(2, M, W) =>
M =
   % rankMen = 
   [[7, 3, 8, 9, 6, 4, 2, 1, 5],
    [5, 4, 8, 3, 1, 2, 6, 7, 9],
    [4, 8, 3, 9, 7, 5, 6, 1, 2],
    [9, 7, 4, 2, 5, 8, 3, 1, 6],
    [2, 6, 4, 9, 8, 7, 5, 1, 3],
    [2, 7, 8, 6, 5, 3, 4, 1, 9],
    [1, 6, 2, 3, 8, 5, 4, 9, 7],
    [5, 6, 9, 1, 2, 8, 4, 3, 7],
    [6, 1, 4, 7, 5, 8, 3, 9, 2]],
W =
   % rankWomen =
   [[3, 1, 5, 2, 8, 7, 6, 9, 4],
    [9, 4, 8, 1, 7, 6, 3, 2, 5],
    [3, 1, 8, 9, 5, 4, 2, 6, 7],
    [8, 7, 5, 3, 2, 6, 4, 9, 1],
    [6, 9, 2, 5, 1, 4, 7, 3, 8],
    [2, 4, 5, 1, 6, 8, 3, 9, 7],
    [9, 3, 8, 2, 7, 5, 4, 6, 1],
    [6, 3, 2, 1, 8, 4, 5, 9, 7],
    [8, 2, 6, 4, 9, 1, 3, 7, 5]].

%
% From 
% http://www.csee.wvu.edu/~ksmani/courses/fa01/random/lecnotes/lecture5.pdf
%
problem(3, M, W) =>
M =
   % rankMen = 
   [[1,2,3,4],
    [2,1,3,4],
    [1,4,3,2],
    [4,3,1,2]],
W=
   % rankWomen =
   [[1,2,3,4],
    [4,3,2,1],
    [1,2,3,4],
    [3,4,1,2]].


%
% From http://www.comp.rgu.ac.uk/staff/ha/ZCSP/additional_problems/stable_marriage/stable_marriage.pdf
% page 4
%
problem(4, M, W) =>
M =
   [[1,5,4,6,2,3],
    [4,1,5,2,6,3],
    [6,4,2,1,5,3],
    [1,5,2,4,3,6],
    [4,2,1,5,6,3],
    [2,6,3,5,1,4]],
W =
   [[1,4,2,5,6,3],
    [3,4,6,1,5,2],
    [1,6,4,2,3,5],
    [6,5,3,4,2,1],
    [3,1,2,4,5,6],
    [2,3,1,6,5,4]].


% Random instance (for my MiniZinc model) 10x10
% http://hakank.org/minizinc/stable_marriage_random10.dzn
problem(5, M, W) =>
M =
   [[10,2,5,9,8,1,4,7,3,6],
   [8,9,1,3,7,4,10,2,5,6],
   [8,3,10,2,9,7,4,1,5,6],
   [5,2,10,7,4,6,3,1,9,8],
   [3,9,4,1,7,5,2,6,8,10],
   [9,8,7,4,10,2,6,1,3,5],
   [8,3,9,4,6,7,10,1,5,2],
   [8,1,7,4,2,3,10,9,5,6],
   [8,3,6,4,2,7,9,1,10,5],
   [6,8,5,2,3,1,10,4,7,9]],
W =
   [[10,4,9,7,6,1,3,8,2,5],
   [5,9,4,7,8,10,6,1,3,2],
   [2,7,5,4,1,10,8,3,6,9],
   [3,2,10,7,4,8,6,5,9,1],
   [9,1,8,3,5,2,4,7,6,10],
   [6,7,5,8,1,3,4,9,10,2],
   [9,2,8,3,4,10,1,7,6,5],
   [8,4,10,2,9,6,5,3,1,7],
   [6,7,1,8,4,2,9,10,3,5],
   [7,9,5,8,6,10,3,2,4,1]].


% http://hakank.org/minizinc/stable_marriage_random20.dzn
% 20x20
problem(6, M, W) =>
M =
   [[10,4,3,20,19,11,2,18,6,13,17,5,7,12,14,16,8,15,9,1],
   [4,18,13,11,8,19,2,17,15,10,12,9,16,5,6,20,14,7,3,1],
   [14,11,13,4,17,10,6,12,16,2,7,1,19,9,20,5,3,15,8,18],
   [1,12,19,2,10,11,6,20,17,18,14,15,9,7,16,3,5,8,13,4],
   [8,2,12,20,5,10,9,15,7,16,6,13,18,1,11,14,4,19,3,17],
   [1,11,16,18,15,2,8,20,17,13,14,6,19,9,12,4,5,10,7,3],
   [6,5,20,13,10,1,4,9,17,15,12,14,3,16,18,19,8,2,11,7],
   [9,20,8,16,18,19,15,10,5,7,14,6,17,12,4,1,3,2,13,11],
   [2,20,10,8,14,5,18,15,1,17,16,9,4,6,11,3,19,12,13,7],
   [11,5,15,14,16,8,17,1,3,10,4,20,7,18,2,19,6,12,13,9],
   [11,10,8,13,5,3,15,2,9,1,7,12,14,17,6,19,16,20,4,18],
   [5,18,4,14,16,6,15,12,8,17,19,10,2,20,9,3,13,7,1,11],
   [3,17,14,9,10,16,11,13,8,1,2,6,5,18,4,20,15,19,7,12],
   [19,17,9,14,5,6,1,13,4,7,12,15,18,11,8,3,10,20,2,16],
   [12,5,6,14,16,4,18,3,11,19,15,17,2,13,1,8,9,20,7,10],
   [10,19,12,13,3,20,17,11,4,18,8,2,7,6,5,1,9,14,16,15],
   [2,19,1,12,16,20,6,13,14,11,18,17,4,10,9,5,3,15,7,8],
   [4,2,11,9,1,19,13,17,6,15,18,8,10,16,12,3,14,5,7,20],
   [18,17,8,4,10,13,19,1,12,20,3,11,5,7,6,14,15,9,2,16],
   [11,1,12,16,7,15,3,18,5,8,13,19,6,4,9,20,2,14,10,17]],
W =
   [[14,13,1,18,12,10,16,19,20,11,2,8,15,3,6,17,5,4,9,7],
    [1,7,13,3,18,16,17,20,9,6,2,11,14,10,4,8,12,19,15,5],
    [9,20,5,10,2,3,14,16,11,4,15,6,13,18,17,8,1,12,7,19],
    [3,7,1,11,8,13,18,20,12,16,2,4,15,9,10,17,6,19,14,5],
    [2,4,13,9,7,14,1,20,15,19,18,5,17,11,6,8,16,3,12,10],
    [12,16,4,15,9,14,17,6,2,1,7,11,8,10,19,20,13,18,3,5],
    [16,12,20,19,14,17,10,2,13,5,1,6,18,11,15,7,4,9,8,3],
    [2,15,1,20,10,19,7,14,6,8,16,9,18,4,5,12,17,11,3,13],
    [15,18,12,9,2,19,17,4,13,5,6,8,16,1,7,14,20,3,11,10],
    [12,1,7,18,17,4,14,15,5,8,10,20,19,16,2,9,13,6,3,11],
    [12,2,18,11,16,19,8,4,15,10,9,20,1,7,5,6,13,14,17,3],
    [14,15,11,7,16,12,2,1,17,4,20,3,5,9,8,18,13,19,6,10],
    [19,10,15,7,16,9,4,18,17,12,2,8,1,13,20,6,5,3,11,14],
    [13,2,12,3,19,6,16,5,7,9,11,4,1,18,20,14,8,10,17,15],
    [3,12,17,14,4,10,20,15,5,9,19,16,8,7,13,6,1,2,11,18],
    [16,20,2,10,17,11,9,8,15,12,13,5,14,4,7,3,18,19,1,6],
    [12,11,10,6,19,1,4,2,8,20,15,3,13,9,18,14,17,16,5,7],
    [16,7,1,13,11,3,8,2,9,14,10,6,15,17,20,12,18,4,5,19],
    [11,9,2,7,13,5,16,14,1,12,19,15,8,4,20,6,17,10,3,18],
    [6,15,3,19,8,9,5,1,11,7,12,18,13,4,10,16,17,14,20,2]].


%
% http://hakank.org/minizinc/stable_marriage_random50.dzn
% 50x50
problem(7, M, W) => 
M = 
[[35,39,42,37,1,22,7,3,8,15,23,47,31,6,43,40,10,50,48,14,44,28,16,45,26,34,24,20,32,49,11,5,36,19,17,29,41,4,38,25,18,13,9,21,33,12,46,2,30,27],
[33,8,1,22,39,12,49,41,48,23,10,6,35,40,26,38,43,2,50,37,4,44,34,32,31,18,7,42,19,5,45,29,46,16,11,28,36,14,21,15,17,9,47,13,27,24,30,25,20,3],
[18,14,32,33,23,35,16,43,26,17,48,21,12,46,3,50,49,25,34,42,27,6,11,29,4,41,8,37,22,47,9,28,39,13,7,36,30,31,24,20,2,10,1,15,45,40,19,5,38,44],
[3,25,21,28,41,36,48,46,10,2,19,35,14,13,11,37,33,20,5,50,4,27,22,7,12,39,26,43,34,1,24,38,32,29,49,15,17,18,16,9,31,8,30,42,23,44,6,45,40,47],
[8,23,18,34,25,21,20,16,11,2,47,6,32,43,3,22,50,36,26,42,10,5,39,30,15,45,44,19,48,1,12,37,29,49,24,41,13,9,33,7,27,40,38,28,35,17,46,14,4,31],
[35,26,42,17,27,12,5,1,4,24,15,38,14,31,9,32,6,50,28,39,49,13,16,43,45,36,41,3,23,10,29,33,22,8,30,11,21,19,25,20,18,2,40,46,48,34,44,7,37,47],
[14,26,18,29,48,8,15,20,41,1,11,12,7,45,22,10,46,16,31,38,3,13,5,40,36,23,2,30,50,43,17,24,4,37,42,32,25,6,19,49,28,21,33,39,34,47,35,27,9,44],
[32,33,39,20,4,37,8,47,1,10,36,12,43,49,22,29,46,14,11,48,50,6,31,25,2,13,23,19,40,28,3,18,9,41,44,16,21,7,35,45,38,24,17,42,15,34,26,30,27,5],
[25,39,40,7,11,36,29,31,27,17,49,32,12,37,19,43,34,8,18,2,10,48,16,3,46,9,30,15,20,44,22,28,47,4,38,42,13,26,5,1,6,23,24,21,35,50,41,14,45,33],
[42,25,9,40,10,36,48,1,28,13,16,24,6,49,45,50,33,23,19,4,2,17,47,7,11,35,34,26,44,43,18,12,29,8,32,15,3,5,21,14,41,30,39,31,38,27,46,37,20,22],
[29,44,9,33,49,46,38,18,12,41,1,32,30,19,39,50,27,11,21,31,37,17,22,16,14,15,13,47,20,26,42,43,3,40,23,24,25,45,28,10,5,8,4,2,6,48,7,35,34,36],
[19,48,50,36,8,38,4,24,31,30,29,17,2,1,7,3,47,41,23,37,43,5,33,10,44,49,34,22,14,9,6,27,26,16,18,20,13,40,21,15,39,28,25,11,45,42,46,32,12,35],
[49,23,20,46,8,9,31,41,26,3,24,30,13,11,47,28,17,36,40,44,2,12,10,35,27,7,19,5,37,22,39,1,15,25,33,38,48,50,21,43,4,42,14,6,45,32,34,29,16,18],
[47,48,49,45,18,38,17,36,37,1,6,27,34,25,12,15,4,33,39,13,7,2,41,10,31,30,11,14,26,9,21,5,35,8,24,3,44,29,23,20,16,46,32,43,42,50,40,19,22,28],
[50,33,5,31,44,46,4,40,42,29,10,26,30,7,1,17,6,8,45,21,34,39,13,35,12,11,48,32,3,47,19,27,41,49,25,36,23,22,18,14,9,37,43,20,16,24,28,15,2,38],
[2,47,22,31,17,3,10,14,25,12,11,7,35,30,4,49,23,44,50,48,41,34,38,6,19,33,27,26,32,20,16,37,21,45,5,29,43,28,13,46,42,39,36,8,40,18,24,9,1,15],
[27,2,35,15,25,46,50,31,34,48,4,21,33,22,38,12,5,20,16,39,9,6,32,18,26,24,40,1,41,36,8,29,49,44,37,17,30,45,7,13,47,3,10,11,28,14,23,42,43,19],
[13,44,38,14,22,26,20,33,19,17,23,24,8,6,12,34,31,16,45,15,39,40,50,27,36,4,42,2,28,43,9,29,1,11,49,37,48,35,3,5,10,41,46,7,30,21,25,32,18,47],
[15,38,23,49,16,37,17,33,47,44,20,31,45,1,6,29,14,46,48,13,41,9,8,5,19,42,7,26,12,50,43,39,22,18,27,32,34,10,21,11,24,3,4,2,35,28,30,25,40,36],
[16,21,20,12,45,27,47,17,29,24,9,49,48,36,42,39,4,38,46,23,7,30,44,8,19,10,5,15,43,40,33,11,34,28,32,35,25,37,41,22,1,14,6,3,50,2,13,26,18,31],
[47,41,35,17,10,9,5,28,48,4,24,50,29,14,42,32,20,44,16,27,33,11,3,46,13,49,23,12,39,31,36,19,26,15,7,37,45,2,21,38,8,22,6,18,30,34,43,1,25,40],
[1,9,30,40,50,46,15,13,48,25,31,19,24,12,36,41,22,43,45,42,6,18,28,33,2,5,39,38,8,32,34,4,11,37,3,16,29,47,14,17,7,10,20,44,21,23,27,26,49,35],
[7,11,36,19,37,47,5,2,49,50,35,39,12,13,4,15,8,10,18,25,29,20,30,3,21,33,40,14,23,17,28,16,43,48,44,9,1,41,32,45,27,38,42,6,46,34,26,22,24,31],
[22,12,18,17,50,33,2,16,34,10,1,44,23,19,32,47,38,20,8,45,29,27,26,30,42,13,7,21,15,43,37,24,25,48,9,49,36,35,41,39,14,6,11,28,31,46,5,40,3,4],
[29,48,47,3,28,4,8,1,30,35,43,49,36,24,46,21,10,2,14,16,41,20,45,7,26,12,32,27,39,17,23,31,25,42,18,34,13,44,11,15,6,50,37,40,19,9,22,33,38,5],
[44,31,30,3,47,10,15,24,19,39,9,2,45,28,43,33,49,48,41,42,23,17,38,1,29,13,11,37,22,40,18,20,34,35,4,21,27,12,36,8,14,5,46,26,16,32,50,6,25,7],
[26,40,42,28,3,37,36,6,20,46,11,48,8,27,24,45,7,14,32,16,35,43,17,15,13,23,31,47,10,39,21,12,1,49,44,9,5,4,29,38,2,22,18,34,50,41,25,19,33,30],
[24,10,17,38,43,6,8,18,28,11,7,31,14,39,32,19,26,22,16,27,3,29,9,20,4,35,30,2,40,42,15,36,45,46,48,23,49,12,1,21,5,50,33,41,47,37,25,34,44,13],
[12,31,17,45,26,4,27,41,16,7,44,35,32,25,11,38,18,24,42,46,29,33,20,10,13,40,48,30,36,43,15,2,6,8,3,5,9,34,19,14,21,50,23,39,49,47,22,37,1,28],
[34,43,40,13,46,6,37,10,16,47,11,9,36,41,29,28,45,26,21,33,3,31,8,38,1,48,49,12,2,4,50,39,20,7,25,44,27,35,19,30,15,18,5,42,24,17,22,14,23,32],
[28,20,37,29,7,8,17,18,10,48,49,21,12,33,26,36,5,1,30,45,40,47,14,25,31,15,39,16,4,3,44,11,46,35,24,41,42,32,27,50,9,43,22,34,6,19,13,23,2,38],
[41,6,17,3,30,34,47,7,29,8,37,25,39,28,48,40,15,50,49,13,32,42,38,1,21,16,5,26,36,45,23,12,19,22,24,44,4,2,33,10,43,9,14,46,27,18,11,31,20,35],
[23,36,44,9,32,49,12,40,21,33,20,8,28,17,2,3,14,39,26,25,35,19,16,5,30,13,18,37,31,24,6,45,10,1,27,48,7,15,50,46,22,42,11,47,29,4,43,41,38,34],
[39,50,11,22,43,6,20,46,17,3,49,48,10,16,13,1,25,9,23,14,21,28,19,30,27,38,2,26,34,40,45,35,8,5,37,32,24,42,31,47,44,36,12,7,29,4,33,41,15,18],
[40,28,47,7,24,35,36,19,22,30,34,8,11,10,26,23,13,46,49,14,3,6,33,4,44,9,12,1,21,27,31,18,29,38,16,17,37,39,43,32,45,15,25,50,20,5,42,41,48,2],
[33,28,46,17,37,2,8,27,11,20,15,24,29,36,25,7,31,38,34,23,32,4,45,3,6,12,44,19,10,9,43,48,26,50,30,13,49,47,14,42,5,40,39,1,22,21,41,35,18,16],
[46,37,15,29,2,36,9,26,12,38,34,44,25,28,5,39,19,16,33,17,8,50,45,1,42,23,7,21,10,14,27,43,31,24,4,49,22,30,48,35,11,32,13,18,3,6,20,41,40,47],
[47,6,39,45,3,33,43,19,48,21,22,37,20,25,17,35,36,14,24,5,44,30,50,26,46,16,9,2,32,10,31,23,11,7,12,28,29,40,4,18,1,42,38,34,13,8,41,49,15,27],
[30,36,26,50,7,15,6,35,9,11,34,48,39,3,21,12,13,22,25,43,29,2,31,24,40,16,49,4,18,32,28,42,17,37,1,10,46,44,41,45,14,8,20,27,47,33,19,38,23,5],
[28,36,43,17,35,8,1,49,2,38,26,19,12,5,31,44,21,13,7,18,46,30,37,22,41,11,42,27,48,33,25,23,45,32,40,4,10,47,39,6,16,34,3,15,24,9,14,20,50,29],
[18,13,30,46,27,12,5,43,40,16,38,37,24,22,34,9,29,7,28,4,10,25,32,1,3,20,26,47,44,6,2,17,48,14,33,42,49,45,21,36,39,35,50,15,19,8,41,31,11,23],
[25,33,2,9,23,11,48,50,35,44,17,18,10,24,38,20,28,19,22,49,47,46,34,27,36,16,4,8,42,37,21,6,41,45,14,39,29,5,15,31,43,12,26,40,3,13,1,32,7,30],
[45,11,36,25,29,43,16,42,4,26,30,7,17,35,12,49,14,9,8,39,24,19,13,3,18,32,27,31,33,21,20,40,10,15,47,34,2,5,1,37,41,23,6,46,50,28,22,38,48,44],
[31,19,32,28,27,39,9,14,2,15,36,40,20,23,8,11,12,46,43,13,47,16,48,33,18,29,25,3,24,21,50,45,37,44,22,10,17,34,6,7,5,26,42,30,4,49,1,35,41,38],
[21,26,43,2,6,18,47,39,48,36,14,17,16,49,12,33,15,38,25,7,40,4,42,45,20,10,28,50,1,5,8,9,32,30,27,22,23,35,19,44,37,3,34,24,41,31,13,29,46,11],
[5,8,48,33,31,28,34,43,26,39,3,49,21,35,46,36,41,1,38,6,2,25,4,12,18,14,20,15,37,7,45,44,23,17,10,24,11,47,9,30,27,22,13,29,40,42,16,19,32,50],
[12,9,41,19,38,32,39,49,46,23,48,21,13,45,22,31,4,26,34,29,14,25,2,15,43,50,42,11,33,40,5,27,35,37,28,20,30,18,24,47,6,8,36,7,3,16,1,17,10,44],
[43,22,41,39,45,49,50,7,21,25,23,14,32,18,5,46,2,48,29,38,26,31,8,34,19,13,3,9,42,4,37,28,27,24,36,1,15,12,10,16,40,47,20,33,30,6,35,44,11,17],
[46,34,48,14,49,7,43,45,10,23,21,42,3,44,18,8,50,39,25,38,30,13,26,32,33,2,29,37,40,15,41,22,35,20,47,6,1,36,28,24,9,4,12,27,31,19,16,17,5,11],
[47,11,43,44,37,25,19,29,40,23,3,50,20,22,39,28,15,36,5,9,49,34,38,27,24,48,32,41,13,14,30,26,1,8,6,2,18,21,4,42,17,35,7,10,12,31,33,16,45,46]],
W = 
[[11,12,45,2,43,5,4,42,29,19,32,7,47,18,31,50,14,46,16,39,22,8,37,35,38,41,20,40,9,24,23,1,21,26,25,13,15,48,27,10,33,30,3,34,36,44,28,49,17,6],
[36,35,33,1,32,13,40,9,12,44,38,45,42,23,46,50,21,8,28,26,11,3,6,18,19,43,25,29,47,34,37,14,16,7,15,39,31,22,27,17,2,10,41,48,5,30,49,24,20,4],
[37,22,45,10,33,38,35,4,50,43,20,24,25,21,31,40,12,48,5,1,15,7,26,28,47,46,6,30,44,39,42,17,36,49,11,3,13,16,34,27,41,8,19,29,23,9,14,2,18,32],
[31,7,21,8,13,49,3,32,25,30,6,9,22,43,11,1,35,20,24,47,12,38,42,18,44,28,27,36,29,14,39,5,48,17,50,19,45,2,41,34,10,4,15,40,26,37,46,16,23,33],
[20,36,22,50,8,33,18,16,3,21,35,11,13,42,27,38,15,37,25,45,30,1,26,9,31,23,39,7,41,28,46,40,48,5,24,32,49,44,4,34,43,12,29,6,14,10,19,47,17,2],
[45,3,10,29,35,42,2,7,36,16,23,33,13,4,38,15,50,43,30,27,9,31,37,14,21,28,49,22,1,19,11,34,5,26,41,40,32,24,47,12,46,18,17,39,20,44,25,6,8,48],
[44,2,17,38,22,27,35,48,24,5,50,8,1,15,49,37,46,19,10,26,33,43,11,42,30,32,39,34,25,40,20,41,28,18,3,13,9,23,36,45,6,4,16,29,31,12,14,47,21,7],
[8,10,34,45,47,16,22,50,28,2,49,4,37,7,24,29,3,44,35,5,11,26,27,30,33,38,17,13,43,48,21,25,15,31,41,32,9,46,12,39,6,18,42,36,1,40,19,20,14,23],
[37,5,10,46,14,4,42,19,32,40,12,13,43,25,50,2,23,26,28,41,49,35,45,48,36,21,31,30,44,8,39,24,9,27,33,3,11,47,15,7,22,16,17,6,1,20,29,18,34,38],
[41,43,31,27,35,15,5,48,29,13,40,28,42,22,20,17,14,30,44,7,3,37,9,25,45,21,8,39,19,24,34,38,49,50,46,47,33,32,4,23,11,18,1,6,26,10,12,2,16,36],
[38,44,50,25,29,36,39,42,33,22,9,16,26,28,23,8,45,10,41,3,14,18,13,48,34,37,7,32,15,46,47,21,4,1,27,30,43,24,6,17,5,12,40,35,31,19,20,11,2,49],
[43,33,12,31,35,34,3,19,44,14,50,24,1,30,8,32,28,13,15,11,10,38,18,26,29,39,46,40,25,37,17,36,42,6,48,5,49,4,16,7,27,2,22,45,41,20,21,47,9,23],
[31,43,27,40,41,44,5,17,36,39,34,30,32,3,47,42,50,7,8,38,20,23,25,28,29,49,26,11,45,13,9,19,35,6,2,1,46,16,48,37,10,24,33,15,12,21,4,22,14,18],
[8,12,14,38,29,37,19,16,7,47,33,31,9,17,1,30,40,23,50,2,49,4,13,43,41,10,11,24,5,42,27,25,35,36,18,22,45,44,46,32,15,26,28,39,34,48,20,6,21,3],
[30,46,24,9,4,13,2,31,35,48,12,11,25,36,1,33,40,22,7,28,47,21,27,50,45,34,10,19,3,29,6,38,39,44,20,41,5,8,14,26,23,37,32,42,18,49,17,15,43,16],
[25,24,3,27,5,17,36,29,23,39,34,42,12,45,31,16,19,20,8,21,26,2,22,37,46,49,18,1,9,44,33,11,14,48,13,4,32,15,41,35,30,6,7,28,43,10,47,38,50,40],
[27,6,18,25,9,2,20,22,45,21,32,29,26,15,34,44,4,14,37,11,16,31,8,41,5,7,10,19,33,28,46,24,30,43,50,38,17,48,35,39,42,13,36,40,3,47,1,12,23,49],
[28,6,32,29,23,47,27,40,44,43,2,19,48,49,31,37,21,4,38,15,50,30,17,14,46,3,24,1,10,11,41,25,12,7,42,33,34,8,20,22,39,36,26,35,13,18,45,9,16,5],
[31,2,37,3,14,30,49,42,25,38,17,35,43,24,8,41,7,23,16,40,11,48,4,44,22,12,27,26,32,10,21,47,13,33,45,19,46,50,18,28,9,39,20,6,29,36,15,5,1,34],
[18,14,17,27,1,8,49,6,10,42,43,30,11,50,37,46,35,12,31,25,28,20,32,21,3,45,33,7,26,19,38,47,40,4,44,39,29,13,41,16,24,15,9,48,22,34,36,2,23,5],
[22,20,4,43,39,16,37,44,2,50,7,3,15,34,35,23,27,38,48,25,32,13,19,30,46,1,21,42,31,12,10,41,6,28,11,47,29,17,5,14,26,45,40,49,18,33,24,36,8,9],
[29,46,37,5,26,42,45,10,30,23,13,4,39,50,14,15,49,31,22,34,20,48,43,33,28,41,17,25,8,47,12,24,38,44,7,36,3,16,40,9,19,2,11,21,6,18,1,35,27,32],
[22,20,41,18,25,17,38,24,1,40,16,39,49,3,13,14,19,6,35,23,26,29,43,27,7,9,44,28,11,46,12,48,21,37,30,8,33,34,36,47,10,31,15,42,32,45,2,4,50,5],
[29,36,47,10,12,34,49,39,22,4,14,37,19,41,21,33,26,16,20,3,30,23,6,32,17,11,9,15,46,43,40,38,18,35,24,44,2,8,50,28,48,1,42,45,25,7,27,5,31,13],
[31,29,18,15,26,32,42,48,14,34,10,27,50,30,1,44,46,3,23,6,20,24,8,13,2,45,5,37,4,40,9,17,28,11,25,16,39,36,12,47,7,22,33,35,38,21,41,19,43,49],
[14,45,42,38,44,30,41,29,26,39,34,32,21,6,46,49,11,22,15,23,10,33,2,20,8,7,5,16,43,3,4,36,50,13,12,18,31,28,48,25,47,24,35,40,27,37,9,1,17,19],
[19,17,2,30,44,12,46,20,24,40,28,7,9,29,8,5,33,26,18,39,1,27,3,6,48,31,35,49,32,11,42,10,45,41,22,14,15,47,43,34,25,13,36,4,21,23,37,50,38,16],
[49,44,10,37,6,3,16,32,45,26,31,14,11,5,20,1,8,18,15,27,21,25,50,7,38,2,42,46,24,23,34,48,35,29,22,30,36,19,39,47,41,33,28,4,43,17,13,9,40,12],
[13,14,26,19,11,4,29,28,18,10,32,47,45,33,8,40,41,37,39,9,17,24,2,38,42,16,25,5,48,22,50,35,6,1,12,44,43,23,31,7,36,34,27,49,30,21,46,15,20,3],
[49,33,11,47,38,7,41,28,27,2,32,1,24,21,5,4,43,22,37,36,23,8,13,34,30,9,3,18,39,29,44,35,31,14,46,10,26,16,25,15,6,40,48,19,17,42,20,45,50,12],
[2,36,44,6,23,31,1,16,25,42,45,15,47,5,49,34,38,19,11,10,48,12,43,30,40,27,17,32,20,24,26,50,29,28,41,18,7,39,3,21,37,8,35,46,9,22,13,14,4,33],
[42,29,32,28,38,21,30,13,17,11,20,44,50,27,41,1,19,35,36,16,15,7,22,47,33,37,39,25,48,9,23,45,12,18,14,43,46,24,8,49,10,4,26,3,40,2,6,31,5,34],
[15,48,50,43,20,16,33,36,42,26,39,6,19,18,1,13,5,22,31,34,25,2,8,21,38,3,12,41,35,30,28,17,29,23,46,44,11,27,47,7,9,14,49,24,40,45,32,37,4,10],
[32,11,16,4,37,28,5,19,13,40,15,49,23,39,35,41,26,7,2,44,48,1,50,43,17,14,25,36,29,21,47,31,27,20,46,6,10,12,8,9,33,3,24,42,22,30,34,18,45,38],
[11,19,10,15,35,48,6,44,20,16,21,27,8,1,13,22,30,25,4,32,39,36,42,41,12,49,28,24,34,14,17,38,47,5,37,7,46,43,23,29,26,33,9,50,18,2,45,31,40,3],
[1,21,43,14,27,49,15,18,2,4,42,41,6,19,38,26,31,30,47,20,16,24,37,22,28,8,48,13,40,29,17,23,25,45,39,46,44,5,9,11,10,33,50,36,3,34,32,35,7,12],
[41,18,15,7,50,44,33,45,20,6,40,34,29,19,14,4,35,31,38,2,3,1,27,13,23,48,11,9,30,21,5,10,16,43,17,24,49,25,39,12,28,47,26,8,22,37,32,42,36,46],
[39,14,43,2,33,21,17,27,26,47,13,30,4,35,32,18,1,24,11,25,28,46,34,48,23,19,5,31,40,15,44,16,37,36,45,3,7,20,42,50,22,12,9,41,10,38,29,49,8,6],
[14,18,16,44,31,23,38,5,24,7,25,49,47,30,36,20,45,28,15,26,8,4,34,17,39,48,46,11,22,37,32,3,50,43,21,13,33,10,41,1,19,12,6,42,2,9,29,27,35,40],
[37,42,44,30,8,26,43,31,40,5,18,45,36,28,14,22,41,33,27,38,29,34,6,16,10,39,35,15,19,9,4,23,2,3,24,11,47,17,46,25,1,12,32,48,50,7,20,13,21,49],
[14,47,48,23,2,39,43,34,3,22,45,27,17,41,35,9,20,26,10,7,46,44,29,5,19,40,49,30,37,6,12,11,42,1,24,18,16,50,8,33,36,25,31,32,38,28,15,13,4,21],
[39,42,23,15,9,17,47,5,29,14,36,33,11,43,45,30,10,6,50,28,16,25,26,35,34,7,3,20,12,8,18,13,44,22,27,49,21,37,38,31,2,24,46,4,32,48,19,41,40,1],
[22,41,23,40,6,48,37,45,30,7,49,1,35,47,21,34,9,13,29,17,18,16,14,24,15,42,12,31,33,36,46,2,44,50,28,11,39,38,43,19,27,4,5,32,8,3,25,20,10,26],
[31,8,23,34,5,11,50,46,47,27,49,29,42,24,20,15,40,36,43,7,38,22,9,45,13,33,19,41,16,10,28,32,12,48,4,30,2,18,1,44,21,17,35,39,37,14,6,25,3,26],
[23,11,25,42,20,34,9,7,48,37,5,4,32,47,2,19,41,29,17,21,30,24,44,10,36,46,6,39,14,28,3,33,27,38,1,35,31,40,18,43,45,8,50,49,12,22,15,26,13,16],
[9,26,43,35,17,33,16,13,37,44,21,31,32,38,11,15,46,36,49,14,8,3,27,23,28,12,45,4,34,20,39,7,2,42,50,5,40,24,29,48,19,1,30,41,10,47,6,18,25,22],
[32,19,24,1,30,14,33,49,36,23,25,6,8,31,13,45,34,20,29,26,4,38,21,41,47,37,15,9,22,11,27,10,46,44,35,2,5,18,48,3,40,16,42,50,39,12,7,17,43,28],
[34,16,13,9,11,47,25,35,4,30,32,15,10,2,1,7,38,48,29,21,49,14,40,44,28,18,33,6,12,36,23,46,45,19,50,17,22,3,24,27,42,43,26,31,5,20,8,37,39,41],
[24,45,18,46,19,8,41,31,29,42,11,7,48,13,39,26,28,3,22,47,44,35,32,20,4,34,33,2,37,50,5,12,30,15,43,36,27,17,6,25,23,14,9,1,38,21,10,16,40,49],
[50,43,33,36,28,37,21,13,1,16,15,32,23,24,19,2,17,26,30,18,6,40,10,46,34,38,42,29,39,22,45,20,25,5,27,9,31,14,44,11,12,47,8,3,7,4,48,35,49,41]].


%
% http://hakank.org/minizinc/stable_marriage_random100.dzn
% 100x100
problem(8, M, W) =>
M = 
[[49,63,43,21,87,61,1,34,66,24,14,26,41,8,35,44,58,33,90,25,3,84,92,97,27,55,83,45,28,5,89,6,74,56,9,81,52,94,23,36,22,54,86,62,19,96,20,46,15,79,32,39,12,17,4,100,18,68,82,85,38,13,59,47,93,77,91,99,57,2,70,64,53,76,29,80,40,42,71,72,78,69,37,51,65,11,88,7,73,67,10,50,75,31,60,48,16,95,98,30],
[25,45,80,62,14,50,81,18,63,42,47,33,71,26,30,55,48,5,94,13,74,41,20,32,22,95,49,37,6,3,88,38,16,78,52,92,89,46,85,70,86,66,24,2,83,53,75,56,100,82,10,4,54,29,31,69,51,43,99,7,27,65,72,64,93,57,84,61,87,97,96,1,44,59,36,79,58,17,91,21,98,76,8,90,23,15,34,9,35,11,40,77,19,68,39,60,12,67,73,28],
[18,20,6,63,71,82,65,51,85,87,57,16,92,21,91,2,76,93,1,80,49,37,52,24,29,10,25,79,75,27,4,36,47,83,98,88,34,15,81,8,54,26,100,11,73,72,56,22,84,86,45,77,99,67,89,59,41,61,3,5,66,74,94,40,64,97,38,70,30,44,62,35,28,60,19,12,7,33,43,46,50,55,68,17,42,69,90,96,95,48,14,23,78,31,58,9,53,39,13,32],
[33,32,49,79,10,52,1,65,46,69,44,78,37,85,84,59,68,8,60,64,77,15,86,3,83,17,67,96,55,26,92,76,87,80,88,82,5,20,42,73,25,61,27,30,47,13,14,4,63,89,58,99,81,29,62,71,39,75,7,28,12,19,98,35,72,57,24,91,66,36,93,23,94,97,41,50,51,40,21,6,31,53,38,54,74,95,9,11,22,90,34,100,2,43,16,45,70,48,56,18],
[28,29,45,30,63,27,47,60,16,26,49,14,34,59,9,85,79,3,10,81,93,65,35,82,44,50,31,67,24,54,75,13,80,6,42,76,86,48,4,61,32,62,1,5,98,90,100,78,51,96,69,57,18,37,25,41,33,36,94,70,58,83,95,68,23,40,99,52,38,46,43,71,87,72,53,7,88,8,12,73,22,55,20,92,21,17,15,2,89,56,64,11,39,74,77,66,97,91,19,84],
[6,74,54,35,25,8,88,22,14,31,39,65,87,64,57,52,43,23,73,95,55,66,12,1,91,27,49,82,9,70,78,80,41,7,60,79,85,24,61,4,19,59,86,42,99,92,53,62,97,93,40,15,50,2,45,72,36,30,63,48,96,44,26,84,20,18,83,32,28,33,3,21,90,51,75,29,46,58,13,11,17,68,5,37,100,34,16,47,56,76,67,81,98,10,69,71,77,94,89,38],
[69,97,70,47,30,65,27,39,38,35,6,81,86,8,71,87,84,73,78,46,89,75,49,52,22,31,88,100,18,72,94,82,20,33,96,25,58,63,32,91,79,98,44,45,15,59,51,56,41,10,66,26,85,9,19,95,60,3,28,17,99,16,90,74,54,43,36,93,80,92,53,48,2,4,12,42,34,5,62,76,57,23,50,67,11,37,55,21,40,1,83,61,7,24,77,13,29,14,64,68],
[43,36,40,11,92,39,35,89,80,91,99,65,60,47,100,75,54,26,10,90,13,62,4,69,2,76,12,61,50,84,28,21,68,14,25,86,30,56,24,45,97,34,72,19,57,16,48,51,79,93,58,67,83,59,95,1,31,42,5,7,78,3,77,44,15,29,73,85,6,82,46,8,88,64,96,17,94,49,53,98,22,63,37,41,71,9,70,32,87,18,74,27,52,23,38,66,81,33,20,55],
[6,27,35,75,84,71,41,45,62,47,5,82,67,19,61,3,91,29,87,59,52,65,28,48,60,4,90,20,99,96,78,38,13,72,89,73,18,88,98,54,12,30,94,76,86,26,79,44,97,16,43,58,34,15,17,39,2,33,7,14,46,24,51,8,56,95,9,93,53,77,50,80,36,92,70,10,22,68,42,23,1,32,74,66,21,81,83,69,11,49,37,55,57,63,40,25,31,85,64,100],
[44,11,43,39,13,59,79,85,37,76,30,35,72,9,40,20,36,41,88,54,70,19,83,49,64,77,87,95,78,71,65,62,94,57,69,97,33,10,68,89,91,3,67,56,58,17,52,31,55,45,29,22,16,96,18,82,24,25,1,28,93,46,86,21,92,27,81,12,26,98,48,75,4,2,32,51,100,60,14,47,8,74,99,84,15,53,50,63,73,34,7,23,80,90,38,66,5,61,42,6],
[10,94,60,33,26,53,52,72,42,1,63,87,65,83,97,13,96,21,24,8,20,15,69,91,67,100,14,36,86,45,29,51,2,46,25,50,28,71,38,89,17,34,22,4,35,74,58,61,78,39,3,88,59,99,66,37,19,41,77,76,98,31,95,5,30,40,68,70,93,82,75,32,9,43,47,44,16,7,80,56,64,90,27,81,73,12,55,11,79,23,57,62,85,49,84,48,18,54,6,92],
[58,27,63,86,13,76,50,8,23,26,93,17,18,15,91,38,36,62,9,68,82,53,97,99,28,43,87,3,94,70,12,44,10,34,16,60,79,20,19,67,59,88,61,74,33,73,83,41,54,39,89,25,71,4,24,66,81,2,57,56,48,65,85,75,98,22,69,7,72,52,55,95,100,40,32,96,37,21,80,49,51,90,47,45,92,84,78,6,35,29,5,42,46,64,11,14,30,77,31,1],
[28,69,46,94,9,92,21,81,73,38,14,49,66,79,97,59,15,32,52,82,30,71,45,8,3,78,93,87,65,39,47,29,24,50,48,34,16,89,6,67,61,17,27,43,54,10,7,62,2,22,4,58,86,76,37,90,23,95,56,64,75,88,41,42,98,35,100,31,12,5,74,19,18,20,83,40,36,25,11,63,1,72,84,96,85,99,26,68,44,57,77,53,33,51,80,60,70,13,55,91],
[75,85,58,19,66,98,24,20,62,90,33,27,18,7,47,57,32,38,6,51,79,76,71,12,56,82,92,54,77,53,52,68,60,35,10,96,42,49,86,50,1,84,94,64,39,55,15,5,89,17,95,45,29,13,72,2,26,61,40,31,88,91,8,36,11,48,100,65,63,23,67,14,9,21,3,30,83,22,97,81,59,69,43,16,46,87,4,80,78,41,70,99,25,93,73,37,28,44,74,34],
[86,70,38,2,8,92,10,67,18,27,89,79,66,49,82,55,94,75,11,69,44,88,54,72,32,24,68,26,76,53,80,43,5,37,96,45,58,31,4,99,42,95,98,14,51,35,23,81,71,12,61,74,16,40,93,30,6,62,56,90,97,13,41,65,63,22,91,50,84,78,9,20,64,46,77,34,100,21,85,1,87,29,15,17,33,73,48,59,7,60,19,83,28,36,3,39,57,25,52,47],
[75,88,10,89,99,24,57,41,2,33,34,25,39,52,76,73,35,29,4,9,87,91,48,28,50,77,22,94,16,68,92,44,23,56,43,96,11,80,59,82,51,46,32,71,15,84,6,3,90,49,70,47,67,14,65,36,66,31,93,20,95,63,37,72,30,74,17,86,79,61,1,100,38,26,7,40,60,54,62,55,83,42,5,12,53,27,19,98,45,13,81,69,18,85,97,78,58,64,8,21],
[71,61,89,48,30,97,11,76,21,20,80,12,4,52,67,18,42,40,16,19,34,49,65,64,60,100,32,73,22,94,98,81,10,36,91,59,62,88,37,8,87,83,56,72,77,39,28,43,50,51,47,84,55,5,68,35,45,2,82,6,41,9,86,17,14,70,26,7,24,74,27,95,69,29,13,44,57,1,53,63,96,15,31,99,66,3,38,58,25,33,78,46,90,79,85,75,54,23,92,93],
[81,87,49,72,39,29,70,5,2,86,65,69,15,76,25,1,84,59,8,38,90,93,10,55,53,85,58,77,32,37,43,62,27,48,46,71,41,56,50,75,31,35,28,57,40,17,12,30,94,21,64,47,88,96,91,33,95,44,52,23,98,20,74,82,78,24,9,89,16,54,42,18,3,79,97,19,83,66,22,26,61,34,80,63,68,60,13,51,100,45,4,99,7,14,73,67,11,36,92,6],
[85,27,16,9,46,84,66,56,49,88,95,50,71,67,12,68,48,47,33,70,44,90,25,10,26,5,96,28,38,35,80,3,37,54,87,53,86,73,11,65,20,76,6,31,91,100,77,42,99,52,98,17,8,74,60,34,2,79,69,40,51,82,4,93,75,55,13,97,92,89,30,45,59,61,21,7,29,94,63,81,15,78,36,72,41,18,1,57,24,62,64,32,43,39,14,58,22,19,23,83],
[13,27,100,21,75,46,60,17,25,31,22,97,95,55,61,72,3,66,68,67,10,51,65,63,36,93,11,8,20,74,92,80,57,91,2,7,89,69,47,14,4,32,35,42,62,37,49,34,64,29,53,94,98,30,85,24,41,84,16,19,9,18,90,48,15,88,52,77,45,76,6,82,50,1,26,44,58,71,39,43,40,86,78,59,56,99,23,73,83,81,38,87,12,79,33,70,5,28,54,96],
[33,25,19,44,88,92,32,79,30,5,95,71,8,64,55,98,86,21,99,53,11,38,52,56,69,23,41,15,58,90,82,6,76,59,54,75,84,87,27,97,43,62,46,16,85,28,47,89,83,2,94,36,4,100,93,45,22,74,39,29,34,50,13,14,7,67,65,57,9,81,20,49,26,51,35,96,80,10,91,77,63,42,72,12,48,31,3,1,37,73,61,66,68,24,17,18,78,60,40,70],
[95,96,42,73,34,85,27,59,57,76,79,56,7,92,55,32,23,62,15,72,26,10,61,43,91,12,90,30,47,48,21,37,99,54,82,1,29,98,16,13,44,14,25,66,2,58,8,70,45,3,49,71,80,81,86,38,41,65,52,40,18,60,33,53,69,5,36,87,78,63,24,74,89,83,22,50,75,93,9,84,35,88,20,11,28,77,97,100,4,68,94,46,31,17,39,6,67,64,51,19],
[12,7,83,92,65,85,46,47,24,22,27,63,62,66,58,79,84,57,11,5,31,16,59,56,38,68,32,95,55,100,13,78,30,87,1,91,39,72,98,96,43,26,18,76,4,81,50,97,82,3,61,75,54,80,48,17,86,45,15,10,49,99,60,2,64,67,70,21,20,52,44,51,42,6,37,40,93,69,9,77,8,28,33,73,29,23,35,89,25,19,41,74,14,36,94,90,53,88,71,34],
[6,70,15,45,100,7,43,46,87,11,85,9,97,34,37,49,24,17,69,13,33,18,22,54,39,91,30,71,99,2,29,63,19,53,55,41,61,36,81,4,1,35,27,38,47,65,5,44,74,62,52,31,73,16,51,50,78,42,66,59,95,57,21,77,28,48,83,68,90,82,10,64,8,94,84,25,56,75,96,14,67,60,76,12,23,86,92,79,88,26,32,40,93,89,3,20,58,98,72,80],
[10,45,93,59,47,65,89,42,16,90,6,58,18,75,29,85,94,55,40,91,92,44,35,17,12,62,79,7,9,5,14,39,96,99,57,48,11,15,71,88,41,61,84,97,81,63,24,38,74,23,64,22,80,32,25,13,98,51,49,8,87,78,52,77,26,73,20,37,95,72,50,31,56,76,30,3,70,43,21,68,46,66,34,19,27,69,82,2,67,60,4,33,100,28,54,86,1,36,53,83],
[11,77,55,96,3,42,67,64,53,68,44,30,97,17,33,71,2,32,27,58,98,24,57,83,19,45,56,100,36,72,13,4,23,52,18,82,38,15,29,25,65,51,81,75,21,9,86,28,63,95,41,84,39,99,20,66,5,6,1,37,88,78,40,73,93,12,87,26,89,80,54,62,22,35,79,92,34,31,59,16,14,61,85,48,91,70,8,90,94,49,46,76,7,50,69,47,10,60,43,74],
[29,9,20,66,95,22,46,75,1,99,49,11,14,92,24,67,54,16,69,93,12,77,83,32,74,18,34,81,57,17,2,62,4,21,72,76,64,43,85,50,52,8,6,35,94,84,56,33,60,7,78,51,45,25,91,41,31,96,15,68,40,55,98,53,44,97,65,36,71,39,80,61,90,58,37,27,13,73,47,87,26,23,63,79,59,86,89,38,88,30,19,70,3,42,82,5,10,48,28,100],
[99,29,6,30,100,21,33,48,18,83,55,78,60,89,45,66,51,75,71,15,39,36,43,44,80,37,61,97,54,27,13,41,98,72,64,46,10,82,26,76,31,35,12,3,74,87,5,25,57,28,42,93,58,70,20,11,49,14,52,92,32,4,62,50,40,69,1,68,34,73,22,90,7,19,63,94,67,88,9,38,65,79,17,81,56,24,85,84,77,47,91,59,16,8,95,86,2,53,96,23],
[98,36,7,72,60,74,56,70,10,94,100,21,24,55,22,33,59,52,48,58,26,18,96,65,95,20,31,67,78,27,49,34,91,84,90,25,13,75,14,1,71,66,57,73,40,80,62,93,41,4,79,38,53,39,50,11,82,44,46,43,32,89,88,45,42,3,12,51,81,76,5,19,15,54,9,63,87,92,23,35,6,29,69,64,77,2,99,37,83,8,28,61,86,85,16,30,17,68,97,47],
[64,43,5,26,56,90,49,3,28,32,53,2,25,89,88,58,4,7,8,68,22,34,97,60,37,17,20,45,23,59,10,27,91,11,13,99,98,78,18,9,44,82,36,65,29,96,52,93,72,55,33,19,71,73,74,67,84,16,100,94,83,69,50,39,79,38,24,48,30,75,1,31,6,85,77,51,81,86,14,92,35,66,21,47,40,63,46,54,80,41,95,57,76,70,15,12,62,87,61,42],
[44,64,63,57,81,52,89,12,1,34,3,86,8,85,92,59,66,17,82,11,84,94,61,65,97,39,47,93,38,16,45,42,80,68,18,33,5,78,56,14,4,13,23,19,10,36,75,7,95,26,73,51,69,99,91,70,50,83,79,87,37,76,27,24,9,100,54,41,60,2,90,20,32,15,58,21,48,67,96,40,72,29,46,22,62,71,53,31,74,30,6,77,35,55,49,25,28,43,88,98],
[97,82,89,11,17,20,71,37,84,13,92,16,95,80,60,91,38,2,59,9,99,79,74,77,83,1,70,57,8,48,5,69,14,62,23,49,21,22,7,36,33,27,78,65,86,39,64,47,87,98,54,73,53,51,67,68,93,41,6,15,50,35,46,40,29,76,42,61,63,88,75,85,3,32,25,18,94,28,34,44,43,66,55,30,12,100,72,58,26,90,31,96,81,19,10,24,52,45,56,4],
[65,76,54,48,88,69,87,2,75,41,29,67,74,10,26,47,79,85,66,25,18,52,39,99,40,11,83,7,28,32,97,37,73,38,92,80,36,91,90,19,61,5,9,43,56,21,71,86,95,89,6,94,22,15,44,8,24,13,1,4,49,3,16,82,46,72,68,14,84,34,60,58,12,51,42,63,30,64,23,81,55,31,96,20,62,27,45,70,33,93,35,100,17,98,77,53,57,78,59,50],
[60,27,97,16,20,37,70,65,35,67,40,86,74,48,76,10,100,12,6,49,64,72,98,79,5,33,43,80,50,57,92,18,8,47,31,94,29,44,53,9,91,41,52,87,93,89,3,21,55,78,38,83,26,77,75,42,71,66,7,95,68,39,90,99,96,45,15,59,32,23,11,54,62,14,24,46,2,28,84,61,51,22,25,4,36,13,85,63,69,73,19,1,56,30,82,17,81,34,58,88],
[21,41,61,2,66,87,4,65,98,40,8,13,16,54,78,82,7,30,83,53,96,14,22,58,25,46,36,39,18,79,28,93,95,73,91,52,84,81,19,85,100,71,62,80,38,64,1,72,20,90,59,26,24,10,60,34,77,12,44,70,99,75,50,42,92,76,68,31,33,3,63,57,88,45,89,43,55,48,47,6,35,17,37,97,86,23,49,51,67,27,11,94,56,5,69,15,32,74,9,29],
[46,75,16,41,84,77,86,21,60,4,80,8,70,55,5,97,69,58,54,31,14,51,44,95,23,9,48,65,39,74,34,87,67,98,52,22,11,57,37,18,82,100,71,27,40,64,13,76,20,73,7,1,33,2,93,25,47,81,79,96,24,50,35,85,90,91,30,19,17,10,68,6,88,89,26,49,56,15,61,63,3,66,59,53,92,29,94,45,28,38,62,83,99,72,12,32,36,43,78,42],
[48,51,28,89,23,93,22,87,44,63,88,70,43,17,25,95,35,37,27,76,67,42,50,68,21,47,30,29,59,84,5,41,71,80,16,85,31,96,6,91,78,73,53,3,18,77,58,92,55,39,12,56,34,38,4,10,14,100,20,2,45,62,36,11,9,49,86,19,65,60,97,54,74,94,69,15,82,32,83,81,33,99,98,26,40,79,75,1,72,90,7,46,64,13,66,57,24,52,61,8],
[27,28,87,18,15,76,53,91,7,89,95,98,58,96,52,30,4,37,2,41,19,29,79,74,64,8,82,35,42,6,73,36,66,9,83,63,11,75,23,21,68,26,99,1,93,49,16,84,69,62,56,32,24,43,71,3,59,50,57,47,90,54,78,85,13,14,38,33,12,46,55,70,44,92,81,86,40,97,65,48,5,22,67,80,60,10,39,88,100,25,51,20,77,17,94,31,61,72,45,34],
[86,37,16,32,72,79,28,22,27,9,80,75,33,61,81,25,11,97,38,96,58,69,20,6,36,84,7,1,59,66,92,56,41,19,87,91,64,48,51,53,71,63,13,68,39,54,14,30,40,99,65,4,15,31,5,24,76,18,49,29,82,78,100,55,73,12,10,47,2,3,67,60,57,89,17,50,52,85,83,98,34,23,46,74,94,62,8,88,93,77,95,21,90,45,26,43,42,44,70,35],
[18,91,100,54,16,14,23,81,52,65,33,15,66,86,43,32,19,96,11,7,29,75,1,35,3,67,57,64,36,62,2,61,28,72,4,89,79,26,8,20,97,95,37,42,59,27,56,47,99,74,63,90,88,58,13,84,70,85,5,12,40,71,82,92,44,9,77,55,76,25,38,48,49,22,10,46,21,53,34,60,73,24,50,78,98,17,83,68,51,41,31,87,93,30,45,80,6,39,94,69],
[50,78,53,94,57,13,9,76,74,59,11,97,63,75,73,54,26,21,34,37,79,88,29,80,84,25,82,4,5,64,91,92,22,70,100,60,72,32,18,90,71,24,48,98,58,47,96,85,39,17,3,7,45,8,69,61,89,42,23,99,86,46,87,40,67,1,10,62,83,33,77,2,95,68,30,81,35,66,19,55,52,14,16,15,20,43,41,38,31,56,12,93,28,44,65,36,51,49,6,27],
[64,51,39,35,88,71,4,1,38,91,24,97,3,79,96,28,7,25,62,55,14,30,84,43,83,45,89,13,90,93,42,69,16,76,87,20,73,8,34,19,92,48,59,98,86,21,63,60,6,36,95,32,41,50,80,29,67,61,11,94,56,53,85,31,2,44,65,33,5,46,68,57,37,99,10,72,12,15,49,100,78,54,58,75,26,27,52,17,82,66,77,81,47,18,74,23,70,22,9,40],
[44,42,90,8,89,36,17,88,34,30,13,37,49,91,87,100,41,9,26,3,56,4,80,64,99,92,45,27,97,79,74,66,85,53,78,32,70,7,33,48,57,5,21,52,50,12,10,83,69,95,93,18,77,1,47,84,6,54,61,86,28,55,98,81,24,68,19,82,23,29,76,58,67,39,11,2,51,65,25,75,59,71,60,40,96,31,72,20,94,38,14,73,63,16,43,35,46,22,62,15],
[37,45,73,47,29,44,62,42,13,34,51,57,67,61,87,23,31,60,19,86,55,35,14,85,56,7,65,89,46,6,81,50,95,68,20,33,71,36,88,92,80,93,69,59,72,9,75,28,2,96,16,64,3,39,63,76,83,11,43,40,49,12,38,77,100,32,52,30,53,97,70,41,98,58,5,84,21,10,78,27,94,48,91,74,66,22,26,17,79,4,82,90,18,25,24,99,15,54,8,1],
[30,91,88,93,75,52,2,3,34,23,27,78,33,95,59,12,16,77,40,48,81,29,14,18,10,67,17,65,24,43,94,55,42,54,97,8,99,51,56,83,25,7,82,64,11,45,1,100,53,68,70,38,72,87,50,69,90,44,37,85,32,79,28,46,26,63,36,96,9,62,92,98,35,89,4,84,39,22,20,57,6,60,58,31,49,66,19,13,71,76,80,74,5,86,21,47,61,73,41,15],
[17,92,30,80,89,41,18,12,38,31,61,79,32,72,43,87,39,28,63,69,29,76,71,7,46,49,47,9,11,50,52,14,26,20,74,13,10,85,58,66,59,62,99,70,88,48,34,82,23,65,45,22,51,75,54,90,94,6,78,1,98,97,56,15,55,3,91,57,4,81,8,36,95,5,73,83,68,19,33,64,24,21,25,100,2,53,27,37,60,93,96,77,84,42,16,35,40,44,86,67],
[29,36,41,62,58,15,16,24,70,91,83,66,22,32,25,9,52,56,54,57,18,11,3,79,92,76,33,88,59,21,71,96,35,38,72,50,8,10,45,75,65,47,14,40,26,39,99,85,87,94,48,60,81,12,34,63,53,100,74,93,80,73,77,46,17,89,98,78,19,90,37,2,1,61,7,55,49,20,31,51,5,68,30,95,97,44,43,28,84,82,64,27,69,86,6,13,23,4,67,42],
[34,84,35,24,32,99,63,98,12,45,48,1,87,68,2,93,40,58,73,51,43,89,37,70,67,39,17,49,57,10,60,86,36,19,14,64,53,75,22,81,92,42,76,21,79,71,3,9,13,50,16,77,8,100,38,11,59,65,29,94,46,28,20,56,30,47,5,62,23,74,31,80,55,91,97,54,72,4,90,25,78,69,85,66,44,7,41,61,95,52,88,6,83,96,15,27,33,18,82,26],
[5,11,60,89,62,75,50,1,88,100,17,18,77,90,59,61,27,12,63,3,69,98,29,24,33,76,32,68,14,83,47,31,42,35,16,4,73,71,92,6,28,37,87,84,82,99,57,34,67,25,95,56,45,78,36,65,20,22,81,26,93,58,7,64,86,38,91,48,97,40,23,15,74,85,39,46,8,94,21,41,79,2,10,9,72,70,53,44,30,52,96,66,51,55,13,43,19,54,49,80],
[85,39,16,34,23,13,15,7,26,58,62,25,82,27,40,53,74,9,83,63,61,19,12,95,8,38,35,51,20,88,22,97,31,29,87,68,28,75,94,93,17,43,55,59,100,69,6,41,3,1,78,10,52,44,32,72,4,64,57,65,66,80,49,89,18,33,96,60,36,56,79,67,76,91,86,42,73,99,2,92,50,14,70,45,77,5,84,71,47,98,48,90,30,11,81,54,46,21,37,24],
[73,19,58,76,38,84,36,74,65,63,20,70,88,30,60,2,3,40,34,54,24,32,69,90,79,93,21,7,62,55,72,77,48,28,35,45,51,9,67,44,89,15,92,5,66,49,12,39,96,75,14,6,27,33,80,97,18,68,10,53,42,25,16,52,47,87,100,59,56,50,61,95,85,98,4,22,46,8,23,13,82,11,57,37,99,83,43,86,81,26,1,41,94,29,71,64,78,91,31,17],
[49,38,21,98,17,2,50,45,61,40,66,48,39,19,46,18,11,71,90,68,15,55,51,63,82,79,16,29,57,85,84,60,94,81,24,53,23,9,93,31,67,87,75,69,70,86,52,13,6,28,58,88,97,47,30,36,35,1,20,41,37,44,43,77,5,96,32,62,27,4,12,42,26,80,59,10,78,76,54,73,72,95,91,25,8,100,7,33,3,56,74,64,65,99,34,83,89,22,92,14],
[1,84,46,10,33,83,62,65,47,92,18,39,70,27,17,25,63,48,29,42,30,37,5,2,16,20,36,35,31,4,57,60,7,72,86,26,14,44,82,38,85,99,32,80,64,6,55,56,19,74,96,52,3,9,53,43,59,28,75,12,13,23,77,87,91,68,21,15,54,79,40,61,66,22,98,88,8,93,81,78,95,58,71,67,76,49,94,69,97,73,11,100,90,50,45,34,24,41,51,89],
[3,60,16,51,92,63,31,88,2,23,79,58,72,55,33,52,4,76,22,65,75,35,53,21,15,81,37,48,19,85,66,62,90,7,96,10,91,46,97,56,42,43,24,18,80,59,39,68,50,54,45,5,38,57,67,30,64,87,44,47,34,26,98,28,27,83,94,36,29,14,40,32,8,20,49,11,70,95,41,86,73,6,93,74,17,82,71,89,77,25,99,61,12,13,100,1,9,69,78,84],
[97,1,91,5,29,61,67,40,100,35,45,64,86,94,4,62,20,89,65,36,46,8,31,55,85,18,44,6,26,37,57,69,68,53,34,95,10,42,19,99,74,7,13,50,84,88,27,11,24,60,33,72,48,79,87,30,78,59,66,17,58,75,3,80,15,25,47,52,28,73,16,41,93,63,2,23,56,54,9,98,77,90,81,22,92,70,38,82,71,32,39,51,49,12,76,14,43,83,21,96],
[22,7,31,12,95,18,16,21,52,54,75,82,41,8,26,92,28,72,66,83,20,91,1,67,73,57,80,17,51,39,76,50,55,81,42,94,100,62,4,34,37,35,11,98,24,47,74,97,59,93,79,10,63,36,96,6,71,61,9,2,30,27,49,23,58,99,33,15,14,5,53,29,56,25,60,69,77,88,78,3,86,84,68,87,70,44,46,89,65,38,40,19,43,48,90,32,45,64,13,85],
[68,95,26,71,3,52,85,42,30,89,11,94,86,32,25,38,54,97,70,45,39,66,50,64,53,12,84,29,28,76,87,8,44,27,7,77,63,100,59,48,24,67,15,5,57,51,80,16,14,81,82,69,13,1,60,17,75,31,61,41,40,34,37,65,62,23,72,88,92,98,33,83,99,43,35,49,93,58,10,96,46,79,55,22,74,9,47,73,2,36,19,18,56,4,21,90,20,6,91,78],
[71,24,29,76,42,70,28,93,69,6,36,47,18,97,65,80,91,10,85,52,64,82,68,94,19,74,35,58,59,12,21,16,9,3,57,22,92,43,75,100,66,81,32,67,84,73,40,78,39,61,8,1,55,53,11,33,60,90,62,48,45,98,96,83,2,49,30,14,38,56,95,46,5,72,7,44,25,41,13,37,26,77,15,31,50,88,87,34,99,89,79,54,4,27,23,20,51,63,86,17],
[25,48,89,49,60,19,69,84,56,91,75,58,41,59,37,46,35,87,22,95,100,52,42,45,21,16,97,57,17,5,65,13,54,27,73,8,34,82,40,18,63,3,32,7,38,94,74,30,55,80,26,68,50,81,33,85,15,39,2,92,29,24,20,66,51,70,76,36,86,96,11,99,14,31,6,72,10,61,64,53,62,28,1,77,93,79,43,23,83,90,44,12,98,4,78,88,67,71,47,9],
[5,48,66,9,100,80,56,92,86,23,68,47,12,32,76,88,57,51,25,27,10,44,93,18,3,31,13,49,83,29,53,17,62,95,26,87,24,34,22,30,71,94,28,85,15,20,82,19,37,84,16,67,45,90,77,89,81,38,78,98,70,54,74,4,21,1,96,63,72,59,14,65,42,11,75,91,40,8,7,64,52,97,6,41,55,69,43,35,2,39,61,60,46,79,33,99,36,73,58,50],
[26,4,38,27,35,7,12,32,14,39,73,45,66,78,24,98,6,31,19,28,69,49,43,91,89,68,8,92,99,41,82,71,11,17,33,85,60,97,93,70,88,15,52,86,3,61,81,57,40,58,18,65,25,46,10,84,67,95,5,74,20,54,72,76,50,90,1,30,79,94,2,9,48,42,80,100,29,64,36,75,34,83,96,23,62,44,59,13,53,22,56,47,51,16,77,87,37,55,21,63],
[68,25,45,19,34,79,84,92,74,88,15,61,99,40,32,16,7,31,2,91,27,50,64,54,5,24,23,53,33,63,85,58,42,20,96,43,46,67,47,28,87,60,95,49,11,10,86,52,48,14,22,26,51,56,82,72,69,93,78,94,66,37,36,100,98,41,1,76,6,9,13,71,44,83,57,80,4,30,38,97,70,55,29,89,35,62,65,18,59,77,17,12,8,81,75,21,73,3,90,39],
[33,51,83,89,74,37,32,17,86,29,54,75,99,93,7,45,11,43,61,66,12,1,82,87,84,58,98,20,100,88,52,15,36,67,47,23,48,97,16,31,13,70,80,30,39,44,60,85,2,69,35,42,76,34,55,90,79,41,38,8,56,72,19,9,22,65,10,92,96,25,49,26,94,46,81,4,73,62,77,91,95,14,68,40,78,28,27,59,18,24,5,64,50,3,63,71,6,57,53,21],
[42,81,82,99,86,35,20,33,53,79,19,70,38,8,75,84,74,73,49,60,96,92,6,95,76,55,97,32,15,94,28,13,67,91,26,83,78,59,21,27,43,68,56,88,47,22,14,25,93,87,1,98,62,4,34,90,18,31,23,58,57,48,29,61,71,65,41,63,10,44,37,9,11,12,89,69,100,24,66,30,85,40,36,80,17,54,50,46,7,51,16,39,5,77,45,3,2,72,64,52],
[72,46,53,10,77,29,47,67,85,26,13,99,30,33,98,64,42,27,17,45,61,58,63,18,50,54,48,36,2,76,32,56,21,22,8,51,92,71,25,16,9,70,38,37,7,80,81,68,39,40,3,49,12,44,6,59,55,97,31,100,94,24,73,62,74,88,93,41,83,15,19,60,89,78,57,23,20,4,82,28,75,52,84,91,11,34,65,35,86,96,14,66,79,90,1,95,5,43,87,69],
[2,86,74,33,51,47,91,52,16,22,60,17,25,6,94,65,3,49,7,98,95,83,96,69,61,57,36,26,76,19,20,90,34,89,82,54,40,43,27,97,5,50,59,63,15,100,46,53,77,81,70,62,9,58,8,72,67,23,38,85,11,55,92,14,37,24,84,78,4,56,93,42,39,1,32,21,71,10,44,99,45,28,41,68,31,18,87,12,80,88,79,48,73,75,64,13,30,35,66,29],
[44,52,79,81,60,93,68,23,16,20,7,74,9,27,37,84,55,57,53,66,76,36,41,25,21,88,91,92,22,72,98,54,18,48,40,56,67,15,63,39,77,43,5,49,8,10,50,64,89,80,6,11,3,14,75,32,29,69,30,94,59,78,100,83,1,61,13,35,90,33,2,34,26,28,86,46,62,42,47,4,85,45,12,38,96,51,82,87,19,31,24,97,65,95,17,71,99,73,58,70],
[50,18,40,68,83,52,78,61,71,46,91,30,67,37,3,62,93,47,17,84,28,87,43,74,72,19,75,36,66,54,65,79,59,2,58,97,27,96,32,98,100,41,92,38,1,80,22,81,14,90,33,70,35,44,53,10,6,23,31,63,85,49,57,5,21,9,16,86,60,56,26,64,11,8,76,24,48,89,29,45,88,25,42,99,94,34,82,69,15,13,77,73,4,20,12,39,51,55,7,95],
[91,14,94,64,65,58,82,74,86,56,24,57,16,27,100,99,61,84,69,22,31,53,45,81,18,73,44,54,28,70,15,29,83,89,43,7,77,79,30,47,46,85,5,8,97,1,19,67,20,60,59,40,51,17,76,90,12,98,66,75,50,80,26,78,3,6,2,52,10,48,87,38,34,32,23,95,49,62,11,39,36,4,41,55,96,63,37,9,42,68,88,93,21,92,35,33,13,71,72,25],
[85,77,93,98,18,58,35,50,8,34,73,33,74,38,82,12,57,87,65,40,3,95,14,61,42,29,37,68,54,6,62,22,48,52,2,21,23,13,86,81,53,91,30,7,20,11,75,9,41,80,45,88,69,89,78,46,25,51,32,94,28,83,67,47,17,55,19,60,56,24,39,76,72,44,84,90,63,49,27,97,4,36,99,96,5,92,43,31,79,10,71,26,15,66,16,59,1,64,100,70],
[38,13,31,45,40,86,100,30,15,87,32,19,3,5,11,64,12,53,9,2,79,72,93,68,8,17,67,75,61,74,63,16,59,42,56,1,26,69,46,10,48,49,96,57,39,90,20,89,82,99,78,7,6,85,35,97,44,22,94,62,24,43,33,83,50,65,58,51,14,25,95,41,60,18,23,21,55,88,37,66,47,28,36,77,76,73,70,71,92,54,91,98,81,52,34,27,80,84,29,4],
[51,56,58,84,67,92,68,8,65,75,36,80,66,72,73,85,50,40,26,98,81,59,86,79,77,30,34,33,25,95,32,71,37,53,93,64,23,100,89,88,60,3,22,54,12,90,70,74,39,31,52,11,27,76,13,83,2,99,47,57,1,4,21,46,9,6,97,10,17,7,49,15,96,16,63,94,44,14,41,24,38,5,87,43,29,48,18,78,42,55,91,61,35,82,62,45,20,19,28,69],
[26,85,41,2,30,3,83,66,61,78,10,21,12,56,16,84,36,73,13,45,15,40,11,64,38,23,33,20,8,86,55,79,100,77,34,75,74,46,97,43,49,44,9,42,89,95,24,54,5,22,65,87,19,32,81,68,93,4,91,31,52,59,6,69,17,96,53,27,29,80,47,63,14,51,35,88,60,58,98,82,71,99,48,90,7,18,1,92,28,37,25,50,72,76,57,62,94,67,39,70],
[45,6,1,19,98,56,14,38,72,20,8,83,93,33,2,61,71,5,37,82,100,41,3,76,52,30,13,86,26,15,85,34,51,78,42,48,49,24,59,67,68,60,63,50,54,89,16,18,9,97,81,57,25,11,21,95,40,69,62,90,10,32,46,73,36,35,44,53,22,88,87,96,80,17,75,39,7,47,31,84,23,74,55,28,99,65,92,79,91,66,43,77,12,94,70,27,64,58,4,29],
[16,54,98,21,7,30,37,26,65,90,97,94,45,40,42,6,13,64,68,53,87,20,50,96,39,17,9,89,35,22,99,41,23,56,46,95,73,27,25,60,93,74,72,24,83,62,63,19,48,4,66,51,3,18,57,59,86,11,91,43,55,28,47,71,88,49,85,82,8,100,34,92,80,32,1,31,15,2,36,33,79,67,29,84,61,76,10,52,44,69,5,77,14,75,58,70,78,12,38,81],
[3,26,5,37,1,67,17,55,18,39,2,23,72,16,70,46,99,98,9,66,96,90,93,78,6,20,30,49,45,100,95,59,34,71,56,38,61,87,68,76,92,33,31,74,86,64,12,81,97,91,41,22,19,60,84,65,50,53,21,62,8,89,88,25,69,29,40,79,94,73,4,24,14,15,58,52,44,63,47,36,83,82,43,13,7,27,10,51,80,11,48,32,35,28,77,42,54,57,85,75],
[67,15,78,91,37,95,16,23,62,98,31,33,4,79,77,87,5,29,57,18,92,53,89,88,84,49,39,17,63,97,96,73,55,2,60,26,9,94,66,11,35,21,58,8,19,51,34,70,50,3,45,36,43,14,54,61,30,74,38,24,85,68,99,13,100,65,47,64,75,10,44,83,46,81,32,42,69,12,82,41,56,71,52,72,76,48,7,28,22,6,59,20,86,90,40,80,93,1,25,27],
[25,5,96,60,41,84,31,55,100,6,21,89,50,63,99,13,83,51,49,67,62,20,79,18,82,22,66,77,36,52,90,2,75,61,70,88,76,92,40,44,37,9,71,39,35,47,24,86,87,57,65,85,97,33,45,94,80,15,59,95,29,11,72,14,48,17,43,98,34,27,42,10,23,73,81,30,68,16,26,7,64,46,93,12,3,69,54,78,74,4,58,8,56,38,19,91,53,1,28,32],
[62,28,56,50,81,51,54,71,29,31,61,63,39,53,97,5,85,64,89,87,84,98,96,45,44,34,48,55,92,59,68,77,74,37,22,38,67,65,19,100,15,24,36,1,47,88,2,25,58,21,93,16,95,32,69,70,99,35,57,43,11,3,20,12,42,90,13,8,14,46,94,80,52,75,79,83,73,9,91,17,7,41,82,60,27,78,6,49,26,76,66,10,23,86,72,18,4,30,33,40],
[3,59,72,18,54,94,53,70,51,65,27,49,58,38,25,9,100,56,86,6,88,36,33,73,22,4,82,96,69,61,77,89,19,52,11,45,68,14,78,64,85,48,34,12,32,37,71,26,74,47,93,67,7,5,24,20,1,39,91,62,40,92,66,83,97,55,41,29,75,10,17,43,95,90,63,42,28,2,50,30,31,80,44,87,98,84,60,46,35,76,57,81,13,16,99,23,79,21,8,15],
[49,86,90,74,76,1,24,79,32,57,98,18,93,29,39,8,100,61,47,87,88,27,63,52,31,12,11,72,75,80,81,14,73,34,4,17,15,23,7,53,22,83,51,77,35,9,3,85,95,68,19,30,94,20,48,40,92,45,5,26,36,41,50,96,84,56,70,2,44,71,69,99,64,60,58,67,65,62,42,33,54,59,43,46,82,21,89,13,97,25,38,78,6,10,16,37,66,28,91,55],
[41,42,35,75,63,43,85,46,70,69,95,45,56,54,4,65,83,19,71,28,74,26,99,49,53,88,52,82,32,51,40,84,76,57,17,9,14,81,13,21,66,96,64,5,97,59,31,24,18,62,67,86,98,27,47,93,58,20,79,55,6,1,11,12,91,48,100,87,36,2,23,10,16,7,8,33,30,73,29,22,15,89,90,60,94,78,38,92,77,37,3,68,72,34,61,39,80,44,50,25],
[92,43,83,55,10,54,67,25,60,26,35,96,59,76,40,42,50,100,21,13,97,12,47,85,94,89,58,30,18,23,32,73,20,48,3,17,38,37,52,49,71,82,51,19,16,41,91,90,68,79,39,27,28,74,57,70,98,5,15,46,72,8,56,80,22,14,29,99,75,81,33,53,11,63,34,78,44,84,4,88,69,45,6,95,86,77,93,61,2,65,66,87,1,7,36,9,64,24,31,62],
[72,28,79,37,95,5,50,2,10,64,90,96,17,88,100,65,18,45,9,56,44,46,73,77,91,13,20,71,83,6,31,4,16,39,26,8,74,86,35,69,54,51,80,48,82,1,93,66,68,15,30,25,19,87,97,58,47,21,70,61,84,89,57,36,81,23,34,42,11,99,52,75,24,67,92,27,78,12,76,55,59,49,85,3,14,63,60,98,41,62,22,7,32,33,94,29,38,43,40,53],
[40,75,76,88,13,25,12,68,21,41,39,86,80,85,15,82,46,24,77,60,2,3,22,29,71,99,96,94,91,70,53,61,30,64,27,74,47,28,34,89,73,57,59,37,1,26,11,67,54,78,10,81,16,72,90,51,44,18,43,9,14,23,55,66,52,92,98,45,38,69,35,100,65,48,84,33,17,62,58,97,5,36,19,95,8,6,56,50,49,32,79,20,42,31,63,83,7,87,93,4],
[60,86,36,65,45,30,29,66,83,27,79,97,49,80,100,62,13,77,51,68,40,59,61,95,11,70,76,87,88,12,58,71,10,53,23,7,31,19,6,55,34,4,90,33,72,16,78,48,98,81,74,64,38,94,22,92,43,18,69,32,44,35,5,15,21,91,99,82,50,96,67,17,24,1,39,9,28,63,93,75,2,20,85,46,84,26,52,54,56,73,57,41,3,42,89,25,8,47,37,14],
[47,82,16,97,71,20,13,2,93,18,78,68,9,74,43,19,7,64,38,86,100,17,54,42,26,61,50,14,15,60,76,56,48,69,73,96,4,44,6,88,65,59,40,91,41,63,3,8,36,39,52,12,51,37,62,30,21,89,49,28,11,25,1,99,45,46,83,81,85,35,34,79,58,95,55,33,10,66,80,5,77,27,90,24,92,29,87,32,57,94,98,70,72,23,75,67,22,31,84,53],
[86,34,66,43,81,95,99,67,60,23,16,53,30,76,78,29,13,75,8,14,64,4,65,46,22,6,36,69,73,7,21,82,10,96,32,80,68,47,24,59,55,33,1,41,83,25,72,2,84,100,28,89,56,15,18,20,48,58,90,61,92,19,54,51,3,42,97,12,77,9,57,50,52,38,98,39,40,94,45,93,27,71,44,11,17,26,31,85,79,70,63,74,49,91,87,35,5,62,37,88],
[45,3,9,100,21,54,63,59,38,83,81,78,6,10,93,41,65,51,43,26,99,24,49,58,19,17,66,74,44,32,28,97,7,68,72,25,60,57,69,56,89,76,4,91,71,23,62,80,37,18,36,31,94,92,88,55,48,79,85,2,90,12,42,39,34,11,5,33,52,75,98,1,53,16,84,70,77,86,13,95,87,30,27,50,47,82,64,46,15,14,29,96,22,73,67,8,20,40,35,61],
[4,41,97,60,53,89,1,23,2,75,39,28,59,93,74,55,8,48,58,61,31,64,14,33,30,27,11,6,69,85,73,100,72,7,25,47,81,99,24,51,86,91,29,50,44,18,26,37,35,78,38,52,42,79,9,94,46,49,83,17,87,56,45,77,40,95,13,84,19,92,96,54,16,80,76,71,57,67,34,21,68,98,88,43,10,70,12,15,62,32,5,90,20,66,3,36,63,22,65,82],
[75,51,18,7,49,37,56,21,61,94,80,52,41,47,17,43,82,58,6,35,28,23,29,5,12,16,55,98,87,8,84,24,76,42,68,86,53,71,88,33,31,2,30,1,77,65,22,92,59,57,90,48,85,89,13,96,73,36,15,20,81,3,40,79,45,72,10,69,63,62,14,54,26,60,99,4,74,32,39,64,66,70,9,67,44,38,34,46,93,95,19,25,91,27,100,97,11,78,50,83],
[73,85,3,82,11,15,75,93,86,97,60,41,35,50,29,56,22,92,91,77,9,69,44,53,23,8,40,12,7,26,37,78,79,99,71,84,64,5,4,96,76,31,1,95,34,30,90,65,74,45,55,81,67,62,36,10,6,49,100,27,14,19,87,98,2,54,52,63,42,51,70,32,21,68,17,39,38,46,89,72,43,25,33,83,80,88,48,20,57,28,66,61,13,58,18,16,94,59,47,24],
[36,3,93,17,15,30,68,49,72,9,26,80,79,98,97,89,39,65,100,8,85,61,52,83,2,24,90,95,67,64,35,87,37,33,21,19,84,32,74,43,1,60,47,77,71,69,27,10,73,29,59,6,42,25,40,66,50,28,55,45,13,96,91,18,62,14,94,63,34,16,56,23,38,5,12,81,58,57,51,48,53,88,41,99,7,70,46,78,4,31,44,20,76,86,75,92,11,22,82,54],
[43,40,70,35,15,84,23,79,49,48,2,44,89,45,95,20,80,52,22,29,32,67,30,42,69,3,88,7,41,11,91,60,86,36,68,77,8,39,53,26,14,21,74,34,75,90,19,96,99,59,38,76,92,33,54,87,5,61,47,1,50,46,17,66,25,27,13,4,16,73,51,65,97,57,71,81,55,64,24,6,93,98,31,85,78,63,18,72,10,9,56,28,83,37,58,94,100,82,62,12],
[96,57,71,30,53,27,43,47,24,63,52,100,35,28,23,85,45,20,80,54,95,94,58,73,90,15,97,74,40,36,42,2,72,44,82,19,62,67,26,33,32,84,65,86,12,68,51,22,8,91,70,75,25,11,93,49,6,64,18,92,77,29,39,13,10,79,66,16,56,7,38,78,1,31,98,14,87,69,37,50,3,17,34,76,21,46,89,88,60,83,59,81,99,48,4,9,5,41,55,61],
[2,41,82,54,95,45,50,63,51,35,91,78,80,38,57,18,44,76,14,52,29,10,96,42,28,22,11,69,60,87,64,37,77,3,89,19,20,15,86,92,12,48,32,53,46,26,100,25,70,8,75,16,99,94,55,7,43,85,49,59,47,88,9,68,72,39,98,4,65,83,71,17,23,34,93,24,74,90,27,31,58,84,36,33,73,5,62,13,97,66,67,6,40,56,79,81,21,30,1,61],
[70,45,78,97,20,19,84,58,92,14,73,95,67,100,62,13,1,33,61,79,60,27,35,38,5,77,28,15,72,2,31,81,22,74,65,10,34,75,9,3,57,17,21,98,12,11,43,87,36,88,44,18,55,96,50,56,42,80,66,16,59,24,52,63,76,89,93,7,69,71,26,51,30,49,48,6,53,32,29,86,82,37,40,90,99,47,41,46,94,91,64,8,4,25,83,23,68,54,39,85],
[15,18,14,86,31,9,5,20,19,59,23,54,73,27,75,29,96,34,4,66,93,56,72,32,69,84,95,71,85,74,25,42,51,41,36,67,48,6,65,63,62,12,45,30,82,40,46,61,70,98,87,22,53,13,57,91,33,8,39,50,88,80,52,79,58,38,89,60,11,10,100,43,90,21,35,49,16,28,17,77,94,7,24,64,92,81,76,37,68,26,3,99,55,1,78,44,83,97,47,2],
[30,99,71,37,18,45,6,42,14,23,38,1,50,68,78,86,100,72,2,36,22,58,39,27,28,20,80,70,32,66,61,16,26,88,21,67,75,12,93,49,43,51,69,48,55,5,82,46,34,98,81,97,24,77,25,11,53,59,56,7,63,92,87,4,40,64,94,47,19,79,41,17,74,31,8,33,89,44,29,60,83,91,35,13,85,65,84,76,62,90,15,10,57,54,96,95,52,3,73,9],
[50,51,40,84,18,42,16,7,23,91,62,2,25,39,5,19,64,20,43,11,36,3,61,1,12,93,82,78,95,26,49,38,41,100,65,86,22,70,55,44,14,13,90,47,81,27,59,35,15,53,66,54,32,34,52,10,6,75,48,60,31,73,9,76,94,69,17,89,88,4,79,74,85,98,63,99,56,96,28,68,21,58,37,92,87,45,77,72,46,24,71,80,97,30,33,67,83,57,8,29]],
W =
[[64,48,45,92,63,80,21,32,65,38,93,86,67,47,26,33,70,30,85,82,52,100,7,56,27,71,11,50,13,61,77,15,12,20,79,31,84,23,36,34,51,53,9,16,75,76,98,60,29,62,57,22,41,25,54,69,72,78,74,19,42,55,37,89,5,88,2,46,24,99,49,4,94,14,91,58,87,59,81,10,17,6,97,1,35,39,8,90,44,3,83,43,73,95,28,66,40,68,96,18],
[1,36,91,96,27,46,92,6,81,38,89,58,97,37,78,100,18,48,22,77,90,68,30,73,14,71,74,47,95,29,33,79,63,2,86,11,76,93,52,32,49,15,69,64,66,41,70,26,57,98,84,24,87,12,80,43,10,17,55,94,44,62,67,7,65,56,72,85,75,31,35,50,4,20,88,34,83,16,25,3,39,53,99,28,13,82,45,59,54,19,8,9,23,40,51,42,60,5,61,21],
[4,1,14,75,97,3,12,21,29,34,10,84,27,83,40,23,33,47,58,90,22,5,85,79,76,86,72,98,37,31,65,45,67,11,62,6,74,68,95,7,69,26,77,49,8,46,28,54,59,51,20,44,41,36,93,94,82,81,63,78,25,43,60,57,50,18,32,100,53,38,13,19,56,88,92,15,35,16,42,30,55,70,52,24,73,66,89,61,91,96,99,17,48,80,2,71,39,87,64,9],
[54,27,60,39,53,47,22,15,31,80,17,55,59,50,5,97,66,32,65,23,1,94,64,13,18,92,77,49,51,61,2,85,58,95,29,52,12,38,89,83,9,68,69,41,48,87,4,21,3,36,99,96,79,63,37,10,82,7,6,81,24,86,90,56,34,44,57,84,14,46,8,74,72,30,71,70,45,78,35,16,26,28,93,67,76,98,42,73,91,19,20,25,11,62,33,88,75,100,40,43],
[6,91,65,33,57,75,76,12,82,78,89,40,11,46,56,52,30,42,44,63,1,22,41,39,49,37,7,47,68,83,70,35,29,90,86,5,13,53,59,79,64,31,77,10,32,25,48,80,14,26,4,60,27,93,8,85,28,66,84,71,23,21,87,73,88,67,38,81,19,36,100,50,16,98,20,54,2,99,18,61,9,15,58,97,55,95,24,51,74,96,69,43,45,92,3,94,17,72,34,62],
[12,33,5,98,64,6,56,38,68,97,75,14,95,46,1,26,78,8,20,86,3,28,35,10,62,21,34,92,15,67,29,44,49,76,94,90,63,40,77,51,23,30,85,25,17,91,57,55,31,60,69,24,37,7,79,65,89,2,22,58,41,84,54,70,99,47,82,59,88,61,32,13,50,16,4,74,71,73,45,72,96,19,39,53,11,81,42,48,83,52,36,66,9,87,43,100,18,93,80,27],
[16,36,65,52,62,87,69,57,12,46,97,9,10,5,8,23,2,28,100,42,40,72,64,55,53,80,56,26,14,47,27,21,99,92,50,75,41,68,6,3,38,67,20,49,24,89,18,17,63,59,60,77,78,22,79,15,73,71,61,76,34,58,93,85,98,94,39,54,1,4,33,83,81,43,7,31,48,86,51,19,70,25,37,13,84,32,88,45,30,95,44,90,91,96,29,66,35,74,11,82],
[70,25,32,13,31,57,91,7,36,14,55,61,21,48,28,77,3,72,47,15,78,46,60,86,10,18,53,84,88,98,9,16,96,83,27,66,80,2,62,69,54,74,6,29,92,33,97,73,93,4,8,26,51,95,41,71,23,59,38,11,58,87,90,34,5,42,52,22,17,56,40,94,1,75,35,49,79,85,19,100,68,89,67,50,82,24,37,20,12,81,30,43,63,76,45,39,65,99,44,64],
[94,59,7,55,56,38,60,21,69,53,37,47,66,76,57,1,20,52,27,89,23,43,13,49,25,10,74,65,26,84,14,19,33,79,30,67,41,86,68,75,42,17,72,31,28,78,22,5,96,87,46,51,34,40,45,70,71,2,80,95,9,4,11,61,18,91,6,12,39,88,98,8,32,54,93,97,62,29,35,100,15,64,36,90,3,48,73,50,63,44,82,16,99,81,77,92,24,83,58,85],
[61,15,2,27,29,71,58,51,96,16,31,89,74,64,80,76,79,72,10,14,100,41,37,36,13,25,86,94,56,52,28,33,82,30,70,19,20,97,78,55,49,53,90,34,26,75,38,3,68,40,83,67,84,18,12,24,23,93,22,87,47,81,92,35,65,98,32,54,8,69,63,50,43,59,62,7,73,11,57,48,39,6,5,60,9,4,45,91,44,17,46,85,95,66,42,1,21,77,99,88],
[63,47,59,33,80,97,70,76,20,12,13,29,78,34,24,54,43,44,66,18,83,8,91,81,73,19,85,84,77,79,46,27,17,41,30,75,15,45,60,50,4,5,3,90,64,39,56,32,89,23,94,31,55,9,52,49,92,67,28,1,38,22,26,42,51,2,87,71,68,53,96,7,35,69,98,74,58,82,61,6,95,25,72,11,14,37,100,36,40,48,93,65,62,16,21,99,88,57,86,10],
[60,41,58,30,27,19,42,52,56,69,65,17,13,70,62,4,95,78,34,49,64,61,74,82,68,5,36,40,89,99,76,85,88,53,93,66,9,86,20,81,12,24,47,15,31,72,26,67,6,32,54,14,7,73,97,45,10,87,77,71,94,98,37,22,29,57,18,44,84,3,79,1,21,50,43,51,39,63,2,55,96,35,28,8,16,91,48,46,92,38,59,11,25,100,90,83,33,75,80,23],
[64,5,70,53,58,90,59,30,51,62,42,82,55,88,57,68,29,97,100,73,19,32,89,60,99,76,18,43,2,71,91,25,66,49,37,24,47,86,28,61,21,14,23,94,98,17,92,8,87,74,16,78,11,45,84,36,6,12,26,52,81,31,35,4,75,3,41,95,40,50,33,9,13,56,1,72,48,85,39,10,93,20,63,83,69,38,65,7,77,27,46,67,44,34,22,79,54,15,96,80],
[99,56,53,43,70,48,20,78,82,34,83,90,40,95,13,76,25,15,5,22,74,32,39,35,86,68,60,50,91,67,44,55,31,8,71,89,64,85,58,46,27,1,36,23,52,30,63,75,98,6,24,47,96,33,77,80,94,84,2,19,69,51,7,73,10,41,11,26,88,87,18,97,59,28,66,29,72,49,57,3,37,9,17,38,4,61,21,14,100,92,81,16,79,93,45,54,42,65,62,12],
[1,56,20,53,74,98,34,77,29,26,66,100,16,72,24,17,3,50,63,32,46,43,99,97,27,49,45,95,41,80,64,47,89,81,79,54,57,25,15,33,86,62,11,36,67,70,48,75,19,38,7,28,78,31,61,2,68,93,13,65,51,21,59,55,94,87,73,42,60,8,82,14,22,37,18,35,6,92,4,88,5,96,39,69,85,84,30,52,71,90,10,76,58,12,91,83,44,23,40,9],
[45,99,51,88,47,95,56,85,65,33,42,58,100,43,1,93,26,57,20,30,18,70,11,92,76,82,87,25,10,37,13,12,32,75,90,79,27,48,97,89,3,52,22,64,28,73,40,98,60,61,9,91,4,55,63,29,77,23,21,2,86,36,5,84,16,7,94,83,41,78,96,72,35,68,80,24,66,15,69,74,71,54,6,17,39,81,62,31,14,67,38,50,8,49,46,19,34,44,53,59],
[62,39,78,27,6,98,33,100,44,69,45,82,22,24,84,31,63,46,90,85,35,56,43,77,49,47,97,34,8,32,87,99,89,40,37,51,86,17,13,41,72,4,92,52,23,15,30,50,18,10,65,80,25,48,12,59,5,73,29,54,14,38,42,91,7,76,57,53,16,19,58,79,95,68,26,20,3,21,9,1,93,70,96,81,75,64,2,71,83,61,94,88,66,28,60,74,55,67,11,36],
[88,58,78,36,49,44,87,72,10,13,26,21,30,39,29,57,84,97,94,81,12,73,80,100,56,16,98,41,6,95,7,19,53,1,82,66,92,9,59,37,15,25,99,43,47,79,4,52,40,48,46,62,8,32,64,70,50,76,31,51,23,90,33,61,96,60,38,28,3,69,55,17,35,68,18,77,5,11,24,20,45,67,2,65,75,85,93,91,14,74,63,27,83,34,86,42,89,54,22,71],
[50,40,29,79,59,44,67,3,42,93,10,63,58,25,36,95,32,24,66,26,100,23,8,20,22,68,15,38,19,86,47,70,61,31,91,64,46,14,49,81,94,28,74,37,76,56,18,9,89,11,85,13,21,34,5,99,12,65,96,71,90,92,17,51,78,97,35,72,1,53,83,87,45,98,41,75,33,55,77,6,84,2,80,54,48,57,7,30,52,27,4,16,82,62,60,43,69,88,39,73],
[8,62,68,11,79,77,53,67,10,27,47,3,72,6,99,95,88,97,30,22,71,92,33,45,28,55,36,13,34,40,81,46,23,73,86,49,14,51,54,70,5,64,66,20,7,91,59,42,87,83,58,31,63,16,26,12,50,37,15,100,21,38,78,35,17,52,1,80,43,39,76,96,69,24,57,56,85,94,98,4,65,29,60,89,41,82,18,19,84,32,48,9,2,25,93,90,44,61,75,74],
[4,61,59,33,17,90,53,98,29,86,12,5,81,42,55,60,73,94,43,91,23,24,35,89,20,57,75,52,10,69,77,7,78,82,11,30,58,26,9,54,2,1,45,83,21,46,15,64,50,100,96,22,19,99,56,27,49,74,44,88,62,79,13,25,39,16,14,87,38,63,67,32,31,84,51,66,36,28,18,8,40,76,3,47,85,92,70,68,93,71,48,34,97,72,65,37,41,80,95,6],
[24,29,22,99,23,37,81,44,38,71,17,65,50,77,18,87,55,90,39,92,62,43,72,6,83,78,67,69,64,76,95,16,68,49,86,59,10,54,30,63,61,19,97,4,1,70,93,41,46,48,80,13,5,52,82,91,85,35,51,94,73,2,36,45,8,32,60,7,75,21,66,9,96,14,88,53,84,33,40,58,47,98,100,3,12,15,74,26,79,56,57,27,89,28,42,31,34,20,11,25],
[18,49,19,45,85,38,28,17,64,46,36,40,55,24,47,67,15,43,10,48,77,4,16,100,50,81,71,86,1,14,54,3,66,61,33,51,25,74,41,11,52,60,34,63,94,53,20,91,37,30,2,21,13,32,97,56,75,6,95,8,35,73,98,12,87,80,76,26,99,7,65,62,89,23,9,68,5,59,82,79,84,44,70,27,92,72,96,29,93,78,31,69,22,39,57,83,88,90,42,58],
[64,8,7,2,71,59,53,87,68,83,73,51,9,1,69,19,40,37,97,61,66,57,55,10,36,21,98,30,47,62,94,88,28,16,24,63,81,15,4,23,74,25,41,93,44,26,84,6,42,22,43,38,17,29,91,13,89,60,56,14,5,11,48,31,45,80,79,67,85,32,52,77,92,34,72,76,58,18,90,65,54,39,27,12,95,100,49,3,82,96,78,70,46,35,20,50,33,75,86,99],
[65,39,1,22,27,13,56,66,81,85,28,75,96,19,15,54,9,63,68,93,23,61,82,77,100,64,8,98,45,52,4,57,67,2,74,78,86,62,16,7,46,59,43,69,71,33,10,48,99,90,79,24,26,5,29,47,41,60,94,11,37,34,58,6,87,53,51,83,21,97,88,55,36,18,17,70,3,92,20,30,25,76,31,40,72,84,35,32,91,49,50,38,44,89,14,95,80,73,42,12],
[21,27,20,80,45,86,48,34,11,49,57,51,91,38,28,81,5,92,32,73,25,15,68,56,64,97,95,39,87,89,78,67,14,61,3,24,63,71,30,29,59,65,37,36,70,17,6,42,7,66,22,13,72,2,19,43,44,75,41,84,46,54,26,31,96,83,85,52,77,9,35,18,16,40,8,76,1,50,90,60,79,74,99,58,33,82,10,88,23,47,94,98,4,55,100,93,69,12,53,62],
[57,80,89,50,12,20,52,45,33,73,32,78,61,44,58,71,54,98,25,34,86,38,10,72,2,4,67,23,11,6,94,53,68,18,41,56,100,76,24,19,26,88,69,15,47,16,60,63,96,62,90,75,99,64,95,65,17,46,21,79,48,74,8,3,35,81,22,29,30,97,77,27,9,28,51,36,55,39,82,93,85,66,13,31,87,83,59,43,70,91,1,7,40,84,42,5,14,49,92,37],
[100,29,11,14,23,70,76,67,6,95,89,73,45,55,40,44,50,43,93,16,17,85,57,49,81,82,64,79,26,98,97,58,77,60,71,74,46,15,86,39,94,5,4,8,90,99,75,80,91,65,19,27,52,21,87,22,25,7,12,2,53,20,83,66,9,96,78,24,42,63,84,10,13,47,72,48,88,35,68,61,41,28,3,18,56,59,37,38,30,33,62,69,31,1,34,54,32,51,36,92],
[41,56,84,18,10,89,91,100,23,90,65,49,61,47,59,69,32,25,35,97,71,53,93,13,82,80,72,17,78,43,40,77,68,45,16,98,48,22,7,54,63,76,42,21,94,52,92,88,27,9,12,11,14,55,64,66,74,38,83,1,70,37,29,24,67,20,8,6,5,28,33,62,15,85,57,51,46,96,73,79,75,39,44,87,36,4,34,86,81,60,2,58,31,99,19,95,30,26,50,3],
[26,99,14,68,29,28,6,54,1,45,50,13,78,86,46,33,97,40,100,12,35,92,38,53,15,63,36,39,48,42,21,25,51,90,31,77,60,80,74,8,5,73,67,7,18,62,87,96,47,85,59,57,75,93,95,22,71,76,4,44,81,27,79,3,55,66,98,64,89,58,72,52,24,88,30,17,23,9,82,70,11,65,41,19,34,10,37,20,43,56,61,32,16,83,94,91,49,69,2,84],
[59,3,5,14,9,62,50,88,17,83,19,56,37,64,82,31,61,98,94,7,43,78,45,8,66,40,97,52,42,49,4,81,87,27,25,65,12,26,34,51,10,76,15,95,75,38,84,68,71,36,54,100,58,63,6,23,74,77,99,20,90,32,33,60,86,96,30,72,92,39,22,24,57,73,91,2,53,13,69,41,47,21,46,35,89,67,55,29,93,11,85,1,16,48,28,70,18,79,44,80],
[65,13,71,37,66,51,24,67,84,99,74,35,28,23,86,53,36,43,80,25,78,96,50,97,48,69,63,40,14,85,73,26,10,18,98,33,42,94,90,91,75,61,3,5,17,30,29,68,92,79,1,82,89,93,81,70,21,64,76,34,59,12,62,15,11,6,4,47,55,39,60,57,38,52,54,20,45,7,32,46,19,56,22,9,72,27,87,77,83,41,58,49,100,8,31,2,88,16,95,44],
[87,88,44,74,43,78,3,77,59,58,13,71,82,27,16,28,49,100,66,86,32,6,93,47,79,52,65,7,26,23,5,24,84,36,42,73,97,56,20,22,45,50,80,57,17,85,53,34,83,14,60,67,96,29,99,37,31,39,70,54,95,9,11,38,4,69,64,33,92,8,12,94,10,68,25,41,35,76,15,63,75,55,91,40,72,98,48,90,18,46,62,61,19,51,81,30,89,21,1,2],
[2,17,33,65,4,49,8,9,44,10,64,73,68,51,27,19,100,70,57,67,97,34,48,18,86,99,3,88,53,81,90,42,6,66,41,46,25,96,7,52,82,43,29,50,5,1,35,85,95,89,15,76,60,56,79,94,55,14,11,58,54,71,37,26,13,59,92,93,36,69,83,80,74,31,28,21,45,91,22,47,63,78,87,84,72,23,24,77,12,40,32,20,61,62,16,30,98,75,38,39],
[38,65,68,17,79,82,83,47,3,92,12,41,10,29,77,66,28,34,74,15,87,58,97,67,45,62,59,78,64,98,80,70,4,7,49,76,63,36,71,90,53,31,85,18,14,25,86,51,21,55,69,6,84,8,13,42,52,37,44,39,26,11,56,48,93,16,54,75,9,32,61,35,50,100,72,22,73,1,20,46,33,24,2,88,94,40,30,19,27,99,57,60,81,43,91,5,95,89,96,23],
[76,65,56,80,87,22,10,78,42,14,95,32,5,92,40,81,4,34,49,68,6,74,44,58,7,63,60,89,57,91,8,93,24,88,37,2,35,94,26,71,99,100,85,18,31,96,55,84,25,98,61,48,70,39,19,38,15,66,67,47,59,20,29,75,50,28,97,27,79,69,53,3,86,16,23,21,82,51,46,62,77,33,43,41,12,52,90,13,54,45,30,17,83,1,73,9,36,11,72,64],
[32,35,14,87,78,13,61,31,48,4,7,85,10,6,53,33,63,20,39,2,75,41,16,26,19,5,89,34,24,17,18,99,27,58,71,92,57,8,97,44,21,38,50,64,29,70,62,91,23,66,69,1,12,30,42,80,94,45,77,72,96,55,93,47,36,49,73,54,28,46,43,79,84,59,90,86,100,11,60,88,76,25,9,56,37,74,40,65,98,82,51,67,68,81,15,83,95,52,3,22],
[98,59,5,7,10,63,68,27,47,15,75,3,21,2,49,18,38,84,77,90,92,39,85,26,79,55,71,60,32,48,23,4,56,70,20,86,100,44,19,34,61,46,8,95,31,76,37,54,33,80,67,96,83,73,69,36,81,57,12,43,52,65,45,74,82,78,40,14,6,11,93,64,53,58,9,13,25,16,62,87,22,24,66,30,41,1,42,91,72,89,50,88,35,99,29,97,94,17,51,28],
[11,54,52,39,2,76,81,70,16,5,69,29,44,86,78,33,91,12,83,21,6,56,99,47,82,51,41,4,8,96,58,50,59,93,35,95,64,17,100,1,85,23,98,80,73,25,72,13,62,84,45,19,46,36,20,15,31,60,22,67,37,42,65,57,27,89,38,32,55,75,53,9,77,40,87,90,94,3,92,71,48,28,18,68,43,79,24,88,34,30,26,74,61,7,14,66,97,49,10,63],
[36,61,68,32,74,33,62,17,81,3,40,23,18,77,24,73,13,48,46,41,51,28,84,26,39,45,79,88,70,54,27,35,44,7,37,95,30,92,85,71,55,47,25,56,58,87,78,64,10,29,75,50,22,89,91,1,57,53,63,99,34,59,86,52,98,67,20,16,38,49,21,82,93,4,6,2,72,76,90,11,94,80,5,42,66,96,9,97,31,43,65,69,15,83,19,12,14,100,8,60],
[92,97,70,8,20,14,86,89,2,40,35,78,75,68,72,37,52,50,36,22,24,67,91,34,45,60,56,98,18,17,66,90,87,30,21,9,85,59,93,16,76,61,71,42,44,28,5,58,25,82,57,15,96,23,13,65,79,83,81,31,49,55,53,95,12,69,7,32,3,54,47,10,80,64,74,39,62,99,46,88,6,26,4,84,100,1,94,19,77,33,73,27,11,63,43,41,51,38,29,48],
[44,65,4,36,69,31,8,17,59,82,78,18,67,41,74,68,37,53,99,92,83,80,63,21,56,14,85,32,51,27,1,93,50,39,84,66,7,52,28,60,5,23,24,94,95,29,13,62,55,11,12,40,89,77,47,30,10,96,15,48,100,49,75,45,34,57,54,2,79,35,98,19,97,90,38,22,43,86,73,16,72,42,88,6,87,81,33,61,20,58,91,9,3,70,71,76,46,64,26,25],
[18,43,3,52,41,92,57,38,47,49,81,58,30,90,69,20,64,98,93,40,79,85,83,99,62,60,82,59,31,15,94,14,9,50,36,87,76,73,34,63,61,17,91,26,32,24,45,11,27,54,29,22,86,33,44,71,10,12,95,1,6,8,80,100,13,16,84,7,74,96,78,25,65,72,89,97,67,37,55,70,46,68,28,39,4,75,51,23,48,42,88,56,35,66,53,19,2,21,5,77],
[54,73,3,100,67,66,34,2,63,88,48,82,9,64,17,44,52,47,14,39,29,79,35,85,32,7,68,28,10,49,25,15,45,40,21,61,56,4,11,74,6,46,76,53,31,5,92,87,60,83,96,37,12,90,81,55,36,70,91,98,27,84,65,95,57,77,30,26,69,89,86,41,50,75,13,20,1,18,24,42,51,8,16,22,43,80,78,33,59,58,99,23,19,62,71,93,38,97,94,72],
[42,9,27,54,74,24,72,80,44,55,66,90,95,14,6,71,50,5,52,28,25,94,2,61,53,37,75,15,46,83,20,51,91,68,13,59,98,38,92,40,100,86,63,70,10,69,87,19,36,32,33,78,35,89,17,4,88,26,48,64,18,79,45,76,81,97,23,99,65,57,11,29,43,47,96,77,16,3,8,12,62,22,93,39,60,84,82,34,67,21,73,30,49,1,31,85,41,56,7,58],
[45,11,3,54,38,93,83,91,57,15,33,89,1,36,72,98,37,99,75,77,94,48,28,5,96,59,88,24,40,34,60,41,76,87,22,29,71,17,46,56,39,78,20,26,10,79,13,66,51,80,42,43,62,68,58,85,7,32,44,49,100,95,14,8,35,65,16,21,55,30,69,23,61,73,86,19,4,67,9,84,25,53,70,92,47,18,6,31,82,63,2,27,50,81,97,74,90,52,64,12],
[72,28,24,26,88,66,4,53,8,2,21,76,90,99,97,81,70,79,9,12,38,3,41,86,59,77,49,25,37,98,100,47,75,60,32,95,61,69,29,16,64,36,54,45,55,80,85,50,57,67,10,51,83,52,78,48,34,39,94,44,65,27,84,14,71,73,17,6,89,20,87,7,5,35,92,46,11,23,30,63,13,58,33,43,93,15,74,82,62,68,42,56,40,19,22,96,18,31,1,91],
[4,34,99,81,90,51,97,84,11,17,93,82,60,98,36,38,2,58,23,5,96,100,18,21,79,64,83,42,14,68,39,65,41,35,20,47,95,25,24,77,75,53,66,13,61,71,1,46,29,72,3,12,91,55,45,69,33,44,86,62,88,32,16,78,27,59,94,6,40,37,89,73,28,92,87,85,19,52,9,63,80,70,57,30,54,43,56,67,48,7,74,50,15,22,8,26,76,10,49,31],
[84,81,33,46,56,11,64,77,12,23,22,73,51,65,18,67,58,42,21,24,49,63,97,36,59,68,9,62,25,13,41,61,76,87,88,37,20,7,54,78,95,83,90,16,10,75,45,17,80,93,79,28,70,14,35,53,29,1,5,34,31,57,2,32,30,74,55,3,38,44,86,91,98,94,26,52,72,15,96,100,89,99,48,40,6,66,60,50,8,47,82,92,27,43,19,39,71,85,4,69],
[49,33,82,34,25,32,56,36,18,76,40,14,84,64,79,28,96,57,77,17,27,2,35,92,37,21,83,43,91,71,10,48,90,85,5,38,78,12,22,94,15,29,87,58,54,47,1,98,31,52,80,46,11,69,6,67,63,19,24,66,88,59,8,41,50,42,60,13,30,89,68,23,74,9,75,93,81,61,73,45,100,95,97,72,44,4,53,62,26,99,16,39,70,86,3,51,55,7,65,20],
[72,85,52,25,6,64,29,28,35,70,31,79,78,10,43,17,50,34,15,45,26,33,80,8,19,30,77,42,36,67,4,22,76,51,92,99,81,46,95,14,12,53,5,20,65,89,18,74,57,32,93,71,83,37,86,41,87,13,61,9,48,58,88,75,54,11,69,62,56,60,47,24,16,82,100,3,97,44,94,38,66,2,49,21,23,84,96,68,91,40,39,27,90,55,1,73,98,7,63,59],
[89,27,45,46,73,92,20,76,33,37,5,63,8,13,38,12,36,9,24,26,90,86,88,2,65,68,87,61,29,51,54,11,60,56,28,95,98,77,4,67,35,17,18,66,34,96,43,74,97,22,7,62,32,57,100,80,99,44,31,50,55,94,21,1,49,75,10,79,72,84,58,70,59,19,25,71,30,93,23,53,39,6,16,42,15,82,69,64,85,81,83,48,47,14,91,78,3,52,41,40],
[35,16,11,10,91,37,28,2,99,58,78,52,38,3,33,62,61,82,98,51,66,83,19,100,87,89,93,86,59,1,97,49,46,73,21,8,39,72,20,29,60,85,9,32,50,27,22,54,68,45,31,7,84,40,25,55,80,74,48,6,18,14,12,63,56,79,15,47,5,94,43,95,81,96,77,24,57,53,36,17,71,41,4,65,90,76,26,88,92,34,75,67,70,44,69,64,23,42,30,13],
[40,80,66,39,59,38,71,95,7,44,55,62,100,2,50,21,26,63,9,67,60,6,91,56,93,54,23,41,79,99,30,89,35,70,20,98,11,87,42,18,96,58,85,83,10,36,32,37,73,52,86,49,88,8,65,33,4,34,82,43,92,46,14,84,45,68,5,13,17,81,1,22,64,15,48,75,72,74,16,78,29,69,53,25,27,90,76,97,57,94,24,12,61,51,28,47,3,19,77,31],
[12,43,74,20,6,67,39,32,36,58,10,71,14,77,41,92,72,31,95,51,80,68,17,96,23,2,3,60,50,82,37,81,27,84,55,16,21,97,11,59,9,66,47,26,5,4,87,19,70,100,69,78,44,7,57,40,79,94,91,8,54,62,73,63,88,93,30,86,13,34,48,64,25,18,33,24,42,52,35,38,85,1,83,89,90,29,49,22,45,53,76,98,46,61,28,65,99,56,15,75],
[71,40,50,87,28,19,55,94,89,36,4,77,74,88,81,84,23,60,92,75,42,56,10,46,47,48,85,29,80,67,38,83,79,26,57,91,59,96,98,5,45,8,90,35,25,16,31,6,52,14,99,82,97,66,58,34,69,61,32,9,54,27,78,12,1,2,53,100,86,62,93,70,49,13,73,21,43,11,65,72,7,64,15,18,51,76,39,95,30,41,63,22,37,33,24,20,3,17,68,44],
[93,53,76,88,92,35,47,37,83,51,91,22,54,11,57,73,87,6,81,15,36,56,100,12,95,9,8,34,98,72,44,82,19,38,48,1,3,24,59,60,79,4,25,67,40,16,26,42,96,61,20,63,45,52,62,17,75,58,71,14,43,28,30,27,18,85,2,50,31,74,39,84,49,69,66,89,70,65,10,99,77,94,78,68,5,7,29,13,80,21,46,41,32,55,90,64,23,97,33,86],
[35,70,30,56,18,31,91,52,1,77,39,49,63,92,40,75,83,80,88,16,36,38,47,86,12,89,53,90,32,3,82,29,28,72,37,87,99,21,98,45,15,6,79,14,13,60,20,58,26,74,61,7,5,64,67,43,78,46,44,95,41,68,84,51,76,19,96,59,71,17,9,42,11,93,94,73,100,2,55,27,69,34,57,65,66,62,8,4,23,81,10,50,25,48,85,97,24,54,22,33],
[53,2,15,11,24,28,88,84,43,32,33,6,46,57,52,27,19,50,14,10,90,73,67,35,17,69,25,74,8,92,86,45,18,83,3,71,82,21,38,66,65,93,23,95,94,7,78,40,16,13,89,5,59,64,68,99,79,22,98,70,44,49,61,42,100,96,63,58,97,39,72,77,48,26,1,62,37,29,20,56,47,12,54,55,91,85,76,31,34,41,51,87,9,75,81,36,4,60,30,80],
[27,37,80,36,48,92,21,53,91,1,60,95,84,8,86,28,87,33,6,93,16,23,18,4,43,2,20,15,69,58,85,82,47,97,99,61,79,17,50,68,39,35,100,76,44,94,38,65,96,70,62,90,46,51,72,25,45,74,83,88,73,10,3,40,75,31,29,57,5,78,30,71,64,81,14,19,41,54,7,98,9,55,22,42,26,11,89,24,49,63,66,12,32,67,34,13,77,52,59,56],
[14,93,85,91,62,53,39,12,9,94,79,8,26,15,61,88,20,28,18,77,19,1,21,68,54,67,59,81,65,2,10,56,16,64,36,69,87,43,49,75,66,78,86,92,5,38,29,41,22,23,80,31,6,82,58,30,32,37,97,40,99,51,89,47,11,17,72,73,60,50,90,44,52,3,42,33,76,84,34,71,25,98,83,48,63,45,96,46,13,100,57,24,27,70,4,7,55,74,35,95],
[21,66,64,63,57,28,12,16,38,68,2,69,48,19,49,77,72,91,6,97,95,90,96,22,62,45,23,59,53,87,29,85,20,83,73,81,71,92,88,5,32,74,65,10,36,37,11,70,43,35,31,8,78,75,7,30,50,89,52,46,40,79,86,24,34,94,82,54,42,4,3,56,93,58,39,76,13,17,55,1,67,60,14,99,98,44,26,27,41,84,33,9,47,80,25,51,18,15,100,61],
[25,43,61,27,97,83,41,18,51,24,62,16,28,99,93,64,85,42,55,63,46,78,4,14,40,20,6,44,57,36,13,89,70,87,30,98,80,10,23,38,26,9,29,54,79,1,100,50,60,74,59,12,92,71,53,35,19,67,8,21,34,69,52,5,39,45,7,95,84,91,66,65,15,37,94,47,73,17,48,72,49,2,31,22,56,32,11,58,76,33,88,68,86,3,77,96,81,75,82,90],
[50,62,1,85,97,42,16,47,59,93,8,90,79,74,86,17,95,70,31,81,67,30,23,53,40,71,91,36,88,4,48,54,43,7,15,82,66,100,64,94,46,14,34,68,37,56,35,2,99,41,96,18,24,22,32,98,20,21,19,77,78,57,61,92,89,12,6,29,11,49,60,55,80,27,72,69,83,58,75,28,38,25,63,73,87,44,84,3,65,13,51,9,39,52,26,45,10,5,33,76],
[11,58,26,43,15,46,95,90,57,4,37,41,22,12,19,1,52,96,23,81,99,64,76,51,34,47,98,50,83,38,71,75,94,7,3,32,45,53,62,85,59,49,63,9,97,93,70,86,39,74,6,91,66,44,30,24,35,78,17,54,33,8,67,84,73,100,69,21,40,48,14,16,88,56,27,92,55,65,25,31,2,82,79,87,42,68,60,10,72,61,28,13,80,89,5,36,29,18,77,20],
[11,94,92,68,27,48,36,51,8,2,12,45,86,52,55,47,99,57,21,10,46,78,4,6,71,64,76,26,91,16,73,79,35,70,98,72,5,80,32,63,65,15,19,7,30,60,54,44,1,66,85,20,100,3,58,69,43,82,31,75,53,56,87,24,67,95,14,74,34,9,84,77,25,62,42,29,49,81,40,59,33,17,93,18,88,83,23,28,90,22,41,37,13,50,97,61,96,38,39,89],
[12,29,84,95,62,14,16,44,36,42,9,99,97,1,98,19,76,52,78,26,65,79,32,73,82,17,59,38,18,51,87,60,45,2,13,31,56,28,10,90,7,92,80,40,81,89,63,20,6,61,11,25,91,5,22,68,58,66,54,100,8,27,70,86,75,64,41,57,96,39,43,37,15,93,55,30,3,74,33,23,67,4,94,53,71,49,69,21,88,46,50,35,83,47,72,34,24,48,85,77],
[84,3,34,70,25,67,43,31,14,52,22,72,69,13,50,2,49,64,42,32,16,74,58,39,97,71,68,5,57,76,59,55,41,61,38,66,98,54,94,4,12,73,29,27,90,56,26,100,15,44,33,21,18,95,37,20,60,35,30,19,48,23,51,65,87,46,77,82,6,93,85,80,89,79,40,45,24,47,11,1,92,53,96,8,75,17,88,10,83,62,28,78,81,63,91,86,7,36,9,99],
[89,74,40,38,85,52,77,67,68,94,45,63,99,47,61,48,53,15,55,100,80,19,58,95,23,14,78,70,87,86,11,56,51,71,34,88,12,7,84,10,30,49,32,25,3,24,16,31,35,96,37,81,66,50,44,69,98,1,65,62,64,13,27,43,73,92,91,20,82,22,54,2,39,29,18,57,9,5,72,79,4,93,33,21,17,8,60,26,6,46,42,97,28,36,59,90,75,83,76,41],
[61,13,40,3,11,99,63,100,82,16,29,79,50,76,77,30,94,68,93,86,71,51,96,42,33,58,37,45,69,25,54,85,35,74,5,70,47,89,28,43,10,38,98,8,31,56,34,39,67,19,65,15,84,80,23,95,75,1,12,73,91,27,97,57,59,53,18,14,21,7,48,44,62,52,36,81,41,32,55,46,20,2,88,22,60,17,87,66,4,9,78,72,6,90,83,92,49,26,24,64],
[53,54,11,16,64,75,52,34,66,85,36,92,89,4,10,15,42,1,39,5,24,72,99,43,81,86,25,63,80,41,57,19,91,6,88,17,51,37,58,97,68,3,28,95,55,94,50,56,18,65,14,76,26,23,83,20,93,21,59,8,30,27,38,82,29,62,77,67,96,87,46,32,47,69,9,44,40,98,61,12,49,45,71,79,74,33,48,60,90,78,22,70,100,35,84,2,7,73,13,31],
[80,16,28,63,92,11,52,59,26,20,4,69,51,79,99,55,97,58,61,1,75,90,78,27,71,33,70,66,17,14,41,46,68,98,9,65,60,72,37,42,54,3,43,40,38,50,2,87,73,8,94,56,85,31,30,95,36,5,48,10,84,64,88,57,24,45,22,39,25,12,100,67,34,76,19,89,23,74,13,21,53,82,49,62,32,86,83,15,81,44,93,47,18,6,35,96,7,91,29,77],
[28,4,34,74,82,20,84,10,92,77,51,33,89,53,45,80,38,11,67,83,14,18,95,1,65,99,79,36,94,6,41,3,50,54,24,44,43,69,29,61,9,25,15,52,96,39,72,85,90,19,2,97,48,73,12,30,86,49,8,56,64,93,40,76,26,66,71,78,62,98,21,91,63,23,47,46,32,13,75,35,58,22,88,100,37,55,27,59,17,87,57,42,7,70,5,68,16,31,81,60],
[6,97,77,52,69,79,26,1,95,10,76,13,48,33,96,72,62,44,85,84,53,49,91,88,90,22,60,98,30,80,65,64,24,9,54,42,45,74,83,59,19,21,86,3,50,100,2,82,81,93,31,4,18,20,17,70,89,23,73,55,29,28,39,66,51,16,8,27,92,57,63,7,11,47,25,40,14,94,38,35,46,71,99,61,32,15,56,12,36,75,5,78,67,87,34,37,41,68,43,58],
[57,91,94,100,75,37,93,17,18,72,59,82,10,51,73,11,98,31,87,40,62,88,41,7,68,47,33,77,58,28,15,23,78,5,25,63,38,29,19,79,60,16,50,92,74,71,42,13,76,46,80,86,70,34,52,67,85,24,66,84,55,9,64,97,49,89,4,35,1,44,45,69,53,26,20,48,39,99,65,36,12,54,3,43,30,14,27,96,56,90,83,2,8,6,61,81,22,95,21,32],
[47,5,37,66,20,11,98,54,34,17,84,31,6,27,78,35,19,72,77,3,64,26,93,75,41,52,86,18,14,63,50,90,49,36,88,51,58,43,33,70,32,80,13,40,62,24,9,95,30,60,15,100,45,67,55,2,7,28,29,42,48,82,87,76,38,25,83,89,39,92,91,59,65,74,22,94,10,1,97,57,69,81,61,12,68,46,44,99,73,71,21,4,56,16,8,85,79,23,96,53],
[53,22,70,92,13,3,35,76,40,26,48,62,65,96,32,56,14,66,73,45,38,67,74,43,44,7,69,61,97,4,28,25,41,8,63,36,24,17,1,18,58,2,29,81,78,34,9,10,94,57,99,51,39,80,20,72,27,95,59,12,6,23,49,93,87,84,75,55,85,68,42,77,30,100,64,54,33,37,52,50,21,31,11,47,89,46,86,19,98,5,15,90,60,83,16,71,82,91,88,79],
[77,10,49,89,93,58,41,66,50,47,18,67,88,90,94,53,15,78,79,20,43,48,64,57,35,21,80,74,70,76,11,9,56,33,8,6,19,26,32,87,46,1,96,99,16,73,83,54,14,69,22,52,91,62,60,39,84,3,68,7,85,38,31,24,45,17,51,98,5,72,12,34,71,13,81,23,29,97,86,55,27,28,4,82,100,59,36,40,44,65,92,61,25,30,63,42,75,37,2,95],
[1,89,59,32,16,18,99,78,66,71,55,97,94,37,2,45,19,96,76,62,79,28,73,26,43,84,21,15,44,29,30,25,51,65,38,57,68,56,95,50,52,36,22,24,17,33,88,42,7,14,83,48,9,3,93,85,20,72,41,49,87,10,81,60,8,91,98,63,5,67,39,77,75,40,90,46,34,80,31,35,23,27,86,61,70,53,12,6,47,58,11,54,69,74,4,13,100,92,82,64],
[80,46,73,91,77,79,43,82,76,44,39,89,29,10,20,83,42,30,59,5,22,67,96,50,18,19,37,57,25,68,40,48,85,84,71,28,56,27,14,33,93,38,41,58,2,98,24,11,16,6,54,92,31,69,3,26,100,65,52,34,7,12,72,55,51,9,95,97,63,60,45,74,87,4,23,99,15,47,13,81,1,8,36,70,75,32,53,64,61,66,17,86,49,90,78,35,62,21,94,88],
[28,16,55,19,83,58,48,37,15,6,74,43,56,86,89,46,88,24,2,73,7,79,45,72,71,40,77,64,93,60,25,44,30,17,41,4,38,70,54,32,36,42,69,81,34,90,13,50,31,49,92,78,10,99,14,59,85,95,100,11,65,20,62,87,57,66,82,22,97,9,67,8,47,76,26,61,68,27,52,21,53,1,75,5,39,84,29,33,98,96,23,94,91,3,35,51,63,80,18,12],
[43,69,41,91,82,73,38,8,15,100,23,24,68,84,12,48,71,72,34,25,97,67,96,39,26,20,6,99,22,77,56,98,44,76,65,94,80,78,5,60,14,7,29,9,79,58,89,11,10,28,62,87,19,93,75,92,37,64,88,86,42,30,4,35,45,63,36,70,16,33,27,21,51,17,3,54,55,32,57,74,83,1,50,18,66,49,31,95,90,81,52,61,47,85,2,53,46,40,59,13],
[85,67,84,71,91,97,98,15,35,64,24,48,40,58,29,75,13,23,51,52,36,37,47,96,53,76,89,90,83,11,45,10,44,59,54,78,99,50,100,68,27,92,26,66,60,69,1,63,12,86,49,39,93,21,80,32,82,79,57,34,43,17,25,30,77,6,2,3,70,46,41,88,62,73,87,4,72,28,95,22,5,38,33,55,8,20,94,74,65,42,14,31,19,18,56,81,16,7,9,61],
[2,58,100,63,1,38,76,70,82,21,12,85,42,7,66,81,19,51,92,88,40,54,33,45,30,69,27,28,73,16,8,22,83,52,20,35,86,11,72,36,75,61,80,55,64,68,71,47,93,97,77,48,44,59,31,10,34,57,56,53,87,46,9,60,14,26,23,41,4,32,94,74,17,39,99,90,84,49,62,50,91,5,15,95,96,24,78,67,13,18,37,65,6,43,3,25,79,98,89,29],
[66,64,27,21,56,58,99,24,12,8,30,89,62,72,69,5,94,9,29,82,70,60,78,81,52,28,96,57,42,68,48,61,37,74,34,22,85,38,93,83,2,11,87,90,98,3,14,73,100,97,95,43,18,26,67,51,16,47,63,76,45,79,13,17,53,6,46,35,50,92,40,10,20,15,23,31,33,55,88,65,32,84,1,19,91,44,49,7,25,41,39,71,4,80,54,36,59,75,77,86],
[43,92,38,61,12,94,65,17,64,13,58,45,54,99,15,75,73,88,8,5,42,28,67,30,11,59,9,84,46,49,98,56,34,87,41,44,31,66,69,78,97,95,1,63,90,79,22,68,52,16,3,26,74,27,32,57,77,40,35,89,2,33,48,29,55,25,82,20,7,36,96,37,10,91,93,21,60,100,19,81,23,51,14,18,85,72,50,39,71,47,62,4,6,86,70,53,76,80,83,24],
[45,40,99,76,12,88,4,23,65,86,8,58,7,32,36,43,18,53,62,2,83,24,51,46,64,14,10,59,97,27,66,47,6,61,17,78,19,63,50,44,92,33,39,85,37,70,3,80,98,9,60,11,57,56,91,90,71,34,16,94,5,84,20,30,15,87,31,48,21,95,13,22,68,75,100,72,25,26,35,69,96,74,79,93,49,1,55,54,38,42,73,89,52,81,82,41,67,28,77,29],
[2,43,52,65,96,33,5,53,62,88,31,77,4,45,83,18,12,13,97,91,81,49,55,70,39,48,16,89,94,99,6,27,25,82,80,72,66,34,41,37,44,86,54,59,47,75,79,71,19,26,11,92,60,14,57,85,69,24,78,30,90,67,15,46,17,74,95,68,50,23,1,9,73,32,56,87,8,10,35,42,36,20,7,64,100,40,58,38,28,93,76,21,98,3,51,84,29,63,61,22],
[73,42,15,24,91,69,74,10,6,67,8,81,98,45,80,12,19,48,17,11,93,59,52,53,72,49,82,14,31,27,43,79,54,4,84,38,34,30,99,46,7,63,71,5,28,90,21,1,51,39,36,62,77,78,9,56,50,76,68,32,94,20,85,26,44,41,3,65,64,83,88,35,92,22,57,89,75,25,100,37,29,33,97,23,60,61,66,47,18,58,87,40,16,96,2,95,55,70,86,13],
[80,8,41,11,26,92,57,63,31,46,67,76,39,5,84,20,58,47,14,98,36,21,74,49,51,68,72,65,64,56,45,54,2,3,69,13,78,43,53,18,6,48,29,85,83,97,52,1,81,35,66,37,88,89,19,12,55,33,25,38,71,61,96,62,75,4,77,32,86,15,44,42,60,99,59,70,7,100,93,94,87,9,73,50,27,91,34,79,95,22,40,24,82,28,90,10,30,17,23,16],
[84,33,72,71,61,69,60,75,59,82,90,22,30,41,88,21,43,68,70,81,8,10,25,76,4,6,79,78,64,62,28,55,65,50,15,91,98,2,48,93,52,92,47,37,19,40,99,86,87,97,57,80,32,36,54,14,51,66,38,49,95,100,94,23,11,42,7,53,96,3,58,5,18,73,45,1,20,34,67,39,31,46,13,12,56,17,24,63,29,44,35,85,89,26,74,16,27,83,9,77],
[49,16,2,7,71,98,24,65,54,12,68,77,79,96,5,14,13,91,31,95,8,25,1,69,81,52,57,15,59,93,89,60,47,23,45,99,9,100,75,34,55,63,76,11,73,17,44,27,33,20,87,70,56,88,80,86,66,41,97,64,51,72,10,90,62,39,30,37,46,78,85,32,35,21,43,36,53,83,4,42,94,29,61,74,6,92,28,58,22,18,26,19,82,84,38,67,50,48,3,40],
[59,56,68,43,32,22,66,63,28,57,41,45,55,44,82,99,48,61,40,50,13,53,24,52,14,74,78,100,71,31,12,21,75,42,92,37,20,76,49,34,46,83,33,86,65,8,95,69,77,72,73,18,98,91,62,39,29,35,10,17,89,23,5,70,3,81,2,58,4,6,9,51,36,93,96,94,47,64,30,7,19,11,25,80,1,60,87,67,54,84,15,16,88,85,79,90,97,27,26,38],
[7,8,36,69,73,53,14,39,74,32,25,60,33,99,57,80,47,68,91,9,55,24,5,77,87,62,59,84,15,67,34,21,10,2,11,56,54,88,26,58,41,79,83,76,31,27,42,66,28,38,18,96,61,37,23,4,6,52,49,92,1,63,40,48,65,86,13,12,89,98,94,3,43,90,20,70,100,85,51,45,19,46,95,93,22,81,82,50,35,75,97,17,44,29,72,71,30,64,78,16],
[38,14,29,52,66,26,32,79,59,86,76,22,53,75,100,73,31,74,20,13,28,10,9,21,12,64,82,94,6,42,48,43,47,34,77,11,40,25,89,56,18,63,35,2,58,65,72,95,57,4,84,46,62,23,44,49,17,5,71,80,88,1,87,55,99,78,92,33,39,36,51,16,81,68,85,61,3,91,83,27,30,69,8,93,15,98,7,97,70,50,54,37,67,45,24,60,96,41,19,90],
[19,63,77,70,33,73,30,86,42,9,72,66,34,71,11,7,16,39,43,60,53,21,78,80,92,87,82,100,29,3,5,95,47,57,32,12,13,85,83,38,51,18,10,69,40,68,1,49,41,90,25,44,27,28,61,56,75,46,89,81,64,62,31,48,99,23,45,4,17,15,2,35,79,37,91,26,96,50,76,55,97,74,58,84,67,6,94,36,22,14,65,98,8,59,24,52,20,54,93,88],
[63,69,41,37,90,81,18,100,7,91,1,31,53,19,27,28,87,13,21,32,16,59,77,23,68,93,85,55,99,64,47,52,46,45,92,97,44,58,5,40,15,14,35,62,9,12,79,78,2,42,30,73,39,65,29,94,57,4,96,70,20,75,66,95,34,24,76,72,82,71,11,17,38,51,48,80,56,3,8,36,10,26,84,67,33,86,89,60,22,25,49,43,88,98,83,6,50,74,54,61],
[87,67,74,16,63,19,25,49,78,38,93,5,12,6,42,86,17,40,59,66,26,62,1,50,91,82,73,70,37,31,75,15,43,72,84,97,23,34,39,22,54,35,10,32,95,65,3,8,58,28,85,52,47,53,7,18,41,27,46,56,48,79,57,88,99,30,90,9,64,80,45,24,83,55,20,13,92,77,81,96,33,61,4,11,36,51,69,68,98,44,100,89,2,94,14,29,76,71,60,21],
[57,1,92,78,46,77,58,33,83,98,97,31,3,35,5,40,2,86,51,72,41,17,95,96,94,26,32,45,9,82,70,55,38,39,100,44,71,36,65,73,18,81,20,14,29,23,15,52,88,43,6,59,69,13,75,42,90,84,24,37,67,79,85,8,87,50,56,76,4,53,27,62,19,47,34,68,89,16,30,60,7,11,66,80,21,25,28,22,74,64,61,48,10,12,91,49,93,99,63,54],
[78,85,6,99,59,74,46,98,29,61,18,15,69,35,30,53,17,65,72,7,64,42,10,34,91,51,40,67,56,96,37,45,68,97,47,57,76,31,77,28,66,13,33,73,38,49,43,58,92,21,88,24,55,32,82,26,27,84,2,12,93,3,11,60,87,94,16,41,52,80,22,75,50,89,25,86,1,19,14,62,23,20,100,44,36,39,79,48,5,63,70,4,83,8,71,9,81,90,54,95]].
/* 

  Stair case in Picat.

  Ported from B-Prolog program
  http://www.probp.com/examples/foreach/staircase.pl
  """
  Draw a staircase of a given steps. Example query:

  ?-go(4).
              +---+
              |   |
          +---+---+
          |   |   |
      +---+---+---+
      |   |   |   |
  +---+---+---+---+
  |   |   |   |   |
  +---+---+---+---+   
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go =>
    go(4).

go(N) => 
    foreach(I in 1..N)
	foreach(J in 1..N-I) print("    ") end,
	foreach(J in 1..I)  print("+---") end,
	println("+"),
	foreach(J in 1..N-I)  print("    ") end,
	foreach(J in 1..I)  print("|   ") end,
	println("|")
    end,
    foreach(I in 1..N) print("+---") end, println("+").

/*

  Steiner triplets in Picat.

  http://www.probp.com/examples/clpset/steiner.pl
  """
  The ternary Steiner problem of order n is to find n(n-1)/6 sets of elements 
  in {1,2,...,n} such that each set contains three elements and any two 
  sets have at most one element in common.

  For example, the following shows a solution for size n=7:

      {1,2,3}, {1,4,5}, {1,6,7}, {2,4,6}, {2,5,7}, {3,4,7}, {3,5,6}

  Problem taken from:
  C. Gervet: Interval Propagation to Reason about Sets: Definition and 
             Implementation of a PracticalLanguage,  
             Constraints, An International Journal, vol.1, pp.191-246, 1997.
  """


  Note: This model uses arrays of booleans as an representation of sets.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   nolog,
   println(allowedN=[ I : I in 1..40, (I mod 6 == 1; I mod 6 == 3)]),
   N = 7,
   steiner(N,Steiner),
   writeln(Steiner),nl.

/*
  Benchmark (CP vs SAT)

  N    SAT      CP
  --------------------
   3    0.0s    0.0s
   7    0.056s  0.0s
   9    0.232s  0.104s
  13    1.528s  
  15    3.18s
  19   33.878s

*/

go2 => 
   nolog,
   foreach(N in 3..19)
     println([n=N,nMod6=(N mod 6)]),
     (time2(steiner(N,Steiner)) ; true),
     println(Steiner)
   end,
   nl.

steiner(N,Steiner) =>

   if  not(N mod 6 == 1; N mod 6 == 3) then
     println("N must be (1|3) modulo 6"),     
     fail
   end, 

   % number of sets
   Nb = (N * (N-1)) // 6,

   Sets = new_array(Nb,N),
   SetsList = vars(Sets),
   SetsList :: 0..1,

   % atmost 1 element in common
   foreach({S1,I} in zip(Sets.to_list(),1..Nb))
       S1List = S1.to_list(),
       3 #= sum(S1List), % cardinality
       foreach({S2,J} in zip(Sets.to_list(),1..Nb))
          if I > J then
             union_card(S1List,S2.to_list(),Common),
             Common #=< 1
          end
       end
   end,

   % solve([constr,down],SetsList),
   solve([degree,updown],SetsList),
   
   % convert to set representation
   Steiner = [Res : SS in Sets, boolean_to_set(SS,Res)].
  

%
% number of common elements in two "sets"
%
union_card(S1,S2,CardCommon) =>
   CardCommon #= sum([(SS1 + SS2 #= 2) : {SS1,SS2} in zip(S1,S2)]).

%
% convert a list of boolean to a "set"
%
boolean_to_set(List,Set) =>
   Set = [I : {C,I} in zip(List.to_list(), 1..List.length), C = 1].


/*

  Strimko puzzle in Picat.

  From 
  360: A New Twist on Latin Squares
  http://threesixty360.wordpress.com/2009/08/04/a-new-twist-on-latin-squares/
  """
  The idea is simple: each row and column of an nxn grid must contain 
  the number 1, 2, ... n exactly once (that is, the grid must form a 
  Latin square), and each "stream" (connected path in the grid) must 
  also contain the numbers 1, 2, ..., n exactly once.
  """
 
  For more information, see:
  * http://www.strimko.com/
  * http://www.strimko.com/rules.htm
  * http://www.strimko.com/about.htm
  * http://www.puzzlersparadise.com/Strimko.htm

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
        strimko(2).

go2 =>
        Problems = [2,67,68,69,70],
        foreach(P in Problems) 
           strimko(P)
        end.

latin_square(Board) =>
   foreach(Row in Board) all_different(Row) end,
   foreach(Column in transpose(Board)) all_different(Column) end.


strimko(P) =>
        writef("\nProblem %w\n",P),
        problem(P,Streams,Placed),

        N = length(Streams),
        X = new_array(N,N),
        X :: 1..N,

        % is a latin square
        latin_square(X),

        % streams
        foreach(S in 1..N)
            Positions = [X[I,J] : I in 1..N, J in 1..N, S == Streams[I,J]],
            all_different(Positions)
        end,
        

        % placed
        foreach(I in 1..Placed.length)
           X[ Placed[I,1], Placed[I,2] ] #= Placed[I,3]
        end,

        solve(X),
        pretty_print(X),
        nl.


pretty_print(X) =>
        N = X.length,
        foreach(I in 1..N)
            foreach(J in 1..N) writef(" %d ", X[I,J]) end,
            writef("\n")
        end,
        writef("\n").



%
% Strimko Monthly #02
% Via http://www.hakank.org/minizinc/strimko2_002.dzn
%
problem(2,Streams, Placed) =>
    Streams = [[1,1,2,2,2,2,2],
               [1,1,2,3,3,3,2],
               [1,4,1,3,3,5,5],
               [4,4,3,1,3,5,5],
               [4,6,6,6,7,7,5],
               [6,4,6,4,5,5,7],
               [6,6,4,7,7,7,7]],
    Placed =  [[2,1,1],
               [2,3,7],
               [2,5,6],
               [2,7,4],
               [3,2,7],
               [3,6,1],
               [4,1,4],
               [4,7,5],
               [5,2,2],
               [5,6,6]].

% 
% Strimko Weekly Set 067
% Via http://www.hakank.org/minizinc/strimko2_067.dzn
problem(67,Streams, Placed) =>
 Streams =  [[1,1,1,2,3],
             [1,2,2,2,3],
             [1,2,4,5,3],
             [5,4,5,4,3],
             [4,5,5,4,3
             ]],
 Placed =  [[1,3,4],
            [1,4,1],
            [3,3,2],
            [3,5,3],
            [5,4,5]].

%
% Strimko Weekly Set 068
% Via http://www.hakank.org/minizinc/strimko2_068.dzn
problem(68,Streams,Placed) =>

Streams = [[1,2,2,4],
           [2,1,4,2],
           [3,4,1,3],
           [4,3,3,1]],
Placed =  [[2,2,3],
           [2,3,2],
           [3,3,1]].


% Strimko Weekly Set 069
% Via http://www.hakank.org/minizinc/strimko2_069.dzn
problem(69,Streams,Placed) =>
   Streams = [[1,2,3,3,3,4],
              [2,1,3,5,4,3],
              [2,1,3,5,5,4],
              [2,6,1,6,5,4],
              [2,6,1,6,4,5],
              [6,2,6,1,5,4]],
   Placed =  [[2,2,4],
              [2,3,1],
              [2,4,3],
              [2,5,2],
              [3,2,1],
              [3,5,6],
              [4,3,5],
              [4,4,2]].

% Strimko Weekly Set 070
% Via http://www.hakank.org/minizinc/strimko2_070.dzn
problem(70,Streams,Placed) =>
   Streams =  [[1,2,3,3,3],
               [2,1,1,3,1],
               [2,2,3,1,4],
               [5,2,5,4,4],
               [5,5,5,4,4]],
   Placed =   [[1,1,1],
               [2,5,4],
               [4,1,2],
               [5,4,5]].
/*

  Seesaw problem in Picat.

  Marriott & Stuckey "Programming with Constraints", page 257.
 
  Balancing on a seesaw.


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% direct modeling
go =>

   LS = [Liz,Fi,Sara],
   LS :: -5..5,

   9 * Liz + 8 * Fi + 4 * Sara #= 0,
   apart(Liz, Fi, 3),
   apart(Liz, Sara, 3),
   apart(Sara, Fi, 3),

   % symmetry breaking
   Sara #>= 0,
   solve([], LS),

   writeln([liz=Liz,fi=Fi,sara=Sara]),nl.

%
% Page 258 suggests cumulative instead of apart.
%
go2 =>
   LS = [Liz,Fi,Sara],
   LS  :: -5..5,

   9 * Liz + 8 * Fi + 4 * Sara #= 0,
   % symmetry breaking
   Sara #>= 0,

   LD = [3,3,3],
   LR = [1,1,1],
   Limit = 1,
   cumulative(LS, LD, LR, Limit),

   solve(LS),

   write([liz=Liz,fi=Fi,sara=Sara]),nl,nl.


apart(X, Y, N) =>
   (X #>= Y + N) #\/ (Y #>= X + N).

/* 

  Students and Languages problem in Picat.

  This is the Students and Languages problem from section 3.7 of
  Antoni Niederlinski: 
  "A Quick and Gentle Guide to Constraint Logic Programming via ECLiPSe",
  page 122ff.

  Problem formulation (page 122):
  """
  Five students of five nationalities spend their vacation on the Masurian
  Lakes. Its a Pole, a Hungarian, a Finn, a Swede and a German. Determine
  who speaks what language if:
  1. Each student is fluent in one o more foreign languages, but only in those
     that are native for some of the remaining students.
  2. There is no single language spoken by all of them.
  3. Each student may speak with any other student using some language.
  4. The common languages include native languages of all students.
  5. On average each student speaks two foreign languages.
  6. The Pole and the Hungarian speak three foreign languages.
  7. While the Swede has been swimming, the remaining four students could
     speak a common language.
  8. A common language could also be spoken while the Swede returned, but
     the Finn went rowing.
  9. In order to speak Swedish, two student had to leave the group.
  10. Polish and Finnish is spoken (as foreign language) by only two students.
  11. The Pole and Finn may communicate using two languages, none of them
      being German.
  12. The Hungarian and the Swede have only one common language.
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% It's a unique solution.
go ?=>
  time2($students(_Students)),
  fail.

go => true.

% Just test for max three solutions.
go2 =>
  get_N_solutions($students(_Students), 3),
  nl.

get_N_solutions(Goal, N) =>
  printf("Get %d solutions:\n", N),
  get_global_map().put(solcount,1), 
  time2(Goal),
  C = get_global_map().get(solcount),
  if C < N then get_global_map().put(solcount,C+1), fail end,
  nl.


students(Students) =>

  N = 5,

  % Students[Student,Language]
  Students = new_array(N,N),
  Students :: 0..1,

  Polish    = 1,
  Hungarian = 2,
  Finnish   = 3,
  Swedish   = 4,
  German    = 5,


  % Five students of five nationalities spend their vacation on the Masurian
  % Lakes. Its a Pole, a Hungarian, a Finn, a Swede and a German. Determine
  % who speaks what language if:

  % Assumption: A student is fluent is his/her own language
  foreach(I in 1..N) Students[I,I] := 1 end,

  % 1. Each student is fluent in one or more foreign languages, but only in those
  %    that are native for some of the remaining students.
  foreach(S in 1..N) 
    sum([Students[S,L] : L in 1..N]) #>= 2
  end,

  % 2. There is no single language spoken by all of them.
  foreach(L in 1..N) 
    sum([Students[S, L] : S in 1..N]) #< N
  end,

  % 3. Each student may speak with any other student using some language.
  foreach(S1 in 1..N, S2 in 1..N, S1 < S2) 
    sum([Students[S1,L] + Students[S2,L]: L in 1..N]) #>= 2
  end,

  % 4. The common languages include native languages of all students.  
  % foreach(L in 1..N) 
  %   sum([Students[S,L] : S in 1..N]) #>= 2
  % end,

  % 5. On average each student speaks two foreign languages.
  sum([Students[S,L] : L in 1..N, S in 1..N, S != L]) #= 10,

  % 6. The Pole and the Hungarian speak three foreign languages.
  sum([Students[Polish,L] : L in 1..N, L != Polish]) #= 3,
  sum([Students[Hungarian,L] : L in 1..N, L != Hungarian]) #= 3,

  % 7. While the Swede has been swimming, the remaining four students could
  %    speak a common language.
  CommonNoSwedish :: 1..N,
  CommonNoSwedish #!= Swedish,
  sum([T : S in [Polish,Hungarian,Finnish,German], matrix_element(Students,S,CommonNoSwedish,T)]) #= 4,


  % 8. A common language could also be spoken while the Swede returned, but
  %    the Finn went rowing.
  CommonNoFinnish :: 1..N,
  CommonNoFinnish #!= Finnish,
  sum([T : S in [Polish,Hungarian,Swedish,German], matrix_element(Students,S,CommonNoFinnish,T)]) #= 4,

  % 9. In order to speak Swedish, two student had to leave the group.
  sum([Students[S,Swedish] : S in 1..N]) #= 3,

  % 10. Polish and Finnish is spoken (as foreign language) by only two students.
  sum([Students[S,Polish] : S in 1..N, S != Polish]) + 
      sum([Students[S,Finnish] : S in 1..N, S != Finnish]) #= 2,

  % 11. The Pole and Finn may communicate using two languages, none of them
  %     being German.
  sum([Students[Polish,L] #= Students[Finnish,L] : L in 1..N]) #= 2,
  Students[Polish,German] + Students[Finnish,German] #< 2,

  % 12. The Hungarian and the Swede have only one common language.
  sum([Students[Hungarian,L] #= Students[Swedish,L] : L in 1..N]) #= 1,

  % 
  % solve
  % 
  Vars = Students.to_list() ++ [CommonNoFinnish, CommonNoSwedish],
  solve([constr,split], Vars),

  StudentStr = ["Polish","Hungarian","Finnish","Swedish","German"],
  foreach(S in 1..N) 
     printf("%-10s: %w\n", StudentStr[S], Students[S])
  end,
  nl,
  foreach(S in 1..N) 
     printf("The %s student speaks these languages: %w\n", StudentStr[S], [StudentStr[L] : L in 1..N, Students[S,L] == 1])
  end,

  println(commonNoSwedish=StudentStr[CommonNoSwedish]),
  println(commonNoFinnish=StudentStr[CommonNoFinnish]),

  nl.


matrix_element(X, I, J, Val) =>
   % element(I, X, Row),
   Row = X[I],
   element(J, Row, Val).

% matrix_element(X, I, J, Val) =>
%    nth(I, X, Row),
%    nth(J, Row, Val).

% matrix_element(X, I, J, Val) =>
%    freeze(I, (nth(I, X, Row),freeze(J,nth(J,Row,Val)))).

% matrix_element(X, I, J, Val) =>
%    freeze(I, (element(I, X, Row),freeze(J,element(J,Row,Val)))).
/*

  Subset sum problem in Picat.

  From Katta G. Murty: "Optimization Models for Decision Making", page 340
  http://ioe.engin.umich.edu/people/fac/books/murty/opti_model/junior-7.pdf
  
  """
  Example 7.8.1
  
  A bank van had several bags of coins, each containing either
  16, 17, 23, 24, 39, or 40 coins. While the van was parked on the
  street, thieves stole some bags. A total of 100 coins were lost.
  It is required to find how many bags were stolen.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
        
    N = 6,
    Total = 100,
    Coins = [16, 17, 23, 24, 39, 40],
    Len = length(Coins),

    X = new_list(Len), 
    X :: 0..N,

    scalar_product(Coins, X, Total),
    NumStolen #= sum(X), % total number of bags stolen

    solve(X),

    writeln(coins=Coins),
    writeln(total=Total),
    writeln(x=X),
    writeln(num_stolen=NumStolen).


scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).

/*

  Sudoku solver in Picat.

  Some of the problem instances (and some idea) are from 
  ECLiPSe's Sudoku model: 
       http://eclipseclp.org/examples/sudoku.ecl.txt


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   time2(sudoku(1)).

% Using sudoku2/2
go1 =>
   problem(13, Board),
   print_board(Board),
   time2(sudoku2(3,Board)),
   print_board(Board).


%
% Test all problems 
%
go2 =>
   foreach(P in 1..13)
      writeln(problem=P),
      time2(sudoku(P)),
      nl
   end.

%
% Test all problems 
%
go3 =>
   foreach(P in 1..13)
      writeln(problem=P),
      L = findall(P,sudoku2(P)),
      Len = length(L),
      writeln(len=Len),
      if Len > 1 then
          writeln('This has more than one solution!')
      end,
      nl
   end.


%
% Just checking the model: It should be a unique solution, and it is.
%
go4 =>
   problem(12,Board),
   All = findall(Board, (time2(sudoku(3,Board)))),
   foreach(B in All) print_board(B) end.

go5 ?=>
   problem(14,Board),
   sudoku2(3,Board),
   print_board(Board),
   fail.

go5 => true.


%
% Solving Norvig's 95 Sudoku's
% http://norvig.com/top95.txt
% 
go6 => 
   File = "top95.txt",
   if not exists(File) then
      printf("The file %w don't exists. Please donwload from http://norvig.com/top95.txt\n", File),
      halt
   else 
      Sudokus = read_file_lines(File)
   end,
   N = 1,
   foreach(Line in Sudokus)
       printf("Sudoku #%d\n", N),
       Sudoku1 = [cond(C=='.',_,to_integer(C)) : C in Line], 
       Sudoku = [slice(Sudoku1,1+I*9,9+I*9) : I in 0..8],
       print_board(Sudoku),
       time2(All = findall(Sudoku, sudoku(3,Sudoku))),
       if All.length != 1 then
         printf("Sudoku #%d don't have a unique solution!", N),
         halt
       end,
       foreach(S in All)
         print_board(S)
       end,
       nl,
       N := N + 1
   end,
   nl.
  

% 
% Solving Gordon Royle's 17 hint Sudoku puzzles
% The 49151 puzzles with 17 hints are available here:
% http://staffhome.ecm.uwa.edu.au/~0001e3890/sudoku17
% See
% http://staffhome.ecm.uwa.edu.au/~00013890/sudokumin.php
% 
% Note: Some of the times are too large due to garbage collection
%       interferes, see below for this
%
% ffd/split:
% 13:54min total runtime
% 825.4s solve time (13:45min)
% 
% ffd/down:
% 12:00min total runtime
% 711.21s solve time (11:51min)
%
% The following problem took more than 1s to solve:
%
% Sudoku #1977 Time: (1004 ms)  <- slow
% Sudoku #14293 Time: (1172 ms) <- slow
% Sudoku #14474 Time: (1956 ms) (<-- spurious, garbage collection)
% Sudoku #16447 Time: (1084 ms) <- slow
% Sudoku #30050 Time: (3821 ms) (<-- spurious, garbage collection)
% Sudoku #41189 Time: (1008 ms) <- slow
% Sudoku #42962 Time: (1224 ms) <- slow
% 
% Another run:
% Sudoku #1977 Time: (1000 ms) <- slow
% Sudoku #7266 Time: (1036 ms) (<- spurious)
% Sudoku #14293 Time: (1172 ms) <- slow
% Sudoku #15630 Time: (2048 ms) (<- spurious)
% Sudoku #16447 Time: (1084 ms) <- slow
% Sudoku #32364 Time: (4012 ms) (<-- spurious)
% Sudoku #42962 Time: (1212 ms) <- slow
% 
%
% When running each instance isolated (via an external program),
% then we don't get the very large times (>= 2000ms), these instances
% seems to be the stable slow (>= 1s) ones.
%
% #1977 time: 1048ms
% #14293 time: 1184ms
% #16447 time: 1088ms
% #41189 time: 1008ms
% #42962 time: 1224ms
%
go7 => 
   File = "sudoku17",
   if not exists(File) then
      printf("The file %w don't exists.\nPlease donwload from http://staffhome.ecm.uwa.edu.au/~0001e3890/sudoku17\n", File),
      halt
   else 
      Sudokus = read_file_lines(File)
   end,

   N = 1,
   TotalTimes = 0,
   foreach(Line in Sudokus)
       Sudoku1 = [cond(C='0',_,to_integer(C)) : C in Line], 
       Sudoku = [slice(Sudoku1,1+I*9,9+I*9) : I in 0..8],
       % print_board(Sudoku),
       _ = statistics_all(),
       statistics(runtime,_),
       sudoku(3,Sudoku),
       % time2(sudoku(3,Sudoku)),
       statistics(runtime,[_,Time]),
       TotalTimes := TotalTimes + Time,
       Stat = statistics_all(),
       printf("%% Sudoku #%d Time: (%d ms) Stat: %w\n", N, Time, Stat),
       N := N + 1
   end,
   println(totalTimes=TotalTimes),
   TotalSec = TotalTimes / 1000,
   println(totalSec=TotalSec),
   nl.

%
% Checking the reported slow instances
%
go7b => 
         % instance# = reported millis in go7
   Slow = new_map([1977=1004,
                   14293=1172, 
                   14474=1956, 
                   16447=1084, 
                   30049=0000, 
                   30050=3821,     
                   41189=1008,
                   42962=1224
                   ]),

   SlowIds = Slow.keys().sort(),

   File = "sudoku17",
   if not exists(File) then
      printf("The file %w don't exists.\nPlease donwload from http://staffhome.ecm.uwa.edu.au/~0001e3890/sudoku17\n", File),
      halt
   else 
      Sudokus = read_file_lines(File)
   end,
   N = 1,
   statistics(runtime,_),
   TotalTimes = 0,
   statistics(runtime,_),
   foreach(Line in Sudokus)
       % garbage_collect,
       Sudoku1 = [cond(C='0',_,to_integer(C)) : C in Line], 
       Sudoku = [slice(Sudoku1,1+I*9,9+I*9) : I in 0..8],
       if member(N,SlowIds) then
         print_board(Sudoku),
         sudoku(3,Sudoku),
         print_board(Sudoku),
         statistics(runtime,[_,Time]),
         TotalTimes := TotalTimes + Time,
         println(time=Time),
         printf("%% Sudoku #%d Time: (%d ms) (cf reported: %d)\n", N, Time, Slow.get(N)),
         nl
       end,
       N := N + 1
   end,
   println(totalTimes=TotalTimes),
   TotalSec = TotalTimes / 1000,
   println(totalSec=TotalSec),
   nl.



sudoku(ProblemName) =>
	problem(ProblemName, Board),
	print_board(Board),
	sudoku(3, Board),
	print_board(Board).


% Don't print the solution (for go4/0)
sudoku2(ProblemName) =>
	problem(ProblemName, Board),
	sudoku(3, Board).


latin_square(Board) =>
   foreach(Row in Board) all_different(Row) end,
   foreach(Column in transpose(Board)) all_different(Column) end.

% Using rows() and columns() from the util module instead.
latin_square2(Board) => 
   foreach(Row in Board.rows()) all_different(Row) end,
   foreach(Column in Board.columns()) all_different(Column) end.


sudoku(N, Board) =>
   N2 = N*N,

   Vars = Board.vars(),
   Vars :: 1..N2,

   % latin_square2(Board),
   foreach(Row in Board) all_different(Row) end,
   foreach(Column in transpose(Board)) all_different(Column) end,
   foreach(I in 1..N..N2, J in 1..N..N2)
      all_different([Board[I+K,J+L] : K in 0..N-1, L in 0..N-1])
   end,

   % println(vars=Vars),

   solve([ffd,down], Vars). % faster overall

   % solve([ffd,split], Vars). % faster on the slower instances

   % solve([ff,updown], Vars). % faster on slower instances
   % solve([constr,updown], Vars). % slower


%
% Another approach, using matrix extraction slice/2.
%
sudoku2(N, Board) =>
   N2 = N*N,

   Vars = Board.vars(),
   Vars :: 1..N2,

   foreach(I in 1..N2)
     Board.slice2(I,1..N2).all_different(),
     Board.slice2(1..N2,I).all_different()     
   end,

   foreach(I in 1..N..N2, J in 1..N..N2)
      % Note: we must flatten the sub matrix
      Board.slice2([I+K:K in 0..N-1],[J+L:L in 0..N-1]).flatten().all_different()
   end,

   solve([ff,down], Vars).


print_board(Board) =>
   N = Board.length,
   foreach(I in 1..N)
      foreach(J in 1..N)
         X = Board[I,J],
         if var(X) then printf("  _") else printf("  %w", X) end
      end,
      nl
   end,
   nl.


% Returns the list/array M[I,Range2]
slice2(Matrix, I,Range2) = [ Matrix[I,J] : J in Range2], list(Matrix), integer(I),list(Range2) => true.

% Returns the list/array M[Range1,J]
slice2(Matrix, Range1,J) = [Matrix[I,J] : I in Range1 ], list(Matrix), list(Range1), integer(J) => true.

% Returns the list/array matrix M[Range1,Range2]
slice2(Matrix, Range1,Range2) = [ [Matrix[I,J] : I in Range1 ] : J in Range2], list(Matrix) => true.



%----------------------------------------------------------------------
% Sample data
%----------------------------------------------------------------------

problem(1, Data) => 
Data = [
    [_, _, 2, _, _, 5, _, 7, 9],
    [1, _, 5, _, _, 3, _, _, _],
    [_, _, _, _, _, _, 6, _, _],
    [_, 1, _, 4, _, _, 9, _, _],
    [_, 9, _, _, _, _, _, 8, _],
    [_, _, 4, _, _, 9, _, 1, _],
    [_, _, 9, _, _, _, _, _, _],
    [_, _, _, 1, _, _, 3, _, 6],
    [6, 8, _, 3, _, _, 4, _, _]].

problem(2, Data) => 
 Data = [
    [_, _, 3, _, _, 8, _, _, 6],
    [_, _, _, 4, 6, _, _, _, _],
    [_, _, _, 1, _, _, 5, 9, _],
    [_, 9, 8, _, _, _, 6, 4, _],
    [_, _, _, _, 7, _, _, _, _],
    [_, 1, 7, _, _, _, 9, 5, _],
    [_, 2, 4, _, _, 1, _, _, _],
    [_, _, _, _, 4, 6, _, _, _],
    [6, _, _, 5, _, _, 8, _, _]].

problem(3, Data) => 
Data = [
    [_, _, _, 9, _, _, _, _, _],
    [_, _, 7, _, 6, _, 5, _, _],
    [_, _, 3, 5, _, _, _, 7, 9],
    [4, _, 5, _, _, 9, _, _, 1],
    [8, _, _, _, _, _, _, _, 7],
    [1, _, _, 6, _, _, 9, _, 8],
    [6, 4, _, _, _, 8, 7, _, _],
    [_, _, 9, _, 1, _, 2, _, _],
    [_, _, _, _, _, 7, _, _, _]].

problem(4, Data) => 
Data = [
    [_, 5, _, _, _, 1, 4, _, _], 
    [2, _, 3, _, _, _, 7, _, _], 
    [_, 7, _, 3, _, _, 1, 8, 2], 
    [_, _, 4, _, 5, _, _, _, 7], 
    [_, _, _, 1, _, 3, _, _, _], 
    [8, _, _, _, 2, _, 6, _, _], 
    [1, 8, 5, _, _, 6, _, 9, _], 
    [_, _, 2, _, _, _, 8, _, 3], 
    [_, _, 6, 4, _, _, _, 7, _]].

% Problems 5-8 are harder, taken from
% http://www2.ic-net.or.jp/~takaken/auto/guest/bbs46.html
problem(5, Data) => Data = [
    [_, 9, 8, _, _, _, _, _, _],
    [_, _, _, _, 7, _, _, _, _],
    [_, _, _, _, 1, 5, _, _, _],
    [1, _, _, _, _, _, _, _, _],
    [_, _, _, 2, _, _, _, _, 9],
    [_, _, _, 9, _, 6, _, 8, 2],
    [_, _, _, _, _, _, _, 3, _],
    [5, _, 1, _, _, _, _, _, _],
    [_, _, _, 4, _, _, _, 2, _]].

problem(6, Data) => 
Data = [
    [_, _, 1, _, 2, _, 7, _, _],
    [_, 5, _, _, _, _, _, 9, _],
    [_, _, _, 4, _, _, _, _, _],
    [_, 8, _, _, _, 5, _, _, _],
    [_, 9, _, _, _, _, _, _, _],
    [_, _, _, _, 6, _, _, _, 2],
    [_, _, 2, _, _, _, _, _, _],
    [_, _, 6, _, _, _, _, _, 5],
    [_, _, _, _, _, 9, _, 8, 3]].

problem(7, Data) => 
Data = [
    [1, _, _, _, _, _, _, _, _],
    [_, _, 2, 7, 4, _, _, _, _],
    [_, _, _, 5, _, _, _, _, 4],
    [_, 3, _, _, _, _, _, _, _],
    [7, 5, _, _, _, _, _, _, _],
    [_, _, _, _, _, 9, 6, _, _],
    [_, 4, _, _, _, 6, _, _, _],
    [_, _, _, _, _, _, _, 7, 1],
    [_, _, _, _, _, 1, _, 3, _]].

problem(8, Data) => 
Data = [
    [1, _, 4, _, _, _, _, _, _],
    [_, _, 2, 7, 4, _, _, _, _],
    [_, _, _, 5, _, _, _, _, _],
    [_, 3, _, _, _, _, _, _, _],
    [7, 5, _, _, _, _, _, _, _],
    [_, _, _, _, _, 9, 6, _, _],
    [_, 4, _, _, _, 6, _, _, _],
    [_, _, _, _, _, _, _, 7, 1],
    [_, _, _, _, _, 1, _, 3, _]].


% BBC Focus magazine October 2005
problem(9, Data) => 
Data = [
    [_, 6, _, 3, 2, _, _, 7, _],
    [4, 7, _, _, _, _, _, 3, 2],
    [_, _, _, 9, _, _, 1, 4, 6],
    [2, 4, _, 8, _, _, _, _, _],
    [_, _, 8, _, _, _, 2, _, 1],
    [1, _, _, _, _, 2, _, _, _],
    [_, _, 2, 4, 7, 6, 8, _, _],
    [6, 8, 9, _, _, _, _, 5, 4],
    [_, _, _, _, 8, _, _, _, _]].

problem(10, Data) => 
Data = [
    [1, 8, 2, 7, 5, _, 3, _, 9],
    [9, 5, 6, _, 3, _, _, 8, _],
    [3, 4, 7, _, _, 9, _, 5, _],
    [2, _, 3, _, 4, _, _, 9, 8],
    [4, _, 8, 9, _, 2, 5, _, 3],
    [5, 7, 9, 3, 6, 8, 1, 2, 4],
    [_, 2, _, 4, 9, _, 8, 3, _],
    [_, 3, _, _, 2, _, 9, _, 5],
    [_, 9, _, _, _, 3, _, 1, _]].

/*
  These are from J:s sudoku.ijs
*/ 
% Roger Huis example
problem(11,Data) => 
Data = [
       [2,_,_,6,7,_,_,_,_],
       [_,_,6,_,_,_,2,_,1],
       [4,_,_,_,_,_,8,_,_],
       [5,_,_,_,_,9,3,_,_],
       [_,3,_,_,_,_,_,5,_],
       [_,_,2,8,_,_,_,_,7],
       [_,_,1,_,_,_,_,_,4],
       [7,_,8,_,_,_,6,_,_],
       [_,_,_,_,5,3,_,_,8]].


% This puzzle is the evil puzzle from
% Perl's Games::Sudoku examples
problem(12, Data) => 
Data = [
       [_,7,6,4,_,_,5,_,_],
       [_,_,_,_,_,5,_,_,4],
       [_,_,_,_,7,_,_,6,9],
       [5,_,_,_,_,2,_,9,_],
       [_,3,1,_,_,_,2,5,_],
       [_,6,_,5,_,_,_,_,1],
       [6,2,_,_,4,_,_,_,_],
       [8,_,_,3,_,_,_,_,_],
       [_,_,5,_,_,7,4,3,_]].



% From https://groups.google.com/d/topic/comp.lang.prolog/sTSzJMflBDw/discussion
problem(13, Data) => 
Data = [
       [_,_,_,_,_,_,_,1,2],
       [_,_,_,_,_,_,_,_,3],   
       [_,_,2,3,_,_,4,_,_],
       [_,_,1,8,_,_,_,_,5],
       [_,6,_,_,7,_,8,_,_],
       [_,_,_,_,_,9,_,_,_],
       [_,_,8,5,_,_,_,_,_],
       [9,_,_,_,4,_,5,_,_],
       [4,7,_,_,_,6,_,_,_]].

% First problem from Project Euler #96:
% http://projecteuler.net/problem=96
problem(14,Data) => 
Data = 
[
[_,_,3,_,2,_,6,_,_],
[9,_,_,3,_,5,_,_,1],
[_,_,1,8,_,6,4,_,_],
[_,_,8,1,_,2,9,_,_],
[7,_,_,_,_,_,_,_,8],
[_,_,6,7,_,8,2,_,_],
[_,_,2,6,_,9,5,_,_],
[8,_,_,2,_,3,_,_,9],
[_,_,5,_,1,_,3,_,_]
].


% http://blag.nullteilerfrei.de/2014/07/03/why-someone-thought-that-sudoku-might-not-be-boring-while-actually-you-should-learn-how-to-properly-implement-backtracking/
problem(15, Data) =>
  Data =
 [
  [_, _, _, _, 6, _, _, 8, _],
  [_, 2, _, _, _, _, _, _, _],
  [_, _, 1, _, _, _, _, _, _],
  [_, 7, _, _, _, _, 1, _, 2],
  [5, _, _, _, 3, _, _, _, _],
  [_, _, _, _, _, _, 4, _, _],
  [_, _, 4, 2, _, 1, _, _, _],
  [3, _, _, 7, _, _, 6, _, _],
  [_, _, _, _, _, _, _, 5, _] 
].
Grid 01
003020600
900305001
001806400
008102900
700000008
006708200
002609500
800203009
005010300
Grid 02
200080300
060070084
030500209
000105408
000000000
402706000
301007040
720040060
004010003
Grid 03
000000907
000420180
000705026
100904000
050000040
000507009
920108000
034059000
507000000
Grid 04
030050040
008010500
460000012
070502080
000603000
040109030
250000098
001020600
080060020
Grid 05
020810740
700003100
090002805
009040087
400208003
160030200
302700060
005600008
076051090
Grid 06
100920000
524010000
000000070
050008102
000000000
402700090
060000000
000030945
000071006
Grid 07
043080250
600000000
000001094
900004070
000608000
010200003
820500000
000000005
034090710
Grid 08
480006902
002008001
900370060
840010200
003704100
001060049
020085007
700900600
609200018
Grid 09
000900002
050123400
030000160
908000000
070000090
000000205
091000050
007439020
400007000
Grid 10
001900003
900700160
030005007
050000009
004302600
200000070
600100030
042007006
500006800
Grid 11
000125400
008400000
420800000
030000095
060902010
510000060
000003049
000007200
001298000
Grid 12
062340750
100005600
570000040
000094800
400000006
005830000
030000091
006400007
059083260
Grid 13
300000000
005009000
200504000
020000700
160000058
704310600
000890100
000067080
000005437
Grid 14
630000000
000500008
005674000
000020000
003401020
000000345
000007004
080300902
947100080
Grid 15
000020040
008035000
000070602
031046970
200000000
000501203
049000730
000000010
800004000
Grid 16
361025900
080960010
400000057
008000471
000603000
259000800
740000005
020018060
005470329
Grid 17
050807020
600010090
702540006
070020301
504000908
103080070
900076205
060090003
080103040
Grid 18
080005000
000003457
000070809
060400903
007010500
408007020
901020000
842300000
000100080
Grid 19
003502900
000040000
106000305
900251008
070408030
800763001
308000104
000020000
005104800
Grid 20
000000000
009805100
051907420
290401065
000000000
140508093
026709580
005103600
000000000
Grid 21
020030090
000907000
900208005
004806500
607000208
003102900
800605007
000309000
030020050
Grid 22
005000006
070009020
000500107
804150000
000803000
000092805
907006000
030400010
200000600
Grid 23
040000050
001943600
009000300
600050002
103000506
800020007
005000200
002436700
030000040
Grid 24
004000000
000030002
390700080
400009001
209801307
600200008
010008053
900040000
000000800
Grid 25
360020089
000361000
000000000
803000602
400603007
607000108
000000000
000418000
970030014
Grid 26
500400060
009000800
640020000
000001008
208000501
700500000
000090084
003000600
060003002
Grid 27
007256400
400000005
010030060
000508000
008060200
000107000
030070090
200000004
006312700
Grid 28
000000000
079050180
800000007
007306800
450708096
003502700
700000005
016030420
000000000
Grid 29
030000080
009000500
007509200
700105008
020090030
900402001
004207100
002000800
070000090
Grid 30
200170603
050000100
000006079
000040700
000801000
009050000
310400000
005000060
906037002
Grid 31
000000080
800701040
040020030
374000900
000030000
005000321
010060050
050802006
080000000
Grid 32
000000085
000210009
960080100
500800016
000000000
890006007
009070052
300054000
480000000
Grid 33
608070502
050608070
002000300
500090006
040302050
800050003
005000200
010704090
409060701
Grid 34
050010040
107000602
000905000
208030501
040070020
901080406
000401000
304000709
020060010
Grid 35
053000790
009753400
100000002
090080010
000907000
080030070
500000003
007641200
061000940
Grid 36
006080300
049070250
000405000
600317004
007000800
100826009
000702000
075040190
003090600
Grid 37
005080700
700204005
320000084
060105040
008000500
070803010
450000091
600508007
003010600
Grid 38
000900800
128006400
070800060
800430007
500000009
600079008
090004010
003600284
001007000
Grid 39
000080000
270000054
095000810
009806400
020403060
006905100
017000620
460000038
000090000
Grid 40
000602000
400050001
085010620
038206710
000000000
019407350
026040530
900020007
000809000
Grid 41
000900002
050123400
030000160
908000000
070000090
000000205
091000050
007439020
400007000
Grid 42
380000000
000400785
009020300
060090000
800302009
000040070
001070500
495006000
000000092
Grid 43
000158000
002060800
030000040
027030510
000000000
046080790
050000080
004070100
000325000
Grid 44
010500200
900001000
002008030
500030007
008000500
600080004
040100700
000700006
003004050
Grid 45
080000040
000469000
400000007
005904600
070608030
008502100
900000005
000781000
060000010
Grid 46
904200007
010000000
000706500
000800090
020904060
040002000
001607000
000000030
300005702
Grid 47
000700800
006000031
040002000
024070000
010030080
000060290
000800070
860000500
002006000
Grid 48
001007090
590080001
030000080
000005800
050060020
004100000
080000030
100020079
020700400
Grid 49
000003017
015009008
060000000
100007000
009000200
000500004
000000020
500600340
340200000
Grid 50
300200000
000107000
706030500
070009080
900020004
010800050
009040301
000702000
000008006/*

  Survo puzzle in Picat.

  http://en.wikipedia.org/wiki/Survo_Puzzle
  """
  Survo puzzle is a kind of logic puzzle presented (in April 2006) and studied 
  by Seppo Mustonen. The name of the puzzle is associated to Mustonen's 
  Survo system which is a general environment for statistical computing and 
  related areas.
  
  In a Survo puzzle the task is to fill an m * n table by integers 1,2,...,m*n so 
  that each of these numbers appears only once and their row and column sums are 
  equal to integers given on the bottom and the right side of the table. 
  Often some of the integers are given readily in the table in order to 
  guarantee uniqueness of the solution and/or for making the task easier.
  """
  
  See also
  http://www.survo.fi/english/index.html
  http://www.survo.fi/puzzles/index.html
 
  References:
  Mustonen, S. (2006b). "On certain cross sum puzzles"
  http://www.survo.fi/papers/puzzles.pdf 
  Mustonen, S. (2007b). "Enumeration of uniquely solvable open Survo puzzles." 
  http://www.survo.fi/papers/enum_survo_puzzles.pdf 
  Kimmo Vehkalahti: "Some comments on magic squares and Survo puzzles" 
  http://www.helsinki.fi/~kvehkala/Kimmo_Vehkalahti_Windsor.pdf
  R code: http://koti.mbnet.fi/tuimala/tiedostot/survo.R


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

pretty_print(X, RowSums, ColSums) =>
    [N,M] = [X.length, X[1].length],
    foreach(I in 1..N)
        foreach(J in 1..M)
            writef("%2d ",X[I,J])
        end,
        writef(" = %d\n", RowSums[I])
    end,
    foreach(K in 1..M)
       writef("%2d ", ColSums[K])
    end,
    writef("\n\n").



survo_puzzle(Num) =>

    writeln(problem=Num),
    problem(Num, RowSums, ColSums, Problem),
    [R,C] = [Problem.length, Problem[1].length],
    ProblemVar = [P : I in 1..R, J in 1..C, P = Problem[I,J]],
    ProblemVar :: 1..R*C,

    % rowsums
    foreach(I in 1..R)
       RowSums[I] #= sum([P : J in 1..C, P = Problem[I,J]])
    end,
    % colsums
    foreach(J in 1..C)
       ColSums[J] #= sum([P : I in 1..R, P = Problem[I,J]])
    end,

    all_different(ProblemVar),

    solve(ProblemVar),

    pretty_print(Problem, RowSums, ColSums).


go =>
    survo_puzzle(1),
    survo_puzzle(2).


go2 =>
    foreach(P in 1..6)
       survo_puzzle(P); true
    end.

%
% Data
%

% http://en.wikipedia.org/wiki/Survo_Puzzle, first example
%
% Solution:
%  12 6 2 10
%  8 1 5 4
%  7 9 3 11
%
problem(1, RowSums, ColSums, Problem) =>
        RowSums = {30,18,30},
        ColSums = {27,16,10,25},
        Problem = {{_, 6, _, _},
                   {8, _, _, _},
                   {_, _, 3, _}}.



% http://en.wikipedia.org/wiki/Survo_Puzzle, second example
% difficulty 0
problem(2, RowSums, ColSums, Problem) =>
        RowSums = {9, 12},       % rowsums
        ColSums = {9, 7, 5},     % colsums
        Problem = {{_, _, 3},  % problem
                   {_, 6, _}}.
        


% http://en.wikipedia.org/wiki/Survo_Puzzle, third example
% difficulty 150 ("open puzzle", i.e. no hints}
% It's an unique solution.
% (817 propagations with Gecode/fz, and 33 failures, 88 commits}
% r = 3;
% c = 4;
% rowsums = [24,15,39];
% colsums = [21,10,18,29];
% matrix = array2d(1..r, 1..c, 
%   [
%     0, 0, 0, 0,
%     0, 0, 0, 0,
%     0, 0, 0, 0
%   ]};
% Note: this version has no hints
problem(3, RowSums, ColSums, Problem) =>
        RowSums = {24,15,39},      % rowsums
        ColSums = {21,10,18,29},   % colsums
        Problem = {{_, _, _, _}, % problem
                   {_, _, _, _},
                   {_, _, _, _}}.




% same as above but with hints: difficulty 0
% (15 propagations with Gecode/fz, no failures, no commits}
% matrix = array2d(1..r, 1..c, 
%    [
%      7, 0, 5, 0,
%      0, 1, 0, 8,
%      0, 0, 11, 0
%    ]};
problem(4, RowSums, ColSums, Problem) => 
       RowSums = {24,15,39},      % rowsums
       ColSums = {21,10,18,29},   % colsums
       Problem = {{7, _, 5, _}, % problem
                  {_, 1, _, 8},
                  {_, _, 11, _}}.



% http://www.survo.fi/puzzles/280708.txt, third puzzle
% Survo puzzle 128/2008 (1700} #364-35846
%
%    A  B  C  D  E  F
% 1  *  *  *  *  *  * 30
% 2  *  * 18  *  *  * 86
% 3  *  *  *  *  *  * 55
%   22 11 42 32 27 37
problem(5, RowSums, ColSums, Problem) =>
       RowSums = {30, 86, 55},
       ColSums = {22, 11, 42, 32, 27, 37},
       Problem = {{_, _,  _, _, _, _},
                  {_, _, 18, _, _, _},
                  {_, _,  _, _, _, _}}.

%
% http://en.wikipedia.org/wiki/Survo_Puzzle, under "Swapping method"
% (open puzzle}
%
problem(6, RowSums, ColSums, Problem) =>
       RowSums = {51,36,32,17},
       ColSums = {51,42,26,17},
       Problem = {{_, _, _, _},
                  {_, _, _, _},
                  {_, _, _, _},
                  {_, _, _, _}}.
/*

  Global constraint table in Picat.

  From MiniZinc's global.mzn (or rather table_int.mzn) 
  """
  A table constraint: table(x, t) represents the constraint x in t where we
  consider each row in t to be a tuple and t as a set of tuples.
  """

  Note: Picat has a table constraint, e.g.
       (I1,I2,I3) in Allowed.

  Here is a simple variant (poor man's table), not using 
  the "in" construct. And we call it tablex/2 or tablex/3
  to not conflict with the built-in table declaration.
  


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% using table/3
go ?=>

   % the table (1)
   T = [[1,2,1],
          [1,2,3],
          [1,3,3],
          [2,1,3],
          [2,3,4],
          [2,5,2],
          [3,4,4],
          [4,1,3],
          [6,5,1]],
   
   Rows = T.length,

   X :: 1..6,
   Y :: 1..6, 
   Z :: 1..6, 
       
   X #!= Y,
   Z #< 3,

   Ix :: 1..Rows,
   tablex([X,Y,Z], T, Ix),

   Vars = [X,Y,Z,Ix],
   solve(Vars),

   writeln([X,Y,Z]),
   writeln(ix=Ix),
   nl,
   fail.

go => true.

% using table/2
go2 ?=>

   % the table (2)
   T = [[1,2,1],
        [1,2,3],
        [1,3,3],
        [2,1,3],
        [2,3,4],
        [2,5,2],
        [3,4,4],
        [4,1,3],
        [6,5,1]],
   
   X :: 1..6,
   Y :: 1..6, 
   Z :: 1..6, 
       
   X #!= Y,
   Z #< 3,

   tablex([X,Y,Z], T),

   Vars = [X,Y,Z],
   solve(Vars),

   writeln([X,Y,Z]),
   nl,
   fail.

go2 => true.


%
% table/3
% There is some Ix which is the index
% of Table and is = X.
%
% Note: This use freeze(Ix,Goal).
%
tablex(X, Table,Ix) =>
   foreach(I in 1..Table[1].length) 
      freeze(Ix,Table[Ix,I] #= X[I])
   end.

%
% table/2
%
% There is some Ix which is the index
% of Table and is X
% Here Ix is inside the predicate and we use solve/1 
% to fix it.
%
tablex(X, Table) =>
   R = Table.length,
   CLen = Table[1].length,
   Ix :: 1..R,
   foreach(I in 1..CLen)
        freeze(Ix,Table[Ix,I] #= X[I])
   end,
   solve([Ix]).
/*

  Talisman square in Picat.

  http://mathworld.wolfram.com/TalismanSquare.html
  """
  An nXn array of the integers from 1 to n^2 such that the difference between 
  any one integer and its neighbor (horizontally, vertically, or 
  diagonally, without wrapping around) is greater than or equal to
  some value k is called a n,k)-talisman square. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go ?=>

   N = 5,
   K = 4,
   talisman_square(N, K, X),
   pretty_print(X),
   fail.

go => true.

talisman_square(N,K,X) =>

   X = new_array(N,N),
   X :: 1..N*N, 
   
   all_different(vars(X)),

   foreach(I in 2..N, J in 2..N)
       abs(X[I,J]-X[I-1,J]) #>= K,
       abs(X[I,J]-X[I,J-1]) #>= K
   end,

   foreach(I in 1..N-1,J in 1..N-1)
       abs(X[I,J]-X[I+1,J]) #>= K,
       abs(X[I,J]-X[I,J+1]) #>= K
   end,

   % some symmetry breaking
   X[1,1] #= 1,

   solve(X).


pretty_print(X) =>

   foreach(Row in X)
      foreach(R in Row) printf("%2d ",R) end,
      nl
   end,
   nl.


/* 

  Temporal reasoning in Picat.

  From Krzysztof R. Apt "Principle of Constraint Programming", page 23ff
  
  Also see the presentation 
  http://homepages.cwi.nl/~apt/pcp/ch2-sli.pdf.gz, page 15ff)
  
  """
  Consider the following problem:

  The meeting ran non-stop the whole day.
  Each person stayed at the meeting for a continous period of time.
  The meeting began while Mr Jones was present and finished
  while Ms White was present.
  Ms_White arrived after the meeting has began.
  In turn, Director Smith, was also present but he arrived after
  Jones had left.
  Mr Brown talked to Ms White in presence of Smith.
  Could possibly Jones and White have talked during this meeting?
  """

  The solution in Apt's presentation is 
  [0, 3, 1, 5, 0, 5, 4, 5, 2, 6]
  
  which is a valid solution in this model.

  Gecode/fz, MiniZinc/flatzinc, etc all gives the following as the 
  (first) solution: 
  [0, 2, 1, 4, 0, 4, 3, 4, 2, 5]

  Coding:

   J: Jones
   B: Brown
   S: Smith
   W: White
   M: Meeting

  There are 32009 solutions (for time 0..9). Here are two of them:
     [0,2,1,4,0,4,3,4,2,5]
     [0,3,1,5,0,5,4,5,2,6] % Apt's solution in the presentation

  Number of solutions for different time frames:
    - 0..9: 32009 solutions
    - 0..8:  8285 solutions
    - 0..7:  1693 solutions
    - 0..6:   242 solutions
    - 0..5:    18 solutions
    - 0..4:     0 solutions

  So, the shortest time frame for any solution is 0..5.


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
  temporal_reasoning(List),
  writeln(List),
  println("Could possibly Jones and White have talked during this meeting?"),

  [JonesStart,JonesEnd] = [[From,To] : Who=[From,To] in List, Who=j].first(),
  println(jones=[JonesStart,JonesEnd]),

  [WhiteStart,WhiteEnd] = [[From,To] : Who=[From,To] in List, Who=w].first(),
  println(white=[WhiteStart,WhiteEnd]),
  println("using weak_overlap:"),
  if weak_overlap(JonesStart,JonesEnd,WhiteStart,WhiteEnd) then 
    println(yes)
  else 
    println(no)
  end,

  nl.

go2 => 
  All=findall(List, $temporal_reasoning(List)),
  foreach(A in All)  println(A) end,
  writeln(length=All.length),

  nl.


% We assume that the time is 0..9
% (0..5 is the shortest time frame with a solution)
temporal_reasoning(List2) =>
   MaxTime = 9,
   J1 :: 0..MaxTime, % Jones start
   J2 :: 0..MaxTime, % Jones end
   M1 :: 0..MaxTime, % Meeting start
   M2 :: 0..MaxTime, % Meeting end
   B1 :: 0..MaxTime, % Brown start
   B2 :: 0..MaxTime, % Brown end
   S1 :: 0..MaxTime, % Smith start
   S2 :: 0..MaxTime, % Smith end
   W1 :: 0..MaxTime, % White start
   W2 :: 0..MaxTime, % White end
   List = [J1,J2,M1,M2,B1,B2,S1,S2,W1,W2],

   %
   % The story
   % 

   % Meeting and Jones
   (J1 #< M1, M1 #< J2),

   % Meeting and White  
   overlaps(M1, M2, W1, W2),

   % Meeting and Smith
   real_overlap(M1, M2, S1, S2),

   % Jones and Smith
   before(J1, J2, S1, S2),

   % Brown and Smith
   real_overlap(B1, B2, S1, S2),

   % Brown and White
   real_overlap(B1, B2, W1, W2),

   % Smith and White
   real_overlap(S1, S2, W1, W2),

   % "Could possibly Jones and White have talked during this meeting?"
   weak_overlap(J1, J2, W1, W2),

   solve(List),

   % writeln(List),
   List2 = [j=[J1,J2],m=[M1,M2],b=[B1,B2],s=[S1,S2],w=[W1,W2]].



%
% General
%
interval( X1,  X2) =>
  X1 #< X2.

before( X1,  X2,  Y1,  Y2) =>
    interval(X1, X2),
    interval(Y1, Y2),
    X2 #< Y1.

after( X1,  X2,  Y1,  Y2) =>
    before(Y1, Y2, X1, X2).

meets( X1,  X2,  Y1,  Y2) => 
   interval(X1, X2),
   interval(Y1, Y2),
   X2 #= Y1.

met_by( X1,  X2,  Y1,  Y2) =>
   meets(Y1, Y2, X1, X2).

overlaps( X1,  X2,  Y1,  Y2) =>
   interval(X1, X2),
   interval(Y1, Y2),
   X1 #< Y1,
   Y1 #< X2,
   X2 #< Y2.

overlapped_by( X1,  X2,  Y1,  Y2) =>
   overlaps(Y1, Y2, X1, X2).

starts( X1,  X2,  Y1,  Y2) =>
   interval(X1, X2),
   interval(Y1, Y2),
   X1 #= Y1,
   X2 #< Y2.


started_by( X1,  X2,  Y1,  Y2) =>
   starts(Y1, Y2, X1, X2).

during( X1,  X2,  Y1,  Y2) =>
   interval(X1, X2),
   interval(Y1, Y2),
   X1 #> Y1,
   X2 #< Y2.

contains( X1,  X2,  Y1,  Y2) =>
   during(Y1, Y2, X1, X2).

finishes( X1,  X2,  Y1,  Y2) =>
   interval(X1, X2),
   interval(Y1, Y2),
   X1 #> Y1,
   X2 #= Y2.

finished_by( X1,  X2,  Y1,  Y2) =>
   finishes(Y1, Y2, X1, X2).

equal( X1,  X2,  Y1,  Y2) =>
   interval(X1, X2),
   interval(Y1, Y2),
   X1 #= Y1,
   X2 #= Y2.

real_overlap( X1,  X2,  Y1,  Y2) =>
   X1 #< Y2, 
   Y1 #< X2.

weak_overlap( X1,  X2,  Y1,  Y2) =>
   X1 #<= Y2, 
   Y1 #<= X2.
/*

  Testing a Project Euler programs.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
     Skip1 = ["euler67.pi","euler67_old.pi","euler.pi","euler_utils.pi","test_euler.pi",
              "euler51.pi","euler66.pi","euler79_minimal_solutions.pi","euler96.pi"],
     Skip = new_map([(S=1) : S in Skip1]), 
     println(skip=Skip1),
     Timeout = 10000, % 10s timeout
     % Programs = [PP : PP in listdir("."), 
     %                    match(PP, "euler"), 
     %                    match(PP, ".pi")].sort(),
     Programs = [F : F in listdir("."), 
                 not Skip.has_key(F),
                 append("euler",What,".pi",F), 
                 What != [], 
                 W = What.parse_term(), 
                 integer(W), 
                 member(W, 1..50)].qsort(sort_euler),
     println(program=Programs),
     nl,
     Fails = [],
     Times = new_map(),
     TotalTime = 0,
     statistics(runtime,_),
     foreach(P in Programs) 
        if not Skip.has_key(P) then
           printf("Testing %w\n", P),
           cl(P),
           statistics(runtime,[_,_]), % reset timer
           time_out(go, Timeout, Status),
           statistics(runtime,[_,Time]),
           println(status=Status),
           if status==Timeout then
              Fails := Fails ++ [P]
           end,
           TotalTime := TotalTime + Time,
           TimeF = Time / 1000,
           Times.put(P,TimeF),
           nl
        end
     end,
     println(fails=Fails),
     println(times=Times.sort_map(values_reverse)),
     println("TotalTime"=to_fstring("%2.3f", TotalTime / 1000)),
     nl.

match(String, Substring) => once(find(String,Substring,_,_)).

qsort([],_F)    = [].
qsort([H|T],F) = qsort([E : E in T, call(F,E,H)], F) 
                 ++ [H] ++
                 qsort([E : E in T, not call(F,E,H)],F).


%
% sort_map(Map,keys)  : sort Map on keys
% sort_map(Map,values): sort Map on values
%
sort_map(Map,values) = [K=V:_=(K=V) in sort([V=(K=V): K=V in Map])].
sort_map(Map,values_reverse) = [K=V:_=(K=V) in reverse(sort([V=(K=V): K=V in Map]))].
sort_map(Map,keys)   = sort([K=V:K=V in Map]).
sort_map(Map,keys_reverse)   = sort([K=V:K=V in Map]).reverse().
sort_map(Map) = sort_map(Map,keys).

sort_lt(F1,F2), integer(F1), integer(F2) => F1 < F2.
sort_lt(F1,F2), not integer(F1) => F1 @< F2.

sort_le(F1,F2), integer(F1), integer(F2) => F1 =< F2.
sort_le(F1,F2), not integer(F1) => F1 @=< F2.

sort_ge(F1,F2), integer(F1), integer(F2) => F1 >= F2.
sort_ge(F1,F2), not integer(F1) => F1 @>= F2.

sort_gt(F1,F2), integer(F1), integer(F2) => F1 > F2.
sort_gt(F1,F2), not integer(F1) => F1 @> F2.


sort_euler(F1,F2) => 
  append("euler",What1,".pi",F1),
  append("euler",What2,".pi",F2),
  What1.to_integer() < What2.to_integer().



%
% Using bp.system/1 to run the Euler program.
% 
go2 =>
     Skip1 = ["euler67.pi","euler.pi","euler_utils.pi","test_euler.pi"],
     Skip = new_map([(S=1) : S in Skip1]), 
     println(Skip1),
     Timeout = 10000, % 10s timeout
     Programs = [PP : PP in listdir("."), 
                        match(PP, "euler"), 
                        match(PP, ".pi")].sort(),
     Fails = [],
     foreach(P in Programs) 
        if not Skip.has_key(P) then
           printf("Testing %w\n", P),
           System = "picat " ++ P,
           bp.atom_chars(SystemA,System), % bp.system requires an atom as argument
           time_out(time(bp.system(SystemA)),Timeout,Status),
           if Status == timeout then    
              Fails := Fails ++ [P]
           end,
           nl
        end
     end,
     println(fails=Fails),
     nl.
/*

  1D Rubik's Cube in Picat.

  From
  http://www.mail-archive.com/programming@jsoftware.com/msg05817.html
  """
  1D Rubik's Cube

  Oleg Kobchenko
  Mon, 11 Jun 2007 19:09:55 -0700

  I found an interesting game, as found on Andrew Nikitin's 
  MSX-BASIC page http://nsg.upor.net/msx/basic/basic.htm ,
  and I am not sure if its solver has been given as a puzzle.
  Here it goes.

  1D Rubik's Cube is a line of 6 numbers with
  original position:

    1 2 3 4 5 6

  which can be rotated in 3 different ways
  in groups of four:
      _______                _______
     (1 2 3 4)5 6  --(0)->  (4 3 2 1)5 6
        _______                _______
      1(2 3 4 5)6  --(1)->   1(5 4 3 2)6
          _______                _______
      1 2(3 4 5 6) --(2)->   1 2(6 5 4 3)

  Given a scrambled line, return the shortest sequence of 
  rotations to restore the original position.

  Examples:

     solve 1 3 2 6 5 4
  1 2 1
     solve 5 6 2 1 4 3
  0 2
     solve 6 5 4 1 2 3
  0 1 2

  """


  This version use the built-in module planner.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   initial_state(Init),
   time(best_plan(Init, L)),
   println(moves=L), 
   Len=length(L),
   println(len=Len),
   nl.

% increasing the allowed length
go2 =>
   initial_state(Init),
   foreach(Len in 1..25)
      nl,
      println(len=Len),
      (time(best_plan(Init,Len,L)) ; true),
      println(moves=L),
      nl
   end.

% same as go2/0 using indomain/1
go3 =>
   initial_state(Init),
   nolog,
   Len :: 1..25,
   indomain(Len),
   println(len=Len),
   time(best_plan(Init,Len,L)),
   println(moves=L),
   nl.

% random instance
go4 =>
   N = 12,
   NumMoves = 20,
   generate_moves(N,NumMoves,Init,Moves),
   println(init=Init),
   println(generatedMoves=Moves),
   time(best_plan(Init,NumMoves,L)),
   println(moves=L),
   println(len=L.len),
   nl.

generate_moves(N,NumMoves, Init, Moves) =>
   Init1 = 1..N,
   Moves1 = [],
   _ = random2(),
   foreach(I in 1..NumMoves)
     Move = 1 + random() mod 9, % There are 9 moves for the 1..12 puzzle
     Moves1 := Moves1 ++ [Move],
     action(Init1,Init2,Move,_Cost),
     Init1 := Init2
   end, 
   Init = Init1,
   Moves = Moves1.



%
% Length 6 (original problem)
%
% index(-)
% % initial_state([1,3,2,6,5,4]). % Moves: 2,3,2
% % initial_state([5,6,2,1,4,3]). % Moves: 1,3
% % initial_state([6,5,4,1,2,3]). % Moves: 1,2,3
% % initial_state([2,1,5,4,3,6]). % Moves: 1,2,1
% % initial_state([5,1,2,3,4,6]). % Moves: 1,2,1,2
% % initial_state([5,4,3,2,1,6]). % Moves: 1,2,1,2,1
% %% These two takes 11 steps (no problem at all).
% % initial_state([6,3,5,2,4,1]).   % GAP: x3*x1*x2*x1*x3*x2*x1*x2*x1*x3*x1
% % initial_state([6,4,2,5,3,1]).   % GAP: x1*x3*x2*x3*x2*x1*x3*x2*x3*x2*x1
% % initial_state([6,5,4,3,1,2]). % moves 1,3,2,1,3,1,2,1
% % initial_state([6,3,4,5,2,1]). % 1,3,2,1,3

% index(-)
% final([1,2,3,4,5,6]).

% table
% % action(From, Move, To).
% action([M4,M3,M2,M1,M5,M6],To,M,Cost) ?=> Cost=1, M=1, To=[M1,M2,M3,M4,M5,M6]. % move 1
% action([M1,M5,M4,M3,M2,M6],To,M,Cost) ?=> Cost=1, M=2, To=[M1,M2,M3,M4,M5,M6]. % move 2
% action([M1,M2,M6,M5,M4,M3],To,M,Cost)  => Cost=1, M=3, To=[M1,M2,M3,M4,M5,M6]. % move 3

%
% Length 8
%

% index(-)
% initial_state([2,4,1,7,5,3,8,6]). % GAP: x2*x3*x2*x4*x3*x5*x4*x1*x2*x1
% % initial_state([8,7,6,3,2,5,4,1]).  % GAP: x3*x1*x2*x3*x1*x4*x5*x1*x3*x1

% index(-)
% final([1,2,3,4,5,6,7,8]).

% table
% action([M4,M3,M2,M1,M5,M6,M7,M8],To,M,Cost) ?=> Cost=1,M=1,To=[M1,M2,M3,M4,M5,M6,M7,M8]. % move 1
% action([M1,M5,M4,M3,M2,M6,M7,M8],To,M,Cost) ?=> Cost=1,M=2,To=[M1,M2,M3,M4,M5,M6,M7,M8]. % move 2
% action([M1,M2,M6,M5,M4,M3,M7,M8],To,M,Cost) ?=> Cost=1,M=3,To=[M1,M2,M3,M4,M5,M6,M7,M8]. % move 3
% action([M1,M2,M3,M7,M6,M5,M4,M8],To,M,Cost) ?=> Cost=1,M=4,To=[M1,M2,M3,M4,M5,M6,M7,M8]. % move 4
% action([M1,M2,M3,M4,M8,M7,M6,M5],To,M,Cost)  => Cost=1,M=5,To=[M1,M2,M3,M4,M5,M6,M7,M8]. % move 5


%
% Length 12
%
% Using current_resouce and heuristics works and solves the two test problems in 0.3s
%

% table
action([M4,M3,M2,M1,M5,M6,M7,M8,M9,M10,M11,M12],To,M,Cost) ?=> 
       Cost=1,M=1,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12], check_resource_bound(To). % move 1
action([M1,M5,M4,M3,M2,M6,M7,M8,M9,M10,M11,M12],To,M,Cost) ?=> 
       Cost=1,M=2,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12], check_resource_bound(To). % move 2
action([M1,M2,M6,M5,M4,M3,M7,M8,M9,M10,M11,M12],To,M,Cost) ?=> 
       Cost=1,M=3,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12], check_resource_bound(To). % move 3
action([M1,M2,M3,M7,M6,M5,M4,M8,M9,M10,M11,M12],To,M,Cost) ?=> 
       Cost=1,M=4,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12], check_resource_bound(To). % move 4
action([M1,M2,M3,M4,M8,M7,M6,M5,M9,M10,M11,M12],To,M,Cost) ?=> 
       Cost=1,M=5,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12], check_resource_bound(To). % move 5
action([M1,M2,M3,M4,M5,M9,M8,M7,M6,M10,M11,M12],To,M,Cost) ?=> 
       Cost=1,M=6,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12], check_resource_bound(To). % move 6
action([M1,M2,M3,M4,M5,M6,M10,M9,M8,M7,M11,M12],To,M,Cost) ?=> 
       Cost=1,M=7,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12], check_resource_bound(To). % move 7
action([M1,M2,M3,M4,M5,M6,M7,M11,M10,M9,M8,M12],To,M,Cost) ?=> 
       Cost=1,M=8,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12], check_resource_bound(To). % move 8
action([M1,M2,M3,M4,M5,M6,M7,M8,M12,M11,M10,M9],To,M,Cost)  => 
       Cost=1,M=9,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12], check_resource_bound(To). % move 9

check_resource_bound(L) =>
    Dist = dist(L),
    % println([current_resource=current_resource(), dist=Dist]),
    current_resource() > Dist.

dist(L) = sum([1 : I in 1..L.length, L[I] != I]). % simple heuristisc
% dist(L) = sum([abs(I-L[I]) : I in 1..L.length]).

%% number of moves: 12
index(-)
initial_state([7,5,11,8,9,1,10,3,4,2,6,12]).
%% number of moves: 12
% initial_state([12,2,7,3,4,11,1,10,8,9,6,5]).

index(-)
final(1..12).

/* 

  Coins planning in Picat.

  From Thinking as Computation: Three coins problem
  """
  The three-coins problem formulated for the general planner.
  The three possible moves. Each changes one of the coins.
  """


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go ?=> 
   initial_state(Init),
   % L=new_list(3), % exactly three steps
   time(plan(Init,3,L)),
   write(L), nl,
   writeln(len=L.length),
   fail,
   nl.

go => true.

initial_state(Initial) => Initial = [h,h,t].

final(Goal) ?=> Goal = [h,h,h].
final(Goal)  => Goal = [t,t,t].

% The three-coins problem formulated for the general planner.
% The three possible moves. Each changes one of the coins.
action(From, To, Move, Cost) ?=> 
    From=[X,Y,Z],Move=flip_left,To=[X1,Y,Z],
    Cost = 1,
    opposite(X,X1).
action(From, To, Move, Cost) ?=> 
    From=[X,Y,Z],Move=flip_middle,To=[X,Y1,Z], 
    Cost = 1,
    opposite(Y,Y1).
action(From, To, Move, Cost)  =>   
    From=[X,Y,Z],Move=flip_right,To=[X,Y,Z1],
    Cost = 1,
    opposite(Z,Z1).

opposite(H,T) ?=> H=h,T=t. % Flipping a head gives a tail.
opposite(T,H)  => T=t,H=h. % Flipping a tail gives a head.


main =>
    S0=[s,s,s,s],
%    best_plan(S0,Plan),
    plan_unbounded(S0,Plan),
%    best_plan_unbounded(S0,Plan),
    writeln(Plan).

final([n,n,n,n]) => true.

action([F,F,G,C],S1,Action,ActionCost) ?=>
    Action=farmer_wolf,
    ActionCost=1,
    opposite(F,F1),
    S1=[F1,F1,G,C],
    not unsafe(S1).
action([F,W,F,C],S1,Action,ActionCost) ?=>
    Action=farmer_goat,
    ActionCost=1,
    opposite(F,F1),
    S1=[F1,W,F1,C],
    not unsafe(S1).
action([F,W,G,F],S1,Action,ActionCost) ?=>
    Action=farmer_cabbage,
    ActionCost=1,
    opposite(F,F1),
    S1=[F1,W,G,F1],
    not unsafe(S1).
action([F,W,G,C],S1,Action,ActionCost) =>
    Action=farmer_alone,
    ActionCost=1,
    opposite(F,F1),
    S1=[F1,W,G,C],
    not unsafe(S1).

index (+,-) (-,+)
opposite(n,s).
opposite(s,n).

unsafe([F,W,G,_C]),W==G,F!==W => true.
unsafe([F,_W,G,C]),G==C,F!==G => true.

/* 

  M12 problem in Picat.

  See 
  Igor Kriz and Paul Siegel: 
      Rubik's Cube Inspired Puzzles Demonstrate Math's "Simple Groups"
  http://www.sciam.com/article.cfm?id=simple-groups-at-play

  Programs:
   http://www.math.lsa.umich.edu/~ikriz/
   http://www.sciam.com/article.cfm?id=puzzles-simple-groups-at-play

  This model implements the M12 puzzle:
   - length is 12 (2*6)
   - the two operations are 
       * merge (shuffle) and 
       * inverse (reverse)
   - some init configuration

  For a group theoretic solution of the M12 puzzle using the abstract algebra system GAP, 
  see http://www.hakank.org/group_theory/M12_gap.txt
  It is presented in my (Swedish) blog post
  "Gruppteoretisk lsning av M12 puzzle i GAP" [Group theoretical solution of the M12 puzzle in GAP]
  http://www.hakank.org/webblogg/archives/001226.html



  This variant use the built-in planner module instead of my bplan.


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   problem(1,Init),
   % time(best_plan_unbounded(Init, 40,Plan,Cost)), % problem 1 (27 steps): 2.218s
   % time(best_plan(Init, 40,Plan,Cost)), % problem 1 (27 steps): 1.24s
   % time(best_plan(Init, 30,Plan,Cost)), % problem 1 (27 steps): 1.007s
   % time(best_plan(Init, Plan)), % problem 1 (27 steps): 1.048s
   % time(best_plan(Init, Plan)), % problem 1 (27 steps) with table: 1.034s
   time(best_plan(Init, 30,Plan)), % problem 1 (27 steps) with table: 0.999s
   writeln(Plan),
   writeln(len=Plan.length),
   % writeln(cost=Cost),
   nl.

%
% Solving all 21 problems with 
%   * best_plan(Init, Plan): 1.167s (without table: 2.311s)
%
go2 =>
   foreach(P in 1..21) 
     problem(P, Init),
     writeln([p=P, init=Init]),
     time(best_plan(Init, Plan)), % problem 1 (27 steps) with table: 1.9s
     writeln(Plan),
     writeln(len=Plan.length),
     nl
   end,
   nl.

final(Goal) => Goal=[1,2,3,4,5,6,7,8,9,10,11,12].


go3 =>
   nolog,
   problem(3,Init),
   time(best_plan(Init, 30,Plan)), % problem 1 (27 steps) with table
   writeln(Plan),
   writeln(len=Plan.length),

   fail,
   nl.


table
% merge
action([M1,M12,M2,M11,M3,M10,M4,M9,M5,M8,M6,M7], To, M, Cost) ?=>
   Cost=1, M=m,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12],Cost=1.
% reverse
action([M12,M11,M10,M9,M8,M7,M6,M5,M4,M3,M2,M1], To,M, Cost) => 
   Cost=1, M=r,To=[M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12],Cost=1.



rand_perm(List) = List, List.length == 1 => true.
rand_perm(List) = Perm => rand_perm(List, List.length, Perm).

remove_at(X,L,1,R) => L=[X|Xs], R=Xs.
remove_at(X,L,K,R) => L=[Y|Xs], R=[Y|Ys], K > 1, K1 = K - 1, remove_at(X,Xs,K1,Ys).

rand_perm(_,0,R) ?=> R = [].
rand_perm(Xs,N,R) ?=> 
    R = [X|Zs],
    N > 0,
    L = length(Xs),
    I = 1+random2() mod L,
    remove_at(X,Xs,I,Ys),
    N1 = N - 1,
    rand_perm(Ys,N1,Zs).



problem(1, Problem) => Problem = [8,11,6,1,10,9,4,3,12,7,2,5]. % 27 steps
problem(2, Problem) => Problem = [10,5,4,7,1,2,8,3,12,11,9,6]. % this is random generated from M12proj.exe. 15 steps
problem(3, Problem) => Problem = [10,8,6,12,5,2,1,4,11,7,9,3]. % generated from M12proj.exe. harder  22 steps
problem(4, Problem) => Problem = [11,7,3,8,5,2,12,1,9,10,4,6]. % generated from M12proj.exe 22 steps
problem(5, Problem) => Problem = [7,5,8,3,1,11,2,9,4,12,6,10]. % generated from M12proj.exe 19 steps
problem(6, Problem) => Problem = [8,11,6,1,10,9,4,3,12,7,2,5]. % 27 steps
problem(7, Problem) => Problem = [3,8,6,12,4,7,5,11,1,10,9,2]. % 19 steps
problem(8, Problem) => Problem = [4,1,10,7,9,12,3,6,5,2,11,8]. % 4 steps. generated from the following moves:  M2I1M
problem(9, Problem) => Problem = [7,1,8,9,12,5,3,10,4,11,6,2]. % 9 steps
problem(10, Problem) => Problem = [5,6,11,10,8,2,3,12,7,4,9,1]. % 13 steps
problem(11, Problem) => Problem = [5,6,10,4,1,11,9,2,12,8,3,7]. % 12 steps
problem(12, Problem) => Problem = [3,4,6,10,11,1,9,7,8,2,12,5]. % 22 steps
problem(13, Problem) => Problem = [1,12,2,11,3,10,4,9,5,8,6,7]. % 1 step: m
problem(14, Problem) => Problem = [1,4,7,10,12,9,6,3,2,5,8,11]. % 3 steps: mmm
problem(15, Problem) => Problem = [11,2,9,7,1,10,6,5,8,3,12,4]. % 7 steps. mmmrmmm
problem(16, Problem) => Problem = [12,11,10,9,8,7,6,5,4,3,2,1]. % 1 step: r

problem(17, Problem) => Problem = [10,7,5,3,12,11,9,1,8,6,2,4].
problem(18, Problem) => Problem = [11,8,6,3,7,2,1,9,4,12,10,5].

problem(19, Problem) => Problem = [4,2,7,12,1,5,10,9,3,8,11,6]. % [r,m,m,m,r,m,r,m]
problem(20, Problem) => Problem = [6,7,10,9,2,11,12,5,3,4,8,1].
problem(21, Problem) => Problem = [10,9,7,4,6,5,11,1,8,3,2,12]. % 15 steps m,r,m,r,m,r,m,r,m,m,m,r,m,m,m
/*

  Maze problem in Picat.

  Maze problem from Chapter 4 of 
  Peter Norvig's Paradigms of Artificial Intelligence Programming (PAIP)

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
   % Norvig's problem
   Init = 1,
   Final = 25,
   problem(1,Maze),
   solve_maze(Maze, Init,Final,Plan),
   print_plan(Init, Final, Plan),
   nl.


%
% Solve all problems in the Norvig's Maze and
% also show the longest plans.
%
go2 => 
   problem(1,Maze),
   PlanLens = [],
   foreach(Init in 1..25, Final in 1..25, Init != Final)
      printf("Problem %d -> %d\n", Init, Final),
      if solve_maze(Maze, Init,Final, Plan) then
         print_plan(Init, Final, Plan),
         PlanLens := PlanLens ++ [[Init,Final,Plan.length,Plan]]
      else 
         println("No solution.\n"),
         PlanLens := PlanLens ++ [[Init,Final,0,[]]]
      end
   end,
   println("Longest plans:"),
   MaxLen = max([Len : [_,_,Len,_] in PlanLens]),
   writeln(maxLen=MaxLen),
   MaxLens=[[Init,Final,Plan] : [Init,Final,Len,Plan] in PlanLens, Len == MaxLen ],
   foreach([Init,Final,Plan] in MaxLens) print_plan(Init,Final,Plan) end,
   nl.


solve_maze(Maze,Init,Final, Plan) =>

   Facts = [$[maze(From,To), maze(To,From)] : [From,To] in Maze].flatten() ++ [$final(Final)], % undirected
   % Facts = [$[maze(From,To)] : [From,To] in Maze].flatten() ++ [$final(Final)], % directed graph
   % writeln(facts=Facts),
   cl_facts(Facts),

   time(planner.best_plan(Init,Plan)),
   % print_plan(Init, Final, Plan),
   write(len=Plan.length),nl.


print_plan(Init, Final, Plan) => 
   printf("\nFrom %w -> %w\n", Init, Final),
   foreach([From,To] in Plan) printf("%w -> %w\n", From,To) end, 
   nl.


problem(1,Maze) => 
   Maze = 
      [[1,2],[2,3],[3,4],[4,9],[9,14],[9,8],[8,7],[7,12],[12,13],
       [12,11],[11,6],[11,16],[16,17],[17,22],[21,22],[22,23],
       [23,18],[23,24],[24,19],[19,20],[20,15],[15,10],[10,5],[20,25]].


action(From,To,Move,Cost) => 
   maze(From,To),
   Move = [From,To],
   Cost = 1.
/* 

  Missionaries and cannibals problem in Picat.

  See
  http://en.wikipedia.org/wiki/Missionaries_and_cannibals_problem

  Inspired by this Prolog code
  http://www-users.cs.york.ac.uk/~suresh/LAI/exercise1-sol/node3.html
  http://www-users.cs.york.ac.uk/~suresh/LAI/exercise1-sol/node6.html

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
   initial_state(Init),
   time(best_plan(Init,L)),
   foreach(Move in L) writeln(Move) end,
   nl,
   writeln(len=L.length),
   nl.

go2 => 
   initial_state(Init),
   time(best_plan_nondet(Init,L)),
   foreach(Move in L) writeln(Move) end,
   nl,
   writeln(len=L.length),
   fail,

   nl.



initial_state(Init) => Init=[3,3,left].

final(Goal) => Goal=[0,0,_].


legal([LM,LC,_]) ?=>
    %% left-hand side either missionaries greater-equals cannibals
    %%                 or    no missionaries and some cannibals
    ( LM >= LC ; (LM == 0, not(LC==0)) ),
    %% right-hand side either missionaries greater-equals cannibals
    %%                 or    no missionaries and some cannibals
    ( (3 - LM) >= (3 - LC) ; (LM == 3, not(LC==3)) ).


table
%% Move 1 missionary across to right
action(From,To,Move,Cost) ?=> 
    From=[LM,LC,left],
    To=[NLM,LC,right],
    Move=[m1_to_right,To],
    LM >= 1,
    NLM = LM - 1,
    legal([NLM,LC,right]),Cost=1.

%% Move 1 missionary across to left
action(From,To,Move,Cost) ?=> 
    From=[LM,LC,left],
    To=[NLM,LC,right],
    Move=[m1_to_left,To],
    (3 - LM) >= 1,
    NLM = LM + 1,
    legal([NLM,LC,right]),Cost=1.


%% Move 1 cannibal across to right
action(From,To,Move,Cost) ?=> 
    From=[LM,LC,left],
    To=[LM,NLC,right],
    Move=[c1_to_right,To],
    LC >= 1,
    NLC = LC - 1,
    legal([LM,NLC,right]),Cost=1.

%% Move 1 cannibal across to left
action(From,To,Move,Cost) ?=> 
    From=[LM,LC,right],
    To=[LM,NLC,left],
    Move=[c1_to_left,To],
    (3 - LC) >= 1,
    NLC = LC + 1,
    legal([LM,NLC,left]),Cost=1.

%% Move 2 missionaries across to right
action(From,To,Move,Cost) ?=> 
    From=[LM,LC,left],
    To=[NLM,LC,right],
    Move=[m2_to_right,To],
    LM >= 2,
    NLM = LM - 2,
    legal([NLM,LC,right]),Cost=1.

%% Move 2 missionaries across to left
action(From,To,Move,Cost) ?=> 
    From=[LM,LC,right],
    To=[NLM,LC,left],
    Move=[m2_to_left,To],
    (3 - LM) >= 2,
    NLM = LM + 2,
    legal([NLM,LC,right]),Cost=1.

%% Move 2 cannibals across to right
action(From,To,Move,Cost) ?=> 
    From=[LM,LC,left],
    To=[LM,NLC,right],
    Move=[c2_to_right,To],
    LC >= 2,
    NLC = LC - 2,
    legal([LM,NLC,right]),Cost=1.

%% Move 2 cannibals across to left
action(From,To,Move,Cost) ?=> 
    From=[LM,LC,right],
    To=[LM,NLC,left],
    Move=[c2_to_left,To],
    (3 - LC) >= 2,
    NLC = LC + 2,
    legal([LM,NLC,left]),Cost=1.


%% Move 1 missionary + 1 cannibal across to right
action(From,To,Move,Cost) ?=> 
    From=[LM,LC,left],
    To=[NLM,NLC,right],
    Move=[m1c1_to_right,To],
    LM >= 1,
    LC >= 1,
    NLM = LM - 1,
    NLC = LC - 1,
    legal([NLM,NLC,right]),Cost=1.


%% Move 1 missionary + 1 cannibal across to left
action(From,To,Move,Cost) => 
    From=[LM,LC,right],
    To=[NLM,NLC,left],
    Move=[m1c1_to_left,To],
    (3 - LM) >= 1,
    (3 - LC) >= 1,
    NLM = LM + 1,
    NLC = LC + 1,
    legal([NLM,NLC,left]),Cost=1.
/* 

  Monkey and bananas problem in Picat.

  Inspired by the Prolog code in Thinking as Computation. 

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
   initial_state(Init),
   time(best_plan(Init,L)),
   write(L), nl,
   writeln(len=L.length),
   nl.


%  This is the monkey and bananas as a planning problem.

% The bananas, monkey, and box are at different locations.
% The monkey is not on the box and has no bananas.
initial_state(Init) => Init=[loc1,loc2,loc3,n,n].


% The goal is any state where the monkey has the bananas.
final(Goal) => Goal=[_,_,_,_,y].

table
% Climbing on the box causes the monkey to be on the box.
action(From,To,Move,Cost) ?=> 
   From=[B,M,M,n,H],Move=climb_on,To=[B,M,M,y,H],Cost=1.

% Climbing off the box causes the monkey to be off the box.
action(From,To,Move,Cost) ?=> 
   From=[B,M,M,y,H],Move=climb_off,To=[B,M,M,n,H],Cost=1.

% Grabbing the bananas causes the monkey to have the bananas.
action(From,To,Move,Cost) ?=> 
   From=[B,B,B,y,n],Move=grab,To=[B,B,B,y,y],Cost=1.

% Pushing the box changes where the monkey and the box are.
action(From,To,Move,Cost) ?=> 
   From=[B,M,M,n,H],Move=$push(X),To=[B,X,X,n,H],Cost=1.

% Going to a location changes where the monkey is.
action(From,To,Move,Cost) =>   
   From=[B,_,L,n,H],Move=$go(X),To=[B,X,L,n,H],Cost=1.

/* 

  2x3-puzzle in Picat.

  This is a stripped down 8-puzzle,
  inspired by the Prolog code in Thinking as Computation. 

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
   nolog,
   initial_state(Init),
   time(best_plan(Init,L)),
   write(L), nl,
   writeln(len=L.length),
   nl.

go2 => 
   nolog,
   initial_state(Init),
   time(best_plan_nondet(Init,L)),
   write(L), nl,
   writeln(len=L.length),
   fail,
   nl.


% This is a 2x3 version of the 15 puzzle.
% Initial state:
%%%%%%%%%
%   1 5 %
% 4 3 2 %
%%%%%%%%%
initial_state(Init) => Init=[0,1,5,4,3,2].
final(Goal) => Goal=[1,2,3,4,5,0].

% Up <-> Down
action(From,To,Move,Cost) ?=> 
   Cost=1, From=[0,B,C, X,E,F],Move=$up(X),To=[X,B,C, 0,E,F].
action(From,To,Move,Cost) ?=> 
   Cost=1, From=[A,0,C, D,X,F],Move=$up(X),To=[A,X,C, D,0,F].
action(From, To, Move,Cost) ?=> 
   Cost=1, From=[A,B,0, D,E,X],Move=$up(X),To=[A,B,X, D,E,0].
action(From,To,Move,Cost) ?=> 
   % From=S1,Move=$down(X),To=S2,
   % action(S2,$up(X),S1).
   Cost=1, Move=$down(X),
   action(To, From, $up(X),Cost).

% Left <-> Right
action(From,To,Move,Cost) ?=> 
   Cost=1, From=[0,X,C, D,E,F],Move=$left(X),To=[X,0,C, D,E,F].
action(From,To,Move,Cost) ?=> 
   Cost=1, From=[A,0,X, D,E,F],Move=$left(X),To=[A,X,0, D,E,F].
action(From,To,Move,Cost) ?=>
   Cost=1, From=[A,B,C, 0,X,F],Move=$left(X),To=[A,B,C, X,0,F].
action(From,To,Move,Cost) ?=> 
   Cost=1, From=[A,B,C, D,0,X],Move=$left(X),To=[A,B,C, D,X,0].
action(From,To,Move,Cost) => 
   % From=S1,Move=$right(X),To=S2,
   % action(S2,$left(X),S1).
   Cost=1, Move=$right(X),
   action(To,From,$left(X),Cost).
/*

  Railroad switching problem in Picat.

  Problem fromStefan Edelkamp, Stefan Schrdl:
  "Heuristic Search: Theory and Applications, page ff"

  Note: This use a graph representation.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% planner
go =>
   initial_state(Init),
   time(planner.best_plan(Init,Plan)),
   print_plan(Plan),
   write(len=Plan.length),nl.

%
% planner for optimal path 
% and then bplan for all optimal paths
% 
go2 =>
   % first find the optimal plan
   initial_state(Init),
   time(planner.best_plan(Init,Plan1)),

   % then find all optimal plans
   P = new_list(Plan1.length),
   All=findall(P,bplan.plan(P)),
   foreach(Plan in All) print_plan(Plan) end,
   writeln(len=All.length),
   nl.

print_plan(Plan) => 
   foreach([From,To] in Plan) printf("%w -> %w\n", From,To) end, 
   nl.


index(-)
initial_state([e,a,b]).

index(-)
final([e,b,a]).

% for bplan
index(-)
goal_state([e,b,a]).


action(From,To,Move,Cost) ?=>
   graph2(From,To,_),
   Move = [From,To],
   Cost = 1.


% for bplan
legal_move(From,Move,To) =>
   action(From,To,Move,_).


%
% This is the graph from figure 1.4 (page 13) in "Heuristic Search..."
% (This is an directed graph.)
index(-,-,-)
graph([e,a,b],[b,a,e],eab_bae).
graph([b,a,e],[b,e,a],bae_bea).
graph([b,a,e],[a,e,b],bae_aeb).
graph([b,e,a],[a,b,e],bea_abe).
graph([a,b,e],[a,e,b],abe_aeb).
graph([a,b,e],[e,b,a],abe_eba).

% Make the graph undirected
graph2(From,To,Move) ?=> 
  graph(From,To,Move).

graph2(From,To,Move) ?=> 
  graph(To,From, Move).import planner.

main =>
   % One 1-rotation:
   Init = [2,3,7,4,1,6,11,8,5,9,10,12,13,14,15,16],

   % 2,1
   % Init = [2,7,4,8,1,3,11,12,5,6,9,10,13,14,15,16],

   % 1,2,1
   % Init = [7,4,11,8,2,3,9,12,1,5,6,10,13,14,15,16],

   % 1,2,3
   % Init = [3,4,11,8,1,2,10,12,6,5,7,15,9,13,14,16],
   
   % 1,2,3,2,2,3
   % Init = [8,12,7,15,1,4,2,10,3,6,11,14,5,9,13,16 ],
   
   % 4,4,4,1,2,3,2,2,3
   % Init = [8,12,7,15,1,14,16,13,3,10,11,9,5,2,4,6 ],

   % Random puzzle
   % Init = [2,4,16,11,15,7,12,1,8,9,14,3,10,5,13,6],

   % swap 15<->16 (GAP says 53 moves,but that's probably not optimal )
   % Init = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,16,15 ],

   % time(best_plan_unbounded(Init, 10,L,Cost)), % Neng-Fa's original (2,1 problem: heap error)
   % time(best_plan(Init, 10,L,Cost)), % solve 2,1 problem in 2.2 seconds
   % time(plan(Init, L)), % solves 2,1 problem: heap error
   % time(best_plan(Init, 9,L,Cost)), % solves 2,1 problem in 0.376 seconds
   % time(best_plan(Init, 9,L,Cost)), % solves 2,1 problem in 0.376 seconds
                                    % solve 4,4,4,1,2,3,2,2,3 in 2.42s


   % time(best_plan(Init, 10,L,Cost)), % solves 2,1 problem in 2.2s seconds
                                     % solve 4,4,4,1,2,3,2,2,3 in 8.8s

   % time(best_plan(Init, L)),
   time(best_plan(Init, 40,L,Cost)),
   writeln(L),
   writeln(len=L.length),
   writeln(cost=Cost),
   nl.

% hakank:
go2 =>
   % One 1-rotation:
   % Init = [2,3,7,4,1,6,11,8,5,9,10,12,13,14,15,16],

   % 2,1
   % Init = [2,7,4,8,1,3,11,12,5,6,9,10,13,14,15,16],

   % 1,2,1
   % Init = [7,4,11,8,2,3,9,12,1,5,6,10,13,14,15,16],

   % 1,2,3
   % Init = [3,4,11,8,1,2,10,12,6,5,7,15,9,13,14,16],
   
   % 1,2,3,2,2,3
   % Init = [8,12,7,15,1,4,2,10,3,6,11,14,5,9,13,16 ],
   
   % 4,4,4,1,2,3,2,2,3
   % Init = [8,12,7,15,1,14,16,13,3,10,11,9,5,2,4,6 ],

   % Random puzzle
   Init = [2,4,16,11,15,7,12,1,8,9,14,3,10,5,13,6],

   % swap 15<->16 (GAP says 53 moves,but that's probably not optimal )
   % Init = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,16,15 ],

   Limit :: 2..20,
   indomain(Limit),
   writeln(limit=Limit),
   if time(best_plan(Init, Limit,L,Cost)) then
     writeln(L),
     writeln(len=L.length),
     writeln(cost=Cost),
     nl
   else 
     fail
   end,
   nl.



final(Goal) => Goal=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16].


% table
% 1, 2, 3,  7, 11, 10,  9,  5, % move 1 (around 6)
action([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16],To,M,Cost) ?=> 
    M=1, Cost=1, To=[M5,M1,M2,M4,M9,M6,M3,M8,M10,M11,M7,M12,M13,M14,M15,M16].

% 2, 3, 4,  8, 12, 11, 10,  6, % move 2 (around 7)
action([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16],To,M,Cost) ?=> 
    M=2, Cost=1, To=[M1,M6,M2,M3,M5,M10,M7,M4,M9,M11,M12,M8,M13,M14,M15,M16].

% 5, 6, 7, 11, 15, 14, 13,  9, % move 3 (around 10)
action([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16],To,M,Cost) ?=> 
    M=3, Cost=1, To=[M1,M2,M3,M4,M9,M5,M6,M8,M13,M10,M7,M12,M14,M15,M11,M16].

% 6, 7, 8, 12, 16, 15, 14, 10, % move 4 (around 11)
action([M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16],To,M,Cost) => 
    M=4, Cost=1, To=[M1,M2,M3,M4,M5,M10,M6,M7,M9,M14,M11,M8,M13,M15,M16,M12].

/*

  Water jugs problem in Picat.

  We have two jugs with water, one with 4L and one with 3L: [4,3].
  The goal is to have 2L in the first and 0L in the last: [2,0]

  This is a planning model.

  This version use the built-in module planner.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   %           Max  Init  Goal
   water_jugs([4,3],[0,0],[2,0]),
   nl.

go2 =>
   water_jugs([5,4],[0,0],[3,0]),
   nl.

go3 =>
   water_jugs([6,5],[0,0],[4,0]),
   nl.

go4 =>
   water_jugs([7,6],[0,0],[5,0]),
   nl.

% The Die Hard problem
% http://www.math.tamu.edu/~dallen/hollywood/diehard/diehard.htm
go5 =>
   water_jugs([5,3],[0,0],[4,0]),
   nl.

% http://www.cs.ucsb.edu/~pconrad/cs40/lessons/numberTheory/JugsMake1from5and7.html
go6 =>
   water_jugs([7,5],[0,0],[1,0]),
   nl.

go7 =>
   water_jugs([82,39],[0,0],[2,0]), % 118 steps
   nl,
   water_jugs([85,58],[0,0],[2,0]), % 137 steps
   nl,
   water_jugs([88,65],[0,0],[2,0]), % 146 steps
   nl,
   water_jugs([87,80],[0,0],[2,0]), % 142 steps
   nl,
   water_jugs([301,80],[0,0],[2,0]), % 362 steps
   nl,
   water_jugs([968,921],[0,0],[2,0]), % 803 steps
   nl,
   water_jugs([968,283],[0,0],[2,0]), % 946 steps
   nl.


% Random version
go8 => 
   XMax = 3+random2() mod 400,
   YMax = random_list([I : I in 2..XMax,gcd(XMax,I) == 1]),
   time_out(water_jugs([XMax,YMax],
              [0,0],
              [2,0]),
            60000, Status),
   writeln(Status),
   writeln([XMax,YMax]),
   nl.

% Random version
go9 => 
   XMax = 3+random2() mod 1000,
   YMax = random_list([I : I in 2..XMax,gcd(XMax,I) == 1]),
   time_out(water_jugs([XMax,YMax],
              [0,0],
              [2,0]),
            60000, Status),
   writeln(Status),
   writeln([XMax,YMax]),
   nl.

go10 =>
   time(water_jugs([301,80],[0,0],[2,0])), % 362 steps
   nl.


go11 =>
   time(water_jugs([968,283],[0,0],[2,0])), % 362 steps
   nl.



%
% For bplan.plan2/3
%
% _Much_ faster than water_jugs.pi
% 
water_jugs([XMax,YMax],[XInit,YInit],[XGoal,YGoal]) =>

   writeln(max=[XMax,YMax]),
   writeln(init=[XInit,YInit]),
   writeln(final=[XGoal,YGoal]),

   % Add the facts for bplan etc.
   cl_facts($[initial_state([XInit,YInit]), 
              final([XGoal,YGoal])]),

   get_global_map().put(x,XMax),
   get_global_map().put(y,YMax),

   time(best_plan([XInit,YInit],L)),
   foreach(E in L) println(E) end,
   writeln(len=L.length),
   % writeln(cost=Cost),
   nl.

table
% fill X from ground
action([X,Y],To,M,Cost), X < get2(x) ?=> 
  To = [X2,Y2], 
  X2 = get2(x), 
  Y2 = Y,
  Cost=1,
  M = [fill,x,from,ground,[X2,Y2]].

% fill Y from ground
action([X,Y],To,M,Cost), Y < get2(y) ?=> 
  To=[X2,Y2], 
  X2 = X, 
  Y2 = get2(y),
  Cost=1,
  M = [fill,y,from,ground,[X2,Y2]].

% Y -> X
action([X,Y],To,M,Cost), Y > 0, X < get2(x) ?=> 
   To = [X2,Y2], 
   MaxToFill = get2(x)-X,
   ToFill = min(Y,MaxToFill),
   Y2 = Y-ToFill,
   X2 = X+ToFill,
   Cost=1,
   M = [fill,x,from,y,with,ToFill,[X2,Y2]].

% X -> Y
action([X,Y],To,M,Cost), X > 0, Y < get2(y) ?=> 
   To = [X2,Y2], 
   MaxToFill = get2(y)-Y,
   ToFill = min(X,MaxToFill),
   X2 = X-ToFill,
   Y2 = Y+ToFill,
   Cost=1,
   M = [fill,y,from,x,with,ToFill,[X2,Y2]].

% empty X
action([X,Y],To,M,Cost), X > 0 ?=> 
   To = [X2,Y2], 
   X2 = 0, Y2 = Y,
   Cost=1,
   M = [empty,x,[X2,Y2]].

% empty Y
action([X,Y],To,M,Cost), Y > 0 => 
   To=[X2,Y2], 
   X2 = X, Y2 = 0,
   Cost=1,
   M = [empty,y,[X2,Y2]].


% Get the global x and y
get2(X) = get_global_map().get(X).


random_list(List) = List[1+random2() mod List.length].

/*

  The Family Puzzle in Picat.

  From Drools Puzzle Round 2: The Familiy Puzzle
  http://blog.athico.com/2007/08/drools-puzzle-round-2-familiy-puzzle.html
  """
  
  * Three men, Abel, Locker and Snyder are married to Edith, Doris and Luisa, 
    but not necessarily in this order.
  * Each couple has one son.
  * The sons are called Albert, Henry and Victor.
  * Snyder is nor married to Luisa, neither is he Henry's father.
  * Edit is not married to Locker and not Albert's mother.
  * If Alberts father is either Locker or Snyder, then Luisa is Victor's mother.
  * If Luisa is married to Locker, then Doris is not Albert's mother. 
  
  Who is married to whom and what are their sons called?

  Taken from the German book "Denken als Spiel" by Willy Hochkeppel, 1973 
  (Thinking as a Game).  
  """
  
  Solutions and discussions
  http://ningning.org/blog2/2008/05/25/drools-puzzles-result-round-2-the-familiy-puzzle
  http://rbs.gernotstarke.de/samples/page21/page21.html


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   N = 3,

   Abel = 1,
   Locker = 2,
   Snyder = 3,
   Men = [Abel,Locker,Snyder],
   MenS = ["Abel","Locker","Snyder"],

   WomenS = ["Edith", "Doris", "Luisa"],
   Women = [Edith, Doris, Luisa],
   Women :: 1..N,

   SonsS = ["Albert","Henry", "Victor"],
   Sons = [Albert,Henry, Victor],
   Sons :: 1..N,


   all_different(Women),
   all_different(Sons),

   % Snyder is nor married to Luisa, neither is he Henry"s father.
   Snyder #!= Luisa,
   Snyder #!= Henry,
   
   % Edith is not married to Locker and not Albert"s mother.
   Edith #!= Locker,
   Edith #!= Albert,
   
   % If Alberts father is either Locker or Snyder, 
   % then Luisa is Victor"s mother.
   (
       (Albert #= Locker #\/ Albert #= Snyder) #=> 
      Luisa #= Victor
   ),

   % If Luisa is married to Locker, 
   % then Doris is not Albert"s mother. 
   (
       Luisa #= Locker #=> 
      Doris #!= Albert
   ),

   Vars = Women ++ Sons,
   solve(Vars),

   writeln(men=Men),
   writeln(women=Women),
   writeln(sons=Sons),
   nl,
   foreach(I in 1..N)
        Man = [ MenS[W] : W in 1..N, Men[W] == I],
        Woman = [ WomenS[W] : W in 1..N, Women[W] == I],
        Son = [ SonsS[S] : S in 1..N, Sons[S] == I],
        Family = Man ++ Woman ++ Son,
        printf("%w\n", Family)
   end,
   nl.
/* 

  Tic-tac benchmark in Picat.

  From
  http://www.jekejeke.ch/idatab/doclet/prod/en/docs/05_run/15_stdy/06_bench/09_programs/06_tictac/01_tictac.p.html

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


/**
 * Prolog code for the tic-tac-toe game.
 *
 * Min-max search via negation.
 *
 * Copyright 2011-2012, XLOG Technologies GmbH, Switzerland
 * Jekejeke Prolog 0.9.1 (a fast and small prolog interpreter)
 */

% move(+Board,+Player,-Board)
move([[-,B,C],[D,E,F],[G,H,I]],P,M2) ?=> M2=[[P,B,C],[D,E,F],[G,H,I]].
move([[A,-,C],[D,E,F],[G,H,I]],P,M2) ?=> M2=[[A,P,C],[D,E,F],[G,H,I]].
move([[A,B,-],[D,E,F],[G,H,I]],P,M2) ?=> M2=[[A,B,P],[D,E,F],[G,H,I]].
move([[A,B,C],[-,E,F],[G,H,I]],P,M2) ?=> M2=[[A,B,C],[P,E,F],[G,H,I]].
move([[A,B,C],[D,-,F],[G,H,I]],P,M2) ?=> M2=[[A,B,C],[D,P,F],[G,H,I]].
move([[A,B,C],[D,E,-],[G,H,I]],P,M2) ?=> M2=[[A,B,C],[D,E,P],[G,H,I]].
move([[A,B,C],[D,E,F],[-,H,I]],P,M2) ?=> M2=[[A,B,C],[D,E,F],[P,H,I]].
move([[A,B,C],[D,E,F],[G,-,I]],P,M2) ?=> M2=[[A,B,C],[D,E,F],[G,P,I]].
move([[A,B,C],[D,E,F],[G,H,-]],P,M2) => M2=[[A,B,C],[D,E,F],[G,H,P]].

% init(+Board)
init(B) => B=[[-,-,-],[-,-,-],[-,-,-]].

% win(+Board,+Player)
win([[P,P,P],[_,_,_],[_,_,_]],P) => true.
win([[_,_,_],[P,P,P],[_,_,_]],P) => true.
win([[_,_,_],[_,_,_],[P,P,P]],P) => true.
win([[P,_,_],[P,_,_],[P,_,_]],P) => true.
win([[_,P,_],[_,P,_],[_,P,_]],P) => true.
win([[_,_,P],[_,_,P],[_,_,P]],P) => true.
win([[P,_,_],[_,P,_],[_,_,P]],P) => true.
win([[_,_,P],[_,P,_],[P,_,_]],P) => true.

% other(+Player,-Player).
other(o,P2) => P2=x.
other(x,P2) => P2=o.

% tie(+Board,+Player)
tie(X,P) =>
  not move(X,P,_).

% best(+Board,+Player,-Board)
best(X,P,Y) =>
  move(X,P,Y),
  (win(Y,P) -> true;
    other(P,Q),
    not tie(Y,Q),
    not best(Y,Q,_)).

% Should fail
tictac =>
  init(X), 
  best(X,x,_),
  writeln(X).

tictac2 =>
  init(X), 
  best(X,x,_).

go => tictac -> writeln(ok) ; writeln (nope).
go2 => tictac -> write(ok) ; write(nope).

/*

  Mrs Timpkin's Age in Picat.

  From 
  http://www.comp.nus.edu.sg/~henz/projects/puzzles/arith/index.html
  """
  Mrs Timpkin's Age    from "Amusements in Mathematics, Dudeney", number 43.
 
  When the Timpkinses married eighteen years ago, Timpkins was three
  times as old as his wife, and today he is just twice as old as she.
  How old is Mrs. Timpkin? 

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   write(findall(LD, $timpkin(LD))),nl.


timpkin(LD) =>
   
   LD = [T, W],
   LD :: 1..100,
   T - 18 #= 3 * (W - 18),
   T #= 2 * W,

   solve([],LD).
/*

  to_num in Picat.

  to_num(List, Base, Num) converts a list of integers to a number for 
  a base Base. It is bidirectional but it is really recommended that
  the length of List is fixed.

  See examples below.


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

%
% Tests
% 
go =>

   % from number -> digit list
   A = new_list(4),
   A :: 0..9,       
   to_num(A, 10, 1234),
   writeln(a=A),

   % from digit list -> number
   B = [3,1,4,1,5,9,2,6],
   to_num(B, 10, Num),
   solve([Num]),
   writeln(num=Num),

   % show all 2 digit numbers in base 11, 
   C = new_list(2), 
   C :: 0..10, % For base 11
   L = findall([Num2, C], (to_num(C, 11, Num2), solve([ff],C))), 
   writeln([L.length, L]).

go2 =>
  A = new_list(4),
  A :: 0..9,       
  Num :: 0..9999,

  to_num(A, 10, Num),

  Num #> 5000,
  Num mod 3 #= 1,

  A[2] + A[3] #= A[4],
  all_different(A),
  sum(A) #= 22,

  solve(A ++ [Num]),
  println([a=A,num=Num]).



%
% converts a number Num to/from a list of integer List given a base Base
%
to_num(List, Base, Num) =>
   Len = length(List),
   Num #= sum([List[I]*Base**(Len-I) : I in 1..Len]).
/*

  Torn numbers in Picat.

  From
  http://www.comp.nus.edu.sg/~henz/projects/puzzles/digits/torn.html?19

  """
  The Torn Number from "Amusements in Mathematics, Dudeney", number 113

  I had the other day in my possession a label bearing the number 3025
  in large figures. This got accidentally torn in half, so that 30 was
  on one piece and 25 on the other. On looking at these pieces I began
  to make a calculation, scarcely concious of what I was doing, when I
  discovered this little peculiarity. If we add the 30 and the 25
  together and square the sum we get as the result the complete original
  number on the label! Now, the puzzle is to find another number,
  composed of four figures, all different, which may be divided in the
  middle and produce the same result. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   L = findall([LD, Sum], $torn(LD, Sum)),
   write(L),nl.


torn(LD, Sum) =>
   LD = [D3, D2, D1, D0],
   LD :: 0..9,

   all_different(LD),
   D3 #!= 0,
   Sum #= D3 * 10 + D2 + D1 * 10 + D0,
   Sum * Sum #= D3 * 1000 + D2 * 100 + D1 * 10 + D0,

   solve([], LD).
/*

  Tourist Site Competition in Picat.

  From Pierre Flener's presentation 
  "Constraint Technology - A Programming Paradigm on the Rise"
  http://www.it.uu.se/edu/course/homepage/ai/vt08/AI-CT.pdf
     pages 5f: problem statement 
     pages 12f: model
     pages 21ff: walktrough of a solution

  With 7 tourist sites and 7 judges:
  """
  Every tourist site is visited by r = 3 judges.
  Every judge visits c = 3 tourist sites.
  Every pair of sites is visited by lambda = 1 common judge.
  """

  There are 151200 solutions to this problem.
  With the additional constraint that Ali should visit Birka, Falun and Lund
  there are 4320 solutions.


  This problem was also presented as "The Airline-of-the-Year Problem"
  in his (Flener's) presentation
  "Constraint Programming - Programming Paradigm on the Rise"
  http://www.it.uu.se/research/group/astra/ATM-CT/Flener.pdf
  page 4f
  The problem is stated as follows for 7 airlines and 7 judges:
  """
  Constant jury: Every airline is tested by 3 judges.
  Constant load: Every judge tests 3 airlines.
  Equity: Every airline pair is tested by 1 common judge.
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   R = 3,
   C = 3,
   Lambda = 1,

   % Sites
   Birka = 1,
   Falun = 2,
   Lund = 3,
   Mora = 4,
   Sigtuna = 5,
   Uppsala = 6,
   Ystad = 7,
   Sites = [Birka, Falun, Lund, Mora, Sigtuna, Uppsala, Ystad],
   SitesStr = ["Birka", "Falun", "Lund", "Mora", "Sigtuna", "Uppsala", "Ystad"],
   % Judges
   Ali = 1,
   Dan = 2,
   Eva = 3,
   Jim = 4,
   Leo = 5,
   Mia = 6,
   Ulla = 7,
   Judges = [Ali, Dan, Eva, Jim, Leo, Mia, Ulla],
   JudgesStr = ["Ali", "Dan", "Eva", "Jim", "Leo", "Mia", "Ulla"],
   
   SymmetryBreaking = true,
   tourist_site_competition(Sites,Judges,R,C, Lambda,SymmetryBreaking,X),
   foreach(Row in X) writeln(Row) end,
   nl,
   print_assignments(X,SitesStr,JudgesStr).


% Checking the number of solutions
go2 =>
   NumJudges = 7,
   Judges = 1..NumJudges,
   NumSites = 7,
   Sites = 1..NumSites,
   R = 3,
   C = 3,
   Lambda = 1,
   printf("It is %d solutions.\n", num_solutions(Sites,Judges,R,C,Lambda)),
   nl.


num_solutions(Sites,Judges,R,C,Lambda) = NumSolutions =>
  L = findall(X, $tourist_site_competition(Sites,Judges,R,C, Lambda,_,X)),
  NumSolutions = L.length.

tourist_site_competition(Sites,Judges,R,C,Lambda,SymmetryBreaking,X) =>

   NumSites = length(Sites),
   NumJudges = length(Judges),
   writeln([numSites=NumSites, numJudges=NumJudges]),

   % decision variable
   X = new_array(NumSites,NumJudges),
   Vars = vars(X),
   Vars :: 0..1,

   % Symmetry breaking: Assigns the first site to judges {1,2,3}
   if SymmetryBreaking = true then
       foreach(I1 in 1..1..R) X[I1,1] #= 1 end
   end,

   % Every tourist site is visited by R judges.
   foreach(Row in X) sum(Row.to_list()) #= R end,

   % Every judge visits C tourist sites.
   foreach(Column in X.columns().array_matrix_to_list_matrix()) sum(Column) #=C end,

   % Every pair of sites is visited by Lambda common judges.
   % Rows = X.to_list(),
   foreach({X1,I} in zip(X.to_list(), 1..X.length))
      foreach({X2,J} in zip(X.to_list(),1..NumSites))
         if I < J then
           sum([ (XX1 #= 1 #/\ XX1 #= XX2) :
                {XX1,XX2} in zip(X1.to_list(), X2.to_list()) ]) #>= Lambda
         end
      end
   end,
   
   % search
   solve([ff], Vars).



print_assignments(X,SitesStr,JudgesStr) =>
   Len = X.length,
   foreach({Row,S} in zip(X.to_list(),SitesStr))
          printf("%w\t: ",S),
          Where = [ Judge : {R,I} in zip(Row.to_list(), 1..Len), R == 1,  nth(I,JudgesStr,Judge)],
          printf("%w\n", Where)
   end,
   nl.


/*

  Towers of Hanoi Picat.

  From Rosetta code: 
  http://rosettacode.org/wiki/Towers_of_Hanoi
  """
  In this task, the goal is to solve the Towers of Hanoi problem 
  with recursion. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
   Print1 = 1,
   hanoi(4,Print1),
   nl,
   Print2 = 0,
   hanoi(24,Print2),
   nl.

go2 =>
   time(hanoi(10,1)),
   nl.

hanoi(N, Print) => 
   printf("N=%d\n", N),
   Count = move(N, left, center, right, Print, 1) ,
   printf("count=%d, theoretical=%d\n", Count, 2**N-1),
   nl.

move(0, _From, _To, _Via, _Print, _Count) = 0 => true.
table
move(N, From, To, Via, Print, Count) = Count1 => 
    Count1 := Count + move(N - 1, From, Via, To, Print, Count),
    if Print == 1 then
       printf("Move disk %w from pole %w to pole %w\n", N, From, To)
    end,
    Count1 := Count1 + move(N - 1, Via, To, From, Print, Count).

/*

  Traffic lights problem in Picat.

  CSPLib problem 16
  http://www.cs.st-andrews.ac.uk/~ianm/CSPLib/prob/prob016/index.html
  """
  Specification:
  Consider a four way traffic junction with eight traffic lights. Four of the traffic 
  lights are for the vehicles and can be represented by the variables V1 to V4 with domains 
  {r,ry,g,y} (for red, red-yellow, green and yellow). The other four traffic lights are 
  for the pedestrians and can be represented by the variables P1 to P4 with domains {r,g}.
  
  The constraints on these variables can be modelled by quaternary constraints on 
  (Vi, Pi, Vj, Pj ) for 1<=i<=4, j=(1+i)mod 4 which allow just the tuples 
  {(r,r,g,g), (ry,r,y,r), (g,g,r,r), (y,r,ry,r)}.
 
  It would be interesting to consider other types of junction (e.g. five roads 
  intersecting) as well as modelling the evolution over time of the traffic light sequence. 
  ...
 
  Results
  Only 2^2 out of the 2^12 possible assignments are solutions.
  
  (V1,P1,V2,P2,V3,P3,V4,P4) = 
     {(r,r,g,g,r,r,g,g), (ry,r,y,r,ry,r,y,r), (g,g,r,r,g,g,r,r), (y,r,ry,r,y,r,ry,r)}
     [(1,1,3,3,1,1,3,3), ( 2,1,4,1, 2,1,4,1), (3,3,1,1,3,3,1,1), (4,1, 2,1,4,1, 2,1)}
 
 
  The problem has relative few constraints, but each is very tight. Local propagation 
  appears to be rather ineffective on this problem.   
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go => 
  % symbol version of the allowed light combinations
  Allowed1 = [[r,r,g,g],
              [ry,r,y,r],
              [g,g,r,r],
              [y,r,ry,r]],
  print_results(findall([V,P], traffic_lights_table(V,P,Allowed1))),
  nl.


%
% Using table Allowed
%
traffic_lights_table(V, P, Allowed1) =>
  N = 4,

  % Convert to integers according to tr/2.
  % Note: table_in requires structure as a term of the format: (...)
  Allowed = [[D : S in A, tr(S,D)].to_array(): A in Allowed1],
  V = new_list(N), V :: 1..N,
  P = new_list(N), P :: 1..N,
  foreach(I in 1..N, J in 1..N, J == (1+I) mod N)
    table_in({V[I], P[I], V[J], P[J]}, Allowed)
  end,

  Vars = V ++ P,
  solve(Vars).

% translation table of symbols <-> integer
index(-,-)
tr(r, 1).
tr(ry,2).
tr(g, 3).
tr(y, 4).


% translate back to the traffic light symbols
print_results(L) =>
  foreach([V,P] in L)
    foreach(I in 1..4)
      tr(VC,V[I]),
      tr(PC,P[I]),
      printf("%w %w ",VC,PC)
    end,
    nl
 end.
/*

  Trains in Picat.

  This is a simple example using table constraint. 
  From SWI prolog manual
  http://www.swi-prolog.org/pldoc/doc_for?object=section%282%2c%20%27A.7%27%2c%20swi%28%27%2fdoc%2fManual%2fclpfd.html%27%29%29
  """
  As another example, consider a train schedule represented as a list
  of quadruples, denoting departure and arrival places and times for each 
  train. In the following program, Ps is a feasible journey of length 
  3 from A to D via trains that are part of the given schedule.
  """

  Answer:
  [[1,2,0,1],[2,3,4,5],[3,4,8,9]]


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   threepath(1, 4, Ps,TotalTime),
   println(Ps),
   println(total_time=TotalTime),nl.

% Valid tuples for the table constraint
trains(Allowed) => 
  Allowed = [{1,2,0,1},{2,3,4,5},{2,3,0,1},{3,4,5,6},{3,4,2,3},{3,4,8,9}].
 
threepath(A, D, Ps,TotalTime) =>

   Ps = [{A,B,_T0,T1},{B,C,T2,T3},{C,D,T4,_T5}],
   T2 #> T1,
   T4 #> T3,
   trains(Ts),
   % Table constraint
   table_in(Ps,Ts),

   TotalTime #= sum([ End-Start :  (_,_,Start,End) in Ps]).
/* 

  Transitive closure using tabling in Picat.

  Ported from these two B-Prolog program
  http://www.probp.com/examples/tabling/transitiveRight.pl
  http://www.probp.com/examples/tabling/transitiveLeft.pl

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


go => 
    time(top).

top ?=> 
    reach(X,Y),
    writeln([X,Y]),
    fail
.
top => true.


go2 => 
    time(top2).

top2 ?=> 
    reach2(X,Y),
    writeln([X,Y]),
    fail.

top2 => true.


% Transitive closure right
% table
reach(X,Y) ?=> edge(X,Y).
reach(X,Y)  => edge(X,Z),reach(Z,Y).

% Transitive closure left
table
reach2(X,Y) ?=> edge(X,Y).
reach2(X,Y)  => reach2(Z,Y), edge(X,Z).


index(-,-)
edge(1,2).
edge(1,3).
edge(2,4).
edge(2,5).
edge(3,6).
edge(3,7).
edge(4,8).
edge(4,9).
edge(5,10).
edge(5,11).
edge(6,12).
edge(6,13).
edge(7,14).
edge(7,15).
edge(8,16).
edge(8,17).
edge(9,18).
edge(9,19).
edge(10,20).
edge(10,21).
edge(11,22).
edge(11,23).
edge(12,24).
edge(12,25).
edge(13,26).
edge(13,27).
edge(14,28).
edge(14,29).
edge(15,30).
edge(15,31).
edge(16,32).
edge(16,33).
edge(17,34).
edge(17,35).
edge(18,36).
edge(18,37).
edge(19,38).
edge(19,39).
edge(20,40).
edge(20,41).
edge(21,42).
edge(21,43).
edge(22,44).
edge(22,45).
edge(23,46).
edge(23,47).
edge(24,48).
edge(24,49).
edge(25,50).
edge(25,51).
edge(26,52).
edge(26,53).
edge(27,54).
edge(27,55).
edge(28,56).
edge(28,57).
edge(29,58).
edge(29,59).
edge(30,60).
edge(30,61).
edge(31,62).
edge(31,63).
edge(32,64).
edge(32,65).
edge(33,66).
edge(33,67).
edge(34,68).
edge(34,69).
edge(35,70).
edge(35,71).
edge(36,72).
edge(36,73).
edge(37,74).
edge(37,75).
edge(38,76).
edge(38,77).
edge(39,78).
edge(39,79).
edge(40,80).
edge(40,81).
edge(41,82).
edge(41,83).
edge(42,84).
edge(42,85).
edge(43,86).
edge(43,87).
edge(44,88).
edge(44,89).
edge(45,90).
edge(45,91).
edge(46,92).
edge(46,93).
edge(47,94).
edge(47,95).
edge(48,96).
edge(48,97).
edge(49,98).
edge(49,99).
edge(50,100).
edge(50,101).
edge(51,102).
edge(51,103).
edge(52,104).
edge(52,105).
edge(53,106).
edge(53,107).
edge(54,108).
edge(54,109).
edge(55,110).
edge(55,111).
edge(56,112).
edge(56,113).
edge(57,114).
edge(57,115).
edge(58,116).
edge(58,117).
edge(59,118).
edge(59,119).
edge(60,120).
edge(60,121).
edge(61,122).
edge(61,123).
edge(62,124).
edge(62,125).
edge(63,126).
edge(63,127).
edge(64,128).
edge(64,129).
edge(65,130).
edge(65,131).
edge(66,132).
edge(66,133).
edge(67,134).
edge(67,135).
edge(68,136).
edge(68,137).
edge(69,138).
edge(69,139).
edge(70,140).
edge(70,141).
edge(71,142).
edge(71,143).
edge(72,144).
edge(72,145).
edge(73,146).
edge(73,147).
edge(74,148).
edge(74,149).
edge(75,150).
edge(75,151).
edge(76,152).
edge(76,153).
edge(77,154).
edge(77,155).
edge(78,156).
edge(78,157).
edge(79,158).
edge(79,159).
edge(80,160).
edge(80,161).
edge(81,162).
edge(81,163).
edge(82,164).
edge(82,165).
edge(83,166).
edge(83,167).
edge(84,168).
edge(84,169).
edge(85,170).
edge(85,171).
edge(86,172).
edge(86,173).
edge(87,174).
edge(87,175).
edge(88,176).
edge(88,177).
edge(89,178).
edge(89,179).
edge(90,180).
edge(90,181).
edge(91,182).
edge(91,183).
edge(92,184).
edge(92,185).
edge(93,186).
edge(93,187).
edge(94,188).
edge(94,189).
edge(95,190).
edge(95,191).
edge(96,192).
edge(96,193).
edge(97,194).
edge(97,195).
edge(98,196).
edge(98,197).
edge(99,198).
edge(99,199).
edge(100,200).
edge(100,201).
edge(101,202).
edge(101,203).
edge(102,204).
edge(102,205).
edge(103,206).
edge(103,207).
edge(104,208).
edge(104,209).
edge(105,210).
edge(105,211).
edge(106,212).
edge(106,213).
edge(107,214).
edge(107,215).
edge(108,216).
edge(108,217).
edge(109,218).
edge(109,219).
edge(110,220).
edge(110,221).
edge(111,222).
edge(111,223).
edge(112,224).
edge(112,225).
edge(113,226).
edge(113,227).
edge(114,228).
edge(114,229).
edge(115,230).
edge(115,231).
edge(116,232).
edge(116,233).
edge(117,234).
edge(117,235).
edge(118,236).
edge(118,237).
edge(119,238).
edge(119,239).
edge(120,240).
edge(120,241).
edge(121,242).
edge(121,243).
edge(122,244).
edge(122,245).
edge(123,246).
edge(123,247).
edge(124,248).
edge(124,249).
edge(125,250).
edge(125,251).
edge(126,252).
edge(126,253).
edge(127,254).
edge(127,255).
edge(128,256).
edge(128,257).
edge(129,258).
edge(129,259).
edge(130,260).
edge(130,261).
edge(131,262).
edge(131,263).
edge(132,264).
edge(132,265).
edge(133,266).
edge(133,267).
edge(134,268).
edge(134,269).
edge(135,270).
edge(135,271).
edge(136,272).
edge(136,273).
edge(137,274).
edge(137,275).
edge(138,276).
edge(138,277).
edge(139,278).
edge(139,279).
edge(140,280).
edge(140,281).
edge(141,282).
edge(141,283).
edge(142,284).
edge(142,285).
edge(143,286).
edge(143,287).
edge(144,288).
edge(144,289).
edge(145,290).
edge(145,291).
edge(146,292).
edge(146,293).
edge(147,294).
edge(147,295).
edge(148,296).
edge(148,297).
edge(149,298).
edge(149,299).
edge(150,300).
edge(150,301).
edge(151,302).
edge(151,303).
edge(152,304).
edge(152,305).
edge(153,306).
edge(153,307).
edge(154,308).
edge(154,309).
edge(155,310).
edge(155,311).
edge(156,312).
edge(156,313).
edge(157,314).
edge(157,315).
edge(158,316).
edge(158,317).
edge(159,318).
edge(159,319).
edge(160,320).
edge(160,321).
edge(161,322).
edge(161,323).
edge(162,324).
edge(162,325).
edge(163,326).
edge(163,327).
edge(164,328).
edge(164,329).
edge(165,330).
edge(165,331).
edge(166,332).
edge(166,333).
edge(167,334).
edge(167,335).
edge(168,336).
edge(168,337).
edge(169,338).
edge(169,339).
edge(170,340).
edge(170,341).
edge(171,342).
edge(171,343).
edge(172,344).
edge(172,345).
edge(173,346).
edge(173,347).
edge(174,348).
edge(174,349).
edge(175,350).
edge(175,351).
edge(176,352).
edge(176,353).
edge(177,354).
edge(177,355).
edge(178,356).
edge(178,357).
edge(179,358).
edge(179,359).
edge(180,360).
edge(180,361).
edge(181,362).
edge(174,348).
edge(174,349).
edge(175,350).
edge(175,351).
edge(176,352).
edge(176,353).
edge(177,354).
edge(177,355).
edge(178,356).
edge(178,357).
edge(179,358).
edge(179,359).
edge(180,360).
edge(180,361).
edge(181,362).
edge(181,363).
edge(182,364).
edge(182,365).
edge(183,366).
edge(183,367).
edge(184,368).
edge(184,369).
edge(185,370).
edge(185,371).
edge(186,372).
edge(186,373).
edge(187,374).
edge(187,375).
edge(188,376).
edge(188,377).
edge(189,378).
edge(189,379).
edge(190,380).
edge(190,381).
edge(191,382).
edge(191,383).
edge(192,384).
edge(192,385).
edge(193,386).
edge(193,387).
edge(194,388).
edge(194,389).
edge(195,390).
edge(195,391).
edge(196,392).
edge(196,393).
edge(197,394).
edge(197,395).
edge(198,396).
edge(198,397).
edge(199,398).
edge(199,399).
edge(200,400).
edge(200,401).
/*

  Traveling salesperson problem in Picat.

  Inspired by the code from lecture notes
  Ulf Nilsson: Transparencies for the course TDDD08 Logic
  Programming, page 6f
  http://www.ida.liu.se/~TDDD08/misc/ulfni.slides/oh10.pdf

  However this version use foreach/list comprehensions.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go=>        
   time2(do_tsp(nilsson)),  % the original formulation
   time2(do_tsp(nilsson2)), % the loop version
   time2(do_tsp(chip)),
   time2(do_tsp(ilog)).


%
% Problem from GLPK:s example tsp.mod.
% Compare with the MiniZinc model http://www.hakank.org/minizinc/tsp.mzn
% and see more comments below.
%
go2 => 
   time2(do_tsp(glpk)).



%
% Use a random cost matrix of size NxN with cost values of 1..MaxVal
%
go3 =>
  garbage_collect(200_000_000),
  N = 50,
  MaxVal = 150,
  time(Matrix = generate_random(N, MaxVal)),
  if N < 40 then
    println(matrix=Matrix)
  end,
  tsp(Matrix, Cities, Costs,Cost),
  println(cities=Cities),
  println(costs=Costs),
  println(cost=Cost),
  % show_tour(Cities,Costs),
  nl.


% wrapper
do_tsp(P) =>
   printf("Problem %w", P),nl,
   tsp_test(P, Cities, Costs,Cost),
   nl,
   println(cities=Cities),
   println(costs=Costs),
   println(cost=Cost),
   show_tour(Cities,Costs),
   nl.

%
% print the tour
%
show_tour(Cities,Costs) =>
   City = 1, % start from city 1
   N = 0,
   while(N < Cities.len) 
     City2 = Cities[City],
     Cost2 = Costs[City],
     printf("Travel from city %d to city %d with costs %d\n", City,City2,Cost2),
     N := N + 1,
     City := City2
   end,
   nl.


%
% TSP using a matrix, element/1 and circuit/1 constraints.
%
% This is a generalization of Nilsson's original version.
%
tsp(Matrix, Cities, Costs,Cost) =>

   % println(matrix=Matrix),

   Len = Matrix.length,
   Cities = new_list(Len),
   Cities :: 1..Len,

   % calculate upper and lower bounds of the Costs list
   Dists = [Matrix[I,J] : I in 1..Len, J in 1..Len, Matrix[I,J] > 0],
   MinDist = min(Dists),
   MaxDist = max(Dists),

   println([mindist=MinDist,maxDist=MaxDist]),
   Costs = new_list(Len),
   Costs :: MinDist..MaxDist,

   Cost #= sum(Costs),
   Cost #> 0,

   % all_different(Cities), % implied constraint
   circuit(Cities),


   % connect cities and costs 
   foreach({Row,City,C} in zip(Matrix,Cities,Costs))
     element(City,Row,C)
   end,

   println(cost=Cost), % show the inferred domain

   % Vars = Cities ++ Costs, % slower
   Vars = Costs ++ Cities,

   % solve($[min(Cost),report(println(cost=Cost))],Vars), % 3.7s/175883 backtracks for the GLPK problem
   % solve($[ffd,split,min(Cost),report(println(cost=Cost))],Vars), % 3.7s/0 backtracks for the GLPK problem
   % solve($[forward,min(Cost),report(println(cost=Cost))],Vars), % 2.4s/0 backtracks for the GLPK problme

   % solve($[forward,up,min(Cost),report(println(cost=Cost))],Vars), % 3.7s/0 backtracks for the GLPK problme

   % solve($[forward,split,min(Cost),report(println(cost=Cost))],Vars), % 2.3s/0 backtracks for the GLPK problem
   solve($[split,min(Cost),report(println(cost=Cost))],Vars), % 2.3s/0 backtracks for the GLPK problem
   % solve($[ffd,split,min(Cost),report(println(cost=Cost))],Vars), % 

   % println(costs=Costs),
   % println(cost=Cost),
   nl.



%
% Original formulation from Nilsson cited above.
%
tsp_test(nilsson, Cities, Cost) =>
   Cities = [X1,X2,X3,X4,X5,X6,X7],
   element(X1,[ 0, 4, 8,10, 7,14,15],C1),
   element(X2,[ 4, 0, 7, 7,10,12, 5],C2),
   element(X3,[ 8, 7, 0, 4, 6, 8,10],C3),
   element(X4,[10, 7, 4, 0, 2, 5, 8],C4),
   element(X5,[ 7,10, 6, 2, 0, 6, 7],C5),
   element(X6,[14,12, 8, 5, 6, 0, 5],C6),
   element(X7,[15, 5,10, 8, 7, 5, 0],C7),
   Cost #= C1+C2+C3+C4+C5+C6+C7,
   circuit(Cities),

   solve([$min(Cost)], Cities).


% 
% This is a more general solution of the same
% problem using for loops.
%
% It is somewhat most costly than the "explicit"
% model above. It has the same number of 
% backtracks, though.
%
tsp_test(nilsson2,Cities, Costs,Cost) =>
   Matrix = 
       [[ 0, 4, 8,10, 7,14,15],
        [ 4, 0, 7, 7,10,12, 5],
        [ 8, 7, 0, 4, 6, 8,10],
        [10, 7, 4, 0, 2, 5, 8],
        [ 7,10, 6, 2, 0, 6, 7],
        [14,12, 8, 5, 6, 0, 5],
        [15, 5,10, 8, 7, 5, 0]],
   tsp(Matrix, Cities, Costs,Cost).


%
% This problem is from the SICStus example 
% ./library/clpfd/examples/tsp.pl
% The "chip" examples 
%
tsp_test(chip,Cities, Costs,Cost) =>
 Matrix = 
       [[0,205,677,581,461,878,345],
        [205,0,882,427,390,1105,540],
        [677,882,0,619,316,201,470],
        [581,427,619,0,412,592,570],
        [461,390,316,412,0,517,190],
        [878,1105,201,592,517,0,691],
        [345,540,470,570,190,691,0]],
   tsp(Matrix, Cities, Costs,Cost).


% This problem is from the SICStus example 
% ./library/clpfd/examples/tsp.pl
% The "ilog" examples
%
tsp_test(ilog,Cities, Costs,Cost) =>
   Matrix = 
       [[2,4,4,1,9,2,4,4,1,9],
        [2,9,5,5,5,2,9,5,5,5],
        [1,5,2,3,3,1,5,2,3,3],
        [2,6,8,9,5,2,6,8,9,5],
        [3,7,1,6,4,3,7,1,6,4],
        [1,2,4,1,7,1,2,4,1,7],
        [3,5,2,7,6,3,5,2,7,6],
        [2,7,9,5,5,2,7,9,5,5],
        [3,9,7,3,4,3,9,7,3,4],
        [4,1,5,9,2,4,1,5,9,2]],
   tsp(Matrix, Cities, Costs,Cost).


% This problem is from 
% GLPK:s example tsp.mod
% (via http://www.hakank.org/minizinc/tsp.mzn)
% """
% These data correspond to the symmetric instance ulysses16 from:
% Reinelt, G.: TSPLIB - A travelling salesman problem library.
% ORSA-Journal of the Computing 3 (1991) 376-84;
% http://elib.zib.de/pub/Packages/mp-testdata/tsp/tsplib 
% 
% The optimal solution is 6859
% """
tsp_test(glpk,Cities, Costs,Cost) =>
  Matrix = 
  [[0,509,501,312,1019,736,656,60,1039,726,2314,479,448,479,619,150],
   [509,0,126,474,1526,1226,1133,532,1449,1122,2789,958,941,978,1127,542],
   [501,126,0,541,1516,1184,1084,536,1371,1045,2728,913,904,946,1115,499],
   [312,474,541,0,1157,980,919,271,1333,1029,2553,751,704,720,783,455],
   [1019,1526,1516,1157,0,478,583,996,858,855,1504,677,651,600,401,1033],
   [736,1226,1184,980,478,0,115,740,470,379,1581,271,289,261,308,687],
   [656,1133,1084,919,583,115,0,667,455,288,1661,177,216,207,343,592],
   [60,532,536,271,996,740,667,0,1066,759,2320,493,454,479,598,206],
   [1039,1449,1371,1333,858,470,455,1066,0,328,1387,591,650,656,776,933],
   [726,1122,1045,1029,855,379,288,759,328,0,1697,333,400,427,622,610],
   [2314,2789,2728,2553,1504,1581,1661,2320,1387,1697,0,1838,1868,1841,1789,2248],
   [479,958,913,751,677,271,177,493,591,333,1838,0,68,105,336,417],
   [448,941,904,704,651,289,216,454,650,400,1868,68,0,52,287,406],
   [479,978,946,720,600,261,207,479,656,427,1841,105,52,0,237,449],
   [619,1127,1115,783,401,308,343,598,776,622,1789,336,287,237,0,636],
   [150,542,499,455,1033,687,592,206,933,610,2248,417,406,449,636,0]
  ],
  tsp(Matrix, Cities, Costs,Cost).


generate_random(N,MaxVal) = Matrix =>
   % _ = random2(),
   Matrix1 = { {1 + random() mod MaxVal : _ in 1..N} : _ in 1..N},
   foreach(I in 1..N)
     Matrix1[I,I] := 0
   end,
   Matrix = Matrix1.array_matrix_to_list_matrix()./*

  Tunapalooza puzzle (Dell Logic Puzzles) in Picat.

  http://brownbuffalo.sourceforge.net/TunapaloozaClues.html
  """
  Title: Tunapalooza
  Author: Eliot George
  Publication: Dell Logic Puzzles
  Issue: April, 1998
  Page: 10
  Stars: 2
 
  Tim and Keri have a full day ahead for themselves as they plan to see 
  and hear everything at Tunapalooza '98, the annual save-the-tuna benefit 
  concert in their hometown. To cover the most ground, they will have to 
  split up. They have arranged to meet during four rock band acts 
  (Ellyfish, Korrupt, Retread Ed and the Flat Tires, and Yellow Reef) at 
  planned rendezvous points (carnival games, information booth, mosh pit, 
  or T-shirt vendor). Can you help match each band name with the type of 
  music they play (country, grunge, reggae, or speed metal) and Tim and 
  Kerri's prearranged meeting spot while they play?
  
  1. Korrupt isn't a country or grunge music band.
  2. Tim and Kerri won't meet at the carnival games during Ellyfish's 
     performance.
  3. The pair won't meet at the T-shirt vendor during the reggae band's show.
  4. Exactly two of the following three statements are true:
  a) Ellyfish plays grunge music.
  b) Tim and Kerri won't meet at the information booth during a 
     performance by Retread Ed and the Flat Tires.
  c) The two friends won't meet at the T-shirt vendor while Yellow Reef 
     is playing.
  5. The country and speed metal acts are, in some order, Retread Ed 
     and the Flat Tires and the act during which Tim and Kerri will 
     meet at the mosh pit.
  6. The reggae band is neither Korrupt nor the act during which Tim and 
     Kerri will meet at the information booth.
  
  Determine: Band name -- Music type -- Meeting place
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go ?=>

   N = 4,

   Ellyfish            = 1,
   Korrupt             = 2,
   Retread_Ed_and_the_Flat_Tires = 3,
   Yellow_Reef         = 4,
   RockBand = [Ellyfish,Korrupt,Retread_Ed_and_the_Flat_Tires,Yellow_Reef],
   
   Genre = [Country, Grunge, Reggae, SpeedMetal],
   Genre :: 1..N,

   Rendevouz = [CarnivalGames, InformationBooth, MoshPit, TShirtVendor],
   Rendevouz :: 1..N,

   all_different(Genre),
   all_different(Rendevouz),

   % 1. Korrupt isn't a country or grunge music band.
   (Korrupt #!= Country #/\ Korrupt #!= Grunge),

   % 2. Tim and Kerri won't meet at the carnival games during Ellyfish's 
   %    performance.
   Ellyfish #!= CarnivalGames,

   % 3. The pair won't meet at the T-shirt vendor during the reggae 
   %    band's show.
   Reggae #!= TShirtVendor,

   % 4. Exactly two of the following three statements are true:
   % a) Ellyfish plays grunge music.
   % b) Tim and Kerri won't meet at the information booth during a 
   %    performance by Retread Ed and the Flat Tires.
   % c) The two friends won't meet at the T-shirt vendor while 
   %    Yellow Reef is playing.
   R1 :: 0..1,
   R2 :: 0..1,
   R3 :: 0..1,
   Ellyfish #= Grunge #<=> R1 #= 1,
   InformationBooth #!= Retread_Ed_and_the_Flat_Tires #<=> R2 #= 1,
   TShirtVendor #!= Yellow_Reef #<=> R3 #= 1,
   R1 + R2 + R3 #= 2,
   
   % 5. The country and speed metal acts are, in some order, Retread Ed 
   %    and the Flat Tires and the act during which Tim and Kerri will 
   %    meet at the mosh pit.
   (  
    ( Country #= Retread_Ed_and_the_Flat_Tires #/\ SpeedMetal #= MoshPit )
      #\/
    ( SpeedMetal #= Retread_Ed_and_the_Flat_Tires #/\ Country #= MoshPit )
   ),
   
       
   % 6. The reggae band is neither Korrupt nor the act during
   %    which Tim and Kerri will meet at the information booth.
   Reggae #!= Korrupt,
   Reggae #!= InformationBooth,

   Vars = Genre ++ Rendevouz,

   solve([],Vars),
   println("Rockband "=RockBand),
   println("Genre    "=Genre),
   println("Rendevouz"=Rendevouz),nl,fail.

go => true./*

  Twin letters in Picat.

  From
  http://www.comp.nus.edu.sg/~henz/projects/puzzles/digits/index.html
  """
  Twin Letters    

  In the following puzzle, there are ten pairs of
  letters to be assigned to the same digit so that the multiplication
  (including intermediate results) is correct. Can you find out the
  pairs and their values?

          A B C
   *      D E F
   ____________
          G H I
        J K L
      M N O
   ____________
      P Q R S T



  Q=R=0, D=H=1, A=B=2, J=M=3, C=P=4, 
  K=N=5, I=T=6, E=G=7, L=O=8, F=S=9

  224 * 179
  _________
        716
       358
      358
  _________
      40096 
  """""


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   LD = [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T],
   twin(LD), 
   println([a=A,b=B,c=C,d=D,e=E,f=F,g=G,h=H,i=I,j=J]),
   println([k=K,l=L,m=M,n=N,o=O,p=P,q=Q,r=R,s=S,t=T]),

   Alpha = [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t],
   Len = length(LD),
   foreach(CC in 0..9, {El,II} in zip(LD,1..Len))
      if El == CC then
         printf("%d:%w ",CC,Alpha[II])
      end
   end,
   nl.


twin(LD) =>

   LD = [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T],
   LD :: 0..9,

   C1 :: 0..1,
   C2 :: 0..2,
   C3 :: 0..1,

   % exactly 2 occurrences of each digit
   foreach(CC in 0..9) count(CC,LD,#=,2) end, 

   100*G + 10*H + I +
   1000*J + 100*K + 10*L +
   10000*M + 1000*N + 100*O #=
   10000*P + 1000*Q + 100*R + 10*S + T,
   
   (100*D + 10*E + F)*C #= 100*G + 10*H + I,
   (100*D + 10*E + F)*B #= 100*J + 10*K + L,
   (100*D + 10*E + F)*A #= 100*M + 10*N + O,
   
   (100*A + 10*B + C) * (100*D + 10*E + F) #=
   10000*P + 1000*Q + 100*R + 10*S + T,

   % Carry restrictions
   T    #= I,
   S + 10*C1 #= H + L,
   R + 10*C2 #= G + K + O + C1,
   Q + 10*C3 #= J + N + C2,
   P    #= M + C3,


   solve(LD),
   solve([C1,C2,C3]).
/*

  Some general utilities in Picat.

  Note: Some of these are experimental.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

module utils_me.

test => 
   list_test,
   test3.

get_n_solutions(Goal, N) =>
  printf("Get %d solutions:\n", N),
  get_global_map().put(solcount,1), 
  time2(Goal),
  C = get_global_map().get(solcount),
  if C < N then get_global_map().put(solcount,C+1), fail end.


% Flatten a list/array and remove duplicates
term_variables(L) = Flatten =>
   Flatten1 = [],
   foreach(LL in L) 
      Flatten1 := Flatten1 ++ LL
   end,
   Flatten2 = remove_dups(Flatten1),
   Flatten = Flatten2.


next_permutation(P) = Perm =>
   Perm1 = P,
   N = Perm1.length,
   K = N - 1,
   while (Perm1[K] > Perm1[K+1], K >= 0) 
      K := K - 1
   end,
   if K > 0 then
      J = N,
      while (Perm1[K] > Perm1[J])  J := J - 1 end,      
      Tmp := Perm1[K],
      Perm1[K] := Perm1[J],
      Perm1[J] := Tmp,
      R = N, 
      S = K + 1,
      while (R > S) 
         Tmp := Perm1[R],
         Perm1[R] := Perm1[S],
         Perm1[S] := Tmp,
         R := R - 1, 
         S := S + 1
      end
   end,
   Perm = Perm1.

% From T. Van Le, "Techniques of Prolog Programming", page 100f
next_higher_permutation(L,L1) => 
   reverse(L,[],L2),
   append(A,[X,Y|B],L2), X > Y,
   append(A,[X],C),
   append(A1,[U|B1],C), U > Y,
   append(A1,[Y|B1], B2),
   reverse([U|B], B2,L1).

% From T. Van Le, "Techniques of Prolog Programming", page 99
reverse([],R1,R2) => R1=R2.
reverse([H|T],R,L1) => reverse(T,[H|R],L1).

random_perm(L,N) = Perm => 
  Perm = L,
  Len = L.length,
  _ = random2(),
  foreach(_I in 1..N) 
     R1 = 1+(random() mod Len),
     R2 = 1+(random() mod Len),
     T = Perm[R1],
     Perm[R1] := Perm[R2],
     Perm[R2] := T
  end.



%sublist(String1, String2):
%   succeeds if S2 is a sublist of S
% (nondet.)
sublist(S1,S2) =>
    append(_, S, S1), append(S2, _, S).



% all the substrings of string List
all_substrings(List) = L, list(List) =>
     L = findall(S2, $sublist(List,S2)).remove_dups().


%
% Some list utils etc.
%

drop(Xs,0) = Xs.
drop([],_N) = [].
drop([_X|Xs],N) = drop(Xs,N-1).

drop_while([],_P) = [].
drop_while([X|Xs],P) = cond(call(P,X), drop_while(Xs,P), [X] ++ Xs).


% L=take(1..10, 4)
take(_Xs,0) = [].
take([],_N) = [].
take([X|Xs],N) = [X] ++ take(Xs,N-1).

% take_while
% L=take_while([2,4,6,7,8,9,16],even) -> [2,4,6]
take_while([],_P) = [].
take_while([X|Xs],P) = cond(call(P,X),
                           [X] ++ take_while(Xs,P), 
                           []).


butfirst(L) = drop(L,1).
butlast(L) = take(L,L.length-1).

butfirst2(S) = [S[I] : I in 2..S.length].
butlast2(S) = [S[I] : I in 1..S.length-1].

% sort/3 using B-Prolog's sort/3
sort_order(Order, L1) = L2 => bp.sort(Order,L1,L2).

%
% sort_map(Map,keys)  : sort Map on keys
% sort_map(Map,values): sort Map on values
%
sort_map(Map,values) = [K=V:_=(K=V) in sort([V=(K=V): K=V in Map])].
sort_map(Map,keys)   = sort([K=V:K=V in Map]).
sort_map(Map) = sort_map(Map,keys).


swap(A,B) = [B,A].

% sorted(L) =>
%   foreach(I in 2..L.length) L[I-1] =< L[I] end.


% sort list L using position Pos in the list of lists
sort_by(L,Pos) = [L[I] : _=I in sort(Perm)] =>
  Perm = [L[I,Pos]=I : I in 1..L.length].

sort_down_by(L,Pos) = [L[I] : _=I in sort_down(Perm)] =>
  Perm = [L[I,Pos]=I : I in 1..L.length].

% get the max value in position Pos
% max/1 only works for numbers
maximal_by(L,Pos) = L[argmax([L[I,Pos] : I in 1..L.length]).first()], integer(L[1,Pos]) => true.
maximal_by(L,Pos) = sort_by(L,Pos).last().

% get the min value in position Pos
% min/1 only works for numbers
minimal_by(L,Pos) = L[argmin([L[I,Pos] : I in 1..L.length]).first()], integer(L[1,Pos]) => true.
minimal_by(L,Pos) = sort_by(L,Pos).first().


%
% The scan family.
% Note that the list is the first argument so we can chain, e.g. 
%    Picat> L=1..4, L2=L.scanl1(+).scanl1(+).scanl1(+).reduce(+) 
%    L = [1,2,3,4]
%    L2 = 56
%   
%
% scanl(1..10,+,0)   [0,1,3,6,10,15,21,28,36,45,55]
% scanl(1..10,*,1)   [1,1,2,6,24,120,720,5040,40320,362880,3628800]
% scanl(1..4,/,1)    [1,1.0,0.5,0.166666666666667,0.041666666666667]
% scanl([[1],[2],[3]],++,[])    [[],[1],[1,2],[1,2,3]]
% scanl1(1..10,+)    [1,3,6,10,15,21,28,36,45,55]
% scanl1(1..10,*)    [1,2,6,24,120,720,5040,40320,362880,3628800]
% scanl1(2..5,**)    [2,8,4096,1152921504606846976]   
% scanr(1..10,+,0)   [55,54,52,49,45,40,34,27,19,10,0]
% scanr(1..10,*,1)   [3628800,3628800,1814400,604800,151200,30240,5040,720,90,10,1]
% scanr([[1],[2],[3]],++,[])   [[1,2,3],[2,3],[3],[]]
% scanr1(1..10,+)    [55,54,52,49,45,40,34,27,19,10]
% scanr1(1..10,*)    [3628800,3628800,1814400,604800,151200,30240,5040,720,90,10]
%

% scanl
scanl([],_F, E) = [E].
scanl(Xs,F,E) = [E] ++ scanlT(Xs,F,E).
scanlT([],_F,_A) = [].
scanlT([Y|Ys],F,A) = scanl(Ys, F,apply(F,A,Y)).

% scanl1
scanl1([],_F) = _ => throw $error(empty_list,scanl1,[]).
scanl1([X|Xs],F) = scanl(Xs,F,X).

% scanr
scanr([],_F,E) = [E].
scanr([X|Xs],F,E) = [apply(F,X,head(Ys))] ++ Ys =>
                     Ys = scanr(Xs,F,E).

% scanr1
scanr1([],_F) = _ => throw $error(empty_list,scanr1,[]).
scanr1([X],_F) = [X].
scanr1([X,Y|Xs],F) = [apply(F,X,head(Zs))] ++ Zs =>
                     Zs = scanr1([Y|Xs],F).


% L=span([2,3,5,6,7,8,9],prime) -> [[2,3,5],[6,7,8,9]]
span([],_P) = [[],[]].
span([X|Xs],P) = cond(call(P,X),
                      [[X|Ys],Zs],
                      [[],[X|Xs]]) =>
                 [Ys,Zs] = span(Xs,P).

%
% L=split_at(1..10,3) -> [[1,2],[3,4,5,6,7,8,9,10]]
% Note: 1-based
split_at(Xs,1) = [[],Xs].
split_at([],_N) = [[],[]].
split_at([X|Xs],N) = [[X|Ys],Zs] => [Ys,Zs] = split_at(Xs,N-1).


%
% group(List, F) 
% groups together elements in List  according to function F.
% Note: F must be a defined function.
%
% Example:
%   Picat> L=1..10, G=L.group(mod3)      
%   L = [1,2,3,4,5,6,7,8,9,10]
%   G = (map)[0=[3,6,9],1=[1,4,7,10],2=[2,5,8]]
%
group(List, F) = P, list(List) =>
   P = new_map(),
   foreach(E in List) 
      V = apply(F,E),
      P.put(V, P.get(V,[]) ++ [E])
   end.

%
% group/2 with function at first argument.
%
% Picat>  L=1..10, F=mod3,  G=F.group(L)
% L = [1,2,3,4,5,6,7,8,9,10]
% F = mod3
% G = (map)[0=[3,6,9],1=[1,4,7,10],2=[2,5,8]]
% 
group(F,List) = P, list(List) =>
   P = new_map(),
   foreach(E in List) 
      V = apply(F,E),
      P.put(V, P.get(V,[]) ++ [E])
   end.


% example function for group/2:
mod3(I) = I mod 3.   

% partition/3
% Example:
%   partition(1..10, prime)   -> [[2,3,5,7],[1,4,6,8,9,10]]
partition([],_P) = [[],[]].
partition([X|Xs],P) = cond(call(P,X),
                            [[X|Ys],Zs],
                            [Ys,[X|Zs]]) =>
                       [Ys,Zs] = partition(Xs,P).

% partition/4
% Example:
%   partition(1..10, prime,Primes, NoPrimes)
%    Primes = [2,3,5,7]
%    NoPrimes = [1,4,6,8,9,10] ?;
% (nondet)
%
partition([],_, LHS,RHS) => 
  LHS = [],
  RHS = [].

partition([Head|Tail], Pred, HeadLHS, RHS) ?=>
  HeadLHS = [Head|LHS],
  call(Pred,Head),
  partition(Tail, Pred,LHS, RHS).

partition([Head|Tail], Pred, LHS, HeadRHS) =>
  HeadRHS = [Head|RHS],
  not call(Pred,Head),
  partition(Tail, Pred,LHS, RHS).


list_test =>
    writeln(map=map(to_integer,to_string(1234567890))),
    writeln(map=1234567890.to_string().map(to_integer)),

    L = 1..10,
    writeln(butfirst=butfirst(L)),
    writeln(butlast=butlast(L)),

    writeln(sort=sort(>=,L)),
    writeln(swap=swap(1,9999)),
    writeln(swap=swap([1,2,3],[10,11])),

    writeln(group=(1..40).group(mod3)),

    nl.



% More utils



% Inspired by http://www.sci.brooklyn.cuny.edu/~zhou/comp_lang_prolog.pl
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Cartesian product of lists Options 
% Posted July 1, 2011
cartprod(L,R) =>
    L = [L1,L2],    
    R = [[X1,X2] : X1 in L1, X2 in L2].
cartprod(L1,R) =>
    L1 = [L|Ls],
    cartprod(Ls,R1), 
    R = [[X|P] : X in L, P in R1].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inspired by http://www.sci.brooklyn.cuny.edu/~zhou/comp_lang_prolog.pl
% All possible pairs
% Posted Nov. 25, 2010
all_pairs(List,Pairs) =>
    Pairs = [[I=J] : I in List, J in List, I < J].

%
% From http://www.probp.com/publib/listut.html
% 
%   correspond(X, Xlist, Ylist, Y)
%   is true when Xlist and Ylist are lists, X is an element of Xlist, Y is
%   an element of Ylist, and X and Y are in similar places in their lists.
%
correspond(X, X1, Y1, Y) ?=> X1=[X|_], Y1=[Y|_].
correspond(X, X1, Y1, Y) ?=>
        X1 = [_|T],
        Y1 = [_|U],
	correspond(X, T, U, Y).


% Inspired from SWI-Prolog's lib/lists.pl
%%	prefix(?Part, ?Whole)
%
%	True iff Part is a leading substring of Whole.  This is the same
%	as append(Part, _, Whole).
prefix([],X) ?=> X = _.
prefix([E|T0], [E|T]) =>
	prefix(T0, T).


%
% Return a random element from List
%
random_list(List) = List[1+random2() mod List.length].

% Get one element of list L
oneof(L) = L[1+(random2() mod L.length)].


%
% Shuffles the list List.
% 
shuffle(List) = List2 => 
  List2 = List,
  Len = List.length,
  _ = random2(),
  foreach(I in 1..Len) 
    R2 = 1+(random() mod Len),
    List2 := swap(List2,I,R2)
  end.

% pick an element from the list List
choice(List) = List[choice(List.length)], list(List) => true.

% pick a number from 1..N
choice(N) = 1 + random2() mod N, integer(N) => true.

% pick a number from 0..N-1
choice0(N) = random2() mod N.



statistics_all_map() = new_map([ K=V : [K,V] in statistics_all()]).

%
% General functions for the simple integer operations:
% 
%  plus(A,B)
%  minus(A,B)
%  multiply(A,B)
%  divide(A,B)
%  power(A,B)
% 
% where the parameters can be
%   integer op integer
%   integer op list
%   list op integer
%   list op list
%
% In the latter case, if the two lists are of unequal length we pad the shorter
% to left with a default value, see pad/3 and pad_default/2.
% 
% Also, we define self operators
% 
%  plus(A) => plus(A,A)
%  minus(A) => minus(A,A)
%  divide(A) => divide(A,A)
%  plus(A) => plus(A,A)
%  power(A) => power(A,A)
%
arithm(Op,Int1,Int2) = apply(Op, Int1,Int2), integer(Int1), integer(Int2) => true.
arithm(Op,Int1,List2) = [apply(Op,Int1,E2) : E2 in List2], integer(Int1), list(List2) => true.
arithm(Op,List1,Int2) = [apply(Op,E1,Int2): E1 in List1], list(List1), integer(Int2)  => true.
arithm(Op,List1,List2) = [apply(Op,E1,E2): {E1,E2} in zip(List1,List2)], list(List1), list(List2), length(List1) == length(List2) => true.
% lists of unequal length
arithm(Op,List1,List2) = Res, list(List1), list(List2), length(List1) != length(List2) =>
   MaxLen = max(List1.length,List2.length),
   List1b = pad(List1,MaxLen,Op),
   List2b = pad(List2,MaxLen,Op),
   Res = [apply(Op, E1,E2): {E1,E2} in zip(List1b,List2b)].

% operate on self
arithm(Op,List) = arithm(Op,List,List), list(List) => true.

% 
% Picat> L=plus(2,3).plus(4).multiply(4).power(4)
% L = 1679616
% 
plus(A,B) = arithm(+,A,B).
minus(A,B) = arithm(-,A,B).
multiply(A,B) = arithm(*,A,B).
divide(A,B) = arithm(/,A,B).
power(A,B) = arithm(**,A,B).
modulus(A,B) = arithm(mod,A,B).

plus(A) = arithm(+,A,A).
minus(A) = arithm(-,A,A). % quite silly...
multiply(A) = arithm(*,A,A).
divide(A) = arithm(/,A,A). % quite silly...
power(A) = arithm(**,A,A). % beware of this!
modulus(A) = arithm(modulus,A,A).

% We always pad to left
pad(List, N, Op) = Res => 
   Res = List,
   Len = List.length,
   if N > Len then
      (pad_default(Op,Default); Default = 1),
      Res := [Default : _I in 1..N-Len] ++ List
   end.

% the padding values
index(+,+)
pad_default(+,0).
pad_default(-,0).
pad_default(*,1).
pad_default(/,1).
pad_default(**,1).
pad_default(mod,1).


%
% factors of N
%
factors(N) = Factors =>
     M = N,
     Factors1 = [],
     while (M mod 2 == 0) 
         Factors1 := Factors1 ++ [2],  
         M := M div 2 
     end,
     T = 3,
     
     while (M > 1, T < 1+(sqrt(M)))
        if M mod T == 0 then
           [Divisors, NewM] = alldivisorsM(M, T),
           Factors1 := Factors1 ++ Divisors,
           M := NewM
        end,
        T := T + 2
        % next_prime(T, T2),
        % T := T2
     end,
     if M > 1 then Factors1 := Factors1 ++ [M] end,
     Factors = Factors1.

alldivisorsM(N,Div) = [Divisors,NewN] =>
   M = N,
   Divisors1 = [],
   while (M mod Div == 0) 
      Divisors1 := Divisors1 ++ [Div],
      M := M div Div
   end,
   NewN := M,
   Divisors = Divisors1.


table
prime_cached(N) => prime(N).


inc(X) = X+1.
inc(X,N) = X+N.
dec(X) = X-1.
dec(X,N) = X-N.

inc2(N1,N2) =>
  between(N1,99999999,N2).

% with step Step
inc2(N1,Step,N2) =>
  between(N1,99999999,Tmp),
  N2 = (Tmp-N1)*Step+N1.

between(From,Step,To,N) =>
  between(From,To,Tmp),
  N = (Tmp-From)*Step+From.


to_string2(Expr) = [E.to_string() : E in Expr].flatten().

% E=["4","+","3","-","2"].flatten().eval()
% E=["4","-","(","3","-","2",")"].eval()
eval(Expr) = parse_term(Expr.flatten()).apply().

% Replacing all occurrences of the string/list Old in List with New.
% Both Old and New must be lists (or strings).
replace2(List,Old,New) = Res =>
  Res = List,
  while (find(Res,Old,_,_))
    once(append(Before,Old,After,Res)),
    Res := Before ++ New ++ After
  end.

%
% Get first Len digits of Pi
%
pi(Len) = Res => 
   Ndigits = 0,
   Q = 1,
   R = 0,
   T = Q,
   K = Q,
   N = 3,
   L = N,

   Res = "",
   C = 1, % counter for presentation
   while (C <= Len)
       if 4 * Q + R - T < N * T then
           Res := Res ++ [N],
           C := C + 1,
           Ndigits := Ndigits + 1,
           NR := 10 * (R - N * T),
           N := ((10 * (3 * Q + R)) // T) - 10 * N,
           Q := Q* 10,
           R := NR
       else
           NR := (2    * Q + R) * L,
           NN := (Q * (7 * K + 2) + R * L) // (T * L),
           Q := Q * K,
           T := T* L,
           L := L + 2,
           K := K+1,
           N := NN,
           R := NR
       end
   end,
   nl.


%
% Swap position I <=> J in list L
%
swap(L,I,J) = L2, list(L) =>
  L2 = L,
  T = L2[I],
  L2[I] := L2[J],
  L2[J] := T.

num_fixpoints(List) = sum([1 :  I in 1..List.length, List[I] = I]).

%
% occurrences(List): 
% returns a map with all the keys and the 
% number of occurrences of each elements.
%
occurrences(List) = Map =>
  Map = new_map(),
  foreach(E in List)
     Map.put(E, cond(Map.has_key(E),Map.get(E)+1,1))
  end.

push(L,E) = L ++ [E].

%
% This is a bit strange, but might work...
%
% Picat> L=1..10, L:=L.pop(E1).pop(E2).pop(E3)
% L = [4,5,6,7,8,9,10]
% E1 = 1
% E2 = 2
% E3 = 3
%
% Note: This is actually a quite useful idiom since Picat don't
%       have global variables.
%
pop(L,First) = L.tail() => First = L.first().


%
% scalar produt of L1 and L2
%
scalar(L1,L2) = [L1I*L2I : {L1I,L2I} in zip(L1,L2)].sum().

test3 =>
   cartprod([[a,b,d],[1,2,3,4]],CartProd),
   writeln(cartprod=CartProd),

   all_pairs([1,2,3], Pairs),
   writeln(all_pairs=Pairs),

   if prefix("euler","euler10.pi") then
     writeln($prefix("euler","euler10.pi"))
   end,

   correspond(CorrespondX,[6,2,3,4,5], [1,2,7,5],CorrespondY),
   writeln(correspond=[CorrespondX,CorrespondY]),
   CorrespondAll = findall([CX,CY], $correspond(CX,[6,2,3,4,5], [1,2,3,7,5],CY)),
   writeln(correspond=CorrespondAll),

   writeln(factors=factors(600851475143)),
   % foreach(I in 61..100)         
   %     time(F=factors(2**I-1)),         
   %     writeln([I,2**I-1, F]) 
   % end,

   println("arithmetic (integer) functions"),
   writeln(plus2=plus(1,2)),
   writeln(multiply2=multiply(1..10,2)),
   writeln(divide2=divide(1..10,1..3)),
   writeln(power2=power(2,1..10)),

   writeln(power1x2=power(1..3).power()),
   writeln(mult_divide=multiply(1..20).divide(2)),
   writeln(pi100=pi(100)),

   nl,

   writeln(shuffle=(1..20).shuffle()),
   writeln(num_fixpoints=num_fixpoints((1..20).shuffle())),

   nl,

   P = 1..10,
   writeln(push=P.push(11)),
   writeln(P.shuffle().pop(E1).pop(E2).pop(E3)),
   writeln([e1=E1,e2=E2,e3=E3]),


   nl. 

table
binomial(N,K) = Res =>
   R = 1,
   foreach(I in 1..K) 
     R := floor(R * ((N-I+1)/I))
   end,
   Res = R.


% From 
% Mihaela Malita: "Library for Logic Puzzles"
% http://www.anselm.edu/internet/compsci/faculty_staff/mmalita/HOMEPAGE/logic/bibmm.txt
% 
% Note: I have changed some of the predicate names.
%

/* mem(Lr,L). Elements from Lr are all members in L. Same as subset(Lr,L).
	?- mem([X,Y],[a,b,c]).
	X = Y = a ;
	X = a ,Y = b ;
	X = a ,Y = c ;
	X = b ,Y = a ;	
	X = Y = b ;
	X = b ,Y = c ;
	X = c ,Y = a ;
	X = c ,Y = b ;
	X = Y = c ;
*/
mem([],_) => true.
mem([H|T],Y) => member(H,Y),mem(T,Y).

subset(X,Y) => mem(X,Y).

/* all(N,L,X). All possible pairs with elements from [a,b,c,d]:
	| ?- all(2,[a,b,c],I).
	I = [a,a] ;
	I = [a,b] ;
	I = [a,c] ;
	I = [b,a] ;
	I = [b,b] ;
	I = [b,c] ;
	I = [c,a] ;
	I = [c,b] ;
	I = [c,c] ;
*/
subsets(N,L,X) => X = new_list(N),mem(X,L).

/* list_all(N,L,R).  
	?- list_all(2,[a,b,c],R).
	R = [[a,a],[a,b],[a,c],[b,a],[b,b],[b,c],[c,a],[c,b],[c,c]]
*/
all_subsets(N,L) = findall(X,subsets(N,L,X)).


/* 
 set(L). Tests if a list has no duplicates. 
*/
set([]) => true.
set([H|T]) => not(member(H,T)),set(T).

no_duplicates(M) => set(M).
distinct(M) => set(M).
% aldifferent(M) =>  set(M).

/*
 Picat> N=3, R=all_subsets(N,1..N).filter2(distinct) 
 R = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
*/

filter1(_P,[]) = [].
filter1(P,[X|Xs]) = cond(call(P,X), [X] ++ filter1(P,Xs), filter1(P,Xs)).

filter2([],_P) = [].
filter2([X|Xs],P) = cond(call(P,X), [X] ++ filter2(Xs,P), filter2(Xs,P)).

/* arange(N,L,R). Lists have to be sets! That is: elements do not repeat.
	?- arange(2,[a,b,c],R).    
	R = [a,b] ;
	R = [a,c] ;
	R = [b,a] ;
	R = [b,c] ;	
	R = [c,a] ;
	R = [c,b] ;
*/
arange(N,L,X) => X = new_list(N), mem(X,L),no_duplicates(X).
list_arange(N,L) = findall(X,arange(N,L,X)).



/* mem1(Lr,L). For comb/3. Same as mem/2 but does not generate [a,b] and [b,a]. 	
	?- mem1([X,Y],[a,b,c]),write([X,Y]),fail.
	[a,b][a,c][b,a][b,c][c,a][c,b]no
*/
mem1([],_Y) ?=> true.
mem1([H|T],Y) => member(H,Y),rest(H,Y,New),mem1(T,New).

/* rest(A,L,R). For comb/3. Return the rest of the list after the first occurrence of A. 
	| ?- rest(a,[a,b,c,d],I).
	I = [b,c,d]
	| ?- rest(a,[b,c,a,d],I).
	I = [d]
	| ?- rest(a,[b,c,d],I).
	I = []
*/
rest(_X,[],T) => T = [].
rest(X,[X|T],TT) => TT=T.
rest(X,XT,R) => XT = [_|T], rest(X,T,R).

/* comb(N,L,Res). Combinations. Arangements without " order".	
	| ?- comb(2,[a,b,c],I).
	I = [a,b] ;
	I = [a,c] ;
	I = [b,c] ;
*/
comb(N,L,X) => X = new_list(N),mem1(X,L).

/* list_comb(N,L,Res).	
	?-  list_comb(2,[a,b,c,d],L).
	L = [[a,b],[a,c],[a,d],[b,c],[b,d],[c,d]]
*/
% Picat> L = [C : C in all_comb(4,1..10), sum(C) = 30]
% L = [[3,8,9,10],[4,7,9,10],[5,6,9,10],[5,7,8,10],[6,7,8,9]]
%
all_comb(N,L) = findall(X,comb(N,L,X)).


/* Order in a list: 
	List= ....X,Y,... means: Y is in the right of X
	?- right(a,b,[c,a,b,m,n]).
	yes
	?- right(a,X,[c,a,b,m,n]).
	X = b ;
	?- right(a,m,[c,a,b,m,n]).
	no
*/
right(X,Y,L) => append(_,[X,Y|_],L).


/* next(X,Y,L). If X and Y are next to each other in the list.	
	?- next(X,Y,[a,b,c]).
	X = a ,Y = b ;
	X = b ,Y = c ;
	X = b ,Y = a ;
	X = c ,Y = b ;
	?- next(a,b,[m,a,b,c]).
	yes
	?- next(a,c,[m,a,b,c,d]).
	yes
	?- next(a,c,[m,a,b,c,d]).
	no
	?- next(a,X,[m,a,b,c]).
	X = b ;
	X = m ;
*/
next(X,Y,L) => right(X,Y,L) ; right(Y,X,L).



/* neighbor(+X,+Y,X1,Y1,+S). Two cells are neighbors in an array size S
- starts from 0. Assume X and Y are in the range 0 - S.
integer_bound(0,I,5) means 0 <= I <= 5
	?-neighbor(1,1,2,2,3). 
	yes
	?-neighbor(1,2,I,J,2).  
	I = J = 2 ;
	I = 0 ,J = 2 ;
	I = J = 1 ;
	I = 2 ,	J = 1 ;
	I = 0 ,	J = 1 ;
*/
neighbor(X,Y,X1,Y1,S) => ((X1 is X+1, Y=Y1);
                      (X1 is X-1, Y=Y1);
		      (X1=X, Y1 is Y+1);
                      (X1=X, Y1 is Y-1);
		      (X1 is X+1, Y1 is Y-1);
		      (X1 is X-1, Y1 is Y-1);
		      (X1 is X+1, Y1 is Y+1);
		      (X1 is X-1, Y1 is Y+1)), 
		      between(0,S,X1),between(0,S,Y1).


/* before (X,Y,List). Checks if X is before Y in the List.
	Starts from Left to right (normal order..).
	?-before(a,c,[m,a,v,c,d]).
	yes
*/
before(X,Y,L) => append(_,[X|T],L), member(Y,T).

%
% length/2
% as Prolog standard "two-way" length/2
%
length(X,Len), var(X), integer(Len) => X = new_list(Len).
length(X,Len), var(Len), list(X) => Len = X.length.

%% This don't work from Len -> List
% lengthX([],Len) ?=> Len = 0.
% lengthX([_|T], L) =>
%   lengthX(T,L1),
%   L = L1 + 1.

% This works (with accumulator)
length2(List,Len) => 
  length2(List,0,Len).
length2(List,Len0,Len) ?=>  List = [], Len = Len0.
length2(List, Len0,Len) =>
  List = [_|T],
  Len1 = Len0 + 1,
  length2(T,Len1,Len).

% This works as well, but is not tail recursive.
length3(List,Len) ?=> 
  List = [],
  Len = 0.
length3(List,Len) => 
  List = [_|T],
  length3(T,Len1),
  Len = Len1+1.



% lcm/2
lcm(X,Y)= abs(X*Y)//gcd(X,Y).
% lcm/3
lcm(X,Y,LCM) => LCM = abs(X*Y)//gcd(X,Y).

lcm(List) = fold(lcm,1,List).

gcd(List) = fold(gcd,List.first(),List.tail()).


%
% argmax:
% find the index/indices for the max value(s) of L
%
argmax(L) = MaxIxs =>
  Max = max(L),
  MaxIxs = [I : I in 1..L.length, L[I] == Max].

%
% argmin:
% find the index/indices for the min value(s) of L
%
argmin(L) = MinIxs =>
  Min = min(L),
  MinIxs = [I : I in 1..L.length, L[I] == Min].

% Fast fibonacci function.
table
fibt(0)=1.
fibt(1)=1.
fibt(N)=F,N>1 => F=fibt(N-1)+fibt(N-2).

%
% rotate_left/1 and rotate_right/2:
% rotate list L to the left N times
%
rotate_left(L) = rotate_left(L,1).
rotate_left(L,N) = slice(L,N+1,L.length) ++ slice(L,1,N).

 
%
% rotate_right/1 and rotate_right/2:
% rotate list L to the right N times 
%
rotate_right(L) = rotate_right(L,1).
rotate_right(L,N) = Rot =>
  Len = L.length,
  Rot=slice(L,Len-N+1,Len) ++ slice(L,1,Len-N).


%
% Rotate the list L N steps (either positive or negative N)
%   rotate(1..10,3) -> [4,5,6,7,8,9,10,1,2,3]
%   rotate(1..10,-3) -> [8,9,10,1,2,3,4,5,6,7]
%
rotate_n(L,N) = Rot => 
  Len = L.length,
  R = cond(N < 0, Len + N, N),
  Rot = [L[I] : I in (R+1..Len) ++ 1..R].


%
% nest/3:
% apply F to Expr N times, return a single value
%
nest(F,Expr,N) = Nest =>
   Nest = apply(F,Expr),
   foreach(_I in 1..N-1)
      Nest := apply(F,Nest)
   end.

% recursive version of nest/3
nest2(_F,Expr0,0,Expr1) => 
   Expr1=Expr0.
nest2(F,Expr0,N,Expr1) => 
   ExprNew = apply(F,Expr0),
   nest2(F,ExprNew,N-1,Expr1).


% 
% next_list/3:
% apply F to Expr N times, return the complete history
%
nest_list(F,Expr,N) = Nest =>
   L = [Expr] ++ [apply(F,Expr)],
   foreach(_I in 1..N-1)
      L := L ++ [apply(F,L.last())]
   end,
   Nest = L.

% recursive version
nest_list2(F,Expr,N,Nest) =>
   nest_list2(F,Expr,N,[Expr],Nest).

nest_list2(_F,_Expr,0,Nest0,Nest) =>
   Nest = Nest0.reverse().
nest_list2(F,Expr,N,Nest0,Nest) =>
   Expr1 = apply(F,Expr),
   nest_list2(F,Expr1,N-1,[Expr1|Nest0],Nest).


%
% apply F to Expr until no difference
%
fixpoint(F,Expr) = Fix =>
   E1 = Expr, 
   E2 = apply(F,Expr),
   L = [E1,E2],
   while (E1 != E2) 
      E1 := E2,
      E2 := apply(F,E1),
      if (E1 != E2) then
         L := L ++ [E2]
      end
   end,
   Fix = L.

dec_to_base(N, Base) = [Alpha[D+1] : D in reverse(Res)] =>
  Alpha = "0123456789abcdefghijklmnopqrstuvwxyz",
  Res = [],
  while (N > 0) 
    R := N mod Base,
    N := N div Base,
    Res := Res ++ [R]
  end.


base_to_dec(N, Base) = base_to_dec(N.to_string(), Base), integer(N) => true.
base_to_dec(N, Base) = Res =>
  println($base_to_dec(N, Base)),
  Alpha = "0123456789abcdefghijklmnopqrstuvwxyz",
  Map = new_map([A=I : {A,I} in zip(Alpha,0..length(Alpha)-1)]),
  Len = N.length,
  Res = sum([Map.get(D)*Base**(Len-I) : {D,I} in zip(N,1..N.length)]).


%
% Day of week, Sakamoto's method
% http://en.wikipedia.org/wiki/Weekday_determination#Sakamoto.27s_Method
%
dow(Y, M, D) = R =>
  T = [0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4],
  if M < 3 then
     Y := Y - 1
  end,
  R = (Y + Y // 4 - Y // 100 + Y // 400 + T[M] + D) mod 7.

% Maximum days in a month
max_days_in_month(Year,Month) = Days => 
  if member(Month, [1,3,5,7,8,10,12]) then 
    Days = 31
  elseif member(Month,[4,6,9,11]) then
    Days = 30
  else
    if leap_year(Year) then
     Days = 29
   else
     Days = 28
   end
  end.

% is Year a leap year?
leap_year(Year) => 
  (Year mod 4 == 0, Year mod 100 != 0) ; Year mod 400 == 0.


%
% http://en.wikipedia.org/wiki/Julian_day
% Gregorian date -> Julian Day
gregorian2julian(Year,Month,Day) = JD =>
  A = floor((14-Month) / 12), % 1 for Jan or Feb, 0 for other months
  Y = Year + 4800 - A,
  M = Month + 12*A - 3, % 0 for Mars, 11 for Feb
  JD = Day + floor( (153*M + 2) / 5) + 365*Y + floor(Y/4) -
       floor(Y / 100) + floor(Y / 400) - 32045.

% Julian Day -> Gregorian date
julian2gregorian(JD) = Date =>
  Y=4716,
  V=3,
  J=1401,
  U=5,
  M=2,
  S=153,
  N=12,
  W=2,
  R=4,
  B=274277,
  P=1461,
  C= -38,
  F = JD + J + (((4 * JD + B) div 146097) * 3) div 4 + C,
  E = R * F + V,
  G = mod(E, P) div R,
  H = U * G + W,
  Day = (mod(H, S)) div U + 1,
  Month = mod(H div S + M, N) + 1,
  Year = (E div P) - Y + (N + M - Month) div N,
  Date = [Year,Month,Day].



%
% select_many(List, N NewL, Selected)
%
% Selects N elements from the list L:
%  - Selected: the selected elements
%  - NewL: The new L after Selected has been removed
% 
% (used in bridge_and_torch_problem.pi)
%
select_many(L,N, NewL, Selected) => 
  select_many(L,N, 0, NewL, [], Selected).

select_many(L,N, I, NewL,Selected0, Selected), I = N =>
  Selected = Selected0,
  NewL = L.

select_many(L,N, I, NewL,Selected0, Selected) =>
  select(E,L,Rest),
  select_many(Rest,N,I+1,NewL,Selected0++[E], Selected).



% Get the first N numbers that satisfies function F, starting with S
take_n(F,N,S) = L =>
  I = S,
  C = 0,
  L = [],
  while(C < N)
    if call(F,I) then
       L := L ++ [I],
       C := C + 1
    end,
    I := I + 1
  end.


%
% time2 + time_out as a function.
%
time2f(Goal,Timeout) = [End,Backtracks,Status] =>
    statistics(runtime,_),
    statistics(backtracks, Backtracks1),
    time_out(Goal,Timeout,Status),
    statistics(backtracks, Backtracks2),
    statistics(runtime, [_,End]),
    Backtracks = Backtracks2 - Backtracks1.


% 
% Generate a random matrix of size N x N with values of 1..MaxVal,
% default 0 and with a probability of a matrix of Pct %.
%
generate_matrix(N,MaxVal,Pct,Randomize) = Matrix =>
  println($generate_matrix(N,MaxVal,Pct,Randomize)),
  Matrix1 = new_array(N,N),
  bind_vars(Matrix1,0),
  Gen = N*N div Pct,
  % println(gen=Gen),
  if Randomize then _ = random2() end,
  foreach(I in 1..N) 
    Rand = [[1 + random() mod N, 1 + random() mod MaxVal] :  _ in 1..Gen],
    % println(rand=Rand),
    foreach([J,Num] in Rand)
      Matrix1[I,J] := Num
    end
  end,
  Matrix = Matrix1.array_matrix_to_list_matrix().


% From Bob Welham, Lawrence Byrd, R.A.O'Keefe
% (listut.pl)
nth0(0, [Head|_], Head1) => Head1 = Head.

nth0(N, [_|Tail], Elem) =>
    nonvar(N),
    M is N-1,
    nth0(M, Tail, Elem).

nth0(N,[_|T],Item) =>       % Clause added KJ 4-5-87 to allow mode
    var(N),         % nth0(-,+,+)
    nth0(M,T,Item),
    N is M + 1.


pad_string(S,Len,Fill) = Padded =>
   if S.length < Len then
      Padded = [Fill : _I in 1..Len-S.length].flatten().to_string() ++ S
   else
      Padded = S.to_string()
   end.

/*

  Volsay problem in Picat.

  From OPL model volsay.mod

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   Gas :: 0..100000,
   Chloride :: 0..100000,

   Gas + Chloride #=< 50,
   3 * Gas + 4 * Chloride #=< 180,

   MaxVal #= 40 * Gas + 50 * Chloride,

   solve([$max(MaxVal)],[Gas,Chloride]),

   writeln(gas=Gas),
   writeln(chloride=Chloride),
   writeln(max_val=MaxVal),
   nl.
/*

  Volsay problem in Picat.

  From OPL model volsay.mod
  Slightly different from volsay1.pi

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>
   Products = [Gas, Chloride],
   Products :: 0..100000,

   Gas + Chloride #=< 50,
   3 * Gas + 4 * Chloride #=< 180,
   MaxVal #= 40 * Gas + 50 * Chloride,

   solve([$max(MaxVal)],Products),

   writeln(gas=Gas),
   writeln(chloride=Chloride),
   writeln(max_val=MaxVal),
   nl.
/*

  Volsay problem in Picat.

  From OPL model volsay.mod
  """
  Consider a Belgian company Volsay, which specializes in producing ammoniac gas 
  (NH3) and ammonium chloride (NH4Cl). Volsay has at its disposal 50 units of 
  nitrogen (N), 180 units of hydrogen (H), and 40 units of chlorine (Cl). The company 
  makes a profit of 40 Euros for each sale of an ammoniac gas unit and 50 Euros 
  for each sale of an ammonium chloride unit. Volsay would like a production plan 
  maximizing its profits given its available stocks. 
  """

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).

% scalar product with relation
scalar_product(A, X, Rel, Product) => 
   scalar_product(A, X, P),
   call(Rel,P,Product).


go =>
   Products = [Gas, Chloride],
   Products :: 0..100000,
   Profits = [40,50],
   Hydrogen = [3,4],
   MaxHydrogen = 180,
   MaxUnits = 50,

   scalar_product(Products,Hydrogen, #=<, MaxHydrogen),
   scalar_product(Products, Profits,MaxVal),
   sum(Products) #=< MaxUnits,

   solve([$max(MaxVal)],Products),

   writeln(gas=Gas),
   writeln(chloride=Chloride),
   writeln(max_val=MaxVal),
   nl.
/*

  Warehouse location in Picat.

  From OPL model warehouse.mod
  Solution:
  """
  Optimal solution found with objective: 383
  open= [1 1 1 0 1]
  storesof= [{3} {1 5 6 8} {7 9} {} {0 2 4}]
  """


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   Warehouses = ["Bonn", "Bordeaux", "London", "Paris", "Rome"],
   Capacity= [1,4,2,1,3],
   SupplyCost = 
   [[ 20, 24, 11, 25, 30 ], 
    [ 28, 27, 82, 83, 74 ],
    [ 74, 97, 71, 96, 70 ],
    [  2, 55, 73, 69, 61 ],
    [ 46, 96, 59, 83,  4 ],
    [ 42, 22, 29, 67, 59 ],
    [  1,  5, 73, 59, 56 ],
    [ 10, 73, 13, 43, 96 ],
    [ 93, 35, 63, 85, 46 ],
    [ 47, 65, 55, 71, 95 ]],
   
   Fixed = 30,

   NumStores = SupplyCost.length,
   NumWarehouses = SupplyCost[1].length,
   SupplyCostList = flatten(SupplyCost),

   % suppliers
   Supply = new_array(NumStores, NumWarehouses),
   Supply :: 0..1,
   SupplyList = vars(Supply),



   % Open suppliers
   Open = new_list(NumWarehouses),
   Open :: 0..1,

   % Supply
   foreach(SS in Supply) sum(SS.to_list()) #= 1 end,

   foreach(SS in Supply)
      foreach({O,S} in zip(Open,SS.to_list())) S #=< O end
   end,

   % check capacity
   SupplyTransposed = transpose(Supply).array_matrix_to_list_matrix(),
   foreach({Column,Cap} in zip(SupplyTransposed, Capacity)) sum(Column) #=< Cap end,

   
   % calculate total costs: Fixed costs for the open
   Costs1 #= sum([Fixed*O :  O in Open]),

   % cost for open suppliers
   scalar_product(SupplyCostList,SupplyList,Costs2),

   TotalCosts #= Costs1 + Costs2,

   % search
   Vars1 = SupplyList ++ Open,
   solve([$min(TotalCosts)], Vars1),

   % output
   writeln(open=Open),
   println("supply:"),
   foreach(S in Supply) println(S.to_list()) end,
   nl,
   writeln(total_costs=TotalCosts),
   foreach({Warehouse,W} in zip(Warehouses,1..NumWarehouses))
       % element(W,Open,OpenW),
       OpenW = Open[W],
       % OpenW = Open[W], 
       printf("%w: open: %w  Stores: ", Warehouse, OpenW),
       foreach(S in 1..NumStores)
           matrix_element(Supply,S,W,SupplySW),
           if SupplySW == 1  then
               printf("%w ", S)
           end
       end,
       nl
   end,


   nl.

scalar_product(A, X, Product) => 
   Product #= sum([S : I in 1..A.length, S #= A[I]*X[I]]).
/*

  Water jugs problem in Picat.

  We have two jugs with water, one with 4L and one with 3L: [4,3].
  The goal is to have 2L in the first and 0L in the last: [2,0]

  This is a planning model.

  This version use bplan.plan2 and is much faster than the version in
  http://www.hakank.org/picat/water_jugs.pi.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% See http://www.hakank.org/picat/bplan.pi

go =>
   %           Max  Init  Goal
   water_jugs([4,3],[0,0],[2,0]),
   nl.

go2 =>
   water_jugs([5,4],[0,0],[3,0]),
   nl.

go3 =>
   water_jugs([6,5],[0,0],[4,0]),
   nl.

go4 =>
   water_jugs([7,6],[0,0],[5,0]),
   nl.

% The Die Hard problem
% http://www.math.tamu.edu/~dallen/hollywood/diehard/diehard.htm
go5 =>
   water_jugs([5,3],[0,0],[4,0]),
   nl.

% http://www.cs.ucsb.edu/~pconrad/cs40/lessons/numberTheory/JugsMake1from5and7.html
go6 =>
   water_jugs([7,5],[0,0],[1,0]),
   nl.

go7 =>
   water_jugs([82,39],[0,0],[2,0]), % 118 steps
   nl,
   water_jugs([85,58],[0,0],[2,0]), % 137 steps
   nl,
   water_jugs([88,65],[0,0],[2,0]), % 146 steps
   nl,
   water_jugs([87,80],[0,0],[2,0]), % 142 steps
   nl,
   water_jugs([301,80],[0,0],[2,0]), % 362 steps
   nl,
   water_jugs([968,921],[0,0],[2,0]), % 803 steps
   nl,
   water_jugs([968,283],[0,0],[2,0]), % 946 steps
   nl.


% Random version
go8 => 
   XMax = 3+random2() mod 400,
   YMax = random_list([I : I in 2..XMax,gcd(XMax,I) == 1]),
   time_out(water_jugs([XMax,YMax],
              [0,0],
              [2,0]),
            60000, Status),
   writeln(Status),
   writeln([XMax,YMax]),
   nl.

% Random version
go9 => 
   XMax = 3+random2() mod 1000,
   YMax = random_list([I : I in 2..XMax,gcd(XMax,I) == 1]),
   time_out(water_jugs([XMax,YMax],
              [0,0],
              [2,0]),
            60000, Status),
   writeln(Status),
   writeln([XMax,YMax]),
   nl.

go10 =>
   time(water_jugs([301,80],[0,0],[2,0])), % 362 steps
   nl.


go11 =>
   time(water_jugs([968,283],[0,0],[2,0])), % 362 steps
   nl.


% https://plus.google.com/communities/105822441858552468682
% """
% Given two vessels, one of which can accommodate 5 liters of water and 
% the other which can accommodate 7 liters of water, determine the number of 
% steps required to obtain exactly 1 liters of water in one of the vessels.
% """
go12 =>
   ( water_jugs([5,7],[0,0],[0,1]);
     water_jugs([5,7],[5,7],[1,0]);
     water_jugs([7,5],[0,0],[0,1]); % does order matter (not on this problem)
     water_jugs([7,5],[7,5],[1,0])
   ),
   fail,
   nl.


%
% For bplan.plan2/3
%
% _Much_ faster than water_jugs.pi
% 
water_jugs([XMax,YMax],[XInit,YInit],[XGoal,YGoal]) =>

   writeln(max=[XMax,YMax]),
   writeln(init=[XInit,YInit]),
   writeln(goal=[XGoal,YGoal]),

   % Add the facts for bplan etc.
   cl_facts($[initial_state([XInit,YInit]), 
              goal_state([XGoal,YGoal])]),

   get_global_map().put(x,XMax),
   get_global_map().put(y,YMax),

   time(plan2([XInit,YInit],L,_Cost)),
   foreach(E in L) println(E) end,
   writeln(len=L.length),
   % writeln(cost=Cost),
   nl.

table
% fill X from ground
legal_move([X,Y],M,To,Cost), X < get2(x) ?=> 
  To = [X2,Y2], 
  X2 = get2(x), 
  Y2 = Y,
  Cost=1,
  M = [fill,x,from,ground,[X2,Y2]].

% fill Y from ground
legal_move([X,Y],M,To,Cost), Y < get2(y) ?=> 
  To=[X2,Y2], 
  X2 = X, 
  Y2 = get2(y),
  Cost=1,
  M = [fill,y,from,ground,[X2,Y2]].

% Y -> X
legal_move([X,Y],M,To,Cost), Y > 0, X < get2(x) ?=> 
   To = [X2,Y2], 
   MaxToFill = get2(x)-X,
   ToFill = min(Y,MaxToFill),
   Y2 = Y-ToFill,
   X2 = X+ToFill,
   Cost=1,
   M = [fill,x,from,y,with,ToFill,[X2,Y2]].

% X -> Y
legal_move([X,Y],M,To,Cost), X > 0, Y < get2(y) ?=> 
   To = [X2,Y2], 
   MaxToFill = get2(y)-Y,
   ToFill = min(X,MaxToFill),
   X2 = X-ToFill,
   Y2 = Y+ToFill,
   Cost=1,
   M = [fill,y,from,x,with,ToFill,[X2,Y2]].

% empty X
legal_move([X,Y],M,To,Cost), X > 0 ?=> 
   To = [X2,Y2], 
   X2 = 0, Y2 = Y,
   Cost=1,
   M = [empty,x,[X2,Y2]].

% empty Y
legal_move([X,Y],M,To,Cost), Y > 0 => 
   To=[X2,Y2], 
   X2 = X, Y2 = 0,
   Cost=1,
   M = [empty,y,[X2,Y2]].


% Get the global x and y
get2(X) = get_global_map().get(X).


random_list(List) = List[1+random2() mod List.length].

/*

  Water jugs problem in Picat.

  We have two jugs with water, one with 4L and one with 3L: [4,3].
  The goal is to have 2L in the first and 0L in the last: [2,0]


  This is a planning model.

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% See http://www.hakank.org/picat/bplan.pi

go =>
   %           Max  Init  Goal
   water_jugs([4,3],[0,0],[2,0]),
   nl.

go2 =>
   water_jugs([5,4],[0,0],[3,0]),
   nl.

go3 =>
   water_jugs([6,5],[0,0],[4,0]),
   nl.

go4 =>
   water_jugs([7,6],[0,0],[5,0]),
   nl.

% The Die Hard problem
% http://www.math.tamu.edu/~dallen/hollywood/diehard/diehard.htm
go5 =>
   water_jugs([5,3],[0,0],[4,0]),
   nl.

% http://www.cs.ucsb.edu/~pconrad/cs40/lessons/numberTheory/JugsMake1from5and7.html
go6 =>
   water_jugs([7,5],[0,0],[1,0]),
   nl.

go7 =>
   water_jugs([82,39],[0,0],[2,0]), % 118 steps
   nl,
   water_jugs([85,58],[0,0],[2,0]), % 137 steps
   nl,
   water_jugs([88,65],[0,0],[2,0]), % 146 steps
   nl,
   water_jugs([87,80],[0,0],[2,0]), % 142 steps
   nl,
   water_jugs([301,80],[0,0],[2,0]), % 362 steps
   nl.

go7b =>
   water_jugs([301,80],[0,0],[2,0]), % 362 steps
   nl.



% Random version
go8 => 
   XMax = 3+random2() mod 400,
   YMax = random_list([I : I in 2..XMax,gcd(XMax,I) == 1]),
   time_out(water_jugs([XMax,YMax],
              [0,0],
              [2,0]),
            60000, Status),
   writeln(Status),
   writeln([XMax,YMax]),
   nl.


water_jugs([XMax,YMax],[XInit,YInit],[XGoal,YGoal]) =>

   writeln(max=[XMax,YMax]),
   writeln(init=[XInit,YInit]),
   writeln(goal=[XGoal,YGoal]),

   % Add the facts for bplan etc.
   cl_facts($[initial_state([XInit,YInit]), 
              goal_state([XGoal,YGoal])]),

   get_global_map().put(x,XMax),
   get_global_map().put(y,YMax),

   time(bplan(L)),
   % write(L), nl,
   foreach(E in L) println(E) end,
   Len=length(L),
   write(len=Len),
   nl.

table
% fill X from ground
legal_move([X,Y],M,To), X < get2(x) ?=> 
  To = [X2,Y2], 
  X2 = get2(x), 
  Y2 = Y,
  M = [fill,x,from,ground,[X2,Y2]].

% fill Y from ground
legal_move([X,Y],M,To), Y < get2(y) ?=> 
  To=[X2,Y2], 
  X2 = X, 
  Y2 = get2(y),
  M = [fill,y,from,ground,[X2,Y2]].

% Y -> X
legal_move([X,Y],M,To), Y > 0, X < get2(x) ?=> 
   To = [X2,Y2], 
   MaxToFill = get2(x)-X,
   ToFill = min(Y,MaxToFill),
   Y2 = Y-ToFill,
   X2 = X+ToFill,
   M = [fill,x,from,y,with,ToFill,[X2,Y2]].

% X -> Y
legal_move([X,Y],M,To), X > 0, Y < get2(y) ?=> 
   To = [X2,Y2], 
   MaxToFill = get2(y)-Y,
   ToFill = min(X,MaxToFill),
   X2 = X-ToFill,
   Y2 = Y+ToFill,
   M = [fill,y,from,x,with,ToFill,[X2,Y2]].

% empty X
legal_move([X,Y],M,To), X > 0 ?=> 
   To = [X2,Y2], 
   X2 = 0, Y2 = Y,
   M = [empty,x,[X2,Y2]].

% empty Y
legal_move([X,Y],M,To), Y > 0 => 
   To=[X2,Y2], 
   X2 = X, Y2 = 0,
   M = [empty,y,[X2,Y2]].


% Get the global x and y
get2(X) = get_global_map().get(X).


random_list(List) = List[1+random2() mod List.length].

/*

  Finding an optimal wedding seating chart in Picat.

  From 
  Meghan L. Bellows and J. D. Luc Peterson
  "Finding an optimal seating chart for a wedding"
  http://www.improbable.com/news/2012/Optimal-seating-chart.pdf
  http://www.improbable.com/2012/02/12/finding-an-optimal-seating-chart-for-a-wedding
  
  """
  Every year, millions of brides (not to mention their mothers, future 
  mothers-in-law, and occasionally grooms) struggle with one of the 
  most daunting tasks during the wedding-planning process: the 
  seating chart. The guest responses are in, banquet hall is booked, 
  menu choices have been made. You think the hard parts are over, 
  but you have yet to embark upon the biggest headache of them all. 
  In order to make this process easier, we present a mathematical 
  formulation that models the seating chart problem. This model can 
  be solved to find the optimal arrangement of guests at tables. 
  At the very least, it can provide a starting point and hopefully 
  minimize stress and arguments 
  """

tables: [1 1 2 2 1 1 3 3 2 3 3 4 4 4 5 5 5]
z: 271


  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   % maximize the friends index at a table
   Maximize = 1, 

   % minimize the "friends index" at a table, i.e. disperse as much as possible
   % Maximize = 0, %

   % max_tables(A), % maximum number of guests a table can seat
   % min_tables(B), % minimum number of people each guest knows at their table
   % num_tables(N), % max number of tables

   % problem(1,MaxNumTables,MaxAtTable,MinKnowsAtTable),
   problem(2,MaxNumTables,MaxAtTable,MinKnowsAtTable),
   % problem(3,MaxNumTables,MaxAtTable,MinKnowsAtTable),

   N = MaxNumTables,
   A = MaxAtTable,
   B = MinKnowsAtTable,

   % num_guests(M), % maximum number of quests

   % C[j,k]: Connection matrix, indicating relation of guest j to
   %         guest k (0..50 where 0 is no relation, 50 is strong relation)
   guests(C),

   M = C.length,

   println([a=A,b=B,n=N,m=M]),

   %
   % decision variables
   %

   % At what table sit a person.
   Tables = new_list(M), 
   Tables :: 1..N,

   % number of guests at each table
   % TableCount = new_list(N),
   % TableCount :: 0..A,

   % to maximize (or minimize)
   % Z :: 0..sum([C[J,K] : J in 1..M, K in 1..M]),

   %
   % constraints
   %

   % optimal value
   Z #= sum([C[J,K]*(Tables[J]#=Tables[K]) : J in 1..M, K in 1..M, J < K]),

   foreach(I in 1..N)

      % Minimum number of friends at table I
      sum([(C[J,K] #> 0)*(Tables[J] #= I)*(Tables[K] #= I): J in 1..M, K in 1..M]) #>= B,



      % Max number of guests per table
      sum([Tables[J] #= I : J in 1..M]) #<= A

      % must be at least B guests per table
      % , sum([(Tables[J] #= I): J in 1..M]) #>= B
   end,
   
   % symmetry breaking
   % foreach(T in 1..N) 
   %    TableCount[T] #= sum([(Tables[I] #= T) : I in 1..M])
   % end,
   % decreasing(TableCount),

   % Tables[3] #= 1, % Martha sits at table 1
   Tables[1] #= 1, % Dep sits at table 1
   
   Vars = Tables, % ++ [Z],

   if Maximize == 1 then
      println(maximize),
      if member(cp,sys.loaded_modules()) then
        solve($[inout,up,max(Z),report(printf("Z: %d\n",Z))], Vars)
      else 
        solve($[seq,max(Z),report(printf("Z: %d\n",Z))], Vars)
      end
   else
      println(minimize),
      if member(cp,sys.loaded_modules()) then
         solve($[ff,down,min(Z),report(printf("Z: %d\n",Z))], Vars) % cp
      else 
         solve($[seq,min(Z),report(printf("Z: %d\n",Z))], Vars) % sat
      end
   end,

   println(z=Z),
   println(tables=Tables),
   % println(tableCount=TableCount),

   names(Names),
   foreach(T in 1..N)
     printf("At table %d\n", T),
     foreach(I in 1..M) 
        if Tables[I] == T then
          printf("\t%2d (%s)\n", I, Names[I])
        end
     end,
     nl
   end,

   nl.

decreasing(List) =>
   foreach(I in 2..List.length) List[I-1] #>= List[I] end.

increasing(List) =>
   foreach(I in 2..List.length) List[I-1] #<= List[I] end.


%
% Data
%

%  j   Guest         Relation
%  -------------------------------------
%  1   Deb           mother of the bride
%  2   John          father of the bride
%  3   Martha        sister of the bride
%  4   Travis        boyfriend of Martha
%  5   Allan         grandfather of the bride
%  6   Lois          wife of Allan (the grandfather of the bride)
%  7   Jayne         aunt of the bride
%  8   Brad          uncle of the bride
%  9   Abby          cousin of the bride
% 10   Mary Helen    mother of the groom
% 11   Lee           father of the groom
% 12   Annika        sister of the groom
% 13   Carl          brother of the groom
% 14   Colin         brother of the groom
% 15   Shirley       grandmother of the groom
% 16   DeAnn         aunt of the groom
% 17   Lori          aunt of the groom
%              Table 2: Guest List

% The "friend matrix". Higher value mean stronger bonds.
% Note the two clusters around the bride and groom.
guests(M) => 
M = 
[[ 1,50, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
 [50, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
 [ 1, 1, 1,50, 1, 1, 1, 1,10, 0, 0, 0, 0, 0, 0, 0, 0],
 [ 1, 1,50, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
 [ 1, 1, 1, 1, 1,50, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
 [ 1, 1, 1, 1,50, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
 [ 1, 1, 1, 1, 1, 1, 1,50, 1, 0, 0, 0, 0, 0, 0, 0, 0],
 [ 1, 1, 1, 1, 1, 1,50, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
 [ 1, 1,10, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
 [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,50, 1, 1, 1, 1, 1, 1],
 [ 0, 0, 0, 0, 0, 0, 0, 0, 0,50, 1, 1, 1, 1, 1, 1, 1],
 [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
 [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
 [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
 [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
 [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
 [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]].


names(Names) =>
Names =
[
 "Deb        mother of the bride",
 "John       father of the bride",
 "Martha     sister of the bride",
 "Travis     boyfriend of Martha (sister of the bride)",
 "Allan      grandfather of the bride",
 "Lois       wife of Allan (the grandfather of the bride)",
 "Jayne      aunt of the bride",
 "Brad       uncle of the bride",
 "Abby       cousin of the bride",
 "Mary Helen mother of the groom",
 "Lee        father of the groom",
 "Annika     sister of the groom",
 "Carl       brother of the groom",
 "Colin      brother of the groom",
 "Shirley    grandmother of the groom",
 "DeAnn      aunt of the groom",
 "Lori       aunt of the groom"
].

names2(Names) =>
Names =
[
 "Deb (B)",
 "John (B)",
 "Martha (B)",
 "Travis (B)",
 "Allan (B)",
 "Lois (B)",
 "Jayne (B)",
 "Brad (B)",
 "Abby (B)",
 "Mary Helen (G)",
 "Lee (G)",
 "Annika (G)",
 "Carl (G)",
 "Colin (G)",
 "Shirley (G)",
 "DeAnn (G)",
 "Lori (G)"
].

% num_tables(N) => N = 5. % max number of tables
% max_tables(A) => A = 4. % maximum number of guests a table can seat
% min_tables(B) => B = 2. % minimum number of people each guest knows at their table
problem(1,MaxNumTables,MaxAtTable,MinKnowsAtTable) => 
  MaxNumTables = 5,
  MaxAtTable = 4,
  MinKnowsAtTable = 2.

% Easier problem
% num_tables(N) => N = 2. % max number of tables
% max_tables(A) => A = 10. % maximum number of guests a table can seat
% min_tables(B) => B = 1. % minimum number of people each guest knows at their table
problem(2,MaxNumTables,MaxAtTable,MinKnowsAtTable) => 
  MaxNumTables = 2,
  MaxAtTable = 10,
  MinKnowsAtTable = 1.

problem(3,MaxNumTables,MaxAtTable,MinKnowsAtTable) => 
  MaxNumTables = 6,
  MaxAtTable = 10,
  MinKnowsAtTable = 3.


/*

  Who killed agatha? (The Dreadsbury Mansion Murder Mystery) in Picat.

  This is a standard benchmark for theorem proving.
 
  http://www.lsv.ens-cachan.fr/~goubault/H1.dist/H1.1/Doc/h1003.html
  """ 
  Someone in Dreadsbury Mansion killed Aunt Agatha. 
  Agatha, the butler, and Charles live in Dreadsbury Mansion, and 
  are the only ones to live there. A killer always hates, and is no 
  richer than his victim. Charles hates noone that Agatha hates. Agatha 
  hates everybody except the butler. The butler hates everyone not richer 
  than Aunt Agatha. The butler hates everyone whom Agatha hates. 
  Noone hates everyone. Who killed Agatha? 
  """

  Originally from F. J. Pelletier: 
  Seventy-five problems for testing automatic theorem provers. 
  Journal of Automated Reasoning, 2: 191 216, 1986.
  http://www.sfu.ca/~jeffpell/papers/75ATPproblems86.pdf


  I have blogged about the problem here:
  * "Learning constraint programming - part II: Modeling with the Element constraint"
    http://www.hakank.org/constraint_programming_blog/2009/05/learning_constraint_programmin.html
  * "Learning Constraint Programming IV: Logical constraints: Who killed Agatha? revisited"
  http://www.hakank.org/constraint_programming_blog/2009/05/learning_constraint_programmin_3.html

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

%
% There are 8 solutions: all states that Agatha killed herself.
%
go => 
    % collect all possible solutions
    L = findall(Killer, who_killed_agatha(Killer)),
    writeln(killer=L).


who_killed_agatha(Killer) =>

    % Setup
    N = 3,

    Agatha = 1,
    Butler = 2,
    Charles = 3,

    Killer :: [Agatha,Butler,Charles],

    %
    % define the Hates and Richer matrices
    %
    Hates = new_array(N,N),
    Hates :: 0..1,

    Richer = new_array(N,N),
    Richer :: 0..1,

    %
    % The constraints
    %

    %
    % Agatha, the butler, and Charles live in Dreadsbury Mansion, and 
    % are the only ones to live there. 
    %

    % * A killer always hates, and is no richer than his victim. 
    
    % Note, the following is not supported in Picat
    %
    %   Hates[Killer,Victim] #= 1,
    %   Richer[Killer, Victim] #= 0,
    %
    % This works, though:
    foreach(I in 1..N)
       Killer #= I #=> Hates[I, Agatha] #= 1,
       Killer #= I #=> Richer[I, Agatha] #= 0

       % Killer #= I #=> (Hates[I, Agatha] #= 1 #/\ Richer[I, Agatha] #= 0)

    end,

    % * Define the concept of richer: no one is richer than him-/herself
    foreach(I in 1..N) Richer[I,I] #= 0 end,

    
    % (contd...) if i is richer than j then j is not richer than i
    foreach(I in 1..N, J in 1..N, I != J)
       Richer[I,J] #= 1 #=> Richer[J,I] #= 0,
       Richer[J,I] #= 0 #=> Richer[I,J] #= 1
    end,


    % * Charles hates no one that Agatha hates. 
    foreach(I in 1..N) Hates[Agatha, I] #= 1 #=> Hates[Charles, I] #= 0 end,

    % * Agatha hates everybody except the butler. 
    Hates[Agatha, Butler]  #= 0,
    Hates[Agatha, Charles] #= 1,
    Hates[Agatha, Agatha]  #= 1,

    % * The butler hates everyone not richer than Aunt Agatha. 
    foreach(I in 1 ..N)
      Richer[I, Agatha] #= 0 #=> Hates[Butler, I] #= 1
    end,

    % * The butler hates everyone whom Agatha hates. 
    foreach(I in 1..N) Hates[Agatha, I] #= 1 #=> Hates[Butler, I] #= 1 end,

    % * No one hates every one.
    foreach(I in 1..N) sum([Hates[I,J] : J in 1..N]) #=< 2 end,

    % * A killer always hates, and is no richer than his victim. 
    % Note: When placed here matrix_element/4 works.
    matrix_element(Hates,Killer,Agatha,1),
    matrix_element(Richer,Killer,Agatha,0),


    % * Who killed Agatha?


    Vars = [Killer] ++ Hates ++ Richer,
    solve(Vars).

    % println(hates),
    % foreach(I in 1..N) println(Hates[I]) end,

    % println(richer),
    % foreach(I in 1..N) println(Richer[I]) end.

    %writeln(victim:Victim),
    %writeln(killer:Killer),
    %writeln(hates:Hates),
    %writeln(richer:Richer), fail.


matrix_element1(X, I, J, Val) =>
  element(I, X, Row),
  element(J, Row, Val).

matrix_element2(X, I, J, Val) =>
  nth(I, X, Row),
  element(J, Row, Val).

matrix_element3(X, I, J, Val) =>
  freeze(I, (nth(I, X, Row),freeze(J,nth(J,Row,Val)))).

matrix_element4(X, I, J, Val) =>
  freeze(I, (element(I, X, Row),freeze(J,element(J,Row,Val)))).

matrix_element5(X, I, J, Val) =>
  nth(I, X, Row),
  nth(J, Row, Val).
/*

  xkcd's knapsack/subset-sum problem  in Picat.

  http://xkcd.com/287/

  Some amount (or none) of each dish should be ordered to give a total of exact 15.05

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

xkcd(X) =>
   Prices = [215, 275, 335, 355, 420, 580],
   Total = 1505,
   Len = Prices.length,
   X = new_list(Len),
   X :: 0..10,
   scalar_product(Prices, X, Total),
   solve(X).


xkcd2(All) =>
   Prices = [215, 275, 335, 355, 420, 580],
   Total = 1505,
   Len = Prices.length,
   X = new_list(Len),
   X :: 0..10,
   scalar_product(Prices, X, Total),
   All = solve_all(X).


go =>
   L = findall(X,xkcd(X)),
   writeln(L).


go2 =>
   xkcd2(All),
   writeln(All),
   nl.
/*

  Young tableaux and partition in Picat.

  See 
  http://mathworld.wolfram.com/YoungTableau.html
  and
  http://en.wikipedia.org/wiki/Young_tableau
  """
  The partitions of 4 are
   {4}, {3,1}, {2,2}, {2,1,1}, {1,1,1,1}
 
  And the corresponding standard Young tableaux are:
 
  1.   1 2 3 4
 
  2.   1 2 3         1 2 4    1 3 4
       4             3        2
 
  3.   1 2           1 3
       3 4           2 4
 
  4    1 2           1 3      1 4 
       3             2        2 
       4             4        3
 
  5.   1
       2
       3
       4
  """  

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

% 
% Show all solutions for N=6
%
go => 
    N = 4,
    L = findall(_, young_tableaux(N,_X,_P,1)),
    writef("It was %d solutions.\n\n", L.length).



%
% Get the number of solutions for N in 1..10.
%
go2 =>
    Lens = [],
    foreach(N in 1..10)
       L = findall(_, young_tableaux(N,_X,_P,0)),
       Len = length(L),
       writef("It was %d solutions.\n\n", Len),       
       Lens := Lens ++ [Len]
    end,
    writeln(lengths=Lens).



%
% Ensure that all values in Xs are different (if they are not N).
% 
alldifferent_except_N(Xs,N) =>
    foreach(I in 1..Xs.length, J in 1..I-1)
         (Xs[I] #!= N #/\ Xs[J] #!= N) #=> (Xs[I] #!= Xs[J])
    end.

% From Picat Guide, page 74
my_count(V,L,Rel,N) =>
   sum([V #= E : E in L]) #= Count,
   call(Rel,Count,N).


young_tableaux(N,X,P,Print) =>

    writef("Young tableaux and partitions of order %d\n", N),
    X = new_array(N,N),
    X :: 1..N+1,

    % for count and labeling
    Vars = array_matrix_to_list(X),


    % the partition structure
    P = new_list(N),
    P :: 0..N+1,

    % 1..N is used exactly once (N+1 may be used many times)
    foreach(I in 1..N) count(I, Vars, #=, 1) end,
    % foreach(I in 1..N) my_count(I, Vars, #=, 1) end,

    % alternative (but much slower for this purpose)
    % alldifferent_except_N(Vars,N+1),

    X[1,1] #= 1,
    % all rows and columns should be ordered
    foreach(I in 1..N)
        increasing([X[I,J] : J in 1..N]), % rows
        increasing([X[J,I] : J in 1..N])  % columns
    end,


    % calculate the structure (the partition)
    foreach(I in 1..N) P[I] #= sum([ (X[I,J] #=< N)  : J in 1..N]) end,

    % P should be ordered
    decreasing(P),
    N #= sum(P),

    Vars2 = Vars ++ P,

    solve([ff],Vars2),
    if Print == 1 then
         writeln(p=P),
         pretty_print(X)
    end.


increasing(List) =>
   foreach(I in 2..List.length) List[I-1] #=< List[I] end.

decreasing(List) =>
   foreach(I in 2..List.length) List[I-1] #>= List[I] end.


pretty_print(X) =>
    N = X.length,
    foreach(I in 1..N)
       foreach(J in 1..N)
            XIJ = X[I,J],
            if XIJ #=< N then
               writef("%2d", XIJ)
            end
       end,
       writef(" "),
       % don't show "empty" lines
       if X[I,1] #=< N then writef("\n") end
    end,
    writef("\n").
/*

  Zebra puzzle in Picat.

  Lewis Carrol's classical puzzle with five houses and a zebra:
  
  Five men with different nationalities live in the first five houses
  of a street.  They practise five distinct professions, and each of
  them has a favourite animal and a favourite drink, all of them
  different.  The five houses are painted in different colours.
  
  The Englishman lives in a red house.
  The Spaniard owns a dog.
  The Japanese is a painter.
  The Italian drinks tea.
  The Norwegian lives in the first house on the left.
  The owner of the green house drinks coffee.
  The green house is on the right of the white one.
  The sculptor breeds snails.
  The diplomat lives in the yellow house.
  Milk is drunk in the middle house.
  The Norwegian's house is next to the blue one.
  The violinist drinks fruit juice.
  The fox is in a house next to that of the doctor.
  The horse is in a house next to that of the diplomat.
  
  Who owns a Zebra, and who drinks water?
  

  Model created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

go =>

   Nat        = [English, Spaniard, Japanese, Italian, Norwegian],
   Color      = [Red, Green, White, Yellow, Blue],
   Profession = [Painter, Sculptor, Diplomat, Violinist, Doctor],
   Pet        = [Dog, Snails, Fox, Horse, Zebra],
   Drink      = [Tea, Coffee, Milk, Juice, Water],

   Nat        :: 1..5,
   Color      :: 1..5,
   Profession :: 1..5,
   Pet        :: 1..5,
   Drink      :: 1..5,

   all_different(Nat),
   all_different(Color),
   all_different(Profession),
   all_different(Pet),
   all_different(Drink),

   English #= Red,
   Spaniard #= Dog,
   Japanese #= Painter,
   Italian #= Tea,
   Norwegian #= 1,
   Green #= Coffee,
   Green #= White + 1,
   Sculptor #= Snails,
   Diplomat #= Yellow,
   Milk #= 3,
   abs(Norwegian - Blue) #= 1,
   Violinist #= Juice,
   abs(Fox-Doctor) #= 1,
   abs(Horse - Diplomat) #= 1,

   solve(Nat ++ Color ++ Profession ++ Pet ++ Drink),
   
   NatNames = [English=english, 
               Spaniard=spaniard, 
               Japanese=japanese,
    	       Italian=italian, 
               Norwegian=norwegian],
   member((Zebra=ZebraNat), NatNames),
   member((Water=WaterNat), NatNames),
   writef("The %w owns the zebra\n", ZebraNat),
   writef("The %w drinks water\n", WaterNat).
/* 

  Dummy bench in Picat.


  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/
*/

dummy => true.
/*

go => dummy.

go2 => dummy.
*/
_END_

done-testing;
